#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/FatPacker.pm"} = <<'APP_FATPACKER';
  package App::FatPacker;
  
  use strict;
  use warnings FATAL => 'all';
  use 5.008001;
  use Getopt::Long;
  use Cwd qw(cwd);
  use File::Find qw(find);
  use File::Spec::Functions qw(
    catdir splitpath splitdir catpath rel2abs abs2rel
  );
  use File::Spec::Unix;
  use File::Copy qw(copy);
  use File::Path qw(mkpath rmtree);
  use B qw(perlstring);
  
  our $VERSION = '0.009011'; # 0.9.11
  
  $VERSION = eval $VERSION;
  
  sub call_parser {
    my $self = shift;
    my ($args, $options) = @_;
  
    local *ARGV = [ @{$args} ];
    $self->{option_parser}->getoptions(@$options);
  
    return [ @ARGV ];
  }
  
  sub lines_of {
    map +(chomp,$_)[1], do { local @ARGV = ($_[0]); <> };
  }
  
  sub stripspace {
    my ($text) = @_;
    $text =~ /^(\s+)/ && $text =~ s/^$1//mg;
    $text;
  }
  
  sub import {
    $_[1] && $_[1] eq '-run_script'
      and return shift->new->run_script;
  }
  
  sub new {
    bless {
      option_parser => Getopt::Long::Parser->new(
        config => [ qw(require_order pass_through bundling no_auto_abbrev) ]
      ),
    }, $_[0];
  }
  
  sub run_script {
    my ($self, $args) = @_;
    my @args = $args ? @$args : @ARGV;
    (my $cmd = shift @args || 'help') =~ s/-/_/g;
  
    if (my $meth = $self->can("script_command_${cmd}")) {
      $self->$meth(\@args);
    } else {
      die "No such command ${cmd}";
    }
  }
  
  sub script_command_help {
    print "Try `perldoc fatpack` for how to use me\n";
  }
  
  sub script_command_trace {
    my ($self, $args) = @_;
  
    $args = $self->call_parser($args => [
      'to=s' => \my $file,
      'to-stderr' => \my $to_stderr,
      'use=s' => \my @additional_use
    ]);
  
    die "Can't use to and to-stderr on same call" if $file && $to_stderr;
  
    $file ||= 'fatpacker.trace';
  
    if (!$to_stderr and -e $file) {
      unlink $file or die "Couldn't remove old trace file: $!";
    }
    my $arg = do {
      if ($to_stderr) {
        ">&STDERR"
      } elsif ($file) {
        ">>${file}"
      }
    };
  
    $self->trace(
      use => \@additional_use,
      args => $args,
      output => $arg,
    );
  }
  
  sub trace {
    my ($self, %opts) = @_;
  
    my $capture;
  
    my $output = $opts{output} || do {
      $capture++; '>&STDOUT'
    };
  
    my $trace_opts = join ',', $output||'>&STDOUT', @{$opts{use}||[]};
  
    local $ENV{PERL5OPT} = '-MApp::FatPacker::Trace='.$trace_opts;
  
    my @args = @{$opts{args}||[]};
  
    if ($output) {
      # user specified output target, JFDI
      system $^X, @args;
      return;
    } else {
      # no output target specified, slurp
      open my $out_fh, '-|', $^X, @args;
      return do { local $/; <$out_fh> };
    }
  }
  
  sub script_command_packlists_for {
    my ($self, $args) = @_;
    foreach my $pl ($self->packlists_containing($args)) {
      print "${pl}\n";
    }
  }
  
  sub packlists_containing {
    my ($self, $targets) = @_;
    my @targets = @$targets;
    foreach my $t (@targets) {
      require $t;
    }
    my @search = grep -d $_, map catdir($_, 'auto'), @INC;
    my %pack_rev;
    my $cwd = cwd;
    find(sub {
      return unless $_ eq '.packlist' && -f $_;
      $pack_rev{$_} = $File::Find::name for lines_of $File::Find::name;
    }, @search);
    chdir($cwd) or die "Couldn't chdir back to ${cwd} after find: $!";
    my %found; @found{map +($pack_rev{$INC{$_}}||()), @targets} = ();
    sort keys %found;
  }
  
  sub script_command_tree {
    my ($self, $args) = @_;
    my $base = catdir(cwd,'fatlib');
    $self->packlists_to_tree($base, $args);
  }
  
  sub packlists_to_tree {
    my ($self, $where, $packlists) = @_;
    rmtree $where;
    mkpath $where;
    foreach my $pl (@$packlists) {
      my ($vol, $dirs, $file) = splitpath $pl;
      my @dir_parts = splitdir $dirs;
      my $pack_base;
      PART: foreach my $p (0 .. $#dir_parts) {
        if ($dir_parts[$p] eq 'auto') {
          # $p-2 since it's <wanted path>/$Config{archname}/auto
          $pack_base = catpath $vol, catdir @dir_parts[0..$p-2];
          last PART;
        }
      }
      die "Couldn't figure out base path of packlist ${pl}" unless $pack_base;
      foreach my $source (lines_of $pl) {
        # there is presumably a better way to do "is this under this base?"
        # but if so, it's not obvious to me in File::Spec
        next unless substr($source,0,length $pack_base) eq $pack_base;
        my $target = rel2abs( abs2rel($source, $pack_base), $where );
        my $target_dir = catpath((splitpath $target)[0,1]);
        mkpath $target_dir;
        copy $source => $target;
      }
    }
  }
  
  sub script_command_file {
    my ($self, $args) = @_;
    my $file = shift @$args;
    my $cwd = cwd;
    my @dirs = map rel2abs($_, $cwd), ('lib','fatlib');
    my %files;
    foreach my $dir (@dirs) {
      find(sub {
        return unless -f $_;
        !/\.pm$/ and warn "File ${File::Find::name} isn't a .pm file - can't pack this and if you hoped we were going to things may not be what you expected later\n" and return;
        $files{File::Spec::Unix->abs2rel($File::Find::name,$dir)} = do {
          local (@ARGV, $/) = ($File::Find::name); <>
        };
        close ARGV;
      }, $dir);
    }
    my $start = stripspace <<'  END_START';
      # This chunk of stuff was generated by App::FatPacker. To find the original
      # file's code, look for the end of this BEGIN block or the string 'FATPACK'
      BEGIN {
      my %fatpacked;
    END_START
    my $end = stripspace <<'  END_END';
      s/^  //mg for values %fatpacked;
  
      unshift @INC, sub {
        if (my $fat = $fatpacked{$_[1]}) {
          open my $fh, '<', \$fat
            or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
          return $fh;
        }
        return
      };
  
      } # END OF FATPACK CODE
    END_END
    my @segments = map {
      (my $stub = $_) =~ s/\.pm$//;
      my $name = uc join '_', split '/', $stub;
      my $data = $files{$_}; $data =~ s/^/  /mg; $data =~ s/(?<!\n)\z/\n/;
      '$fatpacked{'.perlstring($_).qq!} = <<'${name}';\n!
      .qq!${data}${name}\n!;
    } sort keys %files;
    print join "\n", $start, @segments, $end;
  }
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::FatPacker - pack your dependencies onto your script file
  
  =head1 SYNOPSIS
  
    $ fatpack trace myscript.pl
    $ fatpack packlists-for `cat fatpacker.trace` >packlists
    $ fatpack tree `cat packlists`
    $ (fatpack file; cat myscript.pl) >myscript.packed.pl
  
  See the documentation for the L<fatpack> script itself for more information.
  
  The programmatic API for this code is not yet fully decided, hence the 0.9
  release version. Expect that to be cleaned up for 1.0.
  
  =head1 SUPPORT
  
  Your current best avenue is to come annoy annoy mst on #toolchain on
  irc.perl.org. There should be a non-IRC means of support by 1.0.
  
  =head1 AUTHOR
  
  Matt S. Trout (mst) <mst@shadowcat.co.uk>
  
  =head2 CONTRIBUTORS
  
  miyagawa - Tatsuhiko Miyagawa (cpan:MIYAGAWA) <miyagawa@bulknews.net>
  
  tokuhirom - MATSUNO★Tokuhiro (cpan:TOKUHIROM) <tokuhirom@gmail.com>
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  gugod - 劉康民 (cpan:GUGOD) <gugod@cpan.org>
  
  t0m - Tomas Doran (cpan:BOBTFISH) <bobtfish@bobtfish.net>
  
  sawyer - Sawyer X (cpan:XSAWYERX) <xsawyerx@cpan.org>
  
  ether - Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  Many more people are probably owed thanks for ideas. Yet
  another doc nit to fix.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the App::FatPacker L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
  
  1;
  
APP_FATPACKER

$fatpacked{"App/FatPacker/Trace.pm"} = <<'APP_FATPACKER_TRACE';
  package App::FatPacker::Trace;
  
  use strict;
  use warnings FATAL => 'all';
  use B ();
  
  my $trace_file;
  my %initial_inc;
  
  sub import {
    my (undef, $file, @extras) = @_;
  
    $trace_file = $file || '>>fatpacker.trace';
    # For filtering out our own deps later.
    # (Not strictly required as these are core only and won't have packlists, but 
    # looks neater.)
    %initial_inc = %INC;
  
    # Use any extra modules specified
    eval "use $_" for @extras;
  
    B::minus_c;
  }
  
  CHECK {
    return unless $trace_file; # not imported
  
    open my $trace, $trace_file
        or die "Couldn't open $trace_file to trace to: $!";
  
    for my $inc (keys %INC) {
      next if exists $initial_inc{$inc};
      print $trace "$inc\n";
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::FatPacker::Trace - Tracing module usage using compilation checking
  
  =head1 SYNOPSIS
  
      # open STDERR for writing
      # will be like: open my $fh, '>', '&STDERR'...
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
      # open a file for writing
      # will be like: open my $fh, '>>', 'fatpacker.trace'
      perl -MApp::FatPacker::Trace=>>fatpacker.trace myscript.pl
  
  =head1 DESCRIPTION
  
  This module allows tracing the modules being used by your code. It does that
  using clever trickery using the C<import> method, the C<CHECK> block and
  L<B>'s C<minus_c> function.
  
  When App::FatPacker::Trace is being used, the import() method will call
  C<B::minus_c> in order to set up the global compilation-only flag perl
  (the interpreter) has. This will prevent any other code from being run.
  
  Then in the C<CHECK> block which is reached at the end of the compilation
  phase (see L<perlmod>), it will gather all modules that have been loaded,
  using C<%INC>, and will write it to a file or to STDERR, determined by
  parameters sent to the C<import> method.
  
  =head1 METHODS
  
  =head2 import
  
  This method gets run when you just load L<App::FatPacker::Trace>. It will
  note the current C<%INC> and will set up the output to be written to, and
  raise the compilation-only flag, which will prevent anything from being
  run past that point. This flag cannot be unset, so this is most easily run
  from the command line as such:
  
      perl -MApp::FatPacker::Trace [...]
  
  You can control the paramters to the import using an equal sign, as such:
  
      # send the parameter "hello"
      perl -MApp::FatPacker::Trace=hello [...]
  
      # send the parameter ">&STDERR"
      perl -MApp::FatPacker::Trace=>&STDERR [...]
  
  The import method accepts a first parameter telling it which output to open
  and how. These are both sent in a single parameter.
  
      # append to mytrace.txt
      perl -MApp::FatPacker::Trace=>>mytrace.txt myscript.pl
  
      # write to STDERR
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
  The import method accepts additional parameters of extra modules to load.
  It will then add these modules to the trace. This is helpful if you want
  to explicitly indicate additional modules to trace, even if they aren't
  used in your script. Perhaps you're conditionally using them, perhaps
  they're for additional features, perhaps they're loaded lazily, whatever
  the reason.
  
      # Add Moo to the trace, even if you don't trace it in myscript.pl
      perl -MApp::FatPacker::Trace=>&STDERR,Moo myscript.pl
  
APP_FATPACKER_TRACE

$fatpacked{"Crypt/RC4.pm"} = <<'CRYPT_RC4';
  #--------------------------------------------------------------------#
  # Crypt::RC4
  #       Date Written:   07-Jun-2000 04:15:55 PM
  #       Last Modified:  13-Dec-2001 03:33:49 PM 
  #       Author:         Kurt Kincaid (sifukurt@yahoo.com)
  #       Copyright (c) 2001, Kurt Kincaid
  #           All Rights Reserved.
  #
  #       This is free software and may be modified and/or
  #       redistributed under the same terms as Perl itself.
  #--------------------------------------------------------------------#
  
  package Crypt::RC4;
  
  use strict;
  use vars qw( $VERSION @ISA @EXPORT $MAX_CHUNK_SIZE );
  
  $MAX_CHUNK_SIZE = 1024 unless $MAX_CHUNK_SIZE;
  
  require Exporter;
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(RC4);
  $VERSION = '2.02';
  
  sub new {
      my ( $class, $key )  = @_;
      my $self = bless {}, $class;
      $self->{state} = Setup( $key );
      $self->{x} = 0;
      $self->{y} = 0;
      $self;
  }
  
  sub RC4 {
      my $self;
      my( @state, $x, $y );
      if ( ref $_[0] ) {
          $self = shift;
      @state = @{ $self->{state} };
      $x = $self->{x};
      $y = $self->{y};
      } else {
          @state = Setup( shift );
      $x = $y = 0;
      }
      my $message = shift;
      my $num_pieces = do {
      my $num = length($message) / $MAX_CHUNK_SIZE;
      my $int = int $num;
      $int == $num ? $int : $int+1;
      };
      for my $piece ( 0..$num_pieces - 1 ) {
      my @message = unpack "C*", substr($message, $piece * $MAX_CHUNK_SIZE, $MAX_CHUNK_SIZE);
      for ( @message ) {
          $x = 0 if ++$x > 255;
          $y -= 256 if ($y += $state[$x]) > 255;
          @state[$x, $y] = @state[$y, $x];
          $_ ^= $state[( $state[$x] + $state[$y] ) % 256];
      }
      substr($message, $piece * $MAX_CHUNK_SIZE, $MAX_CHUNK_SIZE) = pack "C*", @message;
      }
      if ($self) {
      $self->{state} = \@state;
      $self->{x} = $x;
      $self->{y} = $y;
      }
      $message;
  }
  
  sub Setup {
      my @k = unpack( 'C*', shift );
      my @state = 0..255;
      my $y = 0;
      for my $x (0..255) {
      $y = ( $k[$x % @k] + $state[$x] + $y ) % 256;
      @state[$x, $y] = @state[$y, $x];
      }
      wantarray ? @state : \@state;
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  Crypt::RC4 - Perl implementation of the RC4 encryption algorithm
  
  =head1 SYNOPSIS
  
  # Functional Style
    use Crypt::RC4;
    $encrypted = RC4( $passphrase, $plaintext );
    $decrypt = RC4( $passphrase, $encrypted );
    
  # OO Style
    use Crypt::RC4;
    $ref = Crypt::RC4->new( $passphrase );
    $encrypted = $ref->RC4( $plaintext );
  
    $ref2 = Crypt::RC4->new( $passphrase );
    $decrypted = $ref2->RC4( $encrypted );
  
  # process an entire file, one line at a time
  # (Warning: Encrypted file leaks line lengths.)
    $ref3 = Crypt::RC4->new( $passphrase );
    while (<FILE>) {
        chomp;
        print $ref3->RC4($_), "\n";
    }
  
  =head1 DESCRIPTION
  
  A simple implementation of the RC4 algorithm, developed by RSA Security, Inc. Here is the description
  from RSA's website:
  
  RC4 is a stream cipher designed by Rivest for RSA Data Security (now RSA Security). It is a variable
  key-size stream cipher with byte-oriented operations. The algorithm is based on the use of a random
  permutation. Analysis shows that the period of the cipher is overwhelmingly likely to be greater than
  10100. Eight to sixteen machine operations are required per output byte, and the cipher can be
  expected to run very quickly in software. Independent analysts have scrutinized the algorithm and it
  is considered secure.
  
  Based substantially on the "RC4 in 3 lines of perl" found at http://www.cypherspace.org
  
  A major bug in v1.0 was fixed by David Hook (dgh@wumpus.com.au).  Thanks, David.
  
  =head1 AUTHOR
  
  Kurt Kincaid (sifukurt@yahoo.com)
  Ronald Rivest for RSA Security, Inc.
  
  =head1 BUGS
  
  Disclaimer: Strictly speaking, this module uses the "alleged" RC4
  algorithm. The Algorithm known as "RC4" is a trademark of RSA Security
  Inc., and this document makes no claims one way or another that this
  is the correct algorithm, and further, make no claims about the
  quality of the source code nor any licensing requirements for
  commercial use.
  
  There's nothing preventing you from using this module in an insecure
  way which leaks information. For example, encrypting multilple
  messages with the same passphrase may allow an attacker to decode all of
  them with little effort, even though they'll appear to be secured. If
  serious crypto is your goal, be careful. Be very careful.
  
  It's a pure-Perl implementation, so that rating of "Eight
  to sixteen machine operations" is good for nothing but a good laugh.
  If encryption and decryption are a bottleneck for you, please re-write
  this module to use native code wherever practical.
  
  =head1 LICENSE
  
  This is free software and may be modified and/or
  redistributed under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<perl>, L<http://www.cypherspace.org>, L<http://www.rsasecurity.com>, 
  L<http://www.achtung.com/crypto/rc4.html>, 
  L<http://www.columbia.edu/~ariel/ssleay/rrc4.html>
  
  =cut
CRYPT_RC4

$fatpacked{"Digest/Perl/MD5.pm"} = <<'DIGEST_PERL_MD5';
  #! /usr/bin/false
  #
  # $Id: MD5.pm,v 1.23 2004/08/27 20:28:25 lackas Exp $
  #
  
  package Digest::Perl::MD5;
  use strict;
  use integer;
  use Exporter;
  use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);
  
  @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  @ISA = 'Exporter';
  $VERSION = '1.8';
  
  # I-Vektor
  sub A() { 0x67_45_23_01 }
  sub B() { 0xef_cd_ab_89 }
  sub C() { 0x98_ba_dc_fe }
  sub D() { 0x10_32_54_76 }
  
  # for internal use
  sub MAX() { 0xFFFFFFFF }
  
  # padd a message to a multiple of 64
  sub padding {
      my $l = length (my $msg = shift() . chr(128));    
      $msg .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  }
  
  
  sub rotate_left($$) {
  	#$_[0] << $_[1] | $_[0] >> (32 - $_[1]);
  	#my $right = $_[0] >> (32 - $_[1]);
  	#my $rmask = (1 << $_[1]) - 1;
  	($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));
  	#$_[0] << $_[1] | (($_[0]>> (32 - $_[1])) & (1 << (32 - $_[1])) - 1);
  }
  
  sub gen_code {
    # Discard upper 32 bits on 64 bit archs.
    my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';
  #	FF => "X0=rotate_left(((X1&X2)|(~X1&X3))+X0+X4+X6$MSK,X5)+X1$MSK;",
  #	GG => "X0=rotate_left(((X1&X3)|(X2&(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    my %f = (
  	FF => "X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	GG => "X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	HH => "X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",
  	II => "X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    );
    #unless ( (1 << 16) << 16) { %f = %{$CODES{'32bit'}} }
    #else { %f = %{$CODES{'64bit'}} }
  
    my %s = (  # shift lengths
  	S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,
  	S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,
  	S43 => 15, S44 => 21
    );
  
    my $insert = "\n";
    while(<DATA>) {
  	chomp;
  	next unless /^[FGHI]/;
  	my ($func,@x) = split /,/;
  	my $c = $f{$func};
  	$c =~ s/X(\d)/$x[$1]/g;
  	$c =~ s/(S\d{2})/$s{$1}/;
  	$c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;
  
  	my $su = 32 - $3;
  	my $sh = (1 << $3) - 1;
  
  	$c = "$1=(((\$r=$2)<<$3)|((\$r>>$su)&$sh))+$4";
  
  	#my $rotate = "(($2 << $3) || (($2 >> (32 - $3)) & (1 << $2) - 1)))"; 
  	# $c = "\$r = $2;
  	# $1 = ((\$r << $3) | ((\$r >> (32 - $3))  & ((1 << $3) - 1))) + $4";
  	$insert .= "\t$c\n";
    }
    close DATA;
    
    my $dump = '
    sub round {
  	my ($a,$b,$c,$d) = @_[0 .. 3];
  	my $r;' . $insert . '
  	$_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK . 
          ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';
    }';
    eval $dump;
    # print "$dump\n";
    # exit 0;
  }
  
  gen_code();
  
  #########################################
  # Private output converter functions:
  sub _encode_hex { unpack 'H*', $_[0] }
  sub _encode_base64 {
  	my $res;
  	while ($_[0] =~ /(.{1,45})/gs) {
  		$res .= substr pack('u', $1), 1;
  		chop $res;
  	}
  	$res =~ tr|` -_|AA-Za-z0-9+/|;#`
  	chop $res; chop $res;
  	$res
  }
  
  #########################################
  # OOP interface:
  sub new {
  	my $proto = shift;
  	my $class = ref $proto || $proto;
  	my $self = {};
  	bless $self, $class;
  	$self->reset();
  	$self
  }
  
  sub reset {
  	my $self = shift;
  	delete $self->{_data};
  	$self->{_state} = [A,B,C,D];
  	$self->{_length} = 0;
  	$self
  }
  
  sub add {
  	my $self = shift;
  	$self->{_data} .= join '', @_ if @_;
  	my ($i,$c);
  	for $i (0 .. (length $self->{_data})/64-1) {
  		my @X = unpack 'V16', substr $self->{_data}, $i*64, 64;
  		@{$self->{_state}} = round(@{$self->{_state}},@X);
  		++$c;
  	}
  	if ($c) {
  		substr ($self->{_data}, 0, $c*64) = '';
  		$self->{_length} += $c*64;
  	}
  	$self
  }
  
  sub finalize {
  	my $self = shift;
  	$self->{_data} .= chr(128);
      my $l = $self->{_length} + length $self->{_data};
      $self->{_data} .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $self->{_data} .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  	$self->add();
  	$self
  }
  
  sub addfile {
    	my ($self,$fh) = @_;
  	if (!ref($fh) && ref(\$fh) ne "GLOB") {
  	    require Symbol;
  	    $fh = Symbol::qualify($fh, scalar caller);
  	}
  	# $self->{_data} .= do{local$/;<$fh>};
  	my $read = 0;
  	my $buffer = '';
  	$self->add($buffer) while $read = read $fh, $buffer, 8192;
  	die __PACKAGE__, " read failed: $!" unless defined $read;
  	$self
  }
  
  sub add_bits {
  	my $self = shift;
  	return $self->add( pack 'B*', shift ) if @_ == 1;
  	my ($b,$n) = @_;
  	die __PACKAGE__, " Invalid number of bits\n" if $n%8;
  	$self->add( substr $b, 0, $n/8 )
  }
  
  sub digest {
  	my $self = shift;
  	$self->finalize();
  	my $res = pack 'V4', @{$self->{_state}};
  	$self->reset();
  	$res
  }
  
  sub hexdigest {
  	_encode_hex($_[0]->digest)
  }
  
  sub b64digest {
  	_encode_base64($_[0]->digest)
  }
  
  sub clone {
  	my $self = shift;
  	my $clone = { 
  		_state => [@{$self->{_state}}],
  		_length => $self->{_length},
  		_data => $self->{_data}
  	};
  	bless $clone, ref $self || $self;
  }
  
  #########################################
  # Procedural interface:
  sub md5 {
  	my $message = padding(join'',@_);
  	my ($a,$b,$c,$d) = (A,B,C,D);
  	my $i;
  	for $i (0 .. (length $message)/64-1) {
  		my @X = unpack 'V16', substr $message,$i*64,64;	
  		($a,$b,$c,$d) = round($a,$b,$c,$d,@X);
  	}
  	pack 'V4',$a,$b,$c,$d;
  }
  sub md5_hex { _encode_hex &md5 } 
  sub md5_base64 { _encode_base64 &md5 }
  
  
  1;
  
  =head1 NAME
  
  Digest::MD5::Perl - Perl implementation of Ron Rivests MD5 Algorithm
  
  =head1 DISCLAIMER
  
  This is B<not> an interface (like C<Digest::MD5>) but a Perl implementation of MD5.
  It is written in perl only and because of this it is slow but it works without C-Code.
  You should use C<Digest::MD5> instead of this module if it is available.
  This module is only usefull for
  
  =over 4
  
  =item
  
  computers where you cannot install C<Digest::MD5> (e.g. lack of a C-Compiler)
  
  =item
  
  encrypting only small amounts of data (less than one million bytes). I use it to
  hash passwords.
  
  =item
  
  educational purposes
  
  =back
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5  qw(md5 md5_hex md5_base64);
  
   $hash = md5 $data;
   $hash = md5_hex $data;
   $hash = md5_base64 $data;
      
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile(*FILE);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  This modules has the same interface as the much faster C<Digest::MD5>. So you can
  easily exchange them, e.g.
  
  	BEGIN {
  	  eval {
  	    require Digest::MD5;
  	    import Digest::MD5 'md5_hex'
  	  };
  	  if ($@) { # ups, no Digest::MD5
  	    require Digest::Perl::MD5;
  	    import Digest::Perl::MD5 'md5_hex'
  	  }		
  	}
  
  If the C<Digest::MD5> module is available it is used and if not you take
  C<Digest::Perl::MD5>.
  
  You can also install the Perl part of Digest::MD5 together with Digest::Perl::MD5
  and use Digest::MD5 as normal, it falls back to Digest::Perl::MD5 if it
  cannot load its object files.
  
  For a detailed Documentation see the C<Digest::MD5> module.
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::Perl::MD5 'md5_hex';
      print 'Digest is ', md5_hex('foobarbaz'), "\n";
  
  The above example would print out the message
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  provided that the implementation is working correctly.  The same
  checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  The digest methods are destructive. That means you can only call them
  once and the $md5 objects is reset after use. You can make a copy with clone:
  
  	$md5->clone->hexdigest
  
  =head1 LIMITATIONS
  
  This implementation of the MD5 algorithm has some limitations:
  
  =over 4
  
  =item
  
  It's slow, very slow. I've done my very best but Digest::MD5 is still about 100 times faster.
  You can only encrypt Data up to one million bytes in an acceptable time. But it's very usefull
  for encrypting small amounts of data like passwords.
  
  =item
  
  You can only encrypt up to 2^32 bits = 512 MB on 32bit archs. But You should
  use C<Digest::MD5> for those amounts of data anyway.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest::MD5>
  
  L<md5(1)>
  
  RFC 1321
  
  tools/md5: a small BSD compatible md5 tool written in pure perl.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 2000 Christian Lackas, Imperia Software Solutions
   Copyright 1998-1999 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. The basic C code
  implementing the algorithm is derived from that in the RFC and is
  covered by the following copyright:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-1992, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original MD5 interface was written by Neil Winton
  (<N.Winton (at) axion.bt.co.uk>).
  
  C<Digest::MD5> was made by Gisle Aas <gisle (at) aas.no> (I took his Interface
  and part of the documentation).
  
  Thanks to Guido Flohr for his 'use integer'-hint.
  
  This release was made by Christian Lackas <delta (at) lackas.net>.
  
  =cut
  
  __DATA__
  FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
  FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
  FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
  FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
  FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
  FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
  FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
  FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
  FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
  FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
  FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
  FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
  FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
  FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
  FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
  FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
  GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
  GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
  GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
  GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
  GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
  GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
  GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
  GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
  GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
  GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
  GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
  GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
  GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
  GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
  GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
  GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
  HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
  HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
  HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
  HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
  HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
  HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
  HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
  HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
  HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
  HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
  HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
  HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
  HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
  HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
  HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
  HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
  II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
  II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
  II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
  II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
  II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
  II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
  II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
  II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
  II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
  II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
  II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
  II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
  II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
  II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
  II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
  II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */
DIGEST_PERL_MD5

$fatpacked{"IO/AtomicFile.pm"} = <<'IO_ATOMICFILE';
  package IO::AtomicFile;
  
  ### DOCUMENTATION AT BOTTOM OF FILE
  
  # Be strict:
  use strict;
  
  # External modules:
  use IO::File;
  
  
  #------------------------------
  #
  # GLOBALS...
  #
  #------------------------------
  use vars qw($VERSION @ISA);
  
  # The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.110";
  
  # Inheritance:
  @ISA = qw(IO::File);
  
  
  #------------------------------
  # new ARGS...
  #------------------------------
  # Class method, constructor.
  # Any arguments are sent to open().
  #
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new();
      ${*$self}{'io_atomicfile_suffix'} = '';
      $self->open(@_) if @_;
      $self;
  }
  
  #------------------------------
  # DESTROY 
  #------------------------------
  # Destructor.
  #
  sub DESTROY {
      shift->close(1);   ### like close, but raises fatal exception on failure
  }
  
  #------------------------------
  # open PATH, MODE
  #------------------------------
  # Class/instance method.
  #
  sub open {
      my ($self, $path, $mode) = @_;
      ref($self) or $self = $self->new;    ### now we have an instance! 
  
      ### Create tmp path, and remember this info: 
      my $temp = "${path}..TMP" . ${*$self}{'io_atomicfile_suffix'};
      ${*$self}{'io_atomicfile_temp'} = $temp;
      ${*$self}{'io_atomicfile_path'} = $path;
  
      ### Open the file!  Returns filehandle on success, for use as a constructor: 
      $self->SUPER::open($temp, $mode) ? $self : undef;
  }
  
  #------------------------------
  # _closed [YESNO]
  #------------------------------
  # Instance method, private.
  # Are we already closed?  Argument sets new value, returns previous one.
  #
  sub _closed {
      my $self = shift;
      my $oldval = ${*$self}{'io_atomicfile_closed'};
      ${*$self}{'io_atomicfile_closed'} = shift if @_;
      $oldval;
  }
  
  #------------------------------
  # close
  #------------------------------
  # Instance method.
  # Close the handle, and rename the temp file to its final name.
  #
  sub close {
      my ($self, $die) = @_;
      unless ($self->_closed(1)) {             ### sentinel...
          $self->SUPER::close();    
          rename(${*$self}{'io_atomicfile_temp'},
  	       ${*$self}{'io_atomicfile_path'}) 
              or ($die ? die "close atomic file: $!\n" : return undef); 
      }
      1;
  }
  
  #------------------------------
  # delete
  #------------------------------
  # Instance method.
  # Close the handle, and delete the temp file.
  #
  sub delete {
      my $self = shift;
      unless ($self->_closed(1)) {             ### sentinel...
          $self->SUPER::close();    
          return unlink(${*$self}{'io_atomicfile_temp'});
      }
      1;
  }
  
  #------------------------------
  # detach
  #------------------------------
  # Instance method.
  # Close the handle, but DO NOT delete the temp file.
  #
  sub detach {
      my $self = shift;
      $self->SUPER::close() unless ($self->_closed(1));
      1;
  }
  
  #------------------------------
  1;
  __END__
  
  
  =head1 NAME
  
  IO::AtomicFile - write a file which is updated atomically
  
  
  =head1 SYNOPSIS
  
      use IO::AtomicFile;
  
      ### Write a temp file, and have it install itself when closed:
      my $FH = IO::AtomicFile->open("bar.dat", "w");
      print $FH "Hello!\n";
      $FH->close || die "couldn't install atomic file: $!";    
  
      ### Write a temp file, but delete it before it gets installed:
      my $FH = IO::AtomicFile->open("bar.dat", "w");
      print $FH "Hello!\n";
      $FH->delete; 
  
      ### Write a temp file, but neither install it nor delete it:
      my $FH = IO::AtomicFile->open("bar.dat", "w");
      print $FH "Hello!\n";
      $FH->detach;   
  
  
  =head1 DESCRIPTION
  
  This module is intended for people who need to update files 
  reliably in the face of unexpected program termination.  
  
  For example, you generally don't want to be halfway in the middle of
  writing I</etc/passwd> and have your program terminate!  Even
  the act of writing a single scalar to a filehandle is I<not> atomic.
  
  But this module gives you true atomic updates, via rename().
  When you open a file I</foo/bar.dat> via this module, you are I<actually> 
  opening a temporary file I</foo/bar.dat..TMP>, and writing your
  output there.   The act of closing this file (either explicitly
  via close(), or implicitly via the destruction of the object)
  will cause rename() to be called... therefore, from the point
  of view of the outside world, the file's contents are updated
  in a single time quantum.
  
  To ensure that problems do not go undetected, the "close" method
  done by the destructor will raise a fatal exception if the rename()
  fails.  The explicit close() just returns undef.   
  
  You can also decide at any point to trash the file you've been 
  building. 
  
  
  =head1 AUTHOR
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Original Author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head1 REVISION
  
  $Revision: 1.2 $
  
  =cut 
IO_ATOMICFILE

$fatpacked{"IO/InnerFile.pm"} = <<'IO_INNERFILE';
  package IO::InnerFile;
  
  =head1 NAME
  
  IO::InnerFile - define a file inside another file
  
  
  =head1 SYNOPSIS
  
  
      ### Read a subset of a file:
      $inner = IO::InnerFile->new($fh, $start, $length);
      while (<$inner>) {
  	...
      }
  
  
  =head1 DESCRIPTION
  
  If you have a filehandle that can seek() and tell(), then you 
  can open an IO::InnerFile on a range of the underlying file.
  
  
  =head1 PUBLIC INTERFACE
  
  =over
  
  =cut
  
  use Symbol;
  
  # The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.110";
  
  #------------------------------
  
  =item new FILEHANDLE, [START, [LENGTH]]
  
  I<Class method, constructor.>
  Create a new inner-file opened on the given FILEHANDLE,
  from bytes START to START+LENGTH.  Both START and LENGTH
  default to 0; negative values are silently coerced to zero.
  
  Note that FILEHANDLE must be able to seek() and tell(), in addition
  to whatever other methods you may desire for reading it.
  
  =cut
  
  sub new {
     my ($class, $fh, $start, $lg) = @_;
     $start = 0 if (!$start or ($start < 0));
     $lg    = 0 if (!$lg    or ($lg    < 0));
  
     ### Create the underlying "object":
     my $a = {
        FH 	=> 	$fh,
        CRPOS 	=> 	0,
        START	=>	$start,
        LG	=>	$lg,
     };
  
     ### Create a new filehandle tied to this object:
     $fh = gensym;
     tie(*$fh, $class, $a); 
     return bless($fh, $class);
  }
  
  sub TIEHANDLE { 
     my ($class, $data) = @_;
     return bless($data, $class);
  }
  
  sub DESTROY { 
     my ($self) = @_;
     $self->close() if (ref($self) eq 'SCALAR'); 
  }
  
  #------------------------------
  
  =item set_length LENGTH
  
  =item get_length 
  
  =item add_length NBYTES
  
  I<Instance methods.>
  Get/set the virtual length of the inner file.
  
  =cut
  
  sub set_length { tied(${$_[0]})->{LG} = $_[1]; }
  sub get_length { tied(${$_[0]})->{LG}; }
  sub add_length { tied(${$_[0]})->{LG} += $_[1]; }
  
  #------------------------------
  
  =item set_start START
  
  =item get_start 
  
  =item add_start NBYTES
  
  I<Instance methods.>
  Get/set the virtual start position of the inner file.
  
  =cut
  
  sub set_start  { tied(${$_[0]})->{START} = $_[1]; }
  sub get_start  { tied(${$_[0]})->{START}; } 
  sub set_end    { tied(${$_[0]})->{LG} =  $_[1] - tied(${$_[0]})->{START}; }
  sub get_end    { tied(${$_[0]})->{LG} + tied(${$_[0]})->{START}; }
  
  
  #------------------------------
  
  =item binmode
  
  =item close
  
  =item flush
  
  =item getc
  
  =item getline
  
  =item print LIST
  
  =item printf LIST
  
  =item read BUF, NBYTES
  
  =item readline
  
  =item seek OFFFSET, WHENCE
  
  =item tell
  
  =item write ARGS...
  
  I<Instance methods.>
  Standard filehandle methods.
  
  =cut
  
  sub write    { shift->WRITE(@_) }
  sub print    { shift->PRINT(@_) }
  sub printf   { shift->PRINTF(@_) }
  sub flush    { "0 but true"; }
  sub binmode  { 1; }
  sub getc     { return GETC(tied(${$_[0]}) ); }
  sub read     { return READ(     tied(${$_[0]}), @_[1,2,3] ); }
  sub readline { return READLINE( tied(${$_[0]}) ); }
  sub getline  { return READLINE( tied(${$_[0]}) ); }
  sub close    { return CLOSE(tied(${$_[0]}) ); }
  
  sub seek {
     my ($self, $ofs, $whence) = @_;
     $self = tied( $$self );
  
     $self->{CRPOS} = $ofs if ($whence == 0);
     $self->{CRPOS}+= $ofs if ($whence == 1);
     $self->{CRPOS} = $self->{LG} + $ofs if ($whence == 2);
  
     $self->{CRPOS} = 0 if ($self->{CRPOS} < 0);
     $self->{CRPOS} = $self->{LG} if ($self->{CRPOS} > $self->{LG});
     return 1;
  }
  
  sub tell { 
      return tied(${$_[0]})->{CRPOS}; 
  }
  
  sub WRITE  { 
      die "inner files can only open for reading\n";
  }
  
  sub PRINT  {
      die "inner files can only open for reading\n";
  }
  
  sub PRINTF { 
      die "inner files can only open for reading\n";
  }
  
  sub GETC   { 
      my ($self) = @_;
      return 0 if ($self->{CRPOS} >= $self->{LG});
  
      my $data;
  
      ### Save and seek...
      my $old_pos = $self->{FH}->tell;
      $self->{FH}->seek($self->{CRPOS}+$self->{START}, 0);
  
      ### ...read...
      my $lg = $self->{FH}->read($data, 1);
      $self->{CRPOS} += $lg;
  
      ### ...and restore:
      $self->{FH}->seek($old_pos, 0);
  
      $self->{LG} = $self->{CRPOS} unless ($lg); 
      return ($lg ? $data : undef);
  }
  
  sub READ   { 
      my ($self, $undefined, $lg, $ofs) = @_;
      $undefined = undef;
  
      return 0 if ($self->{CRPOS} >= $self->{LG});
      $lg = $self->{LG} - $self->{CRPOS} if ($self->{CRPOS} + $lg > $self->{LG});
      return 0 unless ($lg);
  
      ### Save and seek...
      my $old_pos = $self->{FH}->tell;
      $self->{FH}->seek($self->{CRPOS}+$self->{START}, 0);
  
      ### ...read...
      $lg = $self->{FH}->read($_[1], $lg, $_[3] );
      $self->{CRPOS} += $lg;
  
      ### ...and restore:
      $self->{FH}->seek($old_pos, 0);
  
      $self->{LG} = $self->{CRPOS} unless ($lg); 
      return $lg;
  }
  
  sub READLINE { 
      my ($self) = @_;
      return undef if ($self->{CRPOS} >= $self->{LG});
  
      ### Save and seek...
      my $old_pos = $self->{FH}->tell;
      $self->{FH}->seek($self->{CRPOS}+$self->{START}, 0);
  
      ### ...read...
      my $text = $self->{FH}->getline;
  
      ### ...and restore:
      $self->{FH}->seek($old_pos, 0);
  
      #### If we detected a new EOF ...
      unless (defined $text) {  
         $self->{LG} = $self->{CRPOS};
         return undef;
      }
  
      my $lg=length($text);
  
      $lg = $self->{LG} - $self->{CRPOS} if ($self->{CRPOS} + $lg > $self->{LG});
      $self->{CRPOS} += $lg;
  
      return substr($text, 0,$lg);
  }
  
  sub CLOSE { %{$_[0]}=(); }
  
  
  
  1;
  __END__
  
  =back
  
  
  =head1 VERSION
  
  $Id: InnerFile.pm,v 1.4 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHOR
  
  Original version by Doru Petrescu (pdoru@kappa.ro).
  
  Documentation and by Eryq (eryq@zeegee.com).
  
  Currently maintained by David F. Skoll (dfs@roaringpenguin.com).
  
  =cut
  
  
IO_INNERFILE

$fatpacked{"IO/Lines.pm"} = <<'IO_LINES';
  package IO::Lines;
  
  
  =head1 NAME
  
  IO::Lines - IO:: interface for reading/writing an array of lines
  
  
  =head1 SYNOPSIS
  
      use IO::Lines;
  
      ### See IO::ScalarArray for details 
  
  
  =head1 DESCRIPTION
  
  This class implements objects which behave just like FileHandle
  (or IO::Handle) objects, except that you may use them to write to
  (or read from) an array of lines.  They can be tiehandle'd as well.  
  
  This is a subclass of L<IO::ScalarArray|IO::ScalarArray> 
  in which the underlying
  array has its data stored in a line-oriented-format: that is,
  every element ends in a C<"\n">, with the possible exception of the
  final element.  This makes C<getline()> I<much> more efficient;
  if you plan to do line-oriented reading/printing, you want this class.
  
  The C<print()> method will enforce this rule, so you can print
  arbitrary data to the line-array: it will break the data at
  newlines appropriately.
  
  See L<IO::ScalarArray> for full usage and warnings.
  
  =cut
  
  use Carp;
  use strict;
  use IO::ScalarArray;
  use vars qw($VERSION @ISA);
  
  # The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.110";
  
  # Inheritance:
  @ISA = qw(IO::ScalarArray);     ### also gets us new_tie  :-)
  
  
  #------------------------------
  #
  # getline
  #
  # Instance method, override.
  # Return the next line, or undef on end of data.
  # Can safely be called in an array context.
  # Currently, lines are delimited by "\n".
  #
  sub getline {
      my $self = shift;
  
      if (!defined $/) {
  	return join( '', $self->_getlines_for_newlines );
      }
      elsif ($/ eq "\n") {
  	if (!*$self->{Pos}) {      ### full line...
  	    return *$self->{AR}[*$self->{Str}++];
  	}
  	else {                     ### partial line...
  	    my $partial = substr(*$self->{AR}[*$self->{Str}++], *$self->{Pos});
  	    *$self->{Pos} = 0;
  	    return $partial;
  	}
      }
      else {
  	croak 'unsupported $/: must be "\n" or undef';
      }
  }
  
  #------------------------------
  #
  # getlines
  #
  # Instance method, override.
  # Return an array comprised of the remaining lines, or () on end of data.
  # Must be called in an array context.
  # Currently, lines are delimited by "\n".
  #
  sub getlines {
      my $self = shift;
      wantarray or croak("can't call getlines in scalar context!");
  
      if ((defined $/) and ($/ eq "\n")) {
  	return $self->_getlines_for_newlines(@_);
      }
      else {         ### slow but steady
  	return $self->SUPER::getlines(@_);
      }
  }
  
  #------------------------------
  #
  # _getlines_for_newlines
  #
  # Instance method, private.
  # If $/ is newline, do fast getlines.
  # This CAN NOT invoke getline!
  #
  sub _getlines_for_newlines {
      my $self = shift;
      my ($rArray, $Str, $Pos) = @{*$self}{ qw( AR Str Pos ) };
      my @partial = ();
  
      if ($Pos) {				### partial line...
  	@partial = (substr( $rArray->[ $Str++ ], $Pos ));
  	*$self->{Pos} = 0;
      }
      *$self->{Str} = scalar @$rArray;	### about to exhaust @$rArray
      return (@partial,
  	    @$rArray[ $Str .. $#$rArray ]);	### remaining full lines...
  }
  
  #------------------------------
  #
  # print ARGS...
  #
  # Instance method, override.
  # Print ARGS to the underlying line array.  
  #
  sub print {
      if (defined $\ && $\ ne "\n") {
  	croak 'unsupported $\: must be "\n" or undef';
      }
  
      my $self = shift;
      ### print STDERR "\n[[ARRAY WAS...\n", @{*$self->{AR}}, "<<EOF>>\n";
      my @lines = split /^/, join('', @_); @lines or return 1;
  
      ### Did the previous print not end with a newline?  
      ### If so, append first line:
      if (@{*$self->{AR}} and (*$self->{AR}[-1] !~ /\n\Z/)) {
  	*$self->{AR}[-1] .= shift @lines;
      }
      push @{*$self->{AR}}, @lines;       ### add the remainder
      ### print STDERR "\n[[ARRAY IS NOW...\n", @{*$self->{AR}}, "<<EOF>>\n";
      1;
  }
  
  #------------------------------
  1;
  
  __END__
  
  
  =head1 VERSION
  
  $Id: Lines.pm,v 1.3 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHORS
  
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Principal author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head2 Other contributors 
  
  Thanks to the following individuals for their invaluable contributions
  (if I've forgotten or misspelled your name, please email me!):
  
  I<Morris M. Siegel,>
  for his $/ patch and the new C<getlines()>.
  
  I<Doug Wilson,>
  for the IO::Handle inheritance and automatic tie-ing.
  
  =cut
  
IO_LINES

$fatpacked{"IO/Scalar.pm"} = <<'IO_SCALAR';
  package IO::Scalar;
  
  
  =head1 NAME
  
  IO::Scalar - IO:: interface for reading/writing a scalar
  
  
  =head1 SYNOPSIS
  
  Perform I/O on strings, using the basic OO interface...
  
      use 5.005;
      use IO::Scalar;
      $data = "My message:\n";
  
      ### Open a handle on a string, and append to it:
      $SH = new IO::Scalar \$data;
      $SH->print("Hello");
      $SH->print(", world!\nBye now!\n");
      print "The string is now: ", $data, "\n";
  
      ### Open a handle on a string, read it line-by-line, then close it:
      $SH = new IO::Scalar \$data;
      while (defined($_ = $SH->getline)) {
  	print "Got line: $_";
      }
      $SH->close;
  
      ### Open a handle on a string, and slurp in all the lines:
      $SH = new IO::Scalar \$data;
      print "All lines:\n", $SH->getlines;
  
      ### Get the current position (either of two ways):
      $pos = $SH->getpos;
      $offset = $SH->tell;
  
      ### Set the current position (either of two ways):
      $SH->setpos($pos);
      $SH->seek($offset, 0);
  
      ### Open an anonymous temporary scalar:
      $SH = new IO::Scalar;
      $SH->print("Hi there!");
      print "I printed: ", ${$SH->sref}, "\n";      ### get at value
  
  
  Don't like OO for your I/O?  No problem.
  Thanks to the magic of an invisible tie(), the following now
  works out of the box, just as it does with IO::Handle:
  
      use 5.005;
      use IO::Scalar;
      $data = "My message:\n";
  
      ### Open a handle on a string, and append to it:
      $SH = new IO::Scalar \$data;
      print $SH "Hello";
      print $SH ", world!\nBye now!\n";
      print "The string is now: ", $data, "\n";
  
      ### Open a handle on a string, read it line-by-line, then close it:
      $SH = new IO::Scalar \$data;
      while (<$SH>) {
  	print "Got line: $_";
      }
      close $SH;
  
      ### Open a handle on a string, and slurp in all the lines:
      $SH = new IO::Scalar \$data;
      print "All lines:\n", <$SH>;
  
      ### Get the current position (WARNING: requires 5.6):
      $offset = tell $SH;
  
      ### Set the current position (WARNING: requires 5.6):
      seek $SH, $offset, 0;
  
      ### Open an anonymous temporary scalar:
      $SH = new IO::Scalar;
      print $SH "Hi there!";
      print "I printed: ", ${$SH->sref}, "\n";      ### get at value
  
  
  And for you folks with 1.x code out there: the old tie() style still works,
  though this is I<unnecessary and deprecated>:
  
      use IO::Scalar;
  
      ### Writing to a scalar...
      my $s;
      tie *OUT, 'IO::Scalar', \$s;
      print OUT "line 1\nline 2\n", "line 3\n";
      print "String is now: $s\n"
  
      ### Reading and writing an anonymous scalar...
      tie *OUT, 'IO::Scalar';
      print OUT "line 1\nline 2\n", "line 3\n";
      tied(OUT)->seek(0,0);
      while (<OUT>) {
          print "Got line: ", $_;
      }
  
  
  Stringification works, too!
  
      my $SH = new IO::Scalar \$data;
      print $SH "Hello, ";
      print $SH "world!";
      print "I printed: $SH\n";
  
  
  
  =head1 DESCRIPTION
  
  This class is part of the IO::Stringy distribution;
  see L<IO::Stringy> for change log and general information.
  
  The IO::Scalar class implements objects which behave just like
  IO::Handle (or FileHandle) objects, except that you may use them
  to write to (or read from) scalars.  These handles are
  automatically tiehandle'd (though please see L<"WARNINGS">
  for information relevant to your Perl version).
  
  
  Basically, this:
  
      my $s;
      $SH = new IO::Scalar \$s;
      $SH->print("Hel", "lo, ");         ### OO style
      $SH->print("world!\n");            ### ditto
  
  Or this:
  
      my $s;
      $SH = tie *OUT, 'IO::Scalar', \$s;
      print OUT "Hel", "lo, ";           ### non-OO style
      print OUT "world!\n";              ### ditto
  
  Causes $s to be set to:
  
      "Hello, world!\n"
  
  
  =head1 PUBLIC INTERFACE
  
  =cut
  
  use Carp;
  use strict;
  use vars qw($VERSION @ISA);
  use IO::Handle;
  
  use 5.005;
  
  ### Stringification, courtesy of B. K. Oxley (binkley):  :-)
  use overload '""'   => sub { ${*{$_[0]}->{SR}} };
  use overload 'bool' => sub { 1 };      ### have to do this, so object is true!
  
  ### The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.110";
  
  ### Inheritance:
  @ISA = qw(IO::Handle);
  
  ### This stuff should be got rid of ASAP.
  require IO::WrapTie and push @ISA, 'IO::WrapTie::Slave' if ($] >= 5.004);
  
  #==============================
  
  =head2 Construction
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item new [ARGS...]
  
  I<Class method.>
  Return a new, unattached scalar handle.
  If any arguments are given, they're sent to open().
  
  =cut
  
  sub new {
      my $proto = shift;
      my $class = ref($proto) || $proto;
      my $self = bless \do { local *FH }, $class;
      tie *$self, $class, $self;
      $self->open(@_);   ### open on anonymous by default
      $self;
  }
  sub DESTROY {
      shift->close;
  }
  
  #------------------------------
  
  =item open [SCALARREF]
  
  I<Instance method.>
  Open the scalar handle on a new scalar, pointed to by SCALARREF.
  If no SCALARREF is given, a "private" scalar is created to hold
  the file data.
  
  Returns the self object on success, undefined on error.
  
  =cut
  
  sub open {
      my ($self, $sref) = @_;
  
      ### Sanity:
      defined($sref) or do {my $s = ''; $sref = \$s};
      (ref($sref) eq "SCALAR") or croak "open() needs a ref to a scalar";
  
      ### Setup:
      *$self->{Pos} = 0;          ### seek position
      *$self->{SR}  = $sref;      ### scalar reference
      $self;
  }
  
  #------------------------------
  
  =item opened
  
  I<Instance method.>
  Is the scalar handle opened on something?
  
  =cut
  
  sub opened {
      *{shift()}->{SR};
  }
  
  #------------------------------
  
  =item close
  
  I<Instance method.>
  Disassociate the scalar handle from its underlying scalar.
  Done automatically on destroy.
  
  =cut
  
  sub close {
      my $self = shift;
      %{*$self} = ();
      1;
  }
  
  =back
  
  =cut
  
  
  
  #==============================
  
  =head2 Input and output
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item flush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub flush { "0 but true" }
  
  #------------------------------
  
  =item getc
  
  I<Instance method.>
  Return the next character, or undef if none remain.
  
  =cut
  
  sub getc {
      my $self = shift;
  
      ### Return undef right away if at EOF; else, move pos forward:
      return undef if $self->eof;
      substr(${*$self->{SR}}, *$self->{Pos}++, 1);
  }
  
  #------------------------------
  
  =item getline
  
  I<Instance method.>
  Return the next line, or undef on end of string.
  Can safely be called in an array context.
  Currently, lines are delimited by "\n".
  
  =cut
  
  sub getline {
      my $self = shift;
  
      ### Return undef right away if at EOF:
      return undef if $self->eof;
  
      ### Get next line:
      my $sr = *$self->{SR};
      my $i  = *$self->{Pos};	        ### Start matching at this point.
  
      ### Minimal impact implementation!
      ### We do the fast fast thing (no regexps) if using the
      ### classic input record separator.
  
      ### Case 1: $/ is undef: slurp all...
      if    (!defined($/)) {
  	*$self->{Pos} = length $$sr;
          return substr($$sr, $i);
      }
  
      ### Case 2: $/ is "\n": zoom zoom zoom...
      elsif ($/ eq "\012") {
  
          ### Seek ahead for "\n"... yes, this really is faster than regexps.
          my $len = length($$sr);
          for (; $i < $len; ++$i) {
             last if ord (substr ($$sr, $i, 1)) == 10;
          }
  
          ### Extract the line:
          my $line;
          if ($i < $len) {                ### We found a "\n":
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos} + 1);
              *$self->{Pos} = $i+1;            ### Remember where we finished up.
          }
          else {                          ### No "\n"; slurp the remainder:
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos});
              *$self->{Pos} = $len;
          }
          return $line;
      }
  
      ### Case 3: $/ is ref to int. Do fixed-size records.
      ###        (Thanks to Dominique Quatravaux.)
      elsif (ref($/)) {
          my $len = length($$sr);
  		my $i = ${$/} + 0;
  		my $line = substr ($$sr, *$self->{Pos}, $i);
  		*$self->{Pos} += $i;
          *$self->{Pos} = $len if (*$self->{Pos} > $len);
  		return $line;
      }
  
      ### Case 4: $/ is either "" (paragraphs) or something weird...
      ###         This is Graham's general-purpose stuff, which might be
      ###         a tad slower than Case 2 for typical data, because
      ###         of the regexps.
      else {
          pos($$sr) = $i;
  
  	### If in paragraph mode, skip leading lines (and update i!):
          length($/) or
  	    (($$sr =~ m/\G\n*/g) and ($i = pos($$sr)));
  
          ### If we see the separator in the buffer ahead...
          if (length($/)
  	    ?  $$sr =~ m,\Q$/\E,g          ###   (ordinary sep) TBD: precomp!
              :  $$sr =~ m,\n\n,g            ###   (a paragraph)
              ) {
              *$self->{Pos} = pos $$sr;
              return substr($$sr, $i, *$self->{Pos}-$i);
          }
          ### Else if no separator remains, just slurp the rest:
          else {
              *$self->{Pos} = length $$sr;
              return substr($$sr, $i);
          }
      }
  }
  
  #------------------------------
  
  =item getlines
  
  I<Instance method.>
  Get all remaining lines.
  It will croak() if accidentally called in a scalar context.
  
  =cut
  
  sub getlines {
      my $self = shift;
      wantarray or croak("can't call getlines in scalar context!");
      my ($line, @lines);
      push @lines, $line while (defined($line = $self->getline));
      @lines;
  }
  
  #------------------------------
  
  =item print ARGS...
  
  I<Instance method.>
  Print ARGS to the underlying scalar.
  
  B<Warning:> this continues to always cause a seek to the end
  of the string, but if you perform seek()s and tell()s, it is
  still safer to explicitly seek-to-end before subsequent print()s.
  
  =cut
  
  sub print {
      my $self = shift;
      *$self->{Pos} = length(${*$self->{SR}} .= join('', @_) . (defined($\) ? $\ : ""));
      1;
  }
  sub _unsafe_print {
      my $self = shift;
      my $append = join('', @_) . $\;
      ${*$self->{SR}} .= $append;
      *$self->{Pos}   += length($append);
      1;
  }
  sub _old_print {
      my $self = shift;
      ${*$self->{SR}} .= join('', @_) . $\;
      *$self->{Pos} = length(${*$self->{SR}});
      1;
  }
  
  
  #------------------------------
  
  =item read BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub read {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $read = substr(${*$self->{SR}}, *$self->{Pos}, $n);
      $n = length($read);
      *$self->{Pos} += $n;
      ($off ? substr($_[1], $off) : $_[1]) = $read;
      return $n;
  }
  
  #------------------------------
  
  =item write BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub write {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $data = substr($_[1], $off, $n);
      $n = length($data);
      $self->print($data);
      return $n;
  }
  
  #------------------------------
  
  =item sysread BUF, LEN, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub sysread {
    my $self = shift;
    $self->read(@_);
  }
  
  #------------------------------
  
  =item syswrite BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub syswrite {
    my $self = shift;
    $self->write(@_);
  }
  
  =back
  
  =cut
  
  
  #==============================
  
  =head2 Seeking/telling and other attributes
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item autoflush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub autoflush {}
  
  #------------------------------
  
  =item binmode
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub binmode {}
  
  #------------------------------
  
  =item clearerr
  
  I<Instance method.>  Clear the error and EOF flags.  A no-op.
  
  =cut
  
  sub clearerr { 1 }
  
  #------------------------------
  
  =item eof
  
  I<Instance method.>  Are we at end of file?
  
  =cut
  
  sub eof {
      my $self = shift;
      (*$self->{Pos} >= length(${*$self->{SR}}));
  }
  
  #------------------------------
  
  =item seek OFFSET, WHENCE
  
  I<Instance method.>  Seek to a given position in the stream.
  
  =cut
  
  sub seek {
      my ($self, $pos, $whence) = @_;
      my $eofpos = length(${*$self->{SR}});
  
      ### Seek:
      if    ($whence == 0) { *$self->{Pos} = $pos }             ### SEEK_SET
      elsif ($whence == 1) { *$self->{Pos} += $pos }            ### SEEK_CUR
      elsif ($whence == 2) { *$self->{Pos} = $eofpos + $pos}    ### SEEK_END
      else                 { croak "bad seek whence ($whence)" }
  
      ### Fixup:
      if (*$self->{Pos} < 0)       { *$self->{Pos} = 0 }
      if (*$self->{Pos} > $eofpos) { *$self->{Pos} = $eofpos }
      return 1;
  }
  
  #------------------------------
  
  =item sysseek OFFSET, WHENCE
  
  I<Instance method.> Identical to C<seek OFFSET, WHENCE>, I<q.v.>
  
  =cut
  
  sub sysseek {
      my $self = shift;
      $self->seek (@_);
  }
  
  #------------------------------
  
  =item tell
  
  I<Instance method.>
  Return the current position in the stream, as a numeric offset.
  
  =cut
  
  sub tell { *{shift()}->{Pos} }
  
  #------------------------------
  #
  # use_RS [YESNO]
  #
  # I<Instance method.>
  # Obey the curent setting of $/, like IO::Handle does?
  # Default is false in 1.x, but cold-welded true in 2.x and later.
  #
  sub use_RS {
      my ($self, $yesno) = @_;
      carp "use_RS is deprecated and ignored; \$/ is always consulted\n";
   }
  
  #------------------------------
  
  =item setpos POS
  
  I<Instance method.>
  Set the current position, using the opaque value returned by C<getpos()>.
  
  =cut
  
  sub setpos { shift->seek($_[0],0) }
  
  #------------------------------
  
  =item getpos
  
  I<Instance method.>
  Return the current position in the string, as an opaque object.
  
  =cut
  
  *getpos = \&tell;
  
  
  #------------------------------
  
  =item sref
  
  I<Instance method.>
  Return a reference to the underlying scalar.
  
  =cut
  
  sub sref { *{shift()}->{SR} }
  
  
  #------------------------------
  # Tied handle methods...
  #------------------------------
  
  # Conventional tiehandle interface:
  sub TIEHANDLE {
      ((defined($_[1]) && UNIVERSAL::isa($_[1], "IO::Scalar"))
       ? $_[1]
       : shift->new(@_));
  }
  sub GETC      { shift->getc(@_) }
  sub PRINT     { shift->print(@_) }
  sub PRINTF    { shift->print(sprintf(shift, @_)) }
  sub READ      { shift->read(@_) }
  sub READLINE  { wantarray ? shift->getlines(@_) : shift->getline(@_) }
  sub WRITE     { shift->write(@_); }
  sub CLOSE     { shift->close(@_); }
  sub SEEK      { shift->seek(@_); }
  sub TELL      { shift->tell(@_); }
  sub EOF       { shift->eof(@_); }
  
  #------------------------------------------------------------
  
  1;
  
  __END__
  
  
  
  =back
  
  =cut
  
  
  =head1 WARNINGS
  
  Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
  it was missing support for C<seek()>, C<tell()>, and C<eof()>.
  Attempting to use these functions with an IO::Scalar will not work
  prior to 5.005_57. IO::Scalar will not have the relevant methods
  invoked; and even worse, this kind of bug can lie dormant for a while.
  If you turn warnings on (via C<$^W> or C<perl -w>),
  and you see something like this...
  
      attempt to seek on unopened filehandle
  
  ...then you are probably trying to use one of these functions
  on an IO::Scalar with an old Perl.  The remedy is to simply
  use the OO version; e.g.:
  
      $SH->seek(0,0);    ### GOOD: will work on any 5.005
      seek($SH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
  
  
  =head1 VERSION
  
  $Id: Scalar.pm,v 1.6 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHORS
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Principal author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head2 Other contributors
  
  The full set of contributors always includes the folks mentioned
  in L<IO::Stringy/"CHANGE LOG">.  But just the same, special
  thanks to the following individuals for their invaluable contributions
  (if I've forgotten or misspelled your name, please email me!):
  
  I<Andy Glew,>
  for contributing C<getc()>.
  
  I<Brandon Browning,>
  for suggesting C<opened()>.
  
  I<David Richter,>
  for finding and fixing the bug in C<PRINTF()>.
  
  I<Eric L. Brine,>
  for his offset-using read() and write() implementations.
  
  I<Richard Jones,>
  for his patches to massively improve the performance of C<getline()>
  and add C<sysread> and C<syswrite>.
  
  I<B. K. Oxley (binkley),>
  for stringification and inheritance improvements,
  and sundry good ideas.
  
  I<Doug Wilson,>
  for the IO::Handle inheritance and automatic tie-ing.
  
  
  =head1 SEE ALSO
  
  L<IO::String>, which is quite similar but which was designed
  more-recently and with an IO::Handle-like interface in mind,
  so you could mix OO- and native-filehandle usage without using tied().
  
  I<Note:> as of version 2.x, these classes all work like
  their IO::Handle counterparts, so we have comparable
  functionality to IO::String.
  
  =cut
  
IO_SCALAR

$fatpacked{"IO/ScalarArray.pm"} = <<'IO_SCALARARRAY';
  package IO::ScalarArray;
  
  
  =head1 NAME
  
  IO::ScalarArray - IO:: interface for reading/writing an array of scalars
  
  
  =head1 SYNOPSIS
  
  Perform I/O on strings, using the basic OO interface...
  
      use IO::ScalarArray;
      @data = ("My mes", "sage:\n");
  
      ### Open a handle on an array, and append to it:
      $AH = new IO::ScalarArray \@data;
      $AH->print("Hello");       
      $AH->print(", world!\nBye now!\n");  
      print "The array is now: ", @data, "\n";
  
      ### Open a handle on an array, read it line-by-line, then close it:
      $AH = new IO::ScalarArray \@data;
      while (defined($_ = $AH->getline)) { 
  	print "Got line: $_";
      }
      $AH->close;
  
      ### Open a handle on an array, and slurp in all the lines:
      $AH = new IO::ScalarArray \@data;
      print "All lines:\n", $AH->getlines; 
  
      ### Get the current position (either of two ways):
      $pos = $AH->getpos;         
      $offset = $AH->tell;  
  
      ### Set the current position (either of two ways):
      $AH->setpos($pos);        
      $AH->seek($offset, 0);
  
      ### Open an anonymous temporary array:
      $AH = new IO::ScalarArray;
      $AH->print("Hi there!");
      print "I printed: ", @{$AH->aref}, "\n";      ### get at value
  
  
  Don't like OO for your I/O?  No problem.  
  Thanks to the magic of an invisible tie(), the following now 
  works out of the box, just as it does with IO::Handle:
      
      use IO::ScalarArray;
      @data = ("My mes", "sage:\n");
  
      ### Open a handle on an array, and append to it:
      $AH = new IO::ScalarArray \@data;
      print $AH "Hello";    
      print $AH ", world!\nBye now!\n";
      print "The array is now: ", @data, "\n";
  
      ### Open a handle on a string, read it line-by-line, then close it:
      $AH = new IO::ScalarArray \@data;
      while (<$AH>) {
  	print "Got line: $_";
      }
      close $AH;
  
      ### Open a handle on a string, and slurp in all the lines:
      $AH = new IO::ScalarArray \@data;
      print "All lines:\n", <$AH>;
  
      ### Get the current position (WARNING: requires 5.6):
      $offset = tell $AH;
  
      ### Set the current position (WARNING: requires 5.6):
      seek $AH, $offset, 0;
  
      ### Open an anonymous temporary scalar:
      $AH = new IO::ScalarArray;
      print $AH "Hi there!";
      print "I printed: ", @{$AH->aref}, "\n";      ### get at value
  
  
  And for you folks with 1.x code out there: the old tie() style still works,
  though this is I<unnecessary and deprecated>:
  
      use IO::ScalarArray;
  
      ### Writing to a scalar...
      my @a; 
      tie *OUT, 'IO::ScalarArray', \@a;
      print OUT "line 1\nline 2\n", "line 3\n";
      print "Array is now: ", @a, "\n"
  
      ### Reading and writing an anonymous scalar... 
      tie *OUT, 'IO::ScalarArray';
      print OUT "line 1\nline 2\n", "line 3\n";
      tied(OUT)->seek(0,0);
      while (<OUT>) { 
          print "Got line: ", $_;
      }
  
  
  
  =head1 DESCRIPTION
  
  This class is part of the IO::Stringy distribution;
  see L<IO::Stringy> for change log and general information.
  
  The IO::ScalarArray class implements objects which behave just like 
  IO::Handle (or FileHandle) objects, except that you may use them 
  to write to (or read from) arrays of scalars.  Logically, an
  array of scalars defines an in-core "file" whose contents are
  the concatenation of the scalars in the array.  The handles created by 
  this class are automatically tiehandle'd (though please see L<"WARNINGS">
  for information relevant to your Perl version).
  
  For writing large amounts of data with individual print() statements, 
  this class is likely to be more efficient than IO::Scalar.
  
  Basically, this:
  
      my @a;
      $AH = new IO::ScalarArray \@a;
      $AH->print("Hel", "lo, ");         ### OO style
      $AH->print("world!\n");            ### ditto
  
  Or this:
  
      my @a;
      $AH = new IO::ScalarArray \@a;
      print $AH "Hel", "lo, ";           ### non-OO style
      print $AH "world!\n";              ### ditto
  
  Causes @a to be set to the following array of 3 strings:
  
      ( "Hel" , 
        "lo, " , 
        "world!\n" )
  
  See L<IO::Scalar> and compare with this class.
  
  
  =head1 PUBLIC INTERFACE
  
  =cut
  
  use Carp;
  use strict;
  use vars qw($VERSION @ISA);
  use IO::Handle;
  
  # The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.110";
  
  # Inheritance:
  @ISA = qw(IO::Handle);
  require IO::WrapTie and push @ISA, 'IO::WrapTie::Slave' if ($] >= 5.004);
  
  
  #==============================
  
  =head2 Construction 
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item new [ARGS...]
  
  I<Class method.>
  Return a new, unattached array handle.  
  If any arguments are given, they're sent to open().
  
  =cut
  
  sub new {
      my $proto = shift;
      my $class = ref($proto) || $proto;
      my $self = bless \do { local *FH }, $class;
      tie *$self, $class, $self;
      $self->open(@_);  ### open on anonymous by default
      $self;
  }
  sub DESTROY { 
      shift->close;
  }
  
  
  #------------------------------
  
  =item open [ARRAYREF]
  
  I<Instance method.>
  Open the array handle on a new array, pointed to by ARRAYREF.
  If no ARRAYREF is given, a "private" array is created to hold
  the file data.
  
  Returns the self object on success, undefined on error.
  
  =cut
  
  sub open {
      my ($self, $aref) = @_;
  
      ### Sanity:
      defined($aref) or do {my @a; $aref = \@a};
      (ref($aref) eq "ARRAY") or croak "open needs a ref to a array";
  
      ### Setup:
      $self->setpos([0,0]);
      *$self->{AR} = $aref;
      $self;
  }
  
  #------------------------------
  
  =item opened
  
  I<Instance method.>
  Is the array handle opened on something?
  
  =cut
  
  sub opened {
      *{shift()}->{AR};
  }
  
  #------------------------------
  
  =item close
  
  I<Instance method.>
  Disassociate the array handle from its underlying array.
  Done automatically on destroy.
  
  =cut
  
  sub close {
      my $self = shift;
      %{*$self} = ();
      1;
  }
  
  =back
  
  =cut
  
  
  
  #==============================
  
  =head2 Input and output
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item flush 
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub flush { "0 but true" } 
  
  #------------------------------
  
  =item getc
  
  I<Instance method.>
  Return the next character, or undef if none remain.
  This does a read(1), which is somewhat costly.
  
  =cut
  
  sub getc {
      my $buf = '';
      ($_[0]->read($buf, 1) ? $buf : undef);
  }
  
  #------------------------------
  
  =item getline
  
  I<Instance method.>
  Return the next line, or undef on end of data.
  Can safely be called in an array context.
  Currently, lines are delimited by "\n".
  
  =cut
  
  sub getline {
      my $self = shift;
      my ($str, $line) = (undef, '');
  
  
      ### Minimal impact implementation!
      ### We do the fast fast thing (no regexps) if using the
      ### classic input record separator.
  
      ### Case 1: $/ is undef: slurp all...    
      if    (!defined($/)) {
  
          return undef if ($self->eof);
  
  	### Get the rest of the current string, followed by remaining strings:
  	my $ar = *$self->{AR};
  	my @slurp = (
  		     substr($ar->[*$self->{Str}], *$self->{Pos}),
  		     @$ar[(1 + *$self->{Str}) .. $#$ar ] 
  		     );
  	     	
  	### Seek to end:
  	$self->_setpos_to_eof;
  	return join('', @slurp);
      }
  
      ### Case 2: $/ is "\n": 
      elsif ($/ eq "\012") {    
  	
  	### Until we hit EOF (or exitted because of a found line):
  	until ($self->eof) {
  	    ### If at end of current string, go fwd to next one (won't be EOF):
  	    if ($self->_eos) {++*$self->{Str}, *$self->{Pos}=0};
  
  	    ### Get ref to current string in array, and set internal pos mark:
  	    $str = \(*$self->{AR}[*$self->{Str}]); ### get current string
  	    pos($$str) = *$self->{Pos};            ### start matching from here
  	
  	    ### Get from here to either \n or end of string, and add to line:
  	    $$str =~ m/\G(.*?)((\n)|\Z)/g;         ### match to 1st \n or EOS
  	    $line .= $1.$2;                        ### add it
  	    *$self->{Pos} += length($1.$2);        ### move fwd by len matched
  	    return $line if $3;                    ### done, got line with "\n"
          }
          return ($line eq '') ? undef : $line;  ### return undef if EOF
      }
  
      ### Case 3: $/ is ref to int.  Bail out.
      elsif (ref($/)) {
          croak '$/ given as a ref to int; currently unsupported';
      }
  
      ### Case 4: $/ is either "" (paragraphs) or something weird...
      ###         Bail for now.
      else {                
          croak '$/ as given is currently unsupported';
      }
  }
  
  #------------------------------
  
  =item getlines
  
  I<Instance method.>
  Get all remaining lines.
  It will croak() if accidentally called in a scalar context.
  
  =cut
  
  sub getlines {
      my $self = shift;
      wantarray or croak("can't call getlines in scalar context!");
      my ($line, @lines);
      push @lines, $line while (defined($line = $self->getline));
      @lines;
  }
  
  #------------------------------
  
  =item print ARGS...
  
  I<Instance method.>
  Print ARGS to the underlying array.  
  
  Currently, this always causes a "seek to the end of the array"
  and generates a new array entry.  This may change in the future.
  
  =cut
  
  sub print {
      my $self = shift;
      push @{*$self->{AR}}, join('', @_) . (defined($\) ? $\ : "");      ### add the data
      $self->_setpos_to_eof;
      1;
  }
  
  #------------------------------
  
  =item read BUF, NBYTES, [OFFSET];
  
  I<Instance method.>
  Read some bytes from the array.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub read {
      my $self = $_[0];
      ### we must use $_[1] as a ref
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      ### print "getline\n";
      my $justread;
      my $len;
      ($off ? substr($_[1], $off) : $_[1]) = '';
  
      ### Stop when we have zero bytes to go, or when we hit EOF:
      my @got;
      until (!$n or $self->eof) {       
          ### If at end of current string, go forward to next one (won't be EOF):
          if ($self->_eos) {
              ++*$self->{Str};
              *$self->{Pos} = 0;
          }
  
          ### Get longest possible desired substring of current string:
          $justread = substr(*$self->{AR}[*$self->{Str}], *$self->{Pos}, $n);
          $len = length($justread);
          push @got, $justread;
          $n            -= $len; 
          *$self->{Pos} += $len;
      }
      $_[1] .= join('', @got);
      return length($_[1])-$off;
  }
  
  #------------------------------
  
  =item write BUF, NBYTES, [OFFSET];
  
  I<Instance method.>
  Write some bytes into the array.
  
  =cut
  
  sub write {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $data = substr($_[1], $n, $off);
      $n = length($data);
      $self->print($data);
      return $n;
  }
  
  
  =back
  
  =cut
  
  
  
  #==============================
  
  =head2 Seeking/telling and other attributes
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item autoflush 
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub autoflush {} 
  
  #------------------------------
  
  =item binmode
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub binmode {} 
  
  #------------------------------
  
  =item clearerr
  
  I<Instance method.>  Clear the error and EOF flags.  A no-op.
  
  =cut
  
  sub clearerr { 1 }
  
  #------------------------------
  
  =item eof 
  
  I<Instance method.>  Are we at end of file?
  
  =cut
  
  sub eof {
      ### print "checking EOF [*$self->{Str}, *$self->{Pos}]\n";
      ### print "SR = ", $#{*$self->{AR}}, "\n";
  
      return 0 if (*{$_[0]}->{Str} < $#{*{$_[0]}->{AR}});  ### before EOA
      return 1 if (*{$_[0]}->{Str} > $#{*{$_[0]}->{AR}});  ### after EOA
      ###                                                  ### at EOA, past EOS:
      ((*{$_[0]}->{Str} == $#{*{$_[0]}->{AR}}) && ($_[0]->_eos)); 
  }
  
  #------------------------------
  #
  # _eos
  #
  # I<Instance method, private.>  Are we at end of the CURRENT string?
  #
  sub _eos {
      (*{$_[0]}->{Pos} >= length(*{$_[0]}->{AR}[*{$_[0]}->{Str}])); ### past last char
  }
  
  #------------------------------
  
  =item seek POS,WHENCE
  
  I<Instance method.>
  Seek to a given position in the stream.
  Only a WHENCE of 0 (SEEK_SET) is supported.
  
  =cut
  
  sub seek {
      my ($self, $pos, $whence) = @_; 
  
      ### Seek:
      if    ($whence == 0) { $self->_seek_set($pos); }
      elsif ($whence == 1) { $self->_seek_cur($pos); }
      elsif ($whence == 2) { $self->_seek_end($pos); }
      else                 { croak "bad seek whence ($whence)" }
      return 1;
  }
  
  #------------------------------
  #
  # _seek_set POS
  #
  # Instance method, private.
  # Seek to $pos relative to start:
  #
  sub _seek_set {
      my ($self, $pos) = @_; 
  
      ### Advance through array until done:
      my $istr = 0;
      while (($pos >= 0) && ($istr < scalar(@{*$self->{AR}}))) {
  	if (length(*$self->{AR}[$istr]) > $pos) {   ### it's in this string! 
  	    return $self->setpos([$istr, $pos]);
  	}
  	else {                                      ### it's in next string
  	    $pos -= length(*$self->{AR}[$istr++]);  ### move forward one string
  	}
      }
      ### If we reached this point, pos is at or past end; zoom to EOF:
      return $self->_setpos_to_eof;
  }
  
  #------------------------------
  #
  # _seek_cur POS
  #
  # Instance method, private.
  # Seek to $pos relative to current position.
  #
  sub _seek_cur {
      my ($self, $pos) = @_; 
      $self->_seek_set($self->tell + $pos);
  }
  
  #------------------------------
  #
  # _seek_end POS
  #
  # Instance method, private.
  # Seek to $pos relative to end.
  # We actually seek relative to beginning, which is simple.
  #
  sub _seek_end {
      my ($self, $pos) = @_; 
      $self->_seek_set($self->_tell_eof + $pos);
  }
  
  #------------------------------
  
  =item tell
  
  I<Instance method.>
  Return the current position in the stream, as a numeric offset.
  
  =cut
  
  sub tell {
      my $self = shift;
      my $off = 0;
      my ($s, $str_s);
      for ($s = 0; $s < *$self->{Str}; $s++) {   ### count all "whole" scalars
  	defined($str_s = *$self->{AR}[$s]) or $str_s = '';
  	###print STDERR "COUNTING STRING $s (". length($str_s) . ")\n";
  	$off += length($str_s);
      }
      ###print STDERR "COUNTING POS ($self->{Pos})\n";
      return ($off += *$self->{Pos});            ### plus the final, partial one
  }
  
  #------------------------------
  #
  # _tell_eof
  #
  # Instance method, private.
  # Get position of EOF, as a numeric offset.
  # This is identical to the size of the stream - 1.
  #
  sub _tell_eof {
      my $self = shift;
      my $len = 0;
      foreach (@{*$self->{AR}}) { $len += length($_) }
      $len;
  }
  
  #------------------------------
  
  =item setpos POS
  
  I<Instance method.>
  Seek to a given position in the array, using the opaque getpos() value.
  Don't expect this to be a number.
  
  =cut
  
  sub setpos { 
      my ($self, $pos) = @_;
      (ref($pos) eq 'ARRAY') or
  	die "setpos: only use a value returned by getpos!\n";
      (*$self->{Str}, *$self->{Pos}) = @$pos;
  }
  
  #------------------------------
  #
  # _setpos_to_eof
  #
  # Fast-forward to EOF.
  #
  sub _setpos_to_eof {
      my $self = shift;
      $self->setpos([scalar(@{*$self->{AR}}), 0]);
  }
  
  #------------------------------
  
  =item getpos
  
  I<Instance method.>
  Return the current position in the array, as an opaque value.
  Don't expect this to be a number.
  
  =cut
  
  sub getpos {
      [*{$_[0]}->{Str}, *{$_[0]}->{Pos}];
  }
  
  #------------------------------
  
  =item aref
  
  I<Instance method.>
  Return a reference to the underlying array.
  
  =cut
  
  sub aref {
      *{shift()}->{AR};
  }
  
  =back
  
  =cut
  
  #------------------------------
  # Tied handle methods...
  #------------------------------
  
  ### Conventional tiehandle interface:
  sub TIEHANDLE { (defined($_[1]) && UNIVERSAL::isa($_[1],"IO::ScalarArray"))
  		    ? $_[1] 
  		    : shift->new(@_) }
  sub GETC      { shift->getc(@_) }
  sub PRINT     { shift->print(@_) }
  sub PRINTF    { shift->print(sprintf(shift, @_)) }
  sub READ      { shift->read(@_) }
  sub READLINE  { wantarray ? shift->getlines(@_) : shift->getline(@_) }
  sub WRITE     { shift->write(@_); }
  sub CLOSE     { shift->close(@_); }
  sub SEEK      { shift->seek(@_); }
  sub TELL      { shift->tell(@_); }
  sub EOF       { shift->eof(@_); }
  
  #------------------------------------------------------------
  
  1;
  __END__
  
  # SOME PRIVATE NOTES:
  #
  #     * The "current position" is the position before the next
  #       character to be read/written.
  #
  #     * Str gives the string index of the current position, 0-based
  #
  #     * Pos gives the offset within AR[Str], 0-based.
  #
  #     * Inital pos is [0,0].  After print("Hello"), it is [1,0].
  
  
  
  =head1 WARNINGS
  
  Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
  it was missing support for C<seek()>, C<tell()>, and C<eof()>.
  Attempting to use these functions with an IO::ScalarArray will not work
  prior to 5.005_57. IO::ScalarArray will not have the relevant methods 
  invoked; and even worse, this kind of bug can lie dormant for a while.
  If you turn warnings on (via C<$^W> or C<perl -w>),
  and you see something like this...
  
      attempt to seek on unopened filehandle
  
  ...then you are probably trying to use one of these functions
  on an IO::ScalarArray with an old Perl.  The remedy is to simply
  use the OO version; e.g.:
  
      $AH->seek(0,0);    ### GOOD: will work on any 5.005
      seek($AH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
  
  
  
  =head1 VERSION
  
  $Id: ScalarArray.pm,v 1.7 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHOR
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Principal author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head2 Other contributors 
  
  Thanks to the following individuals for their invaluable contributions
  (if I've forgotten or misspelled your name, please email me!):
  
  I<Andy Glew,>
  for suggesting C<getc()>.
  
  I<Brandon Browning,>
  for suggesting C<opened()>.
  
  I<Eric L. Brine,>
  for his offset-using read() and write() implementations. 
  
  I<Doug Wilson,>
  for the IO::Handle inheritance and automatic tie-ing.
  
  =cut
  
  #------------------------------
  1;
  
IO_SCALARARRAY

$fatpacked{"IO/Stringy.pm"} = <<'IO_STRINGY';
  package IO::Stringy;
  
  use vars qw($VERSION);
  $VERSION = "2.110";
  
  1;
  __END__
  
  
  =head1 NAME
  
  IO-stringy - I/O on in-core objects like strings and arrays
  
  
  =head1 SYNOPSIS
  
      IO::
      ::AtomicFile   adpO  Write a file which is updated atomically     ERYQ
      ::Lines        bdpO  I/O handle to read/write to array of lines   ERYQ
      ::Scalar       RdpO  I/O handle to read/write to a string         ERYQ
      ::ScalarArray  RdpO  I/O handle to read/write to array of scalars ERYQ
      ::Wrap         RdpO  Wrap old-style FHs in standard OO interface  ERYQ
      ::WrapTie      adpO  Tie your handles & retain full OO interface  ERYQ
  
  
  =head1 DESCRIPTION
  
  This toolkit primarily provides modules for performing both traditional
  and object-oriented i/o) on things I<other> than normal filehandles;
  in particular, L<IO::Scalar|IO::Scalar>, L<IO::ScalarArray|IO::ScalarArray>,
  and L<IO::Lines|IO::Lines>.
  
  In the more-traditional IO::Handle front, we
  have L<IO::AtomicFile|IO::AtomicFile>
  which may be used to painlessly create files which are updated
  atomically.
  
  And in the "this-may-prove-useful" corner, we have L<IO::Wrap|IO::Wrap>,
  whose exported wraphandle() function will clothe anything that's not
  a blessed object in an IO::Handle-like wrapper... so you can just
  use OO syntax and stop worrying about whether your function's caller
  handed you a string, a globref, or a FileHandle.
  
  
  =head1 WARNINGS
  
  Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
  it was missing support for C<seek()>, C<tell()>, and C<eof()>.
  Attempting to use these functions with an IO::Scalar, IO::ScalarArray,
  IO::Lines, etc. B<will not work> prior to 5.005_57.
  None of the relevant methods will be invoked by Perl;
  and even worse, this kind of bug can lie dormant for a while.
  If you turn warnings on (via C<$^W> or C<perl -w>), and you see
  something like this...
  
      seek() on unopened file
  
  ...then you are probably trying to use one of these functions
  on one of our IO:: classes with an old Perl.  The remedy is to simply
  use the OO version; e.g.:
  
      $SH->seek(0,0);    ### GOOD: will work on any 5.005
      seek($SH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
  
  
  
  =head1 INSTALLATION
  
  
  =head2 Requirements
  
  As of version 2.x, this toolkit requires Perl 5.005 for
  the IO::Handle subclasses, and 5.005_57 or better is
  B<strongly> recommended.  See L<"WARNINGS"> for details.
  
  
  =head2 Directions
  
  Most of you already know the drill...
  
      perl Makefile.PL
      make
      make test
      make install
  
  For everyone else out there...
  if you've never installed Perl code before, or you're trying to use
  this in an environment where your sysadmin or ISP won't let you do
  interesting things, B<relax:> since this module contains no binary
  extensions, you can cheat.  That means copying the directory tree
  under my "./lib" directory into someplace where your script can "see"
  it.  For example, under Linux:
  
      cp -r IO-stringy-1.234/lib/* /path/to/my/perl/
  
  Now, in your Perl code, do this:
  
      use lib "/path/to/my/perl";
      use IO::Scalar;                   ### or whatever
  
  Ok, now you've been told.  At this point, anyone who whines about
  not being given enough information gets an unflattering haiku
  written about them in the next change log.  I'll do it.
  Don't think I won't.
  
  
  
  =head1 VERSION
  
  $Id: Stringy.pm,v 1.3 2005/02/10 21:24:05 dfs Exp $
  
  
  
  =head1 TO DO
  
  =over 4
  
  =item (2000/08/02)  Finalize $/ support
  
  Graham Barr submitted this patch half a I<year> ago;
  Like a moron, I lost his message under a ton of others,
  and only now have the experimental implementation done.
  
  Will the sudden sensitivity to $/ hose anyone out there?
  I'm worried, so you have to enable it explicitly in 1.x.
  It will be on by default in 2.x, though only IO::Scalar
  has been implemented.
  
  =item (2001/08/08)  Remove IO::WrapTie from new IO:: classes
  
  It's not needed.  Backwards compatibility could be maintained
  by having new_tie() be identical to new().  Heck, I'll bet
  that IO::WrapTie should be reimplemented so the returned
  object is just like an IO::Scalar in its use of globrefs.
  
  
  =back
  
  
  
  =head1 CHANGE LOG
  
  =over 4
  
  
  =item Version 2.110   (2005/02/10)
  
  Maintainership taken over by DSKOLL <dfs@roaringpenguin.com>
  
  Closed the following bugs at
  https://rt.cpan.org/NoAuth/Bugs.html?Dist=IO-stringy:
  
  =item
  
  2208 IO::ScalarArray->getline does not return undef for EOF if undef($/)
  
  =item
  
  7132 IO-stringy/Makefile.PL bug - name should be module name
  
  =item
  
  11249 IO::Scalar flush shouldn't return undef
  
  =item
  
  2172 $\ (output record separator) not respected
  
  =item
  
  8605 IO::InnerFile::seek() should return 1 on success
  
  =item
  
  4798 *.html in lib/
  
  =item
  
  4369 Improvement: handling of fixed-size reads in IO::Scalar
  
  (Actually, bug 4369 was closed in Version 2.109)
  
  =item Version 2.109   (2003/12/21)
  
  IO::Scalar::getline now works with ref to int.
  I<Thanks to Dominique Quatravaux for this patch.>
  
  
  =item Version 2.108   (2001/08/20)
  
  The terms-of-use have been placed in the distribution file "COPYING".
  Also, small documentation tweaks were made.
  
  
  =item Version 2.105   (2001/08/09)
  
  Added support for various seek() whences to IO::ScalarArray.
  
  Added support for consulting $/ in IO::Scalar and IO::ScalarArray.
  The old C<use_RS()> is not even an option.
  Unsupported record separators will cause a croak().
  
  Added a lot of regression tests to supoprt the above.
  
  Better on-line docs (hyperlinks to individual functions).
  
  
  =item Version 2.103   (2001/08/08)
  
  After sober consideration I have reimplemented IO::Scalar::print()
  so that it once again always seeks to the end of the string.
  Benchmarks show the new implementation to be just as fast as
  Juergen's contributed patch; until someone can convince me otherwise,
  the current, safer implementation stays.
  
  I thought more about giving IO::Scalar two separate handles,
  one for reading and one for writing, as suggested by Binkley.
  His points about what tell() and eof() return are, I think,
  show-stoppers for this feature.  Even the manpages for stdio's fseek()
  seem to imply a I<single> file position indicator, not two.
  So I think I will take this off the TO DO list.
  B<Remedy:> you can always have two handles open on the same
  scalar, one which you only write to, and one which you only read from.
  That should give the same effect.
  
  
  =item Version 2.101   (2001/08/07)
  
  B<Alpha release.>
  This is the initial release of the "IO::Scalar and friends are
  now subclasses of IO::Handle".  I'm flinging it against the wall.
  Please tell me if the banana sticks.  When it does, the banana
  will be called 2.2x.
  
  First off, I<many many thanks to Doug Wilson>, who
  has provided an I<invaluable> service by patching IO::Scalar
  and friends so that they (1) inherit from IO::Handle, (2) automatically
  tie themselves so that the C<new()> objects can be used in native i/o
  constructs, and (3) doing it so that the whole damn thing passes
  its regression tests.  As Doug knows, my globref Kung-Fu was not
  up to the task; he graciously provided the patches.  This has earned
  him a seat at the L<Co-Authors|"AUTHOR"> table, and the
  right to have me address him as I<sensei>.
  
  Performance of IO::Scalar::print() has been improved by as much as 2x
  for lots of little prints, with the cost of forcing those
  who print-then-seek-then-print to explicitly seek to end-of-string
  before printing again.
  I<Thanks to Juergen Zeller for this patch.>
  
  Added the COPYING file, which had been missing from prior versions.
  I<Thanks to Albert Chin-A-Young for pointing this out.>
  
  IO::Scalar consults $/ by default (1.x ignored it by default).
  Yes, I still need to support IO::ScalarArray.
  
  
  =item Version 1.221   (2001/08/07)
  
  I threatened in L<"INSTALLATION"> to write an unflattering haiku
  about anyone who whined that I gave them insufficient information...
  but it turns out that I left out a crucial direction.  D'OH!
  I<Thanks to David Beroff for the "patch" and the haiku...>
  
         Enough info there?
  	 Here's unflattering haiku:
         Forgot the line, "make"!  ;-)
  
  
  
  =item Version 1.220   (2001/04/03)
  
  Added untested SEEK, TELL, and EOF methods to IO::Scalar
  and IO::ScalarArray to support corresponding functions for
  tied filehandles: untested, because I'm still running 5.00556
  and Perl is complaining about "tell() on unopened file".
  I<Thanks to Graham Barr for the suggestion.>
  
  Removed not-fully-blank lines from modules; these were causing
  lots of POD-related warnings.
  I<Thanks to Nicolas Joly for the suggestion.>
  
  
  =item Version 1.219   (2001/02/23)
  
  IO::Scalar objects can now be made sensitive to $/ .
  Pains were taken to keep the fast code fast while adding this feature.
  I<Cheers to Graham Barr for submitting his patch;
  jeers to me for losing his email for 6 months.>
  
  
  =item Version 1.218   (2001/02/23)
  
  IO::Scalar has a new sysseek() method.
  I<Thanks again to Richard Jones.>
  
  New "TO DO" section, because people who submit patches/ideas should
  at least know that they're in the system... and that I won't lose
  their stuff.  Please read it.
  
  New entries in L<"AUTHOR">.
  Please read those too.
  
  
  
  =item Version 1.216   (2000/09/28)
  
  B<IO::Scalar and IO::ScalarArray now inherit from IO::Handle.>
  I thought I'd remembered a problem with this ages ago, related to
  the fact that these IO:: modules don't have "real" filehandles,
  but the problem apparently isn't surfacing now.
  If you suddenly encounter Perl warnings during global destruction
  (especially if you're using tied filehandles), then please let me know!
  I<Thanks to B. K. Oxley (binkley) for this.>
  
  B<Nasty bug fixed in IO::Scalar::write().>
  Apparently, the offset and the number-of-bytes arguments were,
  for all practical purposes, I<reversed.>  You were okay if
  you did all your writing with print(), but boy was I<this> a stupid bug!
  I<Thanks to Richard Jones for finding this one.
  For you, Rich, a double-length haiku:>
  
         Newspaper headline
  	  typeset by dyslexic man
         loses urgency
  
         BABY EATS FISH is
  	  simply not equivalent
         to FISH EATS BABY
  
  B<New sysread and syswrite methods for IO::Scalar.>
  I<Thanks again to Richard Jones for this.>
  
  
  =item Version 1.215   (2000/09/05)
  
  Added 'bool' overload to '""' overload, so object always evaluates
  to true.  (Whew.  Glad I caught this before it went to CPAN.)
  
  
  =item Version 1.214   (2000/09/03)
  
  Evaluating an IO::Scalar in a string context now yields
  the underlying string.
  I<Thanks to B. K. Oxley (binkley) for this.>
  
  
  =item Version 1.213   (2000/08/16)
  
  Minor documentation fixes.
  
  
  =item Version 1.212   (2000/06/02)
  
  Fixed IO::InnerFile incompatibility with Perl5.004.
  I<Thanks to many folks for reporting this.>
  
  
  =item Version 1.210   (2000/04/17)
  
  Added flush() and other no-op methods.
  I<Thanks to Doru Petrescu for suggesting this.>
  
  
  =item Version 1.209   (2000/03/17)
  
  Small bug fixes.
  
  
  =item Version 1.208   (2000/03/14)
  
  Incorporated a number of contributed patches and extensions,
  mostly related to speed hacks, support for "offset", and
  WRITE/CLOSE methods.
  I<Thanks to Richard Jones, Doru Petrescu, and many others.>
  
  
  
  =item Version 1.206   (1999/04/18)
  
  Added creation of ./testout when Makefile.PL is run.
  
  
  =item Version 1.205   (1999/01/15)
  
  Verified for Perl5.005.
  
  
  =item Version 1.202   (1998/04/18)
  
  New IO::WrapTie and IO::AtomicFile added.
  
  
  =item Version 1.110
  
  Added IO::WrapTie.
  
  
  =item Version 1.107
  
  Added IO::Lines, and made some bug fixes to IO::ScalarArray.
  Also, added getc().
  
  
  =item Version 1.105
  
  No real changes; just upgraded IO::Wrap to have a $VERSION string.
  
  =back
  
  
  
  
  =head1 AUTHOR
  
  =over 4
  
  =item Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =item Original Author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  =item Co-Authors
  
  For all their bug reports and patch submissions, the following
  are officially recognized:
  
       Richard Jones
       B. K. Oxley (binkley)
       Doru Petrescu
       Doug Wilson (for picking up the ball I dropped, and doing tie() right)
  
  
  =back
  
  Go to F<http://www.zeegee.com> for the latest downloads
  and on-line documentation for this module.
  
  Enjoy.  Yell if it breaks.
  
  
  =cut
IO_STRINGY

$fatpacked{"IO/Wrap.pm"} = <<'IO_WRAP';
  package IO::Wrap;
  
  # SEE DOCUMENTATION AT BOTTOM OF FILE
  
  require 5.002;
  
  use strict;
  use vars qw(@ISA @EXPORT $VERSION);
  @ISA = qw(Exporter);
  @EXPORT = qw(wraphandle);
  
  use FileHandle;
  use Carp;
  
  # The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.110";
  
  
  #------------------------------
  # wraphandle RAW
  #------------------------------
  sub wraphandle {
      my $raw = shift;
      new IO::Wrap $raw;
  }
  
  #------------------------------
  # new STREAM
  #------------------------------
  sub new {
      my ($class, $stream) = @_;
      no strict 'refs';
  
      ### Convert raw scalar to globref:
      ref($stream) or $stream = \*$stream;
  
      ### Wrap globref and incomplete objects:
      if ((ref($stream) eq 'GLOB') or      ### globref
  	(ref($stream) eq 'FileHandle') && !defined(&FileHandle::read)) {
  	return bless \$stream, $class;
      }
      $stream;           ### already okay!
  }
  
  #------------------------------
  # I/O methods...
  #------------------------------
  sub close {
      my $self = shift;
      return close($$self);
  }
  sub getline {
      my $self = shift;
      my $fh = $$self;
      return scalar(<$fh>);
  }
  sub getlines {
      my $self = shift;
      wantarray or croak("Can't call getlines in scalar context!");
      my $fh = $$self;
      <$fh>;
  }
  sub print {
      my $self = shift;
      print { $$self } @_;
  }
  sub read {
      my $self = shift;
      return read($$self, $_[0], $_[1]);
  }
  sub seek {
      my $self = shift;
      return seek($$self, $_[0], $_[1]);
  }
  sub tell {
      my $self = shift;
      return tell($$self);
  }
  
  #------------------------------
  1;
  __END__
  
  
  =head1 NAME
  
  IO::Wrap - wrap raw filehandles in IO::Handle interface
  
  
  =head1 SYNOPSIS
  
     use IO::Wrap;
         
     ### Do stuff with any kind of filehandle (including a bare globref), or 
     ### any kind of blessed object that responds to a print() message.
     ###
     sub do_stuff {
         my $fh = shift;         
         
         ### At this point, we have no idea what the user gave us... 
         ### a globref? a FileHandle? a scalar filehandle name?
         
         $fh = wraphandle($fh);  
          
         ### At this point, we know we have an IO::Handle-like object!
         
         $fh->print("Hey there!");
         ...
     }
      
  
  =head1 DESCRIPTION
  
  Let's say you want to write some code which does I/O, but you don't 
  want to force the caller to provide you with a FileHandle or IO::Handle
  object.  You want them to be able to say:
  
      do_stuff(\*STDOUT);
      do_stuff('STDERR');
      do_stuff($some_FileHandle_object);
      do_stuff($some_IO_Handle_object);
  
  And even:
  
      do_stuff($any_object_with_a_print_method);
  
  Sure, one way to do it is to force the caller to use tiehandle().  
  But that puts the burden on them.  Another way to do it is to 
  use B<IO::Wrap>, which provides you with the following functions:
  
  
  =over 4
  
  =item wraphandle SCALAR
  
  This function will take a single argument, and "wrap" it based on
  what it seems to be...
  
  =over 4
  
  =item *
  
  B<A raw scalar filehandle name,> like C<"STDOUT"> or C<"Class::HANDLE">.
  In this case, the filehandle name is wrapped in an IO::Wrap object, 
  which is returned.
  
  =item *
  
  B<A raw filehandle glob,> like C<\*STDOUT>.
  In this case, the filehandle glob is wrapped in an IO::Wrap object, 
  which is returned.
  
  =item *
  
  B<A blessed FileHandle object.>
  In this case, the FileHandle is wrapped in an IO::Wrap object if and only
  if your FileHandle class does not support the C<read()> method.
  
  =item *
  
  B<Any other kind of blessed object,> which is assumed to be already
  conformant to the IO::Handle interface.
  In this case, you just get back that object.
  
  =back
  
  =back
  
  
  If you get back an IO::Wrap object, it will obey a basic subset of
  the IO:: interface.  That is, the following methods (note: I said
  I<methods>, not named operators) should work on the thing you get back:
  
      close 
      getline 
      getlines 
      print ARGS...
      read BUFFER,NBYTES
      seek POS,WHENCE
      tell 
  
  
  
  =head1 NOTES
  
  Clearly, when wrapping a raw external filehandle (like \*STDOUT), 
  I didn't want to close the file descriptor when the "wrapper" object is
  destroyed... since the user might not appreciate that!  Hence,
  there's no DESTROY method in this class.
  
  When wrapping a FileHandle object, however, I believe that Perl will 
  invoke the FileHandle::DESTROY when the last reference goes away,
  so in that case, the filehandle is closed if the wrapped FileHandle
  really was the last reference to it.
  
  
  =head1 WARNINGS
  
  This module does not allow you to wrap filehandle names which are given
  as strings that lack the package they were opened in. That is, if a user 
  opens FOO in package Foo, they must pass it to you either as C<\*FOO> 
  or as C<"Foo::FOO">.  However, C<"STDIN"> and friends will work just fine.
  
  
  =head1 VERSION
  
  $Id: Wrap.pm,v 1.2 2005/02/10 21:21:53 dfs Exp $
      
  
  =head1 AUTHOR
  
  =item Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =item Original Author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  =cut
  
IO_WRAP

$fatpacked{"IO/WrapTie.pm"} = <<'IO_WRAPTIE';
  # SEE DOCUMENTATION AT BOTTOM OF FILE
  
  
  #------------------------------------------------------------
  package IO::WrapTie;
  #------------------------------------------------------------
  require 5.004;              ### for tie
  use strict;
  use vars qw(@ISA @EXPORT $VERSION);
  use Exporter;
  
  # Inheritance, exporting, and package version:
  @ISA     = qw(Exporter);
  @EXPORT  = qw(wraptie);
  $VERSION = "2.110";
  
  # Function, exported.
  sub wraptie {
      IO::WrapTie::Master->new(@_);
  }
  
  # Class method; BACKWARDS-COMPATIBILITY ONLY!
  sub new { 
      shift; 
      IO::WrapTie::Master->new(@_);
  }
  
  
  
  #------------------------------------------------------------
  package IO::WrapTie::Master;
  #------------------------------------------------------------
  
  use strict;
  use vars qw(@ISA $AUTOLOAD);
  use IO::Handle;
  
  # We inherit from IO::Handle to get methods which invoke i/o operators,
  # like print(), on our tied handle:
  @ISA = qw(IO::Handle);
  
  #------------------------------
  # new SLAVE, TIEARGS...
  #------------------------------
  # Create a new subclass of IO::Handle which...
  #
  #   (1) Handles i/o OPERATORS because it is tied to an instance of 
  #       an i/o-like class, like IO::Scalar.
  #
  #   (2) Handles i/o METHODS by delegating them to that same tied object!.
  #
  # Arguments are the slave class (e.g., IO::Scalar), followed by all 
  # the arguments normally sent into that class's TIEHANDLE method.
  # In other words, much like the arguments to tie().  :-)
  #
  # NOTE:
  # The thing $x we return must be a BLESSED REF, for ($x->print()).
  # The underlying symbol must be a FILEHANDLE, for (print $x "foo").
  # It has to have a way of getting to the "real" back-end object...
  #
  sub new {
      my $master = shift;
      my $io = IO::Handle->new;   ### create a new handle
      my $slave = shift;
      tie *$io, $slave, @_;       ### tie: will invoke slave's TIEHANDLE
      bless $io, $master;         ### return a master
  }
  
  #------------------------------
  # AUTOLOAD
  #------------------------------
  # Delegate method invocations on the master to the underlying slave.
  #
  sub AUTOLOAD {
      my $method = $AUTOLOAD;
      $method =~ s/.*:://;
      my $self = shift; tied(*$self)->$method(\@_);
  }
  
  #------------------------------
  # PRELOAD
  #------------------------------
  # Utility.
  #
  # Most methods like print(), getline(), etc. which work on the tied object 
  # via Perl's i/o operators (like 'print') are inherited from IO::Handle.
  #
  # Other methods, like seek() and sref(), we must delegate ourselves.
  # AUTOLOAD takes care of these.
  #
  # However, it may be necessary to preload delegators into your
  # own class.  PRELOAD will do this.
  #
  sub PRELOAD {
      my $class = shift;
      foreach (@_) {
  	eval "sub ${class}::$_ { my \$s = shift; tied(*\$s)->$_(\@_) }";
      }    
  }
  
  # Preload delegators for some standard methods which we can't simply
  # inherit from IO::Handle... for example, some IO::Handle methods 
  # assume that there is an underlying file descriptor.
  #
  PRELOAD IO::WrapTie::Master 
      qw(open opened close read clearerr eof seek tell setpos getpos);
  
  
  
  #------------------------------------------------------------
  package IO::WrapTie::Slave;
  #------------------------------------------------------------
  # Teeny private class providing a new_tie constructor...
  #
  # HOW IT ALL WORKS:
  # 
  # Slaves inherit from this class.
  #
  # When you send a new_tie() message to a tie-slave class (like IO::Scalar),
  # it first determines what class should provide its master, via TIE_MASTER.
  # In this case, IO::Scalar->TIE_MASTER would return IO::Scalar::Master.
  # Then, we create a new master (an IO::Scalar::Master) with the same args
  # sent to new_tie.
  #
  # In general, the new() method of the master is inherited directly 
  # from IO::WrapTie::Master.
  #
  sub new_tie {
      my $self = shift;
      $self->TIE_MASTER->new($self,@_);     ### e.g., IO::Scalar::Master->new(@_)
  }
  
  # Default class method for new_tie().
  # All your tie-slave class (like IO::Scalar) has to do is override this 
  # method with a method that returns the name of an appropriate "master"
  # class for tying that slave.
  #
  sub TIE_MASTER { 'IO::WrapTie::Master' }
  
  #------------------------------
  1;
  __END__
  
  
  package IO::WrapTie;      ### for doc generator
  
  
  =head1 NAME
  
  IO::WrapTie - wrap tieable objects in IO::Handle interface
  
  I<This is currently Alpha code, released for comments.  
    Please give me your feedback!>
  
  
  =head1 SYNOPSIS
  
  First of all, you'll need tie(), so:
  
     require 5.004;
  
  I<Function interface (experimental).>
  Use this with any existing class...
  
     use IO::WrapTie;
     use FooHandle;                  ### implements TIEHANDLE interface
  
     ### Suppose we want a "FooHandle->new(&FOO_RDWR, 2)".
     ### We can instead say...
  
     $FH = wraptie('FooHandle', &FOO_RDWR, 2); 
  
     ### Now we can use...    
     print $FH "Hello, ";            ### traditional operator syntax...
     $FH->print("world!\n");         ### ...and OO syntax as well!
  
  I<OO interface (preferred).>
  You can inherit from the IO::WrapTie::Slave mixin to get a
  nifty C<new_tie()> constructor...
  
     #------------------------------    
     package FooHandle;                        ### a class which can TIEHANDLE
  
     use IO::WrapTie;  
     @ISA = qw(IO::WrapTie::Slave);            ### inherit new_tie()
     ...
  
  
     #------------------------------    
     package main; 
  
     $FH = FooHandle->new_tie(&FOO_RDWR, 2);   ### $FH is an IO::WrapTie::Master
     print $FH "Hello, ";                      ### traditional operator syntax
     $FH->print("world!\n");                   ### OO syntax
  
  See IO::Scalar as an example.  It also shows you how to create classes
  which work both with and without 5.004.
  
  
  =head1 DESCRIPTION
  
  Suppose you have a class C<FooHandle>, where...
  
  =over 4
  
  =item *
  
  B<FooHandle does not inherit from IO::Handle;> that is, it performs
  filehandle-like I/O, but to something other than an underlying
  file descriptor.  Good examples are IO::Scalar (for printing to a
  string) and IO::Lines (for printing to an array of lines).
  
  =item *
  
  B<FooHandle implements the TIEHANDLE interface> (see L<perltie>);
  that is, it provides methods TIEHANDLE, GETC, PRINT, PRINTF,
  READ, and READLINE.
  
  =item *
  
  B<FooHandle implements the traditional OO interface> of
  FileHandle and IO::Handle; i.e., it contains methods like getline(), 
  read(), print(), seek(), tell(), eof(), etc.
  
  =back
  
  
  Normally, users of your class would have two options:
  
  
  =over 4
  
  =item *
  
  B<Use only OO syntax,> and forsake named I/O operators like 'print'.
  
  =item * 
  
  B<Use with tie,> and forsake treating it as a first-class object 
  (i.e., class-specific methods can only be invoked through the underlying
  object via tied()... giving the object a "split personality").
  
  =back
  
  
  But now with IO::WrapTie, you can say:
  
      $WT = wraptie('FooHandle', &FOO_RDWR, 2);
      $WT->print("Hello, world\n");   ### OO syntax
      print $WT "Yes!\n";             ### Named operator syntax too!
      $WT->weird_stuff;               ### Other methods!
  
  And if you're authoring a class like FooHandle, just have it inherit 
  from C<IO::WrapTie::Slave> and that first line becomes even prettier:
  
      $WT = FooHandle->new_tie(&FOO_RDWR, 2);
  
  B<The bottom line:> now, almost any class can look and work exactly like
  an IO::Handle... and be used both with OO and non-OO filehandle syntax.
  
  
  =head1 HOW IT ALL WORKS
  
  
  =head2 The data structures
  
  Consider this example code, using classes in this distribution:
  
      use IO::Scalar;
      use IO::WrapTie;
  
      $WT = wraptie('IO::Scalar',\$s);
      print $WT "Hello, ";
      $WT->print("world!\n");
  
  In it, the wraptie() function creates a data structure as follows:
  
                            * $WT is a blessed reference to a tied filehandle
                $WT           glob; that glob is tied to the "Slave" object.
                 |          * You would do all your i/o with $WT directly.
                 |       
                 |
                 |     ,---isa--> IO::WrapTie::Master >--isa--> IO::Handle
                 V    /
          .-------------. 
          |             | 
          |             |   * Perl i/o operators work on the tied object,  
          |  "Master"   |     invoking the TIEHANDLE methods.
          |             |   * Method invocations are delegated to the tied 
          |             |     slave.
          `-------------' 
                 |    
      tied(*$WT) |     .---isa--> IO::WrapTie::Slave
                 V    /   
          .-------------.
          |             |
          |   "Slave"   |   * Instance of FileHandle-like class which doesn't
          |             |     actually use file descriptors, like IO::Scalar.
          |  IO::Scalar |   * The slave can be any kind of object.
          |             |   * Must implement the TIEHANDLE interface.
          `-------------'
  
  
  I<NOTE:> just as an IO::Handle is really just a blessed reference to a 
  I<traditional> filehandle glob... so also, an IO::WrapTie::Master 
  is really just a blessed reference to a filehandle 
  glob I<which has been tied to some "slave" class.>
  
  
  =head2 How wraptie() works
  
  =over 4
  
  =item 1.
  
  The call to function C<wraptie(SLAVECLASS, TIEARGS...)> is 
  passed onto C<IO::WrapTie::Master::new()>.  
  Note that class IO::WrapTie::Master is a subclass of IO::Handle.
  
  =item 2.
  
  The C<IO::WrapTie::Master::new> method creates a new IO::Handle object,
  reblessed into class IO::WrapTie::Master.  This object is the I<master>, 
  which will be returned from the constructor.  At the same time...
  
  =item 3.
  
  The C<new> method also creates the I<slave>: this is an instance 
  of SLAVECLASS which is created by tying the master's IO::Handle 
  to SLAVECLASS via C<tie(HANDLE, SLAVECLASS, TIEARGS...)>.  
  This call to C<tie()> creates the slave in the following manner:
  
  =item 4.
  
  Class SLAVECLASS is sent the message C<TIEHANDLE(TIEARGS...)>; it 
  will usually delegate this to C<SLAVECLASS::new(TIEARGS...)>, resulting
  in a new instance of SLAVECLASS being created and returned.
  
  =item 5.
  
  Once both master and slave have been created, the master is returned
  to the caller.  
  
  =back
  
  
  =head2 How I/O operators work (on the master)
  
  Consider using an i/o operator on the master:
  
      print $WT "Hello, world!\n";   
  
  Since the master ($WT) is really a [blessed] reference to a glob, 
  the normal Perl i/o operators like C<print> may be used on it.
  They will just operate on the symbol part of the glob.
  
  Since the glob is tied to the slave, the slave's PRINT method 
  (part of the TIEHANDLE interface) will be automatically invoked.  
  
  If the slave is an IO::Scalar, that means IO::Scalar::PRINT will be 
  invoked, and that method happens to delegate to the C<print()> method 
  of the same class.  So the I<real> work is ultimately done by 
  IO::Scalar::print().
  
  
  =head2 How methods work (on the master)
  
  Consider using a method on the master:
  
      $WT->print("Hello, world!\n");
  
  Since the master ($WT) is blessed into the class IO::WrapTie::Master,
  Perl first attempts to find a C<print()> method there.  Failing that,
  Perl next attempts to find a C<print()> method in the superclass,
  IO::Handle.  It just so happens that there I<is> such a method;
  that method merely invokes the C<print> i/o operator on the self object...
  and for that, see above!
  
  But let's suppose we're dealing with a method which I<isn't> part
  of IO::Handle... for example:
  
      my $sref = $WT->sref;
  
  In this case, the intuitive behavior is to have the master delegate the
  method invocation to the slave (now do you see where the designations
  come from?).  This is indeed what happens: IO::WrapTie::Master contains
  an AUTOLOAD method which performs the delegation.  
  
  So: when C<sref()> can't be found in IO::Handle, the AUTOLOAD method
  of IO::WrapTie::Master is invoked, and the standard behavior of
  delegating the method to the underlying slave (here, an IO::Scalar)
  is done.
  
  Sometimes, to get this to work properly, you may need to create 
  a subclass of IO::WrapTie::Master which is an effective master for
  I<your> class, and do the delegation there.
  
  
  
  
  =head1 NOTES
  
  B<Why not simply use the object's OO interface?> 
      Because that means forsaking the use of named operators
  like print(), and you may need to pass the object to a subroutine
  which will attempt to use those operators:
  
      $O = FooHandle->new(&FOO_RDWR, 2);
      $O->print("Hello, world\n");  ### OO syntax is okay, BUT....
  
      sub nope { print $_[0] "Nope!\n" }
   X  nope($O);                     ### ERROR!!! (not a glob ref)
  
  
  B<Why not simply use tie()?> 
      Because (1) you have to use tied() to invoke methods in the
  object's public interface (yuck), and (2) you may need to pass 
  the tied symbol to another subroutine which will attempt to treat 
  it in an OO-way... and that will break it:
  
      tie *T, 'FooHandle', &FOO_RDWR, 2; 
      print T "Hello, world\n";   ### Operator is okay, BUT... 
  
      tied(*T)->other_stuff;      ### yuck! AND...
  
      sub nope { shift->print("Nope!\n") }
   X  nope(\*T);                  ### ERROR!!! (method "print" on unblessed ref)
  
  
  B<Why a master and slave? 
    Why not simply write FooHandle to inherit from IO::Handle?>
      I tried this, with an implementation similar to that of IO::Socket.  
  The problem is that I<the whole point is to use this with objects
  that don't have an underlying file/socket descriptor.>.
  Subclassing IO::Handle will work fine for the OO stuff, and fine with 
  named operators I<if> you tie()... but if you just attempt to say:
  
      $IO = FooHandle->new(&FOO_RDWR, 2);
      print $IO "Hello!\n";
  
  you get a warning from Perl like:
  
      Filehandle GEN001 never opened
  
  because it's trying to do system-level i/o on an (unopened) file 
  descriptor.  To avoid this, you apparently have to tie() the handle...
  which brings us right back to where we started!  At least the
  IO::WrapTie mixin lets us say:
  
      $IO = FooHandle->new_tie(&FOO_RDWR, 2);
      print $IO "Hello!\n";
  
  and so is not I<too> bad.  C<:-)>
  
  
  =head1 WARNINGS
  
  Remember: this stuff is for doing FileHandle-like i/o on things
  I<without underlying file descriptors>.  If you have an underlying
  file descriptor, you're better off just inheriting from IO::Handle.
  
  B<Be aware that new_tie() always returns an instance of a
  kind of IO::WrapTie::Master...> it does B<not> return an instance 
  of the i/o class you're tying to!  
  
  Invoking some methods on the master object causes AUTOLOAD to delegate
  them to the slave object... so it I<looks> like you're manipulating a 
  "FooHandle" object directly, but you're not.
  
  I have not explored all the ramifications of this use of tie().
  I<Here there be dragons>.
  
  
  =head1 VERSION
  
  $Id: WrapTie.pm,v 1.2 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHOR
  
  =item Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =item Original Author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  =cut
  
IO_WRAPTIE

$fatpacked{"OLE/Storage_Lite.pm"} = <<'OLE_STORAGE_LITE';
  # OLE::Storage_Lite
  #  by Kawai, Takanori (Hippo2000) 2000.11.4, 8, 14
  # This Program is Still ALPHA version.
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS Object
  #//////////////////////////////////////////////////////////////////////////////
  #==============================================================================
  # OLE::Storage_Lite::PPS
  #==============================================================================
  package OLE::Storage_Lite::PPS;
  require Exporter;
  use strict;
  use vars qw($VERSION @ISA);
  @ISA = qw(Exporter);
  $VERSION = '0.19';
  
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub new ($$$$$$$$$$;$$) {
  #1. Constructor for General Usage
    my($sClass, $iNo, $sNm, $iType, $iPrev, $iNext, $iDir,
       $raTime1st, $raTime2nd, $iStart, $iSize, $sData, $raChild) = @_;
  
    if($iType == OLE::Storage_Lite::PpsType_File()) { #FILE
      return OLE::Storage_Lite::PPS::File->_new
          ($iNo, $sNm, $iType, $iPrev, $iNext, $iDir, $raTime1st, $raTime2nd,
           $iStart, $iSize, $sData, $raChild);
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Dir()) { #DIRECTRY
      return OLE::Storage_Lite::PPS::Dir->_new
          ($iNo, $sNm, $iType, $iPrev, $iNext, $iDir, $raTime1st, $raTime2nd,
           $iStart, $iSize, $sData, $raChild);
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Root()) { #ROOT
      return OLE::Storage_Lite::PPS::Root->_new
          ($iNo, $sNm, $iType, $iPrev, $iNext, $iDir, $raTime1st, $raTime2nd,
           $iStart, $iSize, $sData, $raChild);
    }
    else {
      die "Error PPS:$iType $sNm\n";
    }
  }
  #------------------------------------------------------------------------------
  # _new (OLE::Storage_Lite::PPS)
  #   for OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _new ($$$$$$$$$$$;$$) {
    my($sClass, $iNo, $sNm, $iType, $iPrev, $iNext, $iDir,
          $raTime1st, $raTime2nd, $iStart, $iSize, $sData, $raChild) = @_;
  #1. Constructor for OLE::Storage_Lite
    my $oThis = {
      No   => $iNo,
      Name => $sNm,
      Type => $iType,
      PrevPps => $iPrev,
      NextPps => $iNext,
      DirPps => $iDir,
      Time1st => $raTime1st,
      Time2nd => $raTime2nd,
      StartBlock => $iStart,
      Size       => $iSize,
      Data       => $sData,
      Child      => $raChild,
    };
    bless $oThis, $sClass;
    return $oThis;
  }
  #------------------------------------------------------------------------------
  # _DataLen (OLE::Storage_Lite::PPS)
  # Check for update
  #------------------------------------------------------------------------------
  sub _DataLen($) {
      my($oSelf) =@_;
      return 0 unless(defined($oSelf->{Data}));
      return ($oSelf->{_PPS_FILE})?
          ($oSelf->{_PPS_FILE}->stat())[7] : length($oSelf->{Data});
  }
  #------------------------------------------------------------------------------
  # _makeSmallData (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _makeSmallData($$$) {
    my($oThis, $aList, $rhInfo) = @_;
    my ($sRes);
    my $FILE = $rhInfo->{_FILEH_};
    my $iSmBlk = 0;
  
    foreach my $oPps (@$aList) {
  #1. Make SBD, small data string
    if($oPps->{Type}==OLE::Storage_Lite::PpsType_File()) {
      next if($oPps->{Size}<=0);
      if($oPps->{Size} < $rhInfo->{_SMALL_SIZE}) {
        my $iSmbCnt = int($oPps->{Size} / $rhInfo->{_SMALL_BLOCK_SIZE})
                      + (($oPps->{Size} % $rhInfo->{_SMALL_BLOCK_SIZE})? 1: 0);
        #1.1 Add to SBD
        for (my $i = 0; $i<($iSmbCnt-1); $i++) {
              print {$FILE} (pack("V", $i+$iSmBlk+1));
        }
        print {$FILE} (pack("V", -2));
  
        #1.2 Add to Data String(this will be written for RootEntry)
        #Check for update
        if($oPps->{_PPS_FILE}) {
          my $sBuff;
          $oPps->{_PPS_FILE}->seek(0, 0); #To The Top
          while($oPps->{_PPS_FILE}->read($sBuff, 4096)) {
              $sRes .= $sBuff;
          }
        }
        else {
          $sRes .= $oPps->{Data};
        }
        $sRes .= ("\x00" x
          ($rhInfo->{_SMALL_BLOCK_SIZE} - ($oPps->{Size}% $rhInfo->{_SMALL_BLOCK_SIZE})))
          if($oPps->{Size}% $rhInfo->{_SMALL_BLOCK_SIZE});
        #1.3 Set for PPS
        $oPps->{StartBlock} = $iSmBlk;
        $iSmBlk += $iSmbCnt;
      }
    }
    }
    my $iSbCnt = int($rhInfo->{_BIG_BLOCK_SIZE}/ OLE::Storage_Lite::LongIntSize());
    print {$FILE} (pack("V", -1) x ($iSbCnt - ($iSmBlk % $iSbCnt)))
      if($iSmBlk  % $iSbCnt);
  #2. Write SBD with adjusting length for block
    return $sRes;
  }
  #------------------------------------------------------------------------------
  # _savePpsWk (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _savePpsWk($$)
  {
    my($oThis, $rhInfo) = @_;
  #1. Write PPS
    my $FILE = $rhInfo->{_FILEH_};
    print {$FILE} (
              $oThis->{Name}
              . ("\x00" x (64 - length($oThis->{Name})))  #64
              , pack("v", length($oThis->{Name}) + 2)     #66
              , pack("c", $oThis->{Type})         #67
              , pack("c", 0x00) #UK               #68
              , pack("V", $oThis->{PrevPps}) #Prev        #72
              , pack("V", $oThis->{NextPps}) #Next        #76
              , pack("V", $oThis->{DirPps})  #Dir     #80
              , "\x00\x09\x02\x00"                #84
              , "\x00\x00\x00\x00"                #88
              , "\xc0\x00\x00\x00"                #92
              , "\x00\x00\x00\x46"                #96
              , "\x00\x00\x00\x00"                #100
              , OLE::Storage_Lite::LocalDate2OLE($oThis->{Time1st})       #108
              , OLE::Storage_Lite::LocalDate2OLE($oThis->{Time2nd})       #116
              , pack("V", defined($oThis->{StartBlock})?
                        $oThis->{StartBlock}:0)       #116
              , pack("V", defined($oThis->{Size})?
                   $oThis->{Size} : 0)            #124
              , pack("V", 0),                  #128
          );
  }
  
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS::Root Object
  #//////////////////////////////////////////////////////////////////////////////
  #==============================================================================
  # OLE::Storage_Lite::PPS::Root
  #==============================================================================
  package OLE::Storage_Lite::PPS::Root;
  require Exporter;
  use strict;
  use IO::File;
  use IO::Handle;
  use Fcntl;
  use vars qw($VERSION @ISA);
  @ISA = qw(OLE::Storage_Lite::PPS Exporter);
  $VERSION = '0.19';
  sub _savePpsSetPnt($$$);
  sub _savePpsSetPnt2($$$);
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub new ($;$$$) {
      my($sClass, $raTime1st, $raTime2nd, $raChild) = @_;
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          OLE::Storage_Lite::Asc2Ucs('Root Entry'),
          5,
          undef,
          undef,
          undef,
          $raTime1st,
          $raTime2nd,
          undef,
          undef,
          undef,
          $raChild);
  }
  #------------------------------------------------------------------------------
  # save (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub save($$;$$) {
    my($oThis, $sFile, $bNoAs, $rhInfo) = @_;
    #0.Initial Setting for saving
    $rhInfo = {} unless($rhInfo);
    $rhInfo->{_BIG_BLOCK_SIZE}  = 2**
                  (($rhInfo->{_BIG_BLOCK_SIZE})?
                      _adjust2($rhInfo->{_BIG_BLOCK_SIZE})  : 9);
    $rhInfo->{_SMALL_BLOCK_SIZE}= 2 **
                  (($rhInfo->{_SMALL_BLOCK_SIZE})?
                      _adjust2($rhInfo->{_SMALL_BLOCK_SIZE}): 6);
    $rhInfo->{_SMALL_SIZE} = 0x1000;
    $rhInfo->{_PPS_SIZE} = 0x80;
  
    my $closeFile = 1;
  
    #1.Open File
    #1.1 $sFile is Ref of scalar
    if(ref($sFile) eq 'SCALAR') {
      require IO::Scalar;
      my $oIo = new IO::Scalar $sFile, O_WRONLY;
      $rhInfo->{_FILEH_} = $oIo;
    }
    #1.1.1 $sFile is a IO::Scalar object
    # Now handled as a filehandle ref below.
  
    #1.2 $sFile is a IO::Handle object
    elsif(UNIVERSAL::isa($sFile, 'IO::Handle')) {
      # Not all filehandles support binmode() so try it in an eval.
      eval{ binmode $sFile };
      $rhInfo->{_FILEH_} = $sFile;
    }
    #1.3 $sFile is a simple filename string
    elsif(!ref($sFile)) {
      if($sFile ne '-') {
          my $oIo = new IO::File;
          $oIo->open(">$sFile") || return undef;
          binmode($oIo);
          $rhInfo->{_FILEH_} = $oIo;
      }
      else {
          my $oIo = new IO::Handle;
          $oIo->fdopen(fileno(STDOUT),"w") || return undef;
          binmode($oIo);
          $rhInfo->{_FILEH_} = $oIo;
      }
    }
    #1.4 Assume that if $sFile is a ref then it is a valid filehandle
    else {
      # Not all filehandles support binmode() so try it in an eval.
      eval{ binmode $sFile };
      $rhInfo->{_FILEH_} = $sFile;
      # Caller controls filehandle closing
      $closeFile = 0;
    }
  
    my $iBlk = 0;
    #1. Make an array of PPS (for Save)
    my @aList=();
    if($bNoAs) {
      _savePpsSetPnt2([$oThis], \@aList, $rhInfo);
    }
    else {
      _savePpsSetPnt([$oThis], \@aList, $rhInfo);
    }
    my ($iSBDcnt, $iBBcnt, $iPPScnt) = $oThis->_calcSize(\@aList, $rhInfo);
  
    #2.Save Header
    $oThis->_saveHeader($rhInfo, $iSBDcnt, $iBBcnt, $iPPScnt);
  
    #3.Make Small Data string (write SBD)
    my $sSmWk = $oThis->_makeSmallData(\@aList, $rhInfo);
    $oThis->{Data} = $sSmWk;  #Small Datas become RootEntry Data
  
    #4. Write BB
    my $iBBlk = $iSBDcnt;
    $oThis->_saveBigData(\$iBBlk, \@aList, $rhInfo);
  
    #5. Write PPS
    $oThis->_savePps(\@aList, $rhInfo);
  
    #6. Write BD and BDList and Adding Header informations
    $oThis->_saveBbd($iSBDcnt, $iBBcnt, $iPPScnt,  $rhInfo);
  
    #7.Close File
    return $rhInfo->{_FILEH_}->close if $closeFile;
  }
  #------------------------------------------------------------------------------
  # _calcSize (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _calcSize($$)
  {
    my($oThis, $raList, $rhInfo) = @_;
  
  #0. Calculate Basic Setting
    my ($iSBDcnt, $iBBcnt, $iPPScnt) = (0,0,0);
    my $iSmallLen = 0;
    my $iSBcnt = 0;
    foreach my $oPps (@$raList) {
        if($oPps->{Type}==OLE::Storage_Lite::PpsType_File()) {
          $oPps->{Size} = $oPps->_DataLen();  #Mod
          if($oPps->{Size} < $rhInfo->{_SMALL_SIZE}) {
            $iSBcnt += int($oPps->{Size} / $rhInfo->{_SMALL_BLOCK_SIZE})
                            + (($oPps->{Size} % $rhInfo->{_SMALL_BLOCK_SIZE})? 1: 0);
          }
          else {
            $iBBcnt +=
              (int($oPps->{Size}/ $rhInfo->{_BIG_BLOCK_SIZE}) +
                  (($oPps->{Size}% $rhInfo->{_BIG_BLOCK_SIZE})? 1: 0));
          }
        }
    }
    $iSmallLen = $iSBcnt * $rhInfo->{_SMALL_BLOCK_SIZE};
    my $iSlCnt = int($rhInfo->{_BIG_BLOCK_SIZE}/ OLE::Storage_Lite::LongIntSize());
    $iSBDcnt = int($iSBcnt / $iSlCnt)+ (($iSBcnt % $iSlCnt)? 1:0);
    $iBBcnt +=  (int($iSmallLen/ $rhInfo->{_BIG_BLOCK_SIZE}) +
                  (( $iSmallLen% $rhInfo->{_BIG_BLOCK_SIZE})? 1: 0));
    my $iCnt = scalar(@$raList);
    my $iBdCnt = $rhInfo->{_BIG_BLOCK_SIZE}/OLE::Storage_Lite::PpsSize();
    $iPPScnt = (int($iCnt/$iBdCnt) + (($iCnt % $iBdCnt)? 1: 0));
    return ($iSBDcnt, $iBBcnt, $iPPScnt);
  }
  #------------------------------------------------------------------------------
  # _adjust2 (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _adjust2($) {
    my($i2) = @_;
    my $iWk;
    $iWk = log($i2)/log(2);
    return ($iWk > int($iWk))? int($iWk)+1:$iWk;
  }
  #------------------------------------------------------------------------------
  # _saveHeader (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _saveHeader($$$$$) {
    my($oThis, $rhInfo, $iSBDcnt, $iBBcnt, $iPPScnt) = @_;
    my $FILE = $rhInfo->{_FILEH_};
  
  #0. Calculate Basic Setting
    my $iBlCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize();
    my $i1stBdL = int(($rhInfo->{_BIG_BLOCK_SIZE} - 0x4C) / OLE::Storage_Lite::LongIntSize());
    my $i1stBdMax = $i1stBdL * $iBlCnt  - $i1stBdL;
    my $iBdExL = 0;
    my $iAll = $iBBcnt + $iPPScnt + $iSBDcnt;
    my $iAllW = $iAll;
    my $iBdCntW = int($iAllW / $iBlCnt) + (($iAllW % $iBlCnt)? 1: 0);
    my $iBdCnt = int(($iAll + $iBdCntW) / $iBlCnt) + ((($iAllW+$iBdCntW) % $iBlCnt)? 1: 0);
    my $i;
  
    if ($iBdCnt > $i1stBdL) {
      #0.1 Calculate BD count
      $iBlCnt--; #the BlCnt is reduced in the count of the last sect is used for a pointer the next Bl
      my $iBBleftover = $iAll - $i1stBdMax;
  
      if ($iAll >$i1stBdMax) {
        while(1) {
          $iBdCnt = int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0);
          $iBdExL = int(($iBdCnt) / $iBlCnt) + ((($iBdCnt) % $iBlCnt)? 1: 0);
          $iBBleftover = $iBBleftover + $iBdExL;
          last if($iBdCnt == (int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0)));
        }
      }
      $iBdCnt += $i1stBdL;
      #print "iBdCnt = $iBdCnt \n";
    }
  #1.Save Header
    print {$FILE} (
              "\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1"
              , "\x00\x00\x00\x00" x 4
              , pack("v", 0x3b)
              , pack("v", 0x03)
              , pack("v", -2)
              , pack("v", 9)
              , pack("v", 6)
              , pack("v", 0)
              , "\x00\x00\x00\x00" x 2
              , pack("V", $iBdCnt),
              , pack("V", $iBBcnt+$iSBDcnt), #ROOT START
              , pack("V", 0)
              , pack("V", 0x1000)
              , pack("V", $iSBDcnt ? 0 : -2)                  #Small Block Depot
              , pack("V", $iSBDcnt)
      );
  #2. Extra BDList Start, Count
    if($iAll <= $i1stBdMax) {
      print {$FILE} (
                  pack("V", -2),      #Extra BDList Start
                  pack("V", 0),       #Extra BDList Count
          );
    }
    else {
      print {$FILE} (
              pack("V", $iAll+$iBdCnt),
              pack("V", $iBdExL),
          );
    }
  
  #3. BDList
      for($i=0; $i<$i1stBdL and $i < $iBdCnt; $i++) {
          print {$FILE} (pack("V", $iAll+$i));
      }
      print {$FILE} ((pack("V", -1)) x($i1stBdL-$i)) if($i<$i1stBdL);
  }
  #------------------------------------------------------------------------------
  # _saveBigData (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _saveBigData($$$$) {
    my($oThis, $iStBlk, $raList, $rhInfo) = @_;
    my $iRes = 0;
    my $FILE = $rhInfo->{_FILEH_};
  
  #1.Write Big (ge 0x1000) Data into Block
    foreach my $oPps (@$raList) {
      if($oPps->{Type}!=OLE::Storage_Lite::PpsType_Dir()) {
  #print "PPS: $oPps DEF:", defined($oPps->{Data}), "\n";
          $oPps->{Size} = $oPps->_DataLen();  #Mod
          if(($oPps->{Size} >= $rhInfo->{_SMALL_SIZE}) ||
              (($oPps->{Type} == OLE::Storage_Lite::PpsType_Root()) && defined($oPps->{Data}))) {
              #1.1 Write Data
              #Check for update
              if($oPps->{_PPS_FILE}) {
                  my $sBuff;
                  my $iLen = 0;
                  $oPps->{_PPS_FILE}->seek(0, 0); #To The Top
                  while($oPps->{_PPS_FILE}->read($sBuff, 4096)) {
                      $iLen += length($sBuff);
                      print {$FILE} ($sBuff);           #Check for update
                  }
              }
              else {
                  print {$FILE} ($oPps->{Data});
              }
              print {$FILE} (
                          "\x00" x
                          ($rhInfo->{_BIG_BLOCK_SIZE} -
                              ($oPps->{Size} % $rhInfo->{_BIG_BLOCK_SIZE}))
                      ) if ($oPps->{Size} % $rhInfo->{_BIG_BLOCK_SIZE});
              #1.2 Set For PPS
              $oPps->{StartBlock} = $$iStBlk;
              $$iStBlk +=
                      (int($oPps->{Size}/ $rhInfo->{_BIG_BLOCK_SIZE}) +
                          (($oPps->{Size}% $rhInfo->{_BIG_BLOCK_SIZE})? 1: 0));
          }
      }
    }
  }
  #------------------------------------------------------------------------------
  # _savePps (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _savePps($$$)
  {
    my($oThis, $raList, $rhInfo) = @_;
  #0. Initial
    my $FILE = $rhInfo->{_FILEH_};
  #2. Save PPS
    foreach my $oItem (@$raList) {
        $oItem->_savePpsWk($rhInfo);
    }
  #3. Adjust for Block
    my $iCnt = scalar(@$raList);
    my $iBCnt = $rhInfo->{_BIG_BLOCK_SIZE} / $rhInfo->{_PPS_SIZE};
    print {$FILE} ("\x00" x (($iBCnt - ($iCnt % $iBCnt)) * $rhInfo->{_PPS_SIZE}))
          if($iCnt % $iBCnt);
    return int($iCnt / $iBCnt) + (($iCnt % $iBCnt)? 1: 0);
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt2 (OLE::Storage_Lite::PPS::Root)
  #  For Test
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt2($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt2($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = 0; #int($iCnt/ 2);     #$iCnt
  
        my @aWk = @$aThis;
        my @aPrev = ($#$aThis > 1)? splice(@aWk, 1, 1) : (); #$iPos);
        my @aNext = splice(@aWk, 1); #, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt2(
              \@aPrev, $raList, $rhInfo);
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
  
  #1.3.2 Devide a array into Previous,Next
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt2(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt2($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt2 (OLE::Storage_Lite::PPS::Root)
  #  For Test
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt2s($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt2($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = 0; #int($iCnt/ 2);     #$iCnt
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
        my @aWk = @$aThis;
  #1.3.2 Devide a array into Previous,Next
        my @aPrev = splice(@aWk, 0, $iPos);
        my @aNext = splice(@aWk, 1, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt2(
              \@aPrev, $raList, $rhInfo);
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt2(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt2($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = int($iCnt/ 2);     #$iCnt
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
        my @aWk = @$aThis;
  #1.3.2 Devide a array into Previous,Next
        my @aPrev = splice(@aWk, 0, $iPos);
        my @aNext = splice(@aWk, 1, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt(
              \@aPrev, $raList, $rhInfo);
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt1($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = int($iCnt/ 2);     #$iCnt
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
        my @aWk = @$aThis;
  #1.3.2 Devide a array into Previous,Next
        my @aPrev = splice(@aWk, 0, $iPos);
        my @aNext = splice(@aWk, 1, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt(
              \@aPrev, $raList, $rhInfo);
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _saveBbd (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _saveBbd($$$$)
  {
    my($oThis, $iSbdSize, $iBsize, $iPpsCnt, $rhInfo) = @_;
    my $FILE = $rhInfo->{_FILEH_};
  #0. Calculate Basic Setting
    my $iBbCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize();
    my $iBlCnt = $iBbCnt - 1;
    my $i1stBdL = int(($rhInfo->{_BIG_BLOCK_SIZE} - 0x4C) / OLE::Storage_Lite::LongIntSize());
    my $i1stBdMax = $i1stBdL * $iBbCnt  - $i1stBdL;
    my $iBdExL = 0;
    my $iAll = $iBsize + $iPpsCnt + $iSbdSize;
    my $iAllW = $iAll;
    my $iBdCntW = int($iAllW / $iBbCnt) + (($iAllW % $iBbCnt)? 1: 0);
    my $iBdCnt = 0;
    my $i;
  #0.1 Calculate BD count
    my $iBBleftover = $iAll - $i1stBdMax;
    if ($iAll >$i1stBdMax) {
  
      while(1) {
        $iBdCnt = int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0);
        $iBdExL = int(($iBdCnt) / $iBlCnt) + ((($iBdCnt) % $iBlCnt)? 1: 0);
        $iBBleftover = $iBBleftover + $iBdExL;
        last if($iBdCnt == (int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0)));
      }
    }
    $iAllW += $iBdExL;
    $iBdCnt += $i1stBdL;
    #print "iBdCnt = $iBdCnt \n";
  
  #1. Making BD
  #1.1 Set for SBD
    if($iSbdSize > 0) {
      for ($i = 0; $i<($iSbdSize-1); $i++) {
        print {$FILE} (pack("V", $i+1));
      }
      print {$FILE} (pack("V", -2));
    }
  #1.2 Set for B
    for ($i = 0; $i<($iBsize-1); $i++) {
        print {$FILE} (pack("V", $i+$iSbdSize+1));
    }
    print {$FILE} (pack("V", -2));
  
  #1.3 Set for PPS
    for ($i = 0; $i<($iPpsCnt-1); $i++) {
        print {$FILE} (pack("V", $i+$iSbdSize+$iBsize+1));
    }
    print {$FILE} (pack("V", -2));
  #1.4 Set for BBD itself ( 0xFFFFFFFD : BBD)
    for($i=0; $i<$iBdCnt;$i++) {
      print {$FILE} (pack("V", 0xFFFFFFFD));
    }
  #1.5 Set for ExtraBDList
    for($i=0; $i<$iBdExL;$i++) {
      print {$FILE} (pack("V", 0xFFFFFFFC));
    }
  #1.6 Adjust for Block
    print {$FILE} (pack("V", -1) x ($iBbCnt - (($iAllW + $iBdCnt) % $iBbCnt)))
                  if(($iAllW + $iBdCnt) % $iBbCnt);
  #2.Extra BDList
    if($iBdCnt > $i1stBdL)  {
      my $iN=0;
      my $iNb=0;
      for($i=$i1stBdL;$i<$iBdCnt; $i++, $iN++) {
        if($iN>=($iBbCnt-1)) {
            $iN = 0;
            $iNb++;
            print {$FILE} (pack("V", $iAll+$iBdCnt+$iNb));
        }
        print {$FILE} (pack("V", $iBsize+$iSbdSize+$iPpsCnt+$i));
      }
      print {$FILE} (pack("V", -1) x (($iBbCnt-1) - (($iBdCnt-$i1stBdL) % ($iBbCnt-1))))
          if(($iBdCnt-$i1stBdL) % ($iBbCnt-1));
      print {$FILE} (pack("V", -2));
    }
  }
  
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS::File Object
  #//////////////////////////////////////////////////////////////////////////////
  #==============================================================================
  # OLE::Storage_Lite::PPS::File
  #==============================================================================
  package OLE::Storage_Lite::PPS::File;
  require Exporter;
  use strict;
  use vars qw($VERSION @ISA);
  @ISA = qw(OLE::Storage_Lite::PPS Exporter);
  $VERSION = '0.19';
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS::File)
  #------------------------------------------------------------------------------
  sub new ($$$) {
    my($sClass, $sNm, $sData) = @_;
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          $sNm,
          2,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          $sData,
          undef);
  }
  #------------------------------------------------------------------------------
  # newFile (OLE::Storage_Lite::PPS::File)
  #------------------------------------------------------------------------------
  sub newFile ($$;$) {
      my($sClass, $sNm, $sFile) = @_;
      my $oSelf =
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          $sNm,
          2,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          '',
          undef);
  #
      if((!defined($sFile)) or ($sFile eq '')) {
          $oSelf->{_PPS_FILE} = IO::File->new_tmpfile();
      }
      elsif(UNIVERSAL::isa($sFile, 'IO::Handle')) {
          $oSelf->{_PPS_FILE} = $sFile;
      }
      elsif(!ref($sFile)) {
          #File Name
          $oSelf->{_PPS_FILE} = new IO::File;
          return undef unless($oSelf->{_PPS_FILE});
          $oSelf->{_PPS_FILE}->open("$sFile", "r+") || return undef;
      }
      else {
          return undef;
      }
      if($oSelf->{_PPS_FILE}) {
          $oSelf->{_PPS_FILE}->seek(0, 2);
          binmode($oSelf->{_PPS_FILE});
          $oSelf->{_PPS_FILE}->autoflush(1);
      }
      return $oSelf;
  }
  #------------------------------------------------------------------------------
  # append (OLE::Storage_Lite::PPS::File)
  #------------------------------------------------------------------------------
  sub append ($$) {
      my($oSelf, $sData) = @_;
      if($oSelf->{_PPS_FILE}) {
          print {$oSelf->{_PPS_FILE}} $sData;
      }
      else {
          $oSelf->{Data} .= $sData;
      }
  }
  
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS::Dir Object
  #//////////////////////////////////////////////////////////////////////////////
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS::Dir)
  #------------------------------------------------------------------------------
  package OLE::Storage_Lite::PPS::Dir;
  require Exporter;
  use strict;
  use vars qw($VERSION @ISA);
  @ISA = qw(OLE::Storage_Lite::PPS Exporter);
  $VERSION = '0.19';
  sub new ($$;$$$) {
      my($sClass, $sName, $raTime1st, $raTime2nd, $raChild) = @_;
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          $sName,
          1,
          undef,
          undef,
          undef,
          $raTime1st,
          $raTime2nd,
          undef,
          undef,
          undef,
          $raChild);
  }
  #==============================================================================
  # OLE::Storage_Lite
  #==============================================================================
  package OLE::Storage_Lite;
  require Exporter;
  
  use strict;
  use IO::File;
  use Time::Local 'timegm';
  
  use vars qw($VERSION @ISA @EXPORT);
  @ISA = qw(Exporter);
  $VERSION = '0.19';
  sub _getPpsSearch($$$$$;$);
  sub _getPpsTree($$$;$);
  #------------------------------------------------------------------------------
  # Const for OLE::Storage_Lite
  #------------------------------------------------------------------------------
  #0. Constants
  sub PpsType_Root {5};
  sub PpsType_Dir  {1};
  sub PpsType_File {2};
  sub DataSizeSmall{0x1000};
  sub LongIntSize  {4};
  sub PpsSize      {0x80};
  #------------------------------------------------------------------------------
  # new OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub new($$) {
    my($sClass, $sFile) = @_;
    my $oThis = {
      _FILE => $sFile,
    };
    bless $oThis;
    return $oThis;
  }
  #------------------------------------------------------------------------------
  # getPpsTree: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub getPpsTree($;$)
  {
    my($oThis, $bData) = @_;
  #0.Init
    my $rhInfo = _initParse($oThis->{_FILE});
    return undef unless($rhInfo);
  #1. Get Data
    my ($oPps) = _getPpsTree(0, $rhInfo, $bData);
    close(IN);
    return $oPps;
  }
  #------------------------------------------------------------------------------
  # getSearch: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub getPpsSearch($$;$$)
  {
    my($oThis, $raName, $bData, $iCase) = @_;
  #0.Init
    my $rhInfo = _initParse($oThis->{_FILE});
    return undef unless($rhInfo);
  #1. Get Data
    my @aList = _getPpsSearch(0, $rhInfo, $raName, $bData, $iCase);
    close(IN);
    return @aList;
  }
  #------------------------------------------------------------------------------
  # getNthPps: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub getNthPps($$;$)
  {
    my($oThis, $iNo, $bData) = @_;
  #0.Init
    my $rhInfo = _initParse($oThis->{_FILE});
    return undef unless($rhInfo);
  #1. Get Data
    my $oPps = _getNthPps($iNo, $rhInfo, $bData);
    close IN;
    return $oPps;
  }
  #------------------------------------------------------------------------------
  # _initParse: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _initParse($) {
    my($sFile)=@_;
    my $oIo;
    #1. $sFile is Ref of scalar
    if(ref($sFile) eq 'SCALAR') {
      require IO::Scalar;
      $oIo = new IO::Scalar;
      $oIo->open($sFile);
    }
    #2. $sFile is a IO::Handle object
    elsif(UNIVERSAL::isa($sFile, 'IO::Handle')) {
      $oIo = $sFile;
      binmode($oIo);
    }
    #3. $sFile is a simple filename string
    elsif(!ref($sFile)) {
      $oIo = new IO::File;
      $oIo->open("<$sFile") || return undef;
      binmode($oIo);
    }
    #4 Assume that if $sFile is a ref then it is a valid filehandle
    else {
      $oIo = $sFile;
      # Not all filehandles support binmode() so try it in an eval.
      eval{ binmode $oIo };
    }
    return _getHeaderInfo($oIo);
  }
  #------------------------------------------------------------------------------
  # _getPpsTree: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _getPpsTree($$$;$) {
    my($iNo, $rhInfo, $bData, $raDone) = @_;
    if(defined($raDone)) {
      return () if(grep {$_ ==$iNo} @$raDone);
    }
    else {
      $raDone=[];
    }
    push @$raDone, $iNo;
  
    my $iRootBlock = $rhInfo->{_ROOT_START} ;
  #1. Get Information about itself
    my $oPps = _getNthPps($iNo, $rhInfo, $bData);
  #2. Child
    if($oPps->{DirPps} !=  0xFFFFFFFF) {
      my @aChildL = _getPpsTree($oPps->{DirPps}, $rhInfo, $bData, $raDone);
      $oPps->{Child} =  \@aChildL;
    }
    else {
      $oPps->{Child} =  undef;
    }
  #3. Previous,Next PPSs
    my @aList = ();
    push @aList, _getPpsTree($oPps->{PrevPps}, $rhInfo, $bData, $raDone)
                          if($oPps->{PrevPps} != 0xFFFFFFFF);
    push @aList, $oPps;
    push @aList, _getPpsTree($oPps->{NextPps}, $rhInfo, $bData, $raDone)
                  if($oPps->{NextPps} != 0xFFFFFFFF);
    return @aList;
  }
  #------------------------------------------------------------------------------
  # _getPpsSearch: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _getPpsSearch($$$$$;$) {
    my($iNo, $rhInfo, $raName, $bData, $iCase, $raDone) = @_;
    my $iRootBlock = $rhInfo->{_ROOT_START} ;
    my @aRes;
  #1. Check it self
    if(defined($raDone)) {
      return () if(grep {$_==$iNo} @$raDone);
    }
    else {
      $raDone=[];
    }
    push @$raDone, $iNo;
    my $oPps = _getNthPps($iNo, $rhInfo, undef);
  #  if(grep($_ eq $oPps->{Name}, @$raName)) {
    if(($iCase && (grep(/^\Q$oPps->{Name}\E$/i, @$raName))) ||
       (grep($_ eq $oPps->{Name}, @$raName))) {
      $oPps = _getNthPps($iNo, $rhInfo, $bData) if ($bData);
      @aRes = ($oPps);
    }
    else {
      @aRes = ();
    }
  #2. Check Child, Previous, Next PPSs
    push @aRes, _getPpsSearch($oPps->{DirPps},  $rhInfo, $raName, $bData, $iCase, $raDone)
          if($oPps->{DirPps} !=  0xFFFFFFFF) ;
    push @aRes, _getPpsSearch($oPps->{PrevPps}, $rhInfo, $raName, $bData, $iCase, $raDone)
          if($oPps->{PrevPps} != 0xFFFFFFFF );
    push @aRes, _getPpsSearch($oPps->{NextPps}, $rhInfo, $raName, $bData, $iCase, $raDone)
          if($oPps->{NextPps} != 0xFFFFFFFF);
    return @aRes;
  }
  #===================================================================
  # Get Header Info (BASE Informain about that file)
  #===================================================================
  sub _getHeaderInfo($){
    my($FILE) = @_;
    my($iWk);
    my $rhInfo = {};
    $rhInfo->{_FILEH_} = $FILE;
    my $sWk;
  #0. Check ID
    $rhInfo->{_FILEH_}->seek(0, 0);
    $rhInfo->{_FILEH_}->read($sWk, 8);
    return undef unless($sWk eq "\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1");
  #BIG BLOCK SIZE
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x1E, 2, "v");
    return undef unless(defined($iWk));
    $rhInfo->{_BIG_BLOCK_SIZE} = 2 ** $iWk;
  #SMALL BLOCK SIZE
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x20, 2, "v");
    return undef unless(defined($iWk));
    $rhInfo->{_SMALL_BLOCK_SIZE} = 2 ** $iWk;
  #BDB Count
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x2C, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_BDB_COUNT} = $iWk;
  #START BLOCK
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x30, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_ROOT_START} = $iWk;
  #MIN SIZE OF BB
  #  $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x38, 4, "V");
  #  return undef unless(defined($iWk));
  #  $rhInfo->{_MIN_SIZE_BB} = $iWk;
  #SMALL BD START
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x3C, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_SBD_START} = $iWk;
  #SMALL BD COUNT
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x40, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_SBD_COUNT} = $iWk;
  #EXTRA BBD START
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x44, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_EXTRA_BBD_START} = $iWk;
  #EXTRA BD COUNT
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x48, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_EXTRA_BBD_COUNT} = $iWk;
  #GET BBD INFO
    $rhInfo->{_BBD_INFO}= _getBbdInfo($rhInfo);
  #GET ROOT PPS
    my $oRoot = _getNthPps(0, $rhInfo, undef);
    $rhInfo->{_SB_START} = $oRoot->{StartBlock};
    $rhInfo->{_SB_SIZE}  = $oRoot->{Size};
    return $rhInfo;
  }
  #------------------------------------------------------------------------------
  # _getInfoFromFile
  #------------------------------------------------------------------------------
  sub _getInfoFromFile($$$$) {
    my($FILE, $iPos, $iLen, $sFmt) =@_;
    my($sWk);
    return undef unless($FILE);
    return undef if($FILE->seek($iPos, 0)==0);
    return undef if($FILE->read($sWk,  $iLen)!=$iLen);
    return unpack($sFmt, $sWk);
  }
  #------------------------------------------------------------------------------
  # _getBbdInfo
  #------------------------------------------------------------------------------
  sub _getBbdInfo($) {
    my($rhInfo) =@_;
    my @aBdList = ();
    my $iBdbCnt = $rhInfo->{_BDB_COUNT};
    my $iGetCnt;
    my $sWk;
    my $i1stCnt = int(($rhInfo->{_BIG_BLOCK_SIZE} - 0x4C) / OLE::Storage_Lite::LongIntSize());
    my $iBdlCnt = int($rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize()) - 1;
  
  #1. 1st BDlist
    $rhInfo->{_FILEH_}->seek(0x4C, 0);
    $iGetCnt = ($iBdbCnt < $i1stCnt)? $iBdbCnt: $i1stCnt;
    $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize()*$iGetCnt);
    push @aBdList, unpack("V$iGetCnt", $sWk);
    $iBdbCnt -= $iGetCnt;
  #2. Extra BDList
    my $iBlock = $rhInfo->{_EXTRA_BBD_START};
    while(($iBdbCnt> 0) && _isNormalBlock($iBlock)){
      _setFilePos($iBlock, 0, $rhInfo);
      $iGetCnt= ($iBdbCnt < $iBdlCnt)? $iBdbCnt: $iBdlCnt;
      $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize()*$iGetCnt);
      push @aBdList, unpack("V$iGetCnt", $sWk);
      $iBdbCnt -= $iGetCnt;
      $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize());
      $iBlock = unpack("V", $sWk);
    }
  #3.Get BDs
    my @aWk;
    my %hBd;
    my $iBlkNo = 0;
    my $iBdL;
    my $i;
    my $iBdCnt = int($rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize());
    foreach $iBdL (@aBdList) {
      _setFilePos($iBdL, 0, $rhInfo);
      $rhInfo->{_FILEH_}->read($sWk, $rhInfo->{_BIG_BLOCK_SIZE});
      @aWk = unpack("V$iBdCnt", $sWk);
      for($i=0;$i<$iBdCnt;$i++, $iBlkNo++) {
         if($aWk[$i] != ($iBlkNo+1)){
              $hBd{$iBlkNo} = $aWk[$i];
          }
      }
    }
    return \%hBd;
  }
  #------------------------------------------------------------------------------
  # getNthPps (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNthPps($$$){
    my($iPos, $rhInfo, $bData) = @_;
    my($iPpsStart) = ($rhInfo->{_ROOT_START});
    my($iPpsBlock, $iPpsPos);
    my $sWk;
    my $iBlock;
  
    my $iBaseCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::PpsSize();
    $iPpsBlock = int($iPos / $iBaseCnt);
    $iPpsPos   = $iPos % $iBaseCnt;
  
    $iBlock = _getNthBlockNo($iPpsStart, $iPpsBlock, $rhInfo);
    return undef unless(defined($iBlock));
  
    _setFilePos($iBlock, OLE::Storage_Lite::PpsSize()*$iPpsPos, $rhInfo);
    $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::PpsSize());
    return undef unless($sWk);
    my $iNmSize = unpack("v", substr($sWk, 0x40, 2));
    $iNmSize = ($iNmSize > 2)? $iNmSize - 2 : $iNmSize;
    my $sNm= substr($sWk, 0, $iNmSize);
    my $iType = unpack("C", substr($sWk, 0x42, 2));
    my $lPpsPrev = unpack("V", substr($sWk, 0x44, OLE::Storage_Lite::LongIntSize()));
    my $lPpsNext = unpack("V", substr($sWk, 0x48, OLE::Storage_Lite::LongIntSize()));
    my $lDirPps  = unpack("V", substr($sWk, 0x4C, OLE::Storage_Lite::LongIntSize()));
    my @raTime1st =
          (($iType == OLE::Storage_Lite::PpsType_Root()) or ($iType == OLE::Storage_Lite::PpsType_Dir()))?
              OLEDate2Local(substr($sWk, 0x64, 8)) : undef ,
    my @raTime2nd =
          (($iType == OLE::Storage_Lite::PpsType_Root()) or ($iType == OLE::Storage_Lite::PpsType_Dir()))?
              OLEDate2Local(substr($sWk, 0x6C, 8)) : undef,
    my($iStart, $iSize) = unpack("VV", substr($sWk, 0x74, 8));
    if($bData) {
        my $sData = _getData($iType, $iStart, $iSize, $rhInfo);
        return OLE::Storage_Lite::PPS->new(
          $iPos, $sNm, $iType, $lPpsPrev, $lPpsNext, $lDirPps,
          \@raTime1st, \@raTime2nd, $iStart, $iSize, $sData, undef);
    }
    else {
        return OLE::Storage_Lite::PPS->new(
          $iPos, $sNm, $iType, $lPpsPrev, $lPpsNext, $lDirPps,
          \@raTime1st, \@raTime2nd, $iStart, $iSize, undef, undef);
    }
  }
  #------------------------------------------------------------------------------
  # _setFilePos (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _setFilePos($$$){
    my($iBlock, $iPos, $rhInfo) = @_;
    $rhInfo->{_FILEH_}->seek(($iBlock+1)*$rhInfo->{_BIG_BLOCK_SIZE}+$iPos, 0);
  }
  #------------------------------------------------------------------------------
  # _getNthBlockNo (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNthBlockNo($$$){
    my($iStBlock, $iNth, $rhInfo) = @_;
    my $iSv;
    my $iNext = $iStBlock;
    for(my $i =0; $i<$iNth; $i++) {
      $iSv = $iNext;
      $iNext = _getNextBlockNo($iSv, $rhInfo);
      return undef unless _isNormalBlock($iNext);
    }
    return $iNext;
  }
  #------------------------------------------------------------------------------
  # _getData (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getData($$$$)
  {
    my($iType, $iBlock, $iSize, $rhInfo) = @_;
    if ($iType == OLE::Storage_Lite::PpsType_File()) {
      if($iSize < OLE::Storage_Lite::DataSizeSmall()) {
          return _getSmallData($iBlock, $iSize, $rhInfo);
      }
      else {
          return _getBigData($iBlock, $iSize, $rhInfo);
      }
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Root()) {  #Root
      return _getBigData($iBlock, $iSize, $rhInfo);
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Dir()) {  # Directory
      return undef;
    }
  }
  #------------------------------------------------------------------------------
  # _getBigData (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getBigData($$$)
  {
    my($iBlock, $iSize, $rhInfo) = @_;
    my($iRest, $sWk, $sRes);
  
    return '' unless(_isNormalBlock($iBlock));
    $iRest = $iSize;
    my($i, $iGetSize, $iNext);
    $sRes = '';
    my @aKeys= sort({$a<=>$b} keys(%{$rhInfo->{_BBD_INFO}}));
  
    while ($iRest > 0) {
      my @aRes = grep($_ >= $iBlock, @aKeys);
      my $iNKey = $aRes[0];
      $i = $iNKey - $iBlock;
      $iNext = $rhInfo->{_BBD_INFO}{$iNKey};
      _setFilePos($iBlock, 0, $rhInfo);
      my $iGetSize = ($rhInfo->{_BIG_BLOCK_SIZE} * ($i+1));
      $iGetSize = $iRest if($iRest < $iGetSize);
      $rhInfo->{_FILEH_}->read( $sWk, $iGetSize);
      $sRes .= $sWk;
      $iRest -= $iGetSize;
      $iBlock= $iNext;
    }
    return $sRes;
  }
  #------------------------------------------------------------------------------
  # _getNextBlockNo (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNextBlockNo($$){
    my($iBlockNo, $rhInfo) = @_;
    my $iRes = $rhInfo->{_BBD_INFO}->{$iBlockNo};
    return defined($iRes)? $iRes: $iBlockNo+1;
  }
  #------------------------------------------------------------------------------
  # _isNormalBlock (OLE::Storage_Lite)
  # 0xFFFFFFFC : BDList, 0xFFFFFFFD : BBD,
  # 0xFFFFFFFE: End of Chain 0xFFFFFFFF : unused
  #------------------------------------------------------------------------------
  sub _isNormalBlock($){
    my($iBlock) = @_;
    return ($iBlock < 0xFFFFFFFC)? 1: undef;
  }
  #------------------------------------------------------------------------------
  # _getSmallData (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getSmallData($$$)
  {
    my($iSmBlock, $iSize, $rhInfo) = @_;
    my($sRes, $sWk);
    my $iRest = $iSize;
    $sRes = '';
    while ($iRest > 0) {
      _setFilePosSmall($iSmBlock, $rhInfo);
      $rhInfo->{_FILEH_}->read($sWk,
          ($iRest >= $rhInfo->{_SMALL_BLOCK_SIZE})?
              $rhInfo->{_SMALL_BLOCK_SIZE}: $iRest);
      $sRes .= $sWk;
      $iRest -= $rhInfo->{_SMALL_BLOCK_SIZE};
      $iSmBlock= _getNextSmallBlockNo($iSmBlock, $rhInfo);
    }
    return $sRes;
  }
  #------------------------------------------------------------------------------
  # _setFilePosSmall(OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _setFilePosSmall($$)
  {
    my($iSmBlock, $rhInfo) = @_;
    my $iSmStart = $rhInfo->{_SB_START};
    my $iBaseCnt = $rhInfo->{_BIG_BLOCK_SIZE} / $rhInfo->{_SMALL_BLOCK_SIZE};
    my $iNth = int($iSmBlock/$iBaseCnt);
    my $iPos = $iSmBlock % $iBaseCnt;
  
    my $iBlk = _getNthBlockNo($iSmStart, $iNth, $rhInfo);
    _setFilePos($iBlk, $iPos * $rhInfo->{_SMALL_BLOCK_SIZE}, $rhInfo);
  }
  #------------------------------------------------------------------------------
  # _getNextSmallBlockNo (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNextSmallBlockNo($$)
  {
    my($iSmBlock, $rhInfo) = @_;
    my($sWk);
  
    my $iBaseCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize();
    my $iNth = int($iSmBlock/$iBaseCnt);
    my $iPos = $iSmBlock % $iBaseCnt;
    my $iBlk = _getNthBlockNo($rhInfo->{_SBD_START}, $iNth, $rhInfo);
    _setFilePos($iBlk, $iPos * OLE::Storage_Lite::LongIntSize(), $rhInfo);
    $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize());
    return unpack("V", $sWk);
  
  }
  #------------------------------------------------------------------------------
  # Asc2Ucs: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub Asc2Ucs($)
  {
    my($sAsc) = @_;
    return join("\x00", split //, $sAsc) . "\x00";
  }
  #------------------------------------------------------------------------------
  # Ucs2Asc: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub Ucs2Asc($)
  {
    my($sUcs) = @_;
    return join('', map(pack('c', $_), unpack('v*', $sUcs)));
  }
  
  #------------------------------------------------------------------------------
  # OLEDate2Local()
  #
  # Convert from a Window FILETIME structure to a localtime array. FILETIME is
  # a 64-bit value representing the number of 100-nanosecond intervals since
  # January 1 1601.
  #
  # We first convert the FILETIME to seconds and then subtract the difference
  # between the 1601 epoch and the 1970 Unix epoch.
  #
  sub OLEDate2Local {
  
      my $oletime = shift;
  
      # Unpack the FILETIME into high and low longs.
      my ( $lo, $hi ) = unpack 'V2', $oletime;
  
      # Convert the longs to a double.
      my $nanoseconds = $hi * 2**32 + $lo;
  
      # Convert the 100 nanosecond units into seconds.
      my $time = $nanoseconds / 1e7;
  
      # Subtract the number of seconds between the 1601 and 1970 epochs.
      $time -= 11644473600;
  
      # Convert to a localtime (actually gmtime) structure.
      my @localtime = gmtime($time);
  
      return @localtime;
  }
  
  #------------------------------------------------------------------------------
  # LocalDate2OLE()
  #
  # Convert from a a localtime array to a Window FILETIME structure. FILETIME is
  # a 64-bit value representing the number of 100-nanosecond intervals since
  # January 1 1601.
  #
  # We first convert the localtime (actually gmtime) to seconds and then add the
  # difference between the 1601 epoch and the 1970 Unix epoch. We convert that to
  # 100 nanosecond units, divide it into high and low longs and return it as a
  # packed 64bit structure.
  #
  sub LocalDate2OLE {
  
      my $localtime = shift;
  
      return "\x00" x 8 unless $localtime;
  
      # Convert from localtime (actually gmtime) to seconds.
      my $time = timegm( @{$localtime} );
  
      # Add the number of seconds between the 1601 and 1970 epochs.
      $time += 11644473600;
  
      # The FILETIME seconds are in units of 100 nanoseconds.
      my $nanoseconds = $time * 1E7;
  
  use POSIX 'fmod';
  
      # Pack the total nanoseconds into 64 bits...
      my $hi = int( $nanoseconds / 2**32 );
      my $lo = fmod($nanoseconds, 2**32);
  
      my $oletime = pack "VV", $lo, $hi;
  
      return $oletime;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  OLE::Storage_Lite - Simple Class for OLE document interface.
  
  =head1 SYNOPSIS
  
      use OLE::Storage_Lite;
  
      # Initialize.
  
      # From a file
      my $oOl = OLE::Storage_Lite->new("some.xls");
  
      # From a filehandle object
      use IO::File;
      my $oIo = new IO::File;
      $oIo->open("<iofile.xls");
      binmode($oIo);
      my $oOl = OLE::Storage_Lite->new($oFile);
  
      # Read data
      my $oPps = $oOl->getPpsTree(1);
  
      # Save Data
      # To a File
      $oPps->save("kaba.xls"); #kaba.xls
      $oPps->save('-');        #STDOUT
  
      # To a filehandle object
      my $oIo = new IO::File;
      $oIo->open(">iofile.xls");
      bimode($oIo);
      $oPps->save($oIo);
  
  
  =head1 DESCRIPTION
  
  OLE::Storage_Lite allows you to read and write an OLE structured file.
  
  OLE::Storage_Lite::PPS is a class representing PPS. OLE::Storage_Lite::PPS::Root, OLE::Storage_Lite::PPS::File and OLE::Storage_Lite::PPS::Dir
  are subclasses of OLE::Storage_Lite::PPS.
  
  
  =head2 new()
  
  Constructor.
  
      $oOle = OLE::Storage_Lite->new($sFile);
  
  Creates a OLE::Storage_Lite object for C<$sFile>. C<$sFile> must be a correct file name.
  
  The C<new()> constructor also accepts a valid filehandle. Remember to C<binmode()> the filehandle first.
  
  
  =head2 getPpsTree()
  
      $oPpsRoot = $oOle->getPpsTree([$bData]);
  
  Returns PPS as an OLE::Storage_Lite::PPS::Root object.
  Other PPS objects will be included as its children.
  
  If C<$bData> is true, the objects will have data in the file.
  
  
  =head2 getPpsSearch()
  
      $oPpsRoot = $oOle->getPpsTree($raName [, $bData][, $iCase] );
  
  Returns PPSs as OLE::Storage_Lite::PPS objects that has the name specified in C<$raName> array.
  
  If C<$bData> is true, the objects will have data in the file.
  If C<$iCase> is true, search is case insensitive.
  
  
  =head2 getNthPps()
  
      $oPpsRoot = $oOle->getNthPps($iNth [, $bData]);
  
  Returns PPS as C<OLE::Storage_Lite::PPS> object specified number C<$iNth>.
  
  If C<$bData> is true, the objects will have data in the file.
  
  
  =head2 Asc2Ucs()
  
      $sUcs2 = OLE::Storage_Lite::Asc2Ucs($sAsc>);
  
  Utility function. Just adds 0x00 after every characters in C<$sAsc>.
  
  
  =head2 Ucs2Asc()
  
      $sAsc = OLE::Storage_Lite::Ucs2Asc($sUcs2);
  
  Utility function. Just deletes 0x00 after words in C<$sUcs>.
  
  
  =head1 OLE::Storage_Lite::PPS
  
  OLE::Storage_Lite::PPS has these properties:
  
  =over 4
  
  =item No
  
  Order number in saving.
  
  =item Name
  
  Its name in UCS2 (a.k.a Unicode).
  
  =item Type
  
  Its type (1:Dir, 2:File (Data), 5: Root)
  
  =item PrevPps
  
  Previous pps (as No)
  
  =item NextPps
  
  Next pps (as No)
  
  =item DirPps
  
  Dir pps (as No).
  
  =item Time1st
  
  Timestamp 1st in array ref as similar fomat of localtime.
  
  =item Time2nd
  
  Timestamp 2nd in array ref as similar fomat of localtime.
  
  =item StartBlock
  
  Start block number
  
  =item Size
  
  Size of the pps
  
  =item Data
  
  Its data
  
  =item Child
  
  Its child PPSs in array ref
  
  =back
  
  
  =head1 OLE::Storage_Lite::PPS::Root
  
  OLE::Storage_Lite::PPS::Root has 2 methods.
  
  =head2 new()
  
      $oRoot = OLE::Storage_Lite::PPS::Root->new(
                      $raTime1st,
                      $raTime2nd,
                      $raChild);
  
  
  Constructor.
  
  C<$raTime1st>, C<$raTime2nd> are array refs with ($iSec, $iMin, $iHour, $iDay, $iMon, $iYear).
  $iSec means seconds, $iMin means minutes. $iHour means hours.
  $iDay means day. $iMon is month -1. $iYear is year - 1900.
  
  C<$raChild> is a array ref of children PPSs.
  
  
  =head2 save()
  
      $oRoot = $oRoot>->save(
                      $sFile,
                      $bNoAs);
  
  
  Saves information into C<$sFile>. If C<$sFile> is '-', this will use STDOUT.
  
  The C<new()> constructor also accepts a valid filehandle. Remember to C<binmode()> the filehandle first.
  
  If C<$bNoAs> is defined, this function will use the No of PPSs for saving order.
  If C<$bNoAs> is undefined, this will calculate PPS saving order.
  
  
  =head1 OLE::Storage_Lite::PPS::Dir
  
  OLE::Storage_Lite::PPS::Dir has 1 method.
  
  =head2 new()
  
      $oRoot = OLE::Storage_Lite::PPS::Dir->new(
                      $sName,
                    [, $raTime1st]
                    [, $raTime2nd]
                    [, $raChild>]);
  
  
  Constructor.
  
  C<$sName> is a name of the PPS.
  
  C<$raTime1st>, C<$raTime2nd> is a array ref as
  ($iSec, $iMin, $iHour, $iDay, $iMon, $iYear).
  $iSec means seconds, $iMin means minutes. $iHour means hours.
  $iDay means day. $iMon is month -1. $iYear is year - 1900.
  
  C<$raChild> is a array ref of children PPSs.
  
  
  =head1 OLE::Storage_Lite::PPS::File
  
  OLE::Storage_Lite::PPS::File has 3 method.
  
  =head2 new
  
      $oRoot = OLE::Storage_Lite::PPS::File->new($sName, $sData);
  
  C<$sName> is name of the PPS.
  
  C<$sData> is data of the PPS.
  
  
  =head2 newFile()
  
      $oRoot = OLE::Storage_Lite::PPS::File->newFile($sName, $sFile);
  
  This function makes to use file handle for geting and storing data.
  
  C<$sName> is name of the PPS.
  
  If C<$sFile> is scalar, it assumes that is a filename.
  If C<$sFile> is an IO::Handle object, it uses that specified handle.
  If C<$sFile> is undef or '', it uses temporary file.
  
  CAUTION: Take care C<$sFile> will be updated by C<append> method.
  So if you want to use IO::Handle and append a data to it,
  you should open the handle with "r+".
  
  
  =head2 append()
  
      $oRoot = $oPps->append($sData);
  
  appends specified data to that PPS.
  
  C<$sData> is appending data for that PPS.
  
  
  =head1 CAUTION
  
  A saved file with VBA (a.k.a Macros) by this module will not work correctly.
  However modules can get the same information from the file,
  the file occurs a error in application(Word, Excel ...).
  
  
  =head1 DEPRECATED FEATURES
  
  Older version of C<OLE::Storage_Lite> autovivified a scalar ref in the C<new()> constructors into a scalar filehandle. This functionality is still there for backwards compatibility but it is highly recommended that you do not use it. Instead create a filehandle (scalar or otherwise) and pass that in.
  
  
  =head1 COPYRIGHT
  
  The OLE::Storage_Lite module is Copyright (c) 2000,2001 Kawai Takanori. Japan.
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the Perl README file.
  
  
  =head1 ACKNOWLEDGEMENTS
  
  First of all, I would like to acknowledge to Martin Schwartz and his module OLE::Storage.
  
  
  =head1 AUTHOR
  
  Kawai Takanori kwitknr@cpan.org
  
  This module is currently maintained by John McNamara jmcnamara@cpan.org
  
  
  =head1 SEE ALSO
  
  OLE::Storage
  
  Documentation for the OLE Compound document has been released by Microsoft under the I<Open Specification Promise>. See http://www.microsoft.com/interop/docs/supportingtechnologies.mspx
  
  The Digital Imaging Group have also detailed the OLE format in the JPEG2000 specification: see Appendix A of http://www.i3a.org/pdf/wg1n1017.pdf
  
  
  =cut
OLE_STORAGE_LITE

$fatpacked{"Spreadsheet/ParseExcel.pm"} = <<'SPREADSHEET_PARSEEXCEL';
  package Spreadsheet::ParseExcel;
  
  ##############################################################################
  #
  # Spreadsheet::ParseExcel - Extract information from an Excel file.
  #
  # Copyright 2000-2008, Takanori Kawai
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  use 5.008;
  
  use OLE::Storage_Lite;
  use IO::File;
  use Config;
  
  use Crypt::RC4;
  use Digest::Perl::MD5;
  
  our $VERSION = '0.59';
  
  use Spreadsheet::ParseExcel::Workbook;
  use Spreadsheet::ParseExcel::Worksheet;
  use Spreadsheet::ParseExcel::Font;
  use Spreadsheet::ParseExcel::Format;
  use Spreadsheet::ParseExcel::Cell;
  use Spreadsheet::ParseExcel::FmtDefault;
  
  my @aColor = (
      '000000',    # 0x00
      'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF',
      'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF',    # 0x08
      'FFFFFF', 'FF0000', '00FF00', '0000FF',
      'FFFF00', 'FF00FF', '00FFFF', '800000',    # 0x10
      '008000', '000080', '808000', '800080',
      '008080', 'C0C0C0', '808080', '9999FF',    # 0x18
      '993366', 'FFFFCC', 'CCFFFF', '660066',
      'FF8080', '0066CC', 'CCCCFF', '000080',    # 0x20
      'FF00FF', 'FFFF00', '00FFFF', '800080',
      '800000', '008080', '0000FF', '00CCFF',    # 0x28
      'CCFFFF', 'CCFFCC', 'FFFF99', '99CCFF',
      'FF99CC', 'CC99FF', 'FFCC99', '3366FF',    # 0x30
      '33CCCC', '99CC00', 'FFCC00', 'FF9900',
      'FF6600', '666699', '969696', '003366',    # 0x38
      '339966', '003300', '333300', '993300',
      '993366', '333399', '333333', 'FFFFFF'     # 0x40
  );
  use constant verExcel95 => 0x500;
  use constant verExcel97 => 0x600;
  use constant verBIFF2   => 0x00;
  use constant verBIFF3   => 0x02;
  use constant verBIFF4   => 0x04;
  use constant verBIFF5   => 0x08;
  use constant verBIFF8   => 0x18;
  
  use constant MS_BIFF_CRYPTO_NONE => 0;
  use constant MS_BIFF_CRYPTO_XOR  => 1;
  use constant MS_BIFF_CRYPTO_RC4  => 2;
  
  use constant sizeof_BIFF_8_FILEPASS => ( 6 + 3 * 16 );
  
  use constant REKEY_BLOCK => 0x400;
  
  # Error code for some of the common parsing errors.
  use constant ErrorNone          => 0;
  use constant ErrorNoFile        => 1;
  use constant ErrorNoExcelData   => 2;
  use constant ErrorFileEncrypted => 3;
  
  our %error_strings = (
      ErrorNone,          '',                               # 0
      ErrorNoFile,        'File not found',                 # 1
      ErrorNoExcelData,   'No Excel data found in file',    # 2
      ErrorFileEncrypted, 'File is encrypted',              # 3
  
  );
  
  
  our %ProcTbl = (
  
      #Develpers' Kit P291
      0x14   => \&_subHeader,            # Header
      0x15   => \&_subFooter,            # Footer
      0x18   => \&_subName,              # NAME(?)
      0x1A   => \&_subVPageBreak,        # Vertical Page Break
      0x1B   => \&_subHPageBreak,        # Horizontal Page Break
      0x22   => \&_subFlg1904,           # 1904 Flag
      0x26   => \&_subMargin,            # Left Margin
      0x27   => \&_subMargin,            # Right Margin
      0x28   => \&_subMargin,            # Top Margin
      0x29   => \&_subMargin,            # Bottom Margin
      0x2A   => \&_subPrintHeaders,      # Print Headers
      0x2B   => \&_subPrintGridlines,    # Print Gridlines
      0x3C   => \&_subContinue,          # Continue
      0x43   => \&_subXF,                # XF for Excel < 4.
      0x0443 => \&_subXF,                # XF for Excel = 4.
  
      #Develpers' Kit P292
      0x55 => \&_subDefColWidth,         # Consider
      0x5C => \&_subWriteAccess,         # WRITEACCESS
      0x7D => \&_subColInfo,             # Colinfo
      0x7E => \&_subRK,                  # RK
      0x81 => \&_subWSBOOL,              # WSBOOL
      0x83 => \&_subHcenter,             # HCENTER
      0x84 => \&_subVcenter,             # VCENTER
      0x85 => \&_subBoundSheet,          # BoundSheet
  
      0x92 => \&_subPalette,             # Palette, fgp
  
      0x99 => \&_subStandardWidth,       # Standard Col
  
      #Develpers' Kit P293
      0xA1 => \&_subSETUP,               # SETUP
      0xBD => \&_subMulRK,               # MULRK
      0xBE => \&_subMulBlank,            # MULBLANK
      0xD6 => \&_subRString,             # RString
  
      #Develpers' Kit P294
      0xE0 => \&_subXF,                  # ExTended Format
      0xE5 => \&_subMergeArea,           # MergeArea (Not Documented)
      0xFC => \&_subSST,                 # Shared String Table
      0xFD => \&_subLabelSST,            # Label SST
  
      #Develpers' Kit P295
      0x201 => \&_subBlank,              # Blank
  
      0x202 => \&_subInteger,            # Integer(Not Documented)
      0x203 => \&_subNumber,             # Number
      0x204 => \&_subLabel,              # Label
      0x205 => \&_subBoolErr,            # BoolErr
      0x207 => \&_subString,             # STRING
      0x208 => \&_subRow,                # RowData
      0x221 => \&_subArray,              # Array (Consider)
      0x225 => \&_subDefaultRowHeight,   # Consider
  
      0x31  => \&_subFont,               # Font
      0x231 => \&_subFont,               # Font
  
      0x27E => \&_subRK,                 # RK
      0x41E => \&_subFormat,             # Format
  
      0x06  => \&_subFormula,            # Formula
      0x406 => \&_subFormula,            # Formula
  
      0x009 => \&_subBOF,                # BOF(BIFF2)
      0x209 => \&_subBOF,                # BOF(BIFF3)
      0x409 => \&_subBOF,                # BOF(BIFF4)
      0x809 => \&_subBOF,                # BOF(BIFF5-8)
  );
  
  our $BIGENDIAN;
  our $PREFUNC;
  our $_CellHandler;
  our $_NotSetCell;
  our $_Object;
  our $_use_perlio;
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->new
  #------------------------------------------------------------------------------
  sub new {
      my ( $class, %hParam ) = @_;
  
      if ( not defined $_use_perlio ) {
          if (   exists $Config{useperlio}
              && defined $Config{useperlio}
              && $Config{useperlio} eq "define" )
          {
              $_use_perlio = 1;
          }
          else {
              $_use_perlio = 0;
              require IO::Scalar;
              import IO::Scalar;
          }
      }
  
      # Check ENDIAN(Little: Intel etc. BIG: Sparc etc)
      $BIGENDIAN =
          ( defined $hParam{Endian} ) ? $hParam{Endian}
        : ( unpack( "H08", pack( "L", 2 ) ) eq '02000000' ) ? 0
        :                                                     1;
      my $self = {};
      bless $self, $class;
  
      $self->{GetContent} = \&_subGetContent;
  
      if ( $hParam{EventHandlers} ) {
          $self->SetEventHandlers( $hParam{EventHandlers} );
      }
      else {
          $self->SetEventHandlers( \%ProcTbl );
      }
      if ( $hParam{AddHandlers} ) {
          foreach my $sKey ( keys( %{ $hParam{AddHandlers} } ) ) {
              $self->SetEventHandler( $sKey, $hParam{AddHandlers}->{$sKey} );
          }
      }
      $_CellHandler = $hParam{CellHandler} if ( $hParam{CellHandler} );
      $_NotSetCell  = $hParam{NotSetCell};
      $_Object      = $hParam{Object};
  
  
      if ( defined $hParam{Password} ) {
          $self->{Password} = $hParam{Password};
      }
      else {
          $self->{Password} = 'VelvetSweatshop';
      }
  
      $self->{_error_status} = ErrorNone;
      return $self;
  }
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->SetEventHandler
  #------------------------------------------------------------------------------
  sub SetEventHandler {
      my ( $self, $key, $sub_ref ) = @_;
      $self->{FuncTbl}->{$key} = $sub_ref;
  }
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->SetEventHandlers
  #------------------------------------------------------------------------------
  sub SetEventHandlers {
      my ( $self, $rhTbl ) = @_;
      $self->{FuncTbl} = undef;
      foreach my $sKey ( keys %$rhTbl ) {
          $self->{FuncTbl}->{$sKey} = $rhTbl->{$sKey};
      }
  }
  
  #------------------------------------------------------------------------------
  # Decryption routines
  # based on sources of gnumeric (ms-biff.c ms-excel-read.c)
  #------------------------------------------------------------------------------
  sub md5state {
      my ( $md5 ) = @_;
      my $s = '';
      for ( my $i = 0 ; $i < 4 ; $i++ ) {
          my $v = $md5->{_state}[$i];
          $s .= chr( $v & 0xff );
          $s .= chr( ( $v >> 8 ) & 0xff );
          $s .= chr( ( $v >> 16 ) & 0xff );
          $s .= chr( ( $v >> 24 ) & 0xff );
      }
  
      return $s;
  }
  
  sub MakeKey {
      my ( $block, $key, $valContext ) = @_;
  
      my $pwarray = "\0" x 64;
  
      substr( $pwarray, 0, 5 ) = substr( $valContext, 0, 5 );
  
      substr( $pwarray, 5, 1 ) = chr( $block & 0xff );
      substr( $pwarray, 6, 1 ) = chr( ( $block >> 8 ) & 0xff );
      substr( $pwarray, 7, 1 ) = chr( ( $block >> 16 ) & 0xff );
      substr( $pwarray, 8, 1 ) = chr( ( $block >> 24 ) & 0xff );
  
      substr( $pwarray, 9,  1 ) = "\x80";
      substr( $pwarray, 56, 1 ) = "\x48";
  
      my $md5 = Digest::Perl::MD5->new();
      $md5->add( $pwarray );
  
      my $s = md5state( $md5 );
  
      ${$key} = Crypt::RC4->new( $s );
  }
  
  sub VerifyPassword {
      my ( $password, $docid, $salt_data, $hashedsalt_data, $valContext ) = @_;
  
      my $pwarray = "\0" x 64;
      my $i;
      my $md5 = Digest::Perl::MD5->new();
  
      for ( $i = 0 ; $i < length( $password ) ; $i++ ) {
          my $o = ord( substr( $password, $i, 1 ) );
          substr( $pwarray, 2 * $i, 1 ) = chr( $o & 0xff );
          substr( $pwarray, 2 * $i + 1, 1 ) = chr( ( $o >> 8 ) & 0xff );
      }
      substr( $pwarray, 2 * $i, 1 ) = chr( 0x80 );
      substr( $pwarray, 56, 1 ) = chr( ( $i << 4 ) & 0xff );
  
      $md5->add( $pwarray );
  
      my $mdContext1 = md5state( $md5 );
  
      my $offset    = 0;
      my $keyoffset = 0;
      my $tocopy    = 5;
  
      $md5->reset;
  
      while ( $offset != 16 ) {
          if ( ( 64 - $offset ) < 5 ) {
              $tocopy = 64 - $offset;
          }
  
          substr( $pwarray, $offset, $tocopy ) =
            substr( $mdContext1, $keyoffset, $tocopy );
  
          $offset += $tocopy;
  
          if ( $offset == 64 ) {
              $md5->add( $pwarray );
              $keyoffset = $tocopy;
              $tocopy    = 5 - $tocopy;
              $offset    = 0;
              next;
          }
  
          $keyoffset = 0;
          $tocopy    = 5;
          substr( $pwarray, $offset, 16 ) = $docid;
          $offset += 16;
      }
  
      substr( $pwarray, 16, 1 )  = "\x80";
      substr( $pwarray, 17, 47 ) = "\0" x 47;
      substr( $pwarray, 56, 1 )  = "\x80";
      substr( $pwarray, 57, 1 )  = "\x0a";
  
      $md5->add( $pwarray );
      ${$valContext} = md5state( $md5 );
  
      my $key;
  
      MakeKey( 0, \$key, ${$valContext} );
  
      my $salt       = $key->RC4( $salt_data );
      my $hashedsalt = $key->RC4( $hashedsalt_data );
  
      $salt .= "\x80" . "\0" x 47;
  
      substr( $salt, 56, 1 ) = "\x80";
  
      $md5->reset;
      $md5->add( $salt );
      my $mdContext2 = md5state( $md5 );
  
      return ( $mdContext2 eq $hashedsalt );
  }
  
  sub SkipBytes {
      my ( $q, $start, $count ) = @_;
  
      my $scratch = "\0" x REKEY_BLOCK;
      my $block;
  
      $block = int( ( $start + $count ) / REKEY_BLOCK );
  
      if ( $block != $q->{block} ) {
          MakeKey( $q->{block} = $block, \$q->{rc4_key}, $q->{md5_ctxt} );
          $count = ( $start + $count ) % REKEY_BLOCK;
      }
  
      $q->{rc4_key}->RC4( substr( $scratch, 0, $count ) );
  
      return 1;
  }
  
  sub SetDecrypt {
      my ( $q, $version, $password ) = @_;
  
      if ( $q->{opcode} != 0x2f ) {
          return 0;
      }
  
      if ( $password eq '' ) {
          return 0;
      }
  
      # TODO old versions decryption
      #if (version < MS_BIFF_V8 || q->data[0] == 0)
      #    return ms_biff_pre_biff8_query_set_decrypt (q, password);
  
      if ( $q->{length} != sizeof_BIFF_8_FILEPASS ) {
          return 0;
      }
  
      unless (
          VerifyPassword(
              $password,
              substr( $q->{data}, 6,  16 ),
              substr( $q->{data}, 22, 16 ),
              substr( $q->{data}, 38, 16 ),
              \$q->{md5_ctxt}
          )
        )
      {
          return 0;
      }
  
      $q->{encryption} = MS_BIFF_CRYPTO_RC4;
      $q->{block}      = -1;
  
      # The first record after FILEPASS seems to be unencrypted
      $q->{dont_decrypt_next_record} = 1;
  
      # Pretend to decrypt the entire stream up till this point, it was
      # encrypted, but do it anyway to keep the rc4 state in sync
  
      SkipBytes( $q, 0, $q->{streamPos} );
  
      return 1;
  }
  
  sub InitStream {
      my ( $stream_data ) = @_;
      my %q;
  
      $q{opcode} = 0;
      $q{length} = 0;
      $q{data}   = '';
  
      $q{stream}    = $stream_data;              # data stream
      $q{streamLen} = length( $stream_data );    # stream length
      $q{streamPos} = 0;                         # stream position
  
      $q{encryption}               = 0;
      $q{xor_key}                  = '';
      $q{rc4_key}                  = '';
      $q{md5_ctxt}                 = '';
      $q{block}                    = 0;
      $q{dont_decrypt_next_record} = 0;
  
      return \%q;
  }
  
  sub QueryNext {
      my ( $q ) = @_;
  
      if ( $q->{streamPos} + 4 >= $q->{streamLen} ) {
          return 0;
      }
  
      my $data = substr( $q->{stream}, $q->{streamPos}, 4 );
  
      ( $q->{opcode}, $q->{length} ) = unpack( 'v2', $data );
  
      # No biff record should be larger than around 20,000.
      if ( $q->{length} >= 20000 ) {
          return 0;
      }
  
      if ( $q->{length} > 0 ) {
          $q->{data} = substr( $q->{stream}, $q->{streamPos} + 4, $q->{length} );
      }
      else {
          $q->{data}                     = undef;
          $q->{dont_decrypt_next_record} = 1;
      }
  
      if ( $q->{encryption} == MS_BIFF_CRYPTO_RC4 ) {
          if ( $q->{dont_decrypt_next_record} ) {
              SkipBytes( $q, $q->{streamPos}, 4 + $q->{length} );
              $q->{dont_decrypt_next_record} = 0;
          }
          else {
              my $pos  = $q->{streamPos};
              my $data = $q->{data};
              my $len  = $q->{length};
              my $res  = '';
  
              # Pretend to decrypt header.
              SkipBytes( $q, $pos, 4 );
              $pos += 4;
  
              while ( $q->{block} != int( ( $pos + $len ) / REKEY_BLOCK ) ) {
                  my $step = REKEY_BLOCK - ( $pos % REKEY_BLOCK );
                  $res .= $q->{rc4_key}->RC4( substr( $data, 0, $step ) );
                  $data = substr( $data, $step );
                  $pos += $step;
                  $len -= $step;
                  MakeKey( ++$q->{block}, \$q->{rc4_key}, $q->{md5_ctxt} );
              }
  
              $res .= $q->{rc4_key}->RC4( substr( $data, 0, $len ) );
              $q->{data} = $res;
          }
      }
      elsif ( $q->{encryption} == MS_BIFF_CRYPTO_XOR ) {
  
          # not implemented
          return 0;
      }
      elsif ( $q->{encryption} == MS_BIFF_CRYPTO_NONE ) {
  
      }
  
      $q->{streamPos} += 4 + $q->{length};
  
      return 1;
  }
  
  ###############################################################################
  #
  # Parse()
  #
  # Parse the Excel file and convert it into a tree of objects..
  #
  sub parse {
  
      my ( $self, $source, $formatter ) = @_;
  
      my $workbook = Spreadsheet::ParseExcel::Workbook->new();
      $workbook->{SheetCount} = 0;
  
      my ( $biff_data, $data_length ) = $self->_get_content( $source, $workbook );
      return undef if not $biff_data;
  
      if ( $formatter ) {
          $workbook->{FmtClass} = $formatter;
      }
      else {
          $workbook->{FmtClass} = Spreadsheet::ParseExcel::FmtDefault->new();
      }
  
      # Parse the BIFF data.
      my $stream = InitStream( $biff_data );
  
      while ( QueryNext( $stream ) ) {
  
          my $record        = $stream->{opcode};
          my $record_length = $stream->{length};
  
          my $record_header = $stream->{data};
  
          # If the file contains a FILEPASS record we assume that it is encrypted
          # and cannot be parsed.
          if ( $record == 0x002F ) {
              unless ( SetDecrypt( $stream, '', $self->{Password} ) ) {
                  $self->{_error_status} = ErrorFileEncrypted;
                  return undef;
              }
          }
  
          # Special case of a formula String with no string.
          if (   $workbook->{_PrevPos}
              && ( defined $self->{FuncTbl}->{$record} )
              && ( $record != 0x207 ) )
          {
              my $iPos = $workbook->{_PrevPos};
              $workbook->{_PrevPos} = undef;
  
              my ( $row, $col, $format_index ) = @$iPos;
              _NewCell(
                  $workbook, $row, $col,
                  Kind     => 'Formula String',
                  Val      => '',
                  FormatNo => $format_index,
                  Format   => $workbook->{Format}[$format_index],
                  Numeric  => 0,
                  Code     => undef,
                  Book     => $workbook,
              );
          }
  
          # If the BIFF record matches 0x0*09 then it is a BOF record.
          # We reset the _skip_chart flag to ensure we check the sheet type.
          if ( ( $record & 0xF0FF ) == 0x09 ) {
              $workbook->{_skip_chart} = 0;
          }
  
          if ( defined $self->{FuncTbl}->{$record} && !$workbook->{_skip_chart} )
          {
              $self->{FuncTbl}->{$record}
                ->( $workbook, $record, $record_length, $record_header );
          }
  
          $PREFUNC = $record if ( $record != 0x3C );    #Not Continue
  
          return $workbook if defined $workbook->{_ParseAbort};
      }
  
      return $workbook;
  }
  
  ###############################################################################
  #
  # _get_content()
  #
  # Get the Excel BIFF content from the file or filehandle.
  #
  sub _get_content {
  
      my ( $self, $source, $workbook ) = @_;
      my ( $biff_data, $data_length );
  
      # Reset the error status in case method is called more than once.
      $self->{_error_status} = ErrorNone;
  
      if ( ref( $source ) eq "SCALAR" ) {
  
          # Specified by a scalar buffer.
          ( $biff_data, $data_length ) = $self->{GetContent}->( $source );
  
      }
      elsif ( ( ref( $source ) =~ /GLOB/ ) || ( ref( $source ) eq 'Fh' ) ) {
  
          # For CGI.pm (Light FileHandle)
          binmode( $source );
          my $sWk;
          my $sBuff = '';
  
          while ( read( $source, $sWk, 4096 ) ) {
              $sBuff .= $sWk;
          }
  
          ( $biff_data, $data_length ) = $self->{GetContent}->( \$sBuff );
  
      }
      elsif ( ref( $source ) eq 'ARRAY' ) {
  
          # Specified by file content
          $workbook->{File} = undef;
          my $sData = join( '', @$source );
          ( $biff_data, $data_length ) = $self->{GetContent}->( \$sData );
      }
      else {
  
          # Specified by filename .
          $workbook->{File} = $source;
  
          if ( !-e $source ) {
              $self->{_error_status} = ErrorNoFile;
              return undef;
          }
  
          ( $biff_data, $data_length ) = $self->{GetContent}->( $source );
      }
  
      # If the read was successful return the data.
      if ( $data_length ) {
          return ( $biff_data, $data_length );
      }
      else {
          $self->{_error_status} = ErrorNoExcelData;
          return undef;
      }
  
  }
  
  #------------------------------------------------------------------------------
  # _subGetContent (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _subGetContent {
      my ( $sFile ) = @_;
  
      my $oOl = OLE::Storage_Lite->new( $sFile );
      return ( undef, undef ) unless ( $oOl );
      my @aRes = $oOl->getPpsSearch(
          [
              OLE::Storage_Lite::Asc2Ucs( 'Book' ),
              OLE::Storage_Lite::Asc2Ucs( 'Workbook' )
          ],
          1, 1
      );
      return ( undef, undef ) if ( $#aRes < 0 );
  
      #Hack from Herbert
      if ( $aRes[0]->{Data} ) {
          return ( $aRes[0]->{Data}, length( $aRes[0]->{Data} ) );
      }
  
      #Same as OLE::Storage_Lite
      my $oIo;
  
      #1. $sFile is Ref of scalar
      if ( ref( $sFile ) eq 'SCALAR' ) {
          if ( $_use_perlio ) {
              open $oIo, "<", \$sFile;
          }
          else {
              $oIo = IO::Scalar->new;
              $oIo->open( $sFile );
          }
      }
  
      #2. $sFile is a IO::Handle object
      elsif ( UNIVERSAL::isa( $sFile, 'IO::Handle' ) ) {
          $oIo = $sFile;
          binmode( $oIo );
      }
  
      #3. $sFile is a simple filename string
      elsif ( !ref( $sFile ) ) {
          $oIo = IO::File->new;
          $oIo->open( "<$sFile" ) || return undef;
          binmode( $oIo );
      }
      my $sWk;
      my $sBuff = '';
  
      while ( $oIo->read( $sWk, 4096 ) ) {    #4_096 has no special meanings
          $sBuff .= $sWk;
      }
      $oIo->close();
  
      #Not Excel file (simple method)
      return ( undef, undef ) if ( substr( $sBuff, 0, 1 ) ne "\x09" );
      return ( $sBuff, length( $sBuff ) );
  }
  
  #------------------------------------------------------------------------------
  # _subBOF (for Spreadsheet::ParseExcel) Developers' Kit : P303
  #------------------------------------------------------------------------------
  sub _subBOF {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iVer, $iDt ) = unpack( "v2", $sWk );
  
      #Workbook Global
      if ( $iDt == 0x0005 ) {
          $oBook->{Version} = unpack( "v", $sWk );
          $oBook->{BIFFVersion} =
            ( $oBook->{Version} == verExcel95 ) ? verBIFF5 : verBIFF8;
          $oBook->{_CurSheet}  = undef;
          $oBook->{_CurSheet_} = -1;
      }
  
      #Worksheet or Dialogsheet
      elsif ( $iDt != 0x0020 ) {    #if($iDt == 0x0010)
          if ( defined $oBook->{_CurSheet_} ) {
              $oBook->{_CurSheet} = $oBook->{_CurSheet_} + 1;
              $oBook->{_CurSheet_}++;
  
              (
                  $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{SheetVersion},
                  $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{SheetType},
                )
                = unpack( "v2", $sWk )
                if ( length( $sWk ) > 4 );
          }
          else {
              $oBook->{BIFFVersion} = int( $bOp / 0x100 );
              if (   ( $oBook->{BIFFVersion} == verBIFF2 )
                  || ( $oBook->{BIFFVersion} == verBIFF3 )
                  || ( $oBook->{BIFFVersion} == verBIFF4 ) )
              {
                  $oBook->{Version}   = $oBook->{BIFFVersion};
                  $oBook->{_CurSheet} = 0;
                  $oBook->{Worksheet}[ $oBook->{SheetCount} ] =
                    Spreadsheet::ParseExcel::Worksheet->new(
                      _Name    => '',
                      Name     => '',
                      _Book    => $oBook,
                      _SheetNo => $oBook->{SheetCount},
                    );
                  $oBook->{SheetCount}++;
              }
          }
      }
      else {
  
          # Set flag to ignore all chart records until we reach another BOF.
          $oBook->{_skip_chart} = 1;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subBlank (for Spreadsheet::ParseExcel) DK:P303
  #------------------------------------------------------------------------------
  sub _subBlank {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'BLANK',
          Val      => '',
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subInteger (for Spreadsheet::ParseExcel) Not in DK
  #------------------------------------------------------------------------------
  sub _subInteger {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF, $sTxt, $sDum );
  
      ( $iR, $iC, $iF, $sDum, $sTxt ) = unpack( "v3cv", $sWk );
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'INTEGER',
          Val      => $sTxt,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subNumber (for Spreadsheet::ParseExcel)  : DK: P354
  #------------------------------------------------------------------------------
  sub _subNumber {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      my $dVal = _convDval( substr( $sWk, 6, 8 ) );
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'Number',
          Val      => $dVal,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 1,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _convDval (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _convDval {
      my ( $sWk ) = @_;
      return
        unpack( "d",
          ( $BIGENDIAN ) ? pack( "c8", reverse( unpack( "c8", $sWk ) ) ) : $sWk );
  }
  
  #------------------------------------------------------------------------------
  # _subRString (for Spreadsheet::ParseExcel) DK:P405
  #------------------------------------------------------------------------------
  sub _subRString {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF, $iL, $sTxt );
      ( $iR, $iC, $iF, $iL ) = unpack( "v4", $sWk );
      $sTxt = substr( $sWk, 8, $iL );
  
      #Has STRUN
      if ( length( $sWk ) > ( 8 + $iL ) ) {
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'RString',
              Val      => $sTxt,
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 0,
              Code     => '_native_',                        #undef,
              Book     => $oBook,
              Rich     => substr( $sWk, ( 8 + $iL ) + 1 ),
          );
      }
      else {
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'RString',
              Val      => $sTxt,
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 0,
              Code     => '_native_',
              Book     => $oBook,
          );
      }
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subBoolErr (for Spreadsheet::ParseExcel) DK:P306
  #------------------------------------------------------------------------------
  sub _subBoolErr {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      my ( $iVal, $iFlg ) = unpack( "cc", substr( $sWk, 6, 2 ) );
      my $sTxt = DecodeBoolErr( $iVal, $iFlg );
  
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'BoolError',
          Val      => $sTxt,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  ###############################################################################
  #
  # _subRK()
  #
  # Decode the RK BIFF record.
  #
  sub _subRK {
  
      my ( $workbook, $biff_number, $length, $data ) = @_;
  
      my ( $row, $col, $format_index, $rk_number ) = unpack( 'vvvV', $data );
  
      my $number = _decode_rk_number( $rk_number );
  
      _NewCell(
          $workbook, $row, $col,
          Kind     => 'RK',
          Val      => $number,
          FormatNo => $format_index,
          Format   => $workbook->{Format}->[$format_index],
          Numeric  => 1,
          Code     => undef,
          Book     => $workbook,
      );
  
      # Store the max and min row/col values.
      _SetDimension( $workbook, $row, $col, $col );
  }
  
  #------------------------------------------------------------------------------
  # _subArray (for Spreadsheet::ParseExcel)   DK:P297
  #------------------------------------------------------------------------------
  sub _subArray {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iBR, $iER, $iBC, $iEC ) = unpack( "v2c2", $sWk );
  
  }
  
  #------------------------------------------------------------------------------
  # _subFormula (for Spreadsheet::ParseExcel) DK:P336
  #------------------------------------------------------------------------------
  sub _subFormula {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
  
      my ( $iFlg ) = unpack( "v", substr( $sWk, 12, 2 ) );
      if ( $iFlg == 0xFFFF ) {
          my ( $iKind ) = unpack( "c", substr( $sWk, 6, 1 ) );
          my ( $iVal )  = unpack( "c", substr( $sWk, 8, 1 ) );
  
          if ( ( $iKind == 1 ) or ( $iKind == 2 ) ) {
              my $sTxt =
                ( $iKind == 1 )
                ? DecodeBoolErr( $iVal, 0 )
                : DecodeBoolErr( $iVal, 1 );
              _NewCell(
                  $oBook, $iR, $iC,
                  Kind     => 'Formula Bool',
                  Val      => $sTxt,
                  FormatNo => $iF,
                  Format   => $oBook->{Format}[$iF],
                  Numeric  => 0,
                  Code     => undef,
                  Book     => $oBook,
              );
          }
          else {    # Result (Reserve Only)
              $oBook->{_PrevPos} = [ $iR, $iC, $iF ];
          }
      }
      else {
          my $dVal = _convDval( substr( $sWk, 6, 8 ) );
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'Formula Number',
              Val      => $dVal,
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 1,
              Code     => undef,
              Book     => $oBook,
          );
      }
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subString (for Spreadsheet::ParseExcel)  DK:P414
  #------------------------------------------------------------------------------
  sub _subString {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      #Position (not enough for ARRAY)
  
      my $iPos = $oBook->{_PrevPos};
      return undef unless ( $iPos );
      $oBook->{_PrevPos} = undef;
      my ( $iR, $iC, $iF ) = @$iPos;
  
      my ( $iLen, $sTxt, $sCode );
      if ( $oBook->{BIFFVersion} == verBIFF8 ) {
          my ( $raBuff, $iLen ) = _convBIFF8String( $oBook, $sWk, 1 );
          $sTxt = $raBuff->[0];
          $sCode = ( $raBuff->[1] ) ? 'ucs2' : undef;
      }
      elsif ( $oBook->{BIFFVersion} == verBIFF5 ) {
          $sCode = '_native_';
          $iLen  = unpack( "v", $sWk );
          $sTxt  = substr( $sWk, 2, $iLen );
      }
      else {
          $sCode = '_native_';
          $iLen  = unpack( "c", $sWk );
          $sTxt  = substr( $sWk, 1, $iLen );
      }
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'String',
          Val      => $sTxt,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => $sCode,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subLabel (for Spreadsheet::ParseExcel)   DK:P344
  #------------------------------------------------------------------------------
  sub _subLabel {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      my ( $sLbl, $sCode );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          my ( $raBuff, $iLen, $iStPos, $iLenS ) =
            _convBIFF8String( $oBook, substr( $sWk, 6 ), 1 );
          $sLbl = $raBuff->[0];
          $sCode = ( $raBuff->[1] ) ? 'ucs2' : undef;
      }
  
      #Before BIFF8
      else {
          $sLbl = substr( $sWk, 8 );
          $sCode = '_native_';
      }
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'Label',
          Val      => $sLbl,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => $sCode,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  ###############################################################################
  #
  # _subMulRK()
  #
  # Decode the Multiple RK BIFF record.
  #
  sub _subMulRK {
  
      my ( $workbook, $biff_number, $length, $data ) = @_;
  
      # JMN: I don't know why this is here.
      return if $workbook->{SheetCount} <= 0;
  
      my ( $row, $first_col ) = unpack( "v2", $data );
      my $last_col = unpack( "v", substr( $data, length( $data ) - 2, 2 ) );
  
      # Iterate over the RK array and decode the data.
      my $pos = 4;
      for my $col ( $first_col .. $last_col ) {
  
          my $data = substr( $data, $pos, 6 );
          my ( $format_index, $rk_number ) = unpack 'vV', $data;
          my $number = _decode_rk_number( $rk_number );
  
          _NewCell(
              $workbook, $row, $col,
              Kind     => 'MulRK',
              Val      => $number,
              FormatNo => $format_index,
              Format   => $workbook->{Format}->[$format_index],
              Numeric  => 1,
              Code     => undef,
              Book     => $workbook,
          );
          $pos += 6;
      }
  
      # Store the max and min row/col values.
      _SetDimension( $workbook, $row, $first_col, $last_col );
  }
  
  #------------------------------------------------------------------------------
  # _subMulBlank (for Spreadsheet::ParseExcel) DK:P349
  #------------------------------------------------------------------------------
  sub _subMulBlank {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iSc ) = unpack( "v2", $sWk );
      my $iEc = unpack( "v", substr( $sWk, length( $sWk ) - 2, 2 ) );
      my $iPos = 4;
      for ( my $iC = $iSc ; $iC <= $iEc ; $iC++ ) {
          my $iF = unpack( 'v', substr( $sWk, $iPos, 2 ) );
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'MulBlank',
              Val      => '',
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 0,
              Code     => undef,
              Book     => $oBook,
          );
          $iPos += 2;
      }
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iSc, $iEc );
  }
  
  #------------------------------------------------------------------------------
  # _subLabelSST (for Spreadsheet::ParseExcel) DK: P345
  #------------------------------------------------------------------------------
  sub _subLabelSST {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF, $iIdx ) = unpack( 'v3V', $sWk );
  
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'PackedIdx',
          Val      => $oBook->{PkgStr}[$iIdx]->{Text},
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => ( $oBook->{PkgStr}[$iIdx]->{Unicode} ) ? 'ucs2' : undef,
          Book     => $oBook,
          Rich     => $oBook->{PkgStr}[$iIdx]->{Rich},
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subFlg1904 (for Spreadsheet::ParseExcel) DK:P296
  #------------------------------------------------------------------------------
  sub _subFlg1904 {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      $oBook->{Flg1904} = unpack( "v", $sWk );
  }
  
  #------------------------------------------------------------------------------
  # _subRow (for Spreadsheet::ParseExcel) DK:P403
  #------------------------------------------------------------------------------
  sub _subRow {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #0. Get Worksheet info (MaxRow, MaxCol, MinRow, MinCol)
      my ( $iR, $iSc, $iEc, $iHght, $undef1, $undef2, $iGr, $iXf ) =
        unpack( "v8", $sWk );
      $iEc--;
  
      # TODO. we need to handle hidden rows:
      # $iGr & 0x20
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{RowHeight}[$iR] = $iHght / 20;
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iSc, $iEc );
  }
  
  #------------------------------------------------------------------------------
  # _SetDimension (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _SetDimension {
      my ( $oBook, $iR, $iSc, $iEc ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      #2.1 MinRow
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinRow} = $iR
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinRow} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinRow} <= $iR );
  
      #2.2 MaxRow
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxRow} = $iR
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxRow} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxRow} > $iR );
  
      #2.3 MinCol
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinCol} = $iSc
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinCol} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinCol} <= $iSc );
  
      #2.4 MaxCol
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxCol} = $iEc
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxCol} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxCol} > $iEc );
  
  }
  
  #------------------------------------------------------------------------------
  # _subDefaultRowHeight (for Spreadsheet::ParseExcel)    DK: P318
  #------------------------------------------------------------------------------
  sub _subDefaultRowHeight {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #1. RowHeight
      my ( $iDum, $iHght ) = unpack( "v2", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{DefRowHeight} = $iHght / 20;
  
  }
  
  #------------------------------------------------------------------------------
  # _subStandardWidth(for Spreadsheet::ParseExcel)    DK:P413
  #------------------------------------------------------------------------------
  sub _subStandardWidth {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my $iW = unpack( "v", $sWk );
      $oBook->{StandardWidth} = _convert_col_width( $oBook, $iW );
  }
  
  ###############################################################################
  #
  # _subDefColWidth()
  #
  # Read the DEFCOLWIDTH Biff record. This gives the width in terms of chars
  # and is different from the width in the COLINFO record.
  #
  sub _subDefColWidth {
  
      my ( $self, $record, $length, $data ) = @_;
  
      my $width = unpack 'v', $data;
  
      # Adjustment for default Arial 10 width.
      $width = 8.43 if $width == 8;
  
      $self->{Worksheet}->[ $self->{_CurSheet} ]->{DefColWidth} = $width;
  }
  
  ###############################################################################
  #
  # _convert_col_width()
  #
  # Converts from the internal Excel column width units to user units seen in the
  # interface. It is first necessary to convert the internal width to pixels and
  # then to user units. The conversion is specific to a default font of Arial 10.
  # TODO, the conversion should be extended to other fonts and sizes.
  #
  sub _convert_col_width {
  
      my $self        = shift;
      my $excel_width = shift;
  
      # Convert from Excel units to pixels (rounded up).
      my $pixels = int( 0.5 + $excel_width * 7 / 256 );
  
      # Convert from pixels to user units.
      # The conversion is different for columns <= 1 user unit (12 pixels).
      my $user_width;
      if ( $pixels <= 12 ) {
          $user_width = $pixels / 12;
      }
      else {
          $user_width = ( $pixels - 5 ) / 7;
      }
  
      # Round up to 2 decimal places.
      $user_width = int( $user_width * 100 + 0.5 ) / 100;
  
      return $user_width;
  }
  
  #------------------------------------------------------------------------------
  # _subColInfo (for Spreadsheet::ParseExcel) DK:P309
  #------------------------------------------------------------------------------
  sub _subColInfo {
  
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      return undef unless defined $oBook->{_CurSheet};
  
      my ( $iSc, $iEc, $iW, $iXF, $iGr ) = unpack( "v5", $sWk );
  
      for ( my $i = $iSc ; $i <= $iEc ; $i++ ) {
  
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{ColWidth}[$i] =
            _convert_col_width( $oBook, $iW );
  
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{ColFmtNo}[$i] = $iXF;
  
          # TODO. we need to handle hidden cols: $iGr & 0x01.
      }
  }
  
  #------------------------------------------------------------------------------
  # _subSST (for Spreadsheet::ParseExcel) DK:P413
  #------------------------------------------------------------------------------
  sub _subSST {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      _subStrWk( $oBook, substr( $sWk, 8 ) );
  }
  
  #------------------------------------------------------------------------------
  # _subContinue (for Spreadsheet::ParseExcel)    DK:P311
  #------------------------------------------------------------------------------
  sub _subContinue {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      #if(defined $self->{FuncTbl}->{$bOp}) {
      #    $self->{FuncTbl}->{$PREFUNC}->($oBook, $bOp, $bLen, $sWk);
      #}
  
      _subStrWk( $oBook, $sWk, 1 ) if ( $PREFUNC == 0xFC );
  }
  
  #------------------------------------------------------------------------------
  # _subWriteAccess (for Spreadsheet::ParseExcel) DK:P451
  #------------------------------------------------------------------------------
  sub _subWriteAccess {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return if ( defined $oBook->{_Author} );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          $oBook->{Author} = _convBIFF8String( $oBook, $sWk );
      }
  
      #Before BIFF8
      else {
          my ( $iLen ) = unpack( "c", $sWk );
          $oBook->{Author} =
            $oBook->{FmtClass}->TextFmt( substr( $sWk, 1, $iLen ), '_native_' );
      }
  }
  
  #------------------------------------------------------------------------------
  # _convBIFF8String (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _convBIFF8String {
      my ( $oBook, $sWk, $iCnvFlg ) = @_;
      my ( $iLen, $iFlg ) = unpack( "vc", $sWk );
      my ( $iHigh, $iExt, $iRich ) = ( $iFlg & 0x01, $iFlg & 0x04, $iFlg & 0x08 );
      my ( $iStPos, $iExtCnt, $iRichCnt, $sStr );
  
      #2. Rich and Ext
      if ( $iRich && $iExt ) {
          $iStPos = 9;
          ( $iRichCnt, $iExtCnt ) = unpack( 'vV', substr( $sWk, 3, 6 ) );
      }
      elsif ( $iRich ) {    #Only Rich
          $iStPos   = 5;
          $iRichCnt = unpack( 'v', substr( $sWk, 3, 2 ) );
          $iExtCnt  = 0;
      }
      elsif ( $iExt ) {     #Only Ext
          $iStPos   = 7;
          $iRichCnt = 0;
          $iExtCnt  = unpack( 'V', substr( $sWk, 3, 4 ) );
      }
      else {                #Nothing Special
          $iStPos   = 3;
          $iExtCnt  = 0;
          $iRichCnt = 0;
      }
  
      #3.Get String
      if ( $iHigh ) {       #Compressed
          $iLen *= 2;
          $sStr = substr( $sWk, $iStPos, $iLen );
          _SwapForUnicode( \$sStr );
          $sStr = $oBook->{FmtClass}->TextFmt( $sStr, 'ucs2' )
            unless ( $iCnvFlg );
      }
      else {                #Not Compressed
          $sStr = substr( $sWk, $iStPos, $iLen );
          $sStr = $oBook->{FmtClass}->TextFmt( $sStr, undef ) unless ( $iCnvFlg );
      }
  
      #4. return
      if ( wantarray ) {
  
          #4.1 Get Rich and Ext
          if ( length( $sWk ) < $iStPos + $iLen + $iRichCnt * 4 + $iExtCnt ) {
              return (
                  [ undef, $iHigh, undef, undef ],
                  $iStPos + $iLen + $iRichCnt * 4 + $iExtCnt,
                  $iStPos, $iLen
              );
          }
          else {
              return (
                  [
                      $sStr,
                      $iHigh,
                      substr( $sWk, $iStPos + $iLen, $iRichCnt * 4 ),
                      substr( $sWk, $iStPos + $iLen + $iRichCnt * 4, $iExtCnt )
                  ],
                  $iStPos + $iLen + $iRichCnt * 4 + $iExtCnt,
                  $iStPos, $iLen
              );
          }
      }
      else {
          return $sStr;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subXF (for Spreadsheet::ParseExcel)     DK:P453
  #------------------------------------------------------------------------------
  sub _subXF {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      my ( $iFnt, $iIdx );
      my (
          $iLock,    $iHidden, $iStyle,  $i123,   $iAlH,    $iWrap,
          $iAlV,     $iJustL,  $iRotate, $iInd,   $iShrink, $iMerge,
          $iReadDir, $iBdrD,   $iBdrSL,  $iBdrSR, $iBdrST,  $iBdrSB,
          $iBdrSD,   $iBdrCL,  $iBdrCR,  $iBdrCT, $iBdrCB,  $iBdrCD,
          $iFillP,   $iFillCF, $iFillCB
      );
  
  
      if ( $oBook->{BIFFVersion} == verBIFF4 ) {
  
          # Minimal support for Excel 4. We just get the font and format indices
          # so that the cell data value can be formatted.
          ( $iFnt, $iIdx, ) = unpack( "CC", $sWk );
      }
      elsif ( $oBook->{BIFFVersion} == verBIFF8 ) {
          my ( $iGen, $iAlign, $iGen2, $iBdr1, $iBdr2, $iBdr3, $iPtn );
  
          ( $iFnt, $iIdx, $iGen, $iAlign, $iGen2, $iBdr1, $iBdr2, $iBdr3, $iPtn )
            = unpack( "v7Vv", $sWk );
          $iLock   = ( $iGen & 0x01 )   ? 1 : 0;
          $iHidden = ( $iGen & 0x02 )   ? 1 : 0;
          $iStyle  = ( $iGen & 0x04 )   ? 1 : 0;
          $i123    = ( $iGen & 0x08 )   ? 1 : 0;
          $iAlH    = ( $iAlign & 0x07 );
          $iWrap   = ( $iAlign & 0x08 ) ? 1 : 0;
          $iAlV    = ( $iAlign & 0x70 ) / 0x10;
          $iJustL  = ( $iAlign & 0x80 ) ? 1 : 0;
  
          $iRotate = ( ( $iAlign & 0xFF00 ) / 0x100 ) & 0x00FF;
          $iRotate = 90            if ( $iRotate == 255 );
          $iRotate = 90 - $iRotate if ( $iRotate > 90 );
  
          $iInd     = ( $iGen2 & 0x0F );
          $iShrink  = ( $iGen2 & 0x10 ) ? 1 : 0;
          $iMerge   = ( $iGen2 & 0x20 ) ? 1 : 0;
          $iReadDir = ( ( $iGen2 & 0xC0 ) / 0x40 ) & 0x03;
          $iBdrSL   = $iBdr1 & 0x0F;
          $iBdrSR   = ( ( $iBdr1 & 0xF0 ) / 0x10 ) & 0x0F;
          $iBdrST   = ( ( $iBdr1 & 0xF00 ) / 0x100 ) & 0x0F;
          $iBdrSB   = ( ( $iBdr1 & 0xF000 ) / 0x1000 ) & 0x0F;
  
          $iBdrCL = ( ( $iBdr2 & 0x7F ) ) & 0x7F;
          $iBdrCR = ( ( $iBdr2 & 0x3F80 ) / 0x80 ) & 0x7F;
          $iBdrD  = ( ( $iBdr2 & 0xC000 ) / 0x4000 ) & 0x3;
  
          $iBdrCT = ( ( $iBdr3 & 0x7F ) ) & 0x7F;
          $iBdrCB = ( ( $iBdr3 & 0x3F80 ) / 0x80 ) & 0x7F;
          $iBdrCD = ( ( $iBdr3 & 0x1FC000 ) / 0x4000 ) & 0x7F;
          $iBdrSD = ( ( $iBdr3 & 0x1E00000 ) / 0x200000 ) & 0xF;
          $iFillP = ( ( $iBdr3 & 0xFC000000 ) / 0x4000000 ) & 0x3F;
  
          $iFillCF = ( $iPtn & 0x7F );
          $iFillCB = ( ( $iPtn & 0x3F80 ) / 0x80 ) & 0x7F;
      }
      else {
          my ( $iGen, $iAlign, $iPtn, $iPtn2, $iBdr1, $iBdr2 );
  
          ( $iFnt, $iIdx, $iGen, $iAlign, $iPtn, $iPtn2, $iBdr1, $iBdr2 ) =
            unpack( "v8", $sWk );
          $iLock   = ( $iGen & 0x01 ) ? 1 : 0;
          $iHidden = ( $iGen & 0x02 ) ? 1 : 0;
          $iStyle  = ( $iGen & 0x04 ) ? 1 : 0;
          $i123    = ( $iGen & 0x08 ) ? 1 : 0;
  
          $iAlH   = ( $iAlign & 0x07 );
          $iWrap  = ( $iAlign & 0x08 ) ? 1 : 0;
          $iAlV   = ( $iAlign & 0x70 ) / 0x10;
          $iJustL = ( $iAlign & 0x80 ) ? 1 : 0;
  
          $iRotate = ( ( $iAlign & 0x300 ) / 0x100 ) & 0x3;
  
          $iFillCF = ( $iPtn & 0x7F );
          $iFillCB = ( ( $iPtn & 0x1F80 ) / 0x80 ) & 0x7F;
  
          $iFillP = ( $iPtn2 & 0x3F );
          $iBdrSB = ( ( $iPtn2 & 0x1C0 ) / 0x40 ) & 0x7;
          $iBdrCB = ( ( $iPtn2 & 0xFE00 ) / 0x200 ) & 0x7F;
  
          $iBdrST = ( $iBdr1 & 0x07 );
          $iBdrSL = ( ( $iBdr1 & 0x38 ) / 0x8 ) & 0x07;
          $iBdrSR = ( ( $iBdr1 & 0x1C0 ) / 0x40 ) & 0x07;
          $iBdrCT = ( ( $iBdr1 & 0xFE00 ) / 0x200 ) & 0x7F;
  
          $iBdrCL = ( $iBdr2 & 0x7F ) & 0x7F;
          $iBdrCR = ( ( $iBdr2 & 0x3F80 ) / 0x80 ) & 0x7F;
      }
  
      push @{ $oBook->{Format} }, Spreadsheet::ParseExcel::Format->new(
          FontNo => $iFnt,
          Font   => $oBook->{Font}[$iFnt],
          FmtIdx => $iIdx,
  
          Lock     => $iLock,
          Hidden   => $iHidden,
          Style    => $iStyle,
          Key123   => $i123,
          AlignH   => $iAlH,
          Wrap     => $iWrap,
          AlignV   => $iAlV,
          JustLast => $iJustL,
          Rotate   => $iRotate,
  
          Indent  => $iInd,
          Shrink  => $iShrink,
          Merge   => $iMerge,
          ReadDir => $iReadDir,
  
          BdrStyle => [ $iBdrSL, $iBdrSR,  $iBdrST, $iBdrSB ],
          BdrColor => [ $iBdrCL, $iBdrCR,  $iBdrCT, $iBdrCB ],
          BdrDiag  => [ $iBdrD,  $iBdrSD,  $iBdrCD ],
          Fill     => [ $iFillP, $iFillCF, $iFillCB ],
      );
  }
  
  #------------------------------------------------------------------------------
  # _subFormat (for Spreadsheet::ParseExcel)  DK: P336
  #------------------------------------------------------------------------------
  sub _subFormat {
  
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my $sFmt;
  
      if ( $oBook->{BIFFVersion} <= verBIFF5 ) {
          $sFmt = substr( $sWk, 3, unpack( 'c', substr( $sWk, 2, 1 ) ) );
          $sFmt = $oBook->{FmtClass}->TextFmt( $sFmt, '_native_' );
      }
      else {
          $sFmt = _convBIFF8String( $oBook, substr( $sWk, 2 ) );
      }
  
      my $format_index = unpack( 'v', substr( $sWk, 0, 2 ) );
  
      # Excel 4 and earlier used an index of 0 to indicate that a built-in format
      # that was stored implicitly.
      if ( $oBook->{BIFFVersion} <= verBIFF4 && $format_index == 0 ) {
          $format_index = keys %{ $oBook->{FormatStr} };
      }
  
      $oBook->{FormatStr}->{$format_index} = $sFmt;
  }
  
  #------------------------------------------------------------------------------
  # _subPalette (for Spreadsheet::ParseExcel) DK: P393
  #------------------------------------------------------------------------------
  sub _subPalette {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      for ( my $i = 0 ; $i < unpack( 'v', $sWk ) ; $i++ ) {
  
          #        push @aColor, unpack('H6', substr($sWk, $i*4+2));
          $aColor[ $i + 8 ] = unpack( 'H6', substr( $sWk, $i * 4 + 2 ) );
      }
  }
  
  #------------------------------------------------------------------------------
  # _subFont (for Spreadsheet::ParseExcel) DK:P333
  #------------------------------------------------------------------------------
  sub _subFont {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iHeight, $iAttr, $iCIdx, $iBold, $iSuper, $iUnderline, $sFntName );
      my ( $bBold, $bItalic, $bUnderline, $bStrikeout );
  
      if ( $oBook->{BIFFVersion} == verBIFF8 ) {
          ( $iHeight, $iAttr, $iCIdx, $iBold, $iSuper, $iUnderline ) =
            unpack( "v5c", $sWk );
          my ( $iSize, $iHigh ) = unpack( 'cc', substr( $sWk, 14, 2 ) );
          if ( $iHigh ) {
              $sFntName = substr( $sWk, 16, $iSize * 2 );
              _SwapForUnicode( \$sFntName );
              $sFntName = $oBook->{FmtClass}->TextFmt( $sFntName, 'ucs2' );
          }
          else {
              $sFntName = substr( $sWk, 16, $iSize );
              $sFntName = $oBook->{FmtClass}->TextFmt( $sFntName, '_native_' );
          }
          $bBold      = ( $iBold >= 0x2BC ) ? 1 : 0;
          $bItalic    = ( $iAttr & 0x02 )   ? 1 : 0;
          $bStrikeout = ( $iAttr & 0x08 )   ? 1 : 0;
          $bUnderline = ( $iUnderline )     ? 1 : 0;
      }
      elsif ( $oBook->{BIFFVersion} == verBIFF5 ) {
          ( $iHeight, $iAttr, $iCIdx, $iBold, $iSuper, $iUnderline ) =
            unpack( "v5c", $sWk );
          $sFntName =
            $oBook->{FmtClass}
            ->TextFmt( substr( $sWk, 15, unpack( "c", substr( $sWk, 14, 1 ) ) ),
              '_native_' );
          $bBold      = ( $iBold >= 0x2BC ) ? 1 : 0;
          $bItalic    = ( $iAttr & 0x02 )   ? 1 : 0;
          $bStrikeout = ( $iAttr & 0x08 )   ? 1 : 0;
          $bUnderline = ( $iUnderline )     ? 1 : 0;
      }
      else {
          ( $iHeight, $iAttr ) = unpack( "v2", $sWk );
          $iCIdx  = undef;
          $iSuper = 0;
  
          $bBold      = ( $iAttr & 0x01 ) ? 1 : 0;
          $bItalic    = ( $iAttr & 0x02 ) ? 1 : 0;
          $bUnderline = ( $iAttr & 0x04 ) ? 1 : 0;
          $bStrikeout = ( $iAttr & 0x08 ) ? 1 : 0;
  
          $sFntName = substr( $sWk, 5, unpack( "c", substr( $sWk, 4, 1 ) ) );
      }
      push @{ $oBook->{Font} }, Spreadsheet::ParseExcel::Font->new(
          Height         => $iHeight / 20.0,
          Attr           => $iAttr,
          Color          => $iCIdx,
          Super          => $iSuper,
          UnderlineStyle => $iUnderline,
          Name           => $sFntName,
  
          Bold      => $bBold,
          Italic    => $bItalic,
          Underline => $bUnderline,
          Strikeout => $bStrikeout,
      );
  
      #Skip Font[4]
      push @{ $oBook->{Font} }, {} if ( scalar( @{ $oBook->{Font} } ) == 4 );
  
  }
  
  #------------------------------------------------------------------------------
  # _subBoundSheet (for Spreadsheet::ParseExcel): DK: P307
  #------------------------------------------------------------------------------
  sub _subBoundSheet {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iPos, $iGr, $iKind ) = unpack( "Lc2", $sWk );
      $iKind &= 0x0F;
      return if ( ( $iKind != 0x00 ) && ( $iKind != 0x01 ) );
  
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          my ( $iSize, $iUni ) = unpack( "cc", substr( $sWk, 6, 2 ) );
          my $sWsName = substr( $sWk, 8 );
          if ( $iUni & 0x01 ) {
              _SwapForUnicode( \$sWsName );
              $sWsName = $oBook->{FmtClass}->TextFmt( $sWsName, 'ucs2' );
          }
          $oBook->{Worksheet}[ $oBook->{SheetCount} ] =
            Spreadsheet::ParseExcel::Worksheet->new(
              Name     => $sWsName,
              Kind     => $iKind,
              _Pos     => $iPos,
              _Book    => $oBook,
              _SheetNo => $oBook->{SheetCount},
            );
      }
      else {
          $oBook->{Worksheet}[ $oBook->{SheetCount} ] =
            Spreadsheet::ParseExcel::Worksheet->new(
              Name =>
                $oBook->{FmtClass}->TextFmt( substr( $sWk, 7 ), '_native_' ),
              Kind     => $iKind,
              _Pos     => $iPos,
              _Book    => $oBook,
              _SheetNo => $oBook->{SheetCount},
            );
      }
      $oBook->{SheetCount}++;
  }
  
  #------------------------------------------------------------------------------
  # _subHeader (for Spreadsheet::ParseExcel) DK: P340
  #------------------------------------------------------------------------------
  sub _subHeader {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
      my $sW;
  
      if ( !defined $sWk ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Header} = undef;
          return;
      }
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          $sW = _convBIFF8String( $oBook, $sWk );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Header} =
            ( $sW eq "\x00" ) ? undef : $sW;
      }
  
      #Before BIFF8
      else {
          my ( $iLen ) = unpack( "c", $sWk );
          $sW =
            $oBook->{FmtClass}->TextFmt( substr( $sWk, 1, $iLen ), '_native_' );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Header} =
            ( $sW eq "\x00\x00\x00" ) ? undef : $sW;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subFooter (for Spreadsheet::ParseExcel) DK: P335
  #------------------------------------------------------------------------------
  sub _subFooter {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
      my $sW;
  
      if ( !defined $sWk ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Footer} = undef;
          return;
      }
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          $sW = _convBIFF8String( $oBook, $sWk );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Footer} =
            ( $sW eq "\x00" ) ? undef : $sW;
      }
  
      #Before BIFF8
      else {
          my ( $iLen ) = unpack( "c", $sWk );
          $sW =
            $oBook->{FmtClass}->TextFmt( substr( $sWk, 1, $iLen ), '_native_' );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Footer} =
            ( $sW eq "\x00\x00\x00" ) ? undef : $sW;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subHPageBreak (for Spreadsheet::ParseExcel) DK: P341
  #------------------------------------------------------------------------------
  sub _subHPageBreak {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my @aBreak;
      my $iCnt = unpack( "v", $sWk );
  
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iRow, $iColB, $iColE ) =
                unpack( 'v3', substr( $sWk, 2 + $i * 6, 6 ) );
  
              #            push @aBreak, [$iRow, $iColB, $iColE];
              push @aBreak, $iRow;
          }
      }
  
      #Before BIFF8
      else {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iRow ) = unpack( 'v', substr( $sWk, 2 + $i * 2, 2 ) );
              push @aBreak, $iRow;
  
              #            push @aBreak, [$iRow, 0, 255];
          }
      }
      @aBreak = sort { $a <=> $b } @aBreak;
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{HPageBreak} = \@aBreak;
  }
  
  #------------------------------------------------------------------------------
  # _subVPageBreak (for Spreadsheet::ParseExcel) DK: P447
  #------------------------------------------------------------------------------
  sub _subVPageBreak {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my @aBreak;
      my $iCnt = unpack( "v", $sWk );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iCol, $iRowB, $iRowE ) =
                unpack( 'v3', substr( $sWk, 2 + $i * 6, 6 ) );
              push @aBreak, $iCol;
  
              #            push @aBreak, [$iCol, $iRowB, $iRowE];
          }
      }
  
      #Before BIFF8
      else {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iCol ) = unpack( 'v', substr( $sWk, 2 + $i * 2, 2 ) );
              push @aBreak, $iCol;
  
              #            push @aBreak, [$iCol, 0, 65535];
          }
      }
      @aBreak = sort { $a <=> $b } @aBreak;
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{VPageBreak} = \@aBreak;
  }
  
  #------------------------------------------------------------------------------
  # _subMargin (for Spreadsheet::ParseExcel) DK: P306, 345, 400, 440
  #------------------------------------------------------------------------------
  sub _subMargin {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      # The "Mergin" options are a workaround for a backward compatible typo.
  
      my $dWk = _convDval( substr( $sWk, 0, 8 ) );
      if ( $bOp == 0x26 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{LeftMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{LeftMargin} = $dWk;
      }
      elsif ( $bOp == 0x27 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{RightMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{RightMargin} = $dWk;
      }
      elsif ( $bOp == 0x28 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{TopMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{TopMargin} = $dWk;
      }
      elsif ( $bOp == 0x29 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{BottomMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{BottomMargin} = $dWk;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subHcenter (for Spreadsheet::ParseExcel) DK: P340
  #------------------------------------------------------------------------------
  sub _subHcenter {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{HCenter} = $iWk;
  
  }
  
  #------------------------------------------------------------------------------
  # _subVcenter (for Spreadsheet::ParseExcel) DK: P447
  #------------------------------------------------------------------------------
  sub _subVcenter {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{VCenter} = $iWk;
  }
  
  #------------------------------------------------------------------------------
  # _subPrintGridlines (for Spreadsheet::ParseExcel) DK: P397
  #------------------------------------------------------------------------------
  sub _subPrintGridlines {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{PrintGrid} = $iWk;
  
  }
  
  #------------------------------------------------------------------------------
  # _subPrintHeaders (for Spreadsheet::ParseExcel) DK: P397
  #------------------------------------------------------------------------------
  sub _subPrintHeaders {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{PrintHeaders} = $iWk;
  }
  
  #------------------------------------------------------------------------------
  # _subSETUP (for Spreadsheet::ParseExcel) DK: P409
  #------------------------------------------------------------------------------
  sub _subSETUP {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      # Workaround for some apps and older Excels that don't write a
      # complete SETUP record.
      return undef if $bLen != 34;
  
      my $oWkS = $oBook->{Worksheet}[ $oBook->{_CurSheet} ];
      my $iGrBit;
  
      (
          $oWkS->{PaperSize}, $oWkS->{Scale},     $oWkS->{PageStart},
          $oWkS->{FitWidth},  $oWkS->{FitHeight}, $iGrBit,
          $oWkS->{Res},       $oWkS->{VRes},
      ) = unpack( 'v8', $sWk );
  
      $oWkS->{HeaderMargin} = _convDval( substr( $sWk, 16, 8 ) );
      $oWkS->{FooterMargin} = _convDval( substr( $sWk, 24, 8 ) );
      $oWkS->{Copis} = unpack( 'v2', substr( $sWk, 32, 2 ) );
      $oWkS->{LeftToRight} = ( ( $iGrBit & 0x01 ) ? 1 : 0 );
      $oWkS->{Landscape}   = ( ( $iGrBit & 0x02 ) ? 1 : 0 );
      $oWkS->{NoPls}       = ( ( $iGrBit & 0x04 ) ? 1 : 0 );
      $oWkS->{NoColor}     = ( ( $iGrBit & 0x08 ) ? 1 : 0 );
      $oWkS->{Draft}       = ( ( $iGrBit & 0x10 ) ? 1 : 0 );
      $oWkS->{Notes}       = ( ( $iGrBit & 0x20 ) ? 1 : 0 );
      $oWkS->{NoOrient}    = ( ( $iGrBit & 0x40 ) ? 1 : 0 );
      $oWkS->{UsePage}     = ( ( $iGrBit & 0x80 ) ? 1 : 0 );
  
      # The NoPls flag indicates that the values have not been taken from an
      # actual printer and thus may not be accurate.
  
      # Set default scale if NoPls otherwise it may be an invalid value of 0XFF.
      $oWkS->{Scale} = 100 if $oWkS->{NoPls};
  
      # Workaround for a backward compatible typo.
      $oWkS->{HeaderMergin} = $oWkS->{HeaderMargin};
      $oWkS->{FooterMergin} = $oWkS->{FooterMargin};
  
  }
  
  #------------------------------------------------------------------------------
  # _subName (for Spreadsheet::ParseExcel) DK: P350
  #------------------------------------------------------------------------------
  sub _subName {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my (
          $iGrBit, $cKey,    $cCh,    $iCce,   $ixAls,
          $iTab,   $cchCust, $cchDsc, $cchHep, $cchStatus
      ) = unpack( 'vc2v3c4', $sWk );
  
      #Builtin Name + Length == 1
      if ( ( $iGrBit & 0x20 ) && ( $cCh == 1 ) ) {
  
          #BIFF8
          if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
              my $iName  = unpack( 'n', substr( $sWk, 14 ) );
              my $iSheet = unpack( 'v', substr( $sWk, 8 ) ) - 1;
  
              # Workaround for mal-formed Excel workbooks where Print_Title is
              # set as Global (i.e. itab = 0). Note, this will have to be
              # treated differently when we get around to handling global names.
              return undef if $iSheet == -1;
  
              if ( $iName == 6 ) {    #PrintArea
                  my ( $iSheetW, $raArea ) = _ParseNameArea( substr( $sWk, 16 ) );
                  $oBook->{PrintArea}[$iSheet] = $raArea;
              }
              elsif ( $iName == 7 ) {    #Title
                  my ( $iSheetW, $raArea ) = _ParseNameArea( substr( $sWk, 16 ) );
                  my @aTtlR = ();
                  my @aTtlC = ();
                  foreach my $raI ( @$raArea ) {
                      if ( $raI->[3] == 0xFF ) {    #Row Title
                          push @aTtlR, [ $raI->[0], $raI->[2] ];
                      }
                      else {                        #Col Title
                          push @aTtlC, [ $raI->[1], $raI->[3] ];
                      }
                  }
                  $oBook->{PrintTitle}[$iSheet] =
                    { Row => \@aTtlR, Column => \@aTtlC };
              }
          }
          else {
              my $iName = unpack( 'c', substr( $sWk, 14 ) );
              if ( $iName == 6 ) {                  #PrintArea
                  my ( $iSheet, $raArea ) =
                    _ParseNameArea95( substr( $sWk, 15 ) );
                  $oBook->{PrintArea}[$iSheet] = $raArea;
              }
              elsif ( $iName == 7 ) {               #Title
                  my ( $iSheet, $raArea ) =
                    _ParseNameArea95( substr( $sWk, 15 ) );
                  my @aTtlR = ();
                  my @aTtlC = ();
                  foreach my $raI ( @$raArea ) {
                      if ( $raI->[3] == 0xFF ) {    #Row Title
                          push @aTtlR, [ $raI->[0], $raI->[2] ];
                      }
                      else {                        #Col Title
                          push @aTtlC, [ $raI->[1], $raI->[3] ];
                      }
                  }
                  $oBook->{PrintTitle}[$iSheet] =
                    { Row => \@aTtlR, Column => \@aTtlC };
              }
          }
      }
  }
  
  #------------------------------------------------------------------------------
  # ParseNameArea (for Spreadsheet::ParseExcel) DK: 494 (ptgAread3d)
  #------------------------------------------------------------------------------
  sub _ParseNameArea {
      my ( $sObj ) = @_;
      my ( $iOp );
      my @aRes = ();
      $iOp = unpack( 'C', $sObj );
      my $iSheet;
      if ( $iOp == 0x3b ) {
          my ( $iWkS, $iRs, $iRe, $iCs, $iCe ) =
            unpack( 'v5', substr( $sObj, 1 ) );
          $iSheet = $iWkS;
          push @aRes, [ $iRs, $iCs, $iRe, $iCe ];
      }
      elsif ( $iOp == 0x29 ) {
          my $iLen = unpack( 'v', substr( $sObj, 1, 2 ) );
          my $iSt = 0;
          while ( $iSt < $iLen ) {
              my ( $iOpW, $iWkS, $iRs, $iRe, $iCs, $iCe ) =
                unpack( 'cv5', substr( $sObj, $iSt + 3, 11 ) );
  
              if ( $iOpW == 0x3b ) {
                  $iSheet = $iWkS;
                  push @aRes, [ $iRs, $iCs, $iRe, $iCe ];
              }
  
              if ( $iSt == 0 ) {
                  $iSt += 11;
              }
              else {
                  $iSt += 12;    #Skip 1 byte;
              }
          }
      }
      return ( $iSheet, \@aRes );
  }
  
  #------------------------------------------------------------------------------
  # ParseNameArea95 (for Spreadsheet::ParseExcel) DK: 494 (ptgAread3d)
  #------------------------------------------------------------------------------
  sub _ParseNameArea95 {
      my ( $sObj ) = @_;
      my ( $iOp );
      my @aRes = ();
      $iOp = unpack( 'C', $sObj );
      my $iSheet;
      if ( $iOp == 0x3b ) {
          $iSheet = unpack( 'v', substr( $sObj, 11, 2 ) );
          my ( $iRs, $iRe, $iCs, $iCe ) =
            unpack( 'v2C2', substr( $sObj, 15, 6 ) );
          push @aRes, [ $iRs, $iCs, $iRe, $iCe ];
      }
      elsif ( $iOp == 0x29 ) {
          my $iLen = unpack( 'v', substr( $sObj, 1, 2 ) );
          my $iSt = 0;
          while ( $iSt < $iLen ) {
              my $iOpW = unpack( 'c', substr( $sObj, $iSt + 3, 6 ) );
              $iSheet = unpack( 'v', substr( $sObj, $iSt + 14, 2 ) );
              my ( $iRs, $iRe, $iCs, $iCe ) =
                unpack( 'v2C2', substr( $sObj, $iSt + 18, 6 ) );
              push @aRes, [ $iRs, $iCs, $iRe, $iCe ] if ( $iOpW == 0x3b );
  
              if ( $iSt == 0 ) {
                  $iSt += 21;
              }
              else {
                  $iSt += 22;    #Skip 1 byte;
              }
          }
      }
      return ( $iSheet, \@aRes );
  }
  
  #------------------------------------------------------------------------------
  # _subBOOL (for Spreadsheet::ParseExcel) DK: P452
  #------------------------------------------------------------------------------
  sub _subWSBOOL {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{PageFit} =
        ( ( unpack( 'v', $sWk ) & 0x100 ) ? 1 : 0 );
  }
  
  #------------------------------------------------------------------------------
  # _subMergeArea (for Spreadsheet::ParseExcel) DK: (Not)
  #------------------------------------------------------------------------------
  sub _subMergeArea {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iCnt = unpack( "v", $sWk );
      my $oWkS = $oBook->{Worksheet}[ $oBook->{_CurSheet} ];
      $oWkS->{MergedArea} = [] unless ( defined $oWkS->{MergedArea} );
      for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
          my ( $iRs, $iRe, $iCs, $iCe ) =
            unpack( 'v4', substr( $sWk, $i * 8 + 2, 8 ) );
          for ( my $iR = $iRs ; $iR <= $iRe ; $iR++ ) {
              for ( my $iC = $iCs ; $iC <= $iCe ; $iC++ ) {
                  $oWkS->{Cells}[$iR][$iC]->{Merged} = 1
                    if ( defined $oWkS->{Cells}[$iR][$iC] );
              }
          }
          push @{ $oWkS->{MergedArea} }, [ $iRs, $iCs, $iRe, $iCe ];
      }
  }
  
  #------------------------------------------------------------------------------
  # DecodeBoolErr (for Spreadsheet::ParseExcel) DK: P306
  #------------------------------------------------------------------------------
  sub DecodeBoolErr {
      my ( $iVal, $iFlg ) = @_;
      if ( $iFlg ) {    # ERROR
          if ( $iVal == 0x00 ) {
              return "#NULL!";
          }
          elsif ( $iVal == 0x07 ) {
              return "#DIV/0!";
          }
          elsif ( $iVal == 0x0F ) {
              return "#VALUE!";
          }
          elsif ( $iVal == 0x17 ) {
              return "#REF!";
          }
          elsif ( $iVal == 0x1D ) {
              return "#NAME?";
          }
          elsif ( $iVal == 0x24 ) {
              return "#NUM!";
          }
          elsif ( $iVal == 0x2A ) {
              return "#N/A!";
          }
          else {
              return "#ERR";
          }
      }
      else {
          return ( $iVal ) ? "TRUE" : "FALSE";
      }
  }
  
  ###############################################################################
  #
  # _decode_rk_number()
  #
  # Convert an encoded RK number into a real number. The RK encoding is
  # explained in some detail in the MS docs. It is a way of storing applicable
  # ints and doubles in 32bits (30 data + 2 info bits) in order to save space.
  #
  sub _decode_rk_number {
  
      my $rk_number = shift;
      my $number;
  
      # Check the main RK type.
      if ( $rk_number & 0x02 ) {
  
          # RK Type 2 and 4, a packed integer.
  
          # Shift off the info bits.
          $number = $rk_number >> 2;
  
          # Convert from unsigned to signed if required.
          $number -= 0x40000000 if $number & 0x20000000;
      }
      else {
  
          # RK Type 1 and 3, a truncated IEEE Double.
  
          # Pack the RK number into the high 30 bits of an IEEE double.
          $number = pack "VV", 0x0000, $rk_number & 0xFFFFFFFC;
  
          # Reverse the packed IEEE double on big-endian machines.
          $number = reverse $number if $BIGENDIAN;
  
          # Unpack the number.
          $number = unpack "d", $number;
      }
  
      # RK Types 3 and 4 were multiplied by 100 prior to encoding.
      $number /= 100 if $rk_number & 0x01;
  
      return $number;
  }
  
  ###############################################################################
  #
  # _subStrWk()
  #
  # Extract the workbook strings from the SST (Shared String Table) record and
  # any following CONTINUE records.
  #
  # The workbook strings are initially contained in the SST block but may also
  # occupy one or more CONTINUE blocks. Reading the CONTINUE blocks is made a
  # little tricky by the fact that they can contain an additional initial byte
  # if a string is continued from a previous block.
  #
  # Parsing is further complicated by the fact that the continued section of the
  # string may have a different encoding (ASCII or UTF-8) from the previous
  # section. Excel does this to save space.
  #
  sub _subStrWk {
  
      my ( $self, $biff_data, $is_continue ) = @_;
  
      if ( $is_continue ) {
  
          # We are reading a CONTINUE record.
  
          if ( $self->{_buffer} eq '' ) {
  
              # A CONTINUE block with no previous SST.
              $self->{_buffer} .= $biff_data;
          }
          elsif ( !defined $self->{_string_continued} ) {
  
              # The CONTINUE block starts with a new (non-continued) string.
  
              # Strip the Grbit byte and store the string data.
              $self->{_buffer} .= substr $biff_data, 1;
          }
          else {
  
              # A CONTINUE block that starts with a continued string.
  
              # The first byte (Grbit) of the CONTINUE record indicates if (0)
              # the continued string section is single bytes or (1) double bytes.
              my $grbit = ord $biff_data;
  
              my ( $str_position, $str_length ) = @{ $self->{_previous_info} };
              my $buff_length = length $self->{_buffer};
  
              if ( $buff_length >= ( $str_position + $str_length ) ) {
  
                  # Not in a string.
                  $self->{_buffer} .= $biff_data;
              }
              elsif ( ( $self->{_string_continued} & 0x01 ) == ( $grbit & 0x01 ) )
              {
  
                  # Same encoding as the previous block of the string.
                  $self->{_buffer} .= substr( $biff_data, 1 );
              }
              else {
  
                  # Different encoding to the previous block of the string.
                  if ( $grbit & 0x01 ) {
  
                      # Current block is UTF-16, previous was ASCII.
                      my ( undef, $cch ) = unpack 'vc', $self->{_buffer};
                      substr( $self->{_buffer}, 2, 1 ) = pack( 'C', $cch | 0x01 );
  
                      # Convert the previous ASCII, single character, portion of
                      # the string into a double character UTF-16 string by
                      # inserting zero bytes.
                      for (
                          my $i = ( $buff_length - $str_position ) ;
                          $i >= 1 ;
                          $i--
                        )
                      {
                          substr( $self->{_buffer}, $str_position + $i, 0 ) =
                            "\x00";
                      }
  
                  }
                  else {
  
                      # Current block is ASCII, previous was UTF-16.
  
                      # Convert the current ASCII, single character, portion of
                      # the string into a double character UTF-16 string by
                      # inserting null bytes.
                      my $change_length =
                        ( $str_position + $str_length ) - $buff_length;
  
                      # Length of the current CONTINUE record data.
                      my $biff_length = length $biff_data;
  
                      # Restrict the portion to be changed to the current block
                      # if the string extends over more than one block.
                      if ( $change_length > ( $biff_length - 1 ) * 2 ) {
                          $change_length = ( $biff_length - 1 ) * 2;
                      }
  
                      # Insert the null bytes.
                      for ( my $i = ( $change_length / 2 ) ; $i >= 1 ; $i-- ) {
                          substr( $biff_data, $i + 1, 0 ) = "\x00";
                      }
  
                  }
  
                  # Strip the Grbit byte and store the string data.
                  $self->{_buffer} .= substr $biff_data, 1;
              }
          }
      }
      else {
  
          # Not a CONTINUE block therefore an SST block.
          $self->{_buffer} .= $biff_data;
      }
  
      # Reset the state variables.
      $self->{_string_continued} = undef;
      $self->{_previous_info}    = undef;
  
      # Extract out any full strings from the current buffer leaving behind a
      # partial string that is continued into the next block, or an empty
      # buffer is no string is continued.
      while ( length $self->{_buffer} >= 4 ) {
          my ( $str_info, $length, $str_position, $str_length ) =
            _convBIFF8String( $self, $self->{_buffer}, 1 );
  
          if ( defined $str_info->[0] ) {
              push @{ $self->{PkgStr} },
                {
                  Text    => $str_info->[0],
                  Unicode => $str_info->[1],
                  Rich    => $str_info->[2],
                  Ext     => $str_info->[3],
                };
              $self->{_buffer} = substr( $self->{_buffer}, $length );
          }
          else {
              $self->{_string_continued} = $str_info->[1];
              $self->{_previous_info} = [ $str_position, $str_length ];
              last;
          }
      }
  }
  
  #------------------------------------------------------------------------------
  # _SwapForUnicode (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _SwapForUnicode {
      my ( $sObj ) = @_;
  
      #    for(my $i = 0; $i<length($$sObj); $i+=2){
      for ( my $i = 0 ; $i < ( int( length( $$sObj ) / 2 ) * 2 ) ; $i += 2 ) {
          my $sIt = substr( $$sObj, $i, 1 );
          substr( $$sObj, $i, 1 ) = substr( $$sObj, $i + 1, 1 );
          substr( $$sObj, $i + 1, 1 ) = $sIt;
      }
  }
  
  #------------------------------------------------------------------------------
  # _NewCell (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _NewCell {
      my ( $oBook, $iR, $iC, %rhKey ) = @_;
      my ( $sWk, $iLen );
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $FmtClass = $oBook->{FmtClass};
      $rhKey{Type} =
        $FmtClass->ChkType( $rhKey{Numeric}, $rhKey{Format}{FmtIdx} );
      my $FmtStr = $oBook->{FormatStr}{ $rhKey{Format}{FmtIdx} };
  
      # Set "Date" type if required for numbers in a MulRK BIFF block.
      if ( defined $FmtStr && $rhKey{Type} eq "Numeric" ) {
  
          # Match a range of possible date formats. Note: this isn't important
          # except for reporting. The number will still be converted to a date
          # by ExcelFmt() even if 'Type' isn't set to 'Date'.
          if ( $FmtStr =~ m{^[dmy][-\\/dmy]*$}i ) {
              $rhKey{Type} = "Date";
          }
      }
  
      my $oCell = Spreadsheet::ParseExcel::Cell->new(
          Val      => $rhKey{Val},
          FormatNo => $rhKey{FormatNo},
          Format   => $rhKey{Format},
          Code     => $rhKey{Code},
          Type     => $rhKey{Type},
      );
      $oCell->{_Kind} = $rhKey{Kind};
      $oCell->{_Value} = $FmtClass->ValFmt( $oCell, $oBook );
      if ( $rhKey{Rich} ) {
          my @aRich = ();
          my $sRich = $rhKey{Rich};
          for ( my $iWk = 0 ; $iWk < length( $sRich ) ; $iWk += 4 ) {
              my ( $iPos, $iFnt ) = unpack( 'v2', substr( $sRich, $iWk ) );
              push @aRich, [ $iPos, $oBook->{Font}[$iFnt] ];
          }
          $oCell->{Rich} = \@aRich;
      }
  
      if ( defined $_CellHandler ) {
          if ( defined $_Object ) {
              no strict;
              ref( $_CellHandler ) eq "CODE"
                ? $_CellHandler->(
                  $_Object, $oBook, $oBook->{_CurSheet}, $iR, $iC, $oCell
                )
                : $_CellHandler->callback( $_Object, $oBook, $oBook->{_CurSheet},
                  $iR, $iC, $oCell );
          }
          else {
              $_CellHandler->( $oBook, $oBook->{_CurSheet}, $iR, $iC, $oCell );
          }
      }
      unless ( $_NotSetCell ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Cells}[$iR][$iC] = $oCell;
      }
      return $oCell;
  }
  
  #------------------------------------------------------------------------------
  # ColorIdxToRGB (for Spreadsheet::ParseExcel)
  #
  # TODO JMN Make this a Workbook method and re-document.
  #
  #------------------------------------------------------------------------------
  sub ColorIdxToRGB {
      my ( $sPkg, $iIdx ) = @_;
      return ( ( defined $aColor[$iIdx] ) ? $aColor[$iIdx] : $aColor[0] );
  }
  
  
  ###############################################################################
  #
  # error().
  #
  # Return an error string for a failed parse().
  #
  sub error {
  
      my $self = shift;
  
      my $parse_error = $self->{_error_status};
  
      if ( exists $error_strings{$parse_error} ) {
          return $error_strings{$parse_error};
      }
      else {
          return 'Unknown parse error';
      }
  }
  
  
  ###############################################################################
  #
  # error_code().
  #
  # Return an error code for a failed parse().
  #
  sub error_code {
  
      my $self = shift;
  
      return $self->{_error_status};
  }
  
  
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *Parse = *parse;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Spreadsheet::ParseExcel - Read information from an Excel file.
  
  =head1 SYNOPSIS
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die $parser->error(), ".\n";
      }
  
      for my $worksheet ( $workbook->worksheets() ) {
  
          my ( $row_min, $row_max ) = $worksheet->row_range();
          my ( $col_min, $col_max ) = $worksheet->col_range();
  
          for my $row ( $row_min .. $row_max ) {
              for my $col ( $col_min .. $col_max ) {
  
                  my $cell = $worksheet->get_cell( $row, $col );
                  next unless $cell;
  
                  print "Row, Col    = ($row, $col)\n";
                  print "Value       = ", $cell->value(),       "\n";
                  print "Unformatted = ", $cell->unformatted(), "\n";
                  print "\n";
              }
          }
      }
  
  
  =head1 DESCRIPTION
  
  The Spreadsheet::ParseExcel module can be used to read information from Excel 95-2003 binary files.
  
  The module cannot read files in the Excel 2007 Open XML XLSX format. See the L<Spreadsheet::XLSX> module instead.
  
  =head1 Parser
  
  =head2 new()
  
  The C<new()> method is used to create a new C<Spreadsheet::ParseExcel> parser object.
  
      my $parser = Spreadsheet::ParseExcel->new();
  
  It it possible to pass a password to decrypt an encrypted file:
  
      $parser = Spreadsheet::ParseExcel->new( Password => 'secret' );
  
  Only the default Excel encryption scheme is currently supported. See L</Decryption>.
  
  As an advanced feature it is also possible to pass a call-back handler to the parser to control the parsing of the spreadsheet.
  
      $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1,
      );
  
  The call-back can be used to ignore certain cells or to reduce memory usage. See the section L<Reducing the memory usage of Spreadsheet::ParseExcel> for more information.
  
  
  =head2 parse($filename, $formatter)
  
  The Parser C<parse()> method returns a L</Workbook> object.
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
  If an error occurs C<parse()> returns C<undef>. In general, programs should contain a test for failed parsing as follows:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die $parser->error(), ".\n";
      }
  
  The C<$filename> parameter is generally the file to be parsed. However, it can also be a filehandle or a scalar reference.
  
  The optional C<$formatter> parameter can be an reference to a L</Formatter Class> to format the value of cells. This is useful for parsing workbooks with Unicode or Asian characters:
  
      my $parser    = Spreadsheet::ParseExcel->new();
      my $formatter = Spreadsheet::ParseExcel::FmtJapan->new();
      my $workbook  = $parser->parse( 'Book1.xls', $formatter );
  
  The L<Spreadsheet::ParseExcel::FmtJapan> formatter also supports Unicode. If you encounter any encoding problems with the default formatter try that instead.
  
  
  =head2 error()
  
  The Parser C<error()> method returns an error string if a C<parse()> fails:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die $parser->error(), ".\n";
      }
  
  If you wish to generate you own error string you can use the C<error_code()> method instead (see below). The C<error()> and C<error_code()> values are as follows:
  
      error()                         error_code()
      =======                         ============
      ''                              0
      'File not found'                1
      'No Excel data found in file'   2
      'File is encrypted'             3
  
  
  The C<error_code()> method is explained below.
  
  Spreadsheet::ParseExcel will try to decrypt an encrypted Excel file using the default password or a user supplied password passed to C<new()>, see above. If these fail the module will return the C<'File is encrypted'> error. Only the default Excel encryption scheme is currently supported, see L</Decryption>.
  
  
  =head2 error_code()
  
  The Parser C<error_code()> method returns an error code if a C<parse()> fails:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die "Got error code ", $parser->error_code, ".\n";
      }
  
  This can be useful if you wish to employ you own error strings or error handling methods.
  
  
  =head1 Workbook
  
  A C<Spreadsheet::ParseExcel::Workbook> is created via the C<Spreadsheet::ParseExcel> C<parse()> method:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
  The main methods of the Workbook class are:
  
      $workbook->worksheets()
      $workbook->worksheet()
      $workbook->worksheet_count()
      $workbook->get_filename()
  
  These more commonly used methods of the Workbook class are outlined below. The other, less commonly used, methods are documented in L<Spreadsheet::ParseExcel::Worksheet>.
  
  
  =head2 worksheets()
  
  Returns an array of L</Worksheet> objects. This was most commonly used to iterate over the worksheets in a workbook:
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
  
  =head2 worksheet()
  
  The C<worksheet()> method returns a single C<Worksheet> object using either its name or index:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  Returns C<undef> if the sheet name or index doesn't exist.
  
  
  =head2 worksheet_count()
  
  The C<worksheet_count()> method returns the number of Worksheet objects in the Workbook.
  
      my $worksheet_count = $workbook->worksheet_count();
  
  
  =head2 get_filename()
  
  The C<get_filename()> method returns the name of the Excel file of C<undef> if the data was read from a filehandle rather than a file.
  
      my $filename = $workbook->get_filename();
  
  
  =head2 Other Workbook Methods
  
  For full documentation of the methods available via a Workbook object see L<Spreadsheet::ParseExcel::Workbook>.
  
  =head1 Worksheet
  
  The C<Spreadsheet::ParseExcel::Worksheet> class encapsulates the properties of an Excel worksheet.
  
  A Worksheet object is obtained via the L</worksheets()> or L</worksheet()> methods.
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
      # Or:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  The most commonly used methods of the Worksheet class are:
  
      $worksheet->get_cell()
      $worksheet->row_range()
      $worksheet->col_range()
      $worksheet->get_name()
  
  The Spreadsheet::ParseExcel::Worksheet class exposes a lot of methods but in general very few are required unless you are writing an advanced filter.
  
  The most commonly used methods are detailed below. The others are documented in L<Spreadsheet::ParseExcel::Worksheet>.
  
  =head2 get_cell($row, $col)
  
  Return the L</Cell> object at row C<$row> and column C<$col> if it is defined. Otherwise returns undef.
  
      my $cell = $worksheet->get_cell($row, $col);
  
  
  =head2 row_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum defined rows in the worksheet. If there is no row defined C<$max> is smaller than C<$min>.
  
      my ( $row_min, $row_max ) = $worksheet->row_range();
  
  
  =head2 col_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum of defined columns in the worksheet. If there is no column defined C<$max> is smaller than C<$min>.
  
      my ( $col_min, $col_max ) = $worksheet->col_range();
  
  
  =head2 get_name()
  
  The C<get_name()> method returns the name of the worksheet, such as 'Sheet1'.
  
      my $name = $worksheet->get_name();
  
  =head2 Other Worksheet Methods
  
  For other, less commonly used, Worksheet methods see L<Spreadsheet::ParseExcel::Worksheet>.
  
  =head1 Cell
  
  The C<Spreadsheet::ParseExcel::Cell> class has the following main methods.
  
      $cell->value()
      $cell->unformatted()
  
  =head2 value()
  
  The C<value()> method returns the formatted value of the cell.
  
      my $value = $cell->value();
  
  Formatted in this sense refers to the numeric format of the cell value. For example a number such as 40177 might be formatted as 40,117, 40117.000 or even as the date 2009/12/30.
  
  If the cell doesn't contain a numeric format then the formatted and unformatted cell values are the same, see the C<unformatted()> method below.
  
  For a defined C<$cell> the C<value()> method will always return a value.
  
  In the case of a cell with formatting but no numeric or string contents the method will return the empty string C<''>.
  
  
  =head2 unformatted()
  
  The C<unformatted()> method returns the unformatted value of the cell.
  
      my $unformatted = $cell->unformatted();
  
  Returns the cell value without a numeric format. See the C<value()> method above.
  
  =head2 Other Cell Methods
  
  For other, less commonly used, Worksheet methods see L<Spreadsheet::ParseExcel::Cell>.
  
  
  =head1 Format
  
  The C<Spreadsheet::ParseExcel::Format> class has the following properties:
  
  =head2 Format properties
  
      $format->{Font}
      $format->{AlignH}
      $format->{AlignV}
      $format->{Indent}
      $format->{Wrap}
      $format->{Shrink}
      $format->{Rotate}
      $format->{JustLast}
      $format->{ReadDir}
      $format->{BdrStyle}
      $format->{BdrColor}
      $format->{BdrDiag}
      $format->{Fill}
      $format->{Lock}
      $format->{Hidden}
      $format->{Style}
  
  These properties are generally only of interest to advanced users. Casual users can skip this section.
  
  =head2 $format->{Font}
  
  Returns the L</Font> object for the Format.
  
  =head2 $format->{AlignH}
  
  Returns the horizontal alignment of the format where the value has the following meaning:
  
      0 => No alignment
      1 => Left
      2 => Center
      3 => Right
      4 => Fill
      5 => Justify
      6 => Center across
      7 => Distributed/Equal spaced
  
  =head2 $format->{AlignV}
  
  Returns the vertical alignment of the format where the value has the following meaning:
  
      0 => Top
      1 => Center
      2 => Bottom
      3 => Justify
      4 => Distributed/Equal spaced
  
  =head2 $format->{Indent}
  
  Returns the indent level of the C<Left> horizontal alignment.
  
  =head2 $format->{Wrap}
  
  Returns true if textwrap is on.
  
  =head2 $format->{Shrink}
  
  Returns true if "Shrink to fit" is set for the format.
  
  =head2 $format->{Rotate}
  
  Returns the text rotation. In Excel97+, it returns the angle in degrees of the text rotation.
  
  In Excel95 or earlier it returns a value as follows:
  
      0 => No rotation
      1 => Top down
      2 => 90 degrees anti-clockwise,
      3 => 90 clockwise
  
  =head2 $format->{JustLast}
  
  Return true if the "justify last" property is set for the format.
  
  =head2 $format->{ReadDir}
  
  Returns the direction that the text is read from.
  
  =head2 $format->{BdrStyle}
  
  Returns an array ref of border styles as follows:
  
      [ $left, $right, $top, $bottom ]
  
  =head2 $format->{BdrColor}
  
  Returns an array ref of border color indexes as follows:
  
      [ $left, $right, $top, $bottom ]
  
  =head2 $format->{BdrDiag}
  
  Returns an array ref of diagonal border kind, style and color index as follows:
  
      [$kind, $style, $color ]
  
  Where kind is:
  
      0 => None
      1 => Right-Down
      2 => Right-Up
      3 => Both
  
  =head2 $format->{Fill}
  
  Returns an array ref of fill pattern and color indexes as follows:
  
      [ $pattern, $front_color, $back_color ]
  
  =head2 $format->{Lock}
  
  Returns true if the cell is locked.
  
  =head2 $format->{Hidden}
  
  Returns true if the cell is Hidden.
  
  =head2 $format->{Style}
  
  Returns true if the format is a Style format.
  
  
  
  
  =head1 Font
  
  I<Spreadsheet::ParseExcel::Font>
  
  Format class has these properties:
  
  =head1 Font Properties
  
      $font->{Name}
      $font->{Bold}
      $font->{Italic}
      $font->{Height}
      $font->{Underline}
      $font->{UnderlineStyle}
      $font->{Color}
      $font->{Strikeout}
      $font->{Super}
  
  =head2 $font->{Name}
  
  Returns the name of the font, for example 'Arial'.
  
  =head2 $font->{Bold}
  
  Returns true if the font is bold.
  
  =head2 $font->{Italic}
  
  Returns true if the font is italic.
  
  =head2 $font->{Height}
  
  Returns the size (height) of the font.
  
  =head2 $font->{Underline}
  
  Returns true if the font in underlined.
  
  =head2 $font->{UnderlineStyle}
  
  Returns the style of an underlined font where the value has the following meaning:
  
       0 => None
       1 => Single
       2 => Double
      33 => Single accounting
      34 => Double accounting
  
  =head2 $font->{Color}
  
  Returns the color index for the font. The index can be converted to a RGB string using the C<ColorIdxToRGB()> Parser method.
  
  =head2 $font->{Strikeout}
  
  Returns true if the font has the strikeout property set.
  
  =head2 $font->{Super}
  
  Returns one of the following values if the superscript or subscript property of the font is set:
  
      0 => None
      1 => Superscript
      2 => Subscript
  
  =head1 Formatter Class
  
  Formatters can be passed to the C<parse()> method to deal with Unicode or Asian formatting.
  
  Spreadsheet::ParseExcel includes 2 formatter classes. C<FmtDefault> and C<FmtJapanese>. It is also possible to create a user defined formatting class.
  
  The formatter class C<Spreadsheet::ParseExcel::Fmt*> should provide the following functions:
  
  
  =head2 ChkType($self, $is_numeric, $format_index)
  
  Method to check the type of data in the cell. Should return C<Date>, C<Numeric> or C<Text>. It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $is_numeric
  
  If true, the value seems to be number.
  
  =item $format_index
  
  The index number for the cell Format object.
  
  =back
  
  =head2 TextFmt($self, $string_data, $string_encoding)
  
  Converts the string data in the cell into the correct encoding.  It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $string_data
  
  The original string/text data.
  
  =item $string_encoding
  
  The character encoding of original string/text.
  
  =back
  
  =head2 ValFmt($self, $cell, $workbook)
  
  Convert the original unformatted cell value into the appropriate formatted value. For instance turn a number into a formatted date.  It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $cell
  
  A scalar reference to the Cell object.
  
  =item $workbook
  
  A scalar reference to the Workbook object.
  
  =back
  
  
  =head2 FmtString($self, $cell, $workbook)
  
  Get the format string for the Cell.  It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $cell
  
  A scalar reference to the Cell object.
  
  =item $workbook
  
  A scalar reference to the Workbook object.
  
  =back
  
  
  =head1 Reducing the memory usage of Spreadsheet::ParseExcel
  
  In some cases a C<Spreadsheet::ParseExcel> application may consume a lot of memory when processing a large Excel file and, as a result, may fail to complete. The following explains why this can occur and how to resolve it.
  
  C<Spreadsheet::ParseExcel> processes an Excel file in two stages. In the first stage it extracts the Excel binary stream from the OLE container file using C<OLE::Storage_Lite>. In the second stage it parses the binary stream to read workbook, worksheet and cell data which it then stores in memory. The majority of the memory usage is required for storing cell data.
  
  The reason for this is that as the Excel file is parsed and each cell is encountered a cell handling function creates a relatively large nested cell object that contains the cell value and all of the data that relates to the cell formatting. For large files (a 10MB Excel file on a 256MB system) this overhead can cause the system to grind to a halt.
  
  However, in a lot of cases when an Excel file is being processed the only information that is required are the cell values. In these cases it is possible to avoid most of the memory overhead by specifying your own cell handling function and by telling Spreadsheet::ParseExcel not to store the parsed cell data. This is achieved by passing a cell handler function to C<new()> when creating the parse object. Here is an example.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1
      );
  
      my $workbook = $parser->parse('file.xls');
  
      sub cell_handler {
  
          my $workbook    = $_[0];
          my $sheet_index = $_[1];
          my $row         = $_[2];
          my $col         = $_[3];
          my $cell        = $_[4];
  
          # Do something useful with the formatted cell value
          print $cell->value(), "\n";
  
      }
  
  
  The user specified cell handler is passed as a code reference to C<new()> along with the parameter C<NotSetCell> which tells Spreadsheet::ParseExcel not to store the parsed cell. Note, you don't have to iterate over the rows and columns, this happens automatically as part of the parsing.
  
  The cell handler is passed 5 arguments. The first, C<$workbook>, is a reference to the C<Spreadsheet::ParseExcel::Workbook> object that represent the parsed workbook. This can be used to access any of the C<Spreadsheet::ParseExcel::Workbook> methods, see L</Workbook>. The second C<$sheet_index> is the zero-based index of the worksheet being parsed. The third and fourth, C<$row> and C<$col>, are the zero-based row and column number of the cell. The fifth, C<$cell>, is a reference to the C<Spreadsheet::ParseExcel::Cell> object. This is used to extract the data from the cell. See L</Cell> for more information.
  
  This technique can be useful if you are writing an Excel to database filter since you can put your DB calls in the cell handler.
  
  If you don't want all of the data in the spreadsheet you can add some control logic to the cell handler. For example we can extend the previous example so that it only prints the first 10 rows of the first two worksheets in the parsed workbook by adding some C<if()> statements to the cell handler:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1
      );
  
      my $workbook = $parser->parse('file.xls');
  
      sub cell_handler {
  
          my $workbook    = $_[0];
          my $sheet_index = $_[1];
          my $row         = $_[2];
          my $col         = $_[3];
          my $cell        = $_[4];
  
          # Skip some worksheets and rows (inefficiently).
          return if $sheet_index >= 3;
          return if $row >= 10;
  
          # Do something with the formatted cell value
          print $cell->value(), "\n";
  
      }
  
  
  However, this still processes the entire workbook. If you wish to save some additional processing time you can abort the parsing after you have read the data that you want, using the workbook C<ParseAbort> method:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1
      );
  
      my $workbook = $parser->parse('file.xls');
  
      sub cell_handler {
  
          my $workbook    = $_[0];
          my $sheet_index = $_[1];
          my $row         = $_[2];
          my $col         = $_[3];
          my $cell        = $_[4];
  
          # Skip some worksheets and rows (more efficiently).
          if ( $sheet_index >= 1 and $row >= 10 ) {
              $workbook->ParseAbort(1);
              return;
          }
  
          # Do something with the formatted cell value
          print $cell->value(), "\n";
  
      }
  
  =head1 Decryption
  
  If a workbook is "protected" then Excel will encrypt the file whether a password is supplied or not. As of version 0.59 Spreadsheet::ParseExcel supports decrypting Excel workbooks using a default or user supplied password. However, only the following encryption scheme is supported:
  
      Office 97/2000 Compatible encryption
  
  The following encryption methods are not supported:
  
      Weak Encryption (XOR)
      RC4, Microsoft Base Cryptographic Provider v1.0
      RC4, Microsoft Base DSS and Diffie-Hellman Cryptographic Provider
      RC4, Microsoft DH SChannel Cryptographic Provider
      RC4, Microsoft Enhanced Cryptographic Provider v1.0
      RC4, Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider
      RC4, Microsoft Enhanced RSA and AES Cryptographic Provider
      RC4, Microsoft RSA SChannel Cryptographic Provider
      RC4, Microsoft Strong Cryptographic Provider
  
  See the following for more information on Excel encryption: L<http://office.microsoft.com/en-us/office-2003-resource-kit/important-aspects-of-password-and-encryption-protection-HA001140311.aspx>.
  
  
  
  =head1 KNOWN PROBLEMS
  
  =over
  
  =item * Issues reported by users: L<http://rt.cpan.org/Public/Dist/Display.html?Name=Spreadsheet-ParseExcel>
  
  =item * This module cannot read the values of formulas from files created with Spreadsheet::WriteExcel unless the user specified the values when creating the file (which is generally not the case). The reason for this is that Spreadsheet::WriteExcel writes the formula but not the formula result since it isn't in a position to calculate arbitrary Excel formulas without access to Excel's formula engine.
  
  =item * If Excel has date fields where the specified format is equal to the system-default for the short-date locale, Excel does not store the format, but defaults to an internal format which is system dependent. In these cases ParseExcel uses the date format 'yyyy-mm-dd'.
  
  =back
  
  
  
  
  =head1 REPORTING A BUG
  
  Bugs can be reported via rt.cpan.org. See the following for instructions on bug reporting for Spreadsheet::ParseExcel
  
  L<http://rt.cpan.org/Public/Dist/Display.html?Name=Spreadsheet-ParseExcel>
  
  
  
  
  =head1 SEE ALSO
  
  =over
  
  =item * xls2csv by Ken Prows L<http://search.cpan.org/~ken/xls2csv-1.06/script/xls2csv>.
  
  =item * xls2csv and xlscat by H.Merijn Brand (these utilities are part of Spreadsheet::Read, see below).
  
  =item * excel2txt by Ken Youens-Clark, L<http://search.cpan.org/~kclark/excel2txt/excel2txt>. This is an excellent example of an Excel filter using Spreadsheet::ParseExcel. It can produce CSV, Tab delimited, Html, XML and Yaml.
  
  =item * XLSperl by Jon Allen L<http://search.cpan.org/~jonallen/XLSperl/bin/XLSperl>. This application allows you to use Perl "one-liners" with Microsoft Excel files.
  
  =item * Spreadsheet::XLSX L<http://search.cpan.org/~dmow/Spreadsheet-XLSX/lib/Spreadsheet/XLSX.pm> by Dmitry Ovsyanko. A module with a similar interface to Spreadsheet::ParseExcel for parsing Excel 2007 XLSX OpenXML files.
  
  =item * Spreadsheet::Read L<http://search.cpan.org/~hmbrand/Spreadsheet-Read/Read.pm> by H.Merijn Brand. A single interface for reading several different spreadsheet formats.
  
  =item * Spreadsheet::WriteExcel L<http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm>. A perl module for creating new Excel files.
  
  =item * Spreadsheet::ParseExcel::SaveParser L<http://search.cpan.org/~jmcnamara/Spreadsheet-ParseExcel/lib/Spreadsheet/ParseExcel/SaveParser.pm>. This is a combination of Spreadsheet::ParseExcel and Spreadsheet::WriteExcel and it allows you to "rewrite" an Excel file. See the following example L<http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm#MODIFYING_AND_REWRITING_EXCEL_FILES>. It is part of the Spreadsheet::ParseExcel distro.
  
  =item * Text::CSV_XS L<http://search.cpan.org/~hmbrand/Text-CSV_XS/CSV_XS.pm> by H.Merijn Brand. A fast and rigorous module for reading and writing CSV data. Don't consider rolling your own CSV handling, use this module instead.
  
  =back
  
  
  
  
  =head1 MAILING LIST
  
  There is a Google group for discussing and asking questions about Spreadsheet::ParseExcel. This is a good place to search to see if your question has been asked before:  L<http://groups-beta.google.com/group/spreadsheet-parseexcel/>
  
  
  
  
  =head1 DONATIONS
  
  If you'd care to donate to the Spreadsheet::ParseExcel project, you can do so via PayPal: L<http://tinyurl.com/7ayes>
  
  
  
  
  =head1 TODO
  
  =over
  
  =item * The current maintenance work is directed towards making the documentation more useful, improving and simplifying the API, and improving the maintainability of the code base. After that new features will be added.
  
  =item * Fix open bugs and documentation for SaveParser.
  
  =item * Add Formula support, Hyperlink support, Named Range support.
  
  =item * Improve Spreadsheet::ParseExcel::SaveParser compatibility with Spreadsheet::WriteExcel.
  
  =item * Improve Unicode and other encoding support. This will probably require dropping support for perls prior to 5.8+.
  
  =back
  
  
  
  =head1 ACKNOWLEDGEMENTS
  
  From Kawai Takanori:
  
  First of all, I would like to acknowledge the following valuable programs and modules:
  XHTML, OLE::Storage and Spreadsheet::WriteExcel.
  
  In no particular order: Yamaji Haruna, Simamoto Takesi, Noguchi Harumi, Ikezawa Kazuhiro, Suwazono Shugo, Hirofumi Morisada, Michael Edwards, Kim Namusk, Slaven Rezic, Grant Stevens, H.Merijn Brand and many many people + Kawai Mikako.
  
  Alexey Mazurin added the decryption facility.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  Because this software is licensed free of charge, there is no warranty for the software, to the extent permitted by applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the software "as is" without warranty of any kind, either expressed or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and performance of the software is with you. Should the software prove defective, you assume the cost of all necessary servicing, repair, or correction.
  
  In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other party who may modify and/or redistribute the software as permitted by the above licence, be liable to you for damages, including any general, special, incidental, or consequential damages arising out of the use or inability to use the software (including but not limited to loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the software to operate with any other software), even if such holder or other party has been advised of the possibility of such damages.
  
  
  
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>
  
  
  
  
  =head1 AUTHOR
  
  Current maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori (Hippo2000) kwitknr@cpan.org
  
  
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved. This is free software. You may distribute under the terms of either the GNU General Public License or the Artistic License.
  
  
  =cut
SPREADSHEET_PARSEEXCEL

$fatpacked{"Spreadsheet/ParseExcel/Cell.pm"} = <<'SPREADSHEET_PARSEEXCEL_CELL';
  package Spreadsheet::ParseExcel::Cell;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Cell - A class for Cell data and formatting.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.59';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
      my ( $package, %properties ) = @_;
      my $self = \%properties;
  
      bless $self, $package;
  }
  
  ###############################################################################
  #
  # value()
  #
  # Returns the formatted value of the cell.
  #
  sub value {
  
      my $self = shift;
  
      return $self->{_Value};
  }
  
  ###############################################################################
  #
  # unformatted()
  #
  # Returns the unformatted value of the cell.
  #
  sub unformatted {
  
      my $self = shift;
  
      return $self->{Val};
  }
  
  ###############################################################################
  #
  # get_format()
  #
  # Returns the Format object for the cell.
  #
  sub get_format {
  
      my $self = shift;
  
      return $self->{Format};
  }
  
  ###############################################################################
  #
  # type()
  #
  # Returns the type of cell such as Text, Numeric or Date.
  #
  sub type {
  
      my $self = shift;
  
      return $self->{Type};
  }
  
  ###############################################################################
  #
  # encoding()
  #
  # Returns the character encoding of the cell.
  #
  sub encoding {
  
      my $self = shift;
  
      if ( !defined $self->{Code} ) {
          return 1;
      }
      elsif ( $self->{Code} eq 'ucs2' ) {
          return 2;
      }
      elsif ( $self->{Code} eq '_native_' ) {
          return 3;
      }
      else {
          return 0;
      }
  
      return $self->{Code};
  }
  
  ###############################################################################
  #
  # is_merged()
  #
  # Returns true if the cell is merged.
  #
  sub is_merged {
  
      my $self = shift;
  
      return $self->{Merged};
  }
  
  ###############################################################################
  #
  # get_rich_text()
  #
  # Returns an array ref of font information about each string block in a "rich",
  # i.e. multi-format, string.
  #
  sub get_rich_text {
  
      my $self = shift;
  
      return $self->{Rich};
  }
  
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *Value = *value;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Cell - A class for Cell data and formatting.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 Methods
  
  The following Cell methods are available:
  
      $cell->value()
      $cell->unformatted()
      $cell->get_format()
      $cell->type()
      $cell->encoding()
      $cell->is_merged()
      $cell->get_rich_text()
  
  
  =head2 value()
  
  The C<value()> method returns the formatted value of the cell.
  
      my $value = $cell->value();
  
  Formatted in this sense refers to the numeric format of the cell value. For example a number such as 40177 might be formatted as 40,117, 40117.000 or even as the date 2009/12/30.
  
  If the cell doesn't contain a numeric format then the formatted and unformatted cell values are the same, see the C<unformatted()> method below.
  
  For a defined C<$cell> the C<value()> method will always return a value.
  
  In the case of a cell with formatting but no numeric or string contents the method will return the empty string C<''>.
  
  
  =head2 unformatted()
  
  The C<unformatted()> method returns the unformatted value of the cell.
  
      my $unformatted = $cell->unformatted();
  
  Returns the cell value without a numeric format. See the C<value()> method above.
  
  
  =head2 get_format()
  
  The C<get_format()> method returns the L<Spreadsheet::ParseExcel::Format> object for the cell.
  
      my $format = $cell->get_format();
  
  If a user defined format hasn't been applied to the cell then the default cell format is returned.
  
  
  =head2 type()
  
  The C<type()> method returns the type of cell such as Text, Numeric or Date. If the type was detected as Numeric, and the Cell Format matches C<m{^[dmy][-\\/dmy]*$}i>, it will be treated as a Date type.
  
      my $type = $cell->type();
  
  See also L<Dates and Time in Excel>.
  
  
  =head2 encoding()
  
  The C<encoding()> method returns the character encoding of the cell.
  
      my $encoding = $cell->encoding();
  
  This method is only of interest to developers. In general Spreadsheet::ParseExcel will return all character strings in UTF-8 regardless of the encoding used by Excel.
  
  The C<encoding()> method returns one of the following values:
  
  =over
  
  =item * 0: Unknown format. This shouldn't happen. In the default case the format should be 1.
  
  =item * 1: 8bit ASCII or single byte UTF-16. This indicates that the characters are encoded in a single byte. In Excel 95 and earlier This usually meant ASCII or an international variant. In Excel 97 it refers to a compressed UTF-16 character string where all of the high order bytes are 0 and are omitted to save space.
  
  =item * 2: UTF-16BE.
  
  =item * 3: Native encoding. In Excel 95 and earlier this encoding was used to represent multi-byte character encodings such as SJIS.
  
  =back
  
  
  =head2 is_merged()
  
  The C<is_merged()> method returns true if the cell is merged.
  
      my $is_merged = $cell->is_merged();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_rich_text()
  
  The C<get_rich_text()> method returns an array ref of font information about each string block in a "rich", i.e. multi-format, string.
  
      my $rich_text = $cell->get_rich_text();
  
  The return value is an arrayref of arrayrefs in the form:
  
      [
          [ $start_position, $font_object ],
           ...,
      ]
  
  Returns undef if the property isn't set.
  
  
  =head1 Dates and Time in Excel
  
  Dates and times in Excel are represented by real numbers, for example "Jan 1 2001 12:30 PM" is represented by the number 36892.521.
  
  The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day.
  
  A date or time in Excel is just like any other number. The way in which it is displayed is controlled by the number format:
  
      Number format               $cell->value()            $cell->unformatted()
      =============               ==============            ==============
      'dd/mm/yy'                  '28/02/08'                39506.5
      'mm/dd/yy'                  '02/28/08'                39506.5
      'd-m-yyyy'                  '28-2-2008'               39506.5
      'dd/mm/yy hh:mm'            '28/02/08 12:00'          39506.5
      'd mmm yyyy'                '28 Feb 2008'             39506.5
      'mmm d yyyy hh:mm AM/PM'    'Feb 28 2008 12:00 PM'    39506.5
  
  
  The L<Spreadsheet::ParseExcel::Utility> module contains a function called C<ExcelLocaltime> which will convert between an unformatted Excel date/time number and a C<localtime()> like array.
  
  For date conversions using the CPAN C<DateTime> framework see L<DateTime::Format::Excel> http://search.cpan.org/search?dist=DateTime-Format-Excel
  
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_CELL

$fatpacked{"Spreadsheet/ParseExcel/Dump.pm"} = <<'SPREADSHEET_PARSEEXCEL_DUMP';
  package Spreadsheet::ParseExcel::Dump;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Dump - A class for dumping Excel records.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.59';
  
  my %NameTbl = (
  
      #P291
      0x0A => 'EOF',
      0x0C => 'CALCCOUNT',
      0x0D => 'CALCMODE',
      0x0E => 'PRECISION',
      0x0F => 'REFMODE',
      0x10 => 'DELTA',
      0x11 => 'ITERATION',
      0x12 => 'PROTECT',
      0x13 => 'PASSWORD',
      0x14 => 'HEADER',
  
      0x15 => 'FOOTER',
      0x16 => 'EXTERNCOUNT',
      0x17 => 'EXTERNSHEET',
      0x19 => 'WINDOWPROTECT',
      0x1A => 'VERTICALPAGEBREAKS',
      0x1B => 'HORIZONTALPAGEBREAKS',
      0x1C => 'NOTE',
      0x1D => 'SELECTION',
      0x22 => '1904',
      0x26 => 'LEFTMARGIN',
  
      0x27 => 'RIGHTMARGIN',
      0x28 => 'TOPMARGIN',
      0x29 => 'BOTTOMMARGIN',
      0x2A => 'PRINTHEADERS',
      0x2B => 'PRINTGRIDLINES',
      0x2F => 'FILEPASS',
      0x3C => 'COUNTINUE',
      0x3D => 'WINDOW1',
      0x40 => 'BACKUP',
      0x41 => 'PANE',
  
      0x42 => 'CODEPAGE',
      0x4D => 'PLS',
      0x50 => 'DCON',
      0x51 => 'DCONREF',
  
      #P292
      0x52 => 'DCONNAME',
      0x55 => 'DEFCOLWIDTH',
      0x59 => 'XCT',
      0x5A => 'CRN',
      0x5B => 'FILESHARING',
      0x5C => 'WRITEACCES',
      0x5D => 'OBJ',
      0x5E => 'UNCALCED',
      0x5F => 'SAVERECALC',
      0x60 => 'TEMPLATE',
  
      0x63 => 'OBJPROTECT',
      0x7D => 'COLINFO',
      0x7E => 'RK',
      0x7F => 'IMDATA',
      0x80 => 'GUTS',
      0x81 => 'WSBOOL',
      0x82 => 'GRIDSET',
      0x83 => 'HCENTER',
      0x84 => 'VCENTER',
      0x85 => 'BOUNDSHEET',
  
      0x86 => 'WRITEPROT',
      0x87 => 'ADDIN',
      0x88 => 'EDG',
      0x89 => 'PUB',
      0x8C => 'COUNTRY',
      0x8D => 'HIDEOBJ',
      0x90 => 'SORT',
      0x91 => 'SUB',
      0x92 => 'PALETTE',
      0x94 => 'LHRECORD',
  
      0x95 => 'LHNGRAPH',
      0x96 => 'SOUND',
      0x98 => 'LPR',
      0x99 => 'STANDARDWIDTH',
      0x9A => 'FNGROUPNAME',
      0x9B => 'FILTERMODE',
      0x9C => 'FNGROUPCOUNT',
  
      #P293
      0x9D => 'AUTOFILTERINFO',
      0x9E => 'AUTOFILTER',
      0xA0 => 'SCL',
      0xA1 => 'SETUP',
      0xA9 => 'COORDLIST',
      0xAB => 'GCW',
      0xAE => 'SCENMAN',
      0xAF => 'SCENARIO',
      0xB0 => 'SXVIEW',
      0xB1 => 'SXVD',
  
      0xB2 => 'SXV',
      0xB4 => 'SXIVD',
      0xB5 => 'SXLI',
      0xB6 => 'SXPI',
      0xB8 => 'DOCROUTE',
      0xB9 => 'RECIPNAME',
      0xBC => 'SHRFMLA',
      0xBD => 'MULRK',
      0xBE => 'MULBLANK',
      0xBF => 'TOOLBARHDR',
      0xC0 => 'TOOLBAREND',
      0xC1 => 'MMS',
  
      0xC2 => 'ADDMENU',
      0xC3 => 'DELMENU',
      0xC5 => 'SXDI',
      0xC6 => 'SXDB',
      0xCD => 'SXSTRING',
      0xD0 => 'SXTBL',
      0xD1 => 'SXTBRGIITM',
      0xD2 => 'SXTBPG',
      0xD3 => 'OBPROJ',
      0xD5 => 'SXISDTM',
  
      0xD6 => 'RSTRING',
      0xD7 => 'DBCELL',
      0xDA => 'BOOKBOOL',
      0xDC => 'PARAMQRY',
      0xDC => 'SXEXT',
      0xDD => 'SCENPROTECT',
      0xDE => 'OLESIZE',
  
      #P294
      0xDF => 'UDDESC',
      0xE0 => 'XF',
      0xE1 => 'INTERFACEHDR',
      0xE2 => 'INTERFACEEND',
      0xE3 => 'SXVS',
      0xEA => 'TABIDCONF',
      0xEB => 'MSODRAWINGGROUP',
      0xEC => 'MSODRAWING',
      0xED => 'MSODRAWINGSELECTION',
      0xEF => 'PHONETICINFO',
      0xF0 => 'SXRULE',
  
      0xF1 => 'SXEXT',
      0xF2 => 'SXFILT',
      0xF6 => 'SXNAME',
      0xF7 => 'SXSELECT',
      0xF8 => 'SXPAIR',
      0xF9 => 'SXFMLA',
      0xFB => 'SXFORMAT',
      0xFC => 'SST',
      0xFD => 'LABELSST',
      0xFF => 'EXTSST',
  
      0x100 => 'SXVDEX',
      0x103 => 'SXFORMULA',
      0x122 => 'SXDBEX',
      0x13D => 'TABID',
      0x160 => 'USESELFS',
      0x161 => 'DSF',
      0x162 => 'XL5MODIFY',
      0x1A5 => 'FILESHARING2',
      0x1A9 => 'USERBVIEW',
      0x1AA => 'USERVIEWBEGIN',
  
      0x1AB => 'USERSVIEWEND',
      0x1AD => 'QSI',
      0x1AE => 'SUPBOOK',
      0x1AF => 'PROT4REV',
      0x1B0 => 'CONDFMT',
      0x1B1 => 'CF',
      0x1B2 => 'DVAL',
  
      #P295
      0x1B5 => 'DCONBIN',
      0x1B6 => 'TXO',
      0x1B7 => 'REFRESHALL',
      0x1B8 => 'HLINK',
      0x1BA => 'CODENAME',
      0x1BB => 'SXFDBTYPE',
      0x1BC => 'PROT4REVPASS',
      0x1BE => 'DV',
      0x200 => 'DIMENSIONS',
      0x201 => 'BLANK',
  
      0x202 => 'Integer',            #Not Documented
      0x203 => 'NUMBER',
      0x204 => 'LABEL',
      0x205 => 'BOOLERR',
      0x207 => 'STRING',
      0x208 => 'ROW',
      0x20B => 'INDEX',
      0x218 => 'NAME',
      0x221 => 'ARRAY',
      0x223 => 'EXTERNNAME',
      0x225 => 'DEFAULTROWHEIGHT',
  
      0x231 => 'FONT',
      0x236 => 'TABLE',
      0x23E => 'WINDOW2',
      0x293 => 'STYLE',
      0x406 => 'FORMULA',
      0x41E => 'FORMAT',
  
      0x18 => 'NAME',
  
      0x06 => 'FORMULA',
  
      0x09  => 'BOF(BIFF2)',
      0x209 => 'BOF(BIFF3)',
      0x409 => 'BOF(BIFF4)',
      0x809 => 'BOF(BIFF5-7)',
  
      0x31 => 'FONT', 0x27E => 'RK',
  
      #Chart/Graph
      0x1001 => 'UNITS',
      0x1002 => 'CHART',
      0x1003 => 'SERISES',
      0x1006 => 'DATAFORMAT',
      0x1007 => 'LINEFORMAT',
      0x1009 => 'MAKERFORMAT',
      0x100A => 'AREAFORMAT',
      0x100B => 'PIEFORMAT',
      0x100C => 'ATTACHEDLABEL',
      0x100D => 'SERIESTEXT',
      0x1014 => 'CHARTFORMAT',
      0x1015 => 'LEGEND',
      0x1016 => 'SERIESLIST',
      0x1017 => 'BAR',
      0x1018 => 'LINE',
      0x1019 => 'PIE',
      0x101A => 'AREA',
      0x101B => 'SCATTER',
      0x101C => 'CHARTLINE',
      0x101D => 'AXIS',
      0x101E => 'TICK',
      0x101F => 'VALUERANGE',
      0x1020 => 'CATSERRANGE',
      0x1021 => 'AXISLINEFORMAT',
      0x1022 => 'CHARTFORMATLINK',
      0x1024 => 'DEFAULTTEXT',
      0x1025 => 'TEXT',
      0x1026 => 'FONTX',
      0x1027 => 'OBJECTLINK',
      0x1032 => 'FRAME',
      0x1033 => 'BEGIN',
      0x1034 => 'END',
      0x1035 => 'PLOTAREA',
      0x103A => '3D',
      0x103C => 'PICF',
      0x103D => 'DROPBAR',
      0x103E => 'RADAR',
      0x103F => 'SURFACE',
      0x1040 => 'RADARAREA',
      0x1041 => 'AXISPARENT',
      0x1043 => 'LEGENDXN',
      0x1044 => 'SHTPROPS',
      0x1045 => 'SERTOCRT',
      0x1046 => 'AXESUSED',
      0x1048 => 'SBASEREF',
      0x104A => 'SERPARENT',
      0x104B => 'SERAUXTREND',
      0x104E => 'IFMT',
      0x104F => 'POS',
      0x1050 => 'ALRUNS',
      0x1051 => 'AI',
      0x105B => 'SERAUXERRBAR',
      0x105D => 'SERFMT',
      0x1060 => 'FBI',
      0x1061 => 'BOPPOP',
      0x1062 => 'AXCEXT',
      0x1063 => 'DAT',
      0x1064 => 'PLOTGROWTH',
      0x1065 => 'SINDEX',
      0x1066 => 'GELFRAME',
      0x1067 => 'BPOPPOPCUSTOM',
  );
  
  #------------------------------------------------------------------------------
  # subDUMP (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub subDUMP {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      printf "%04X:%-23s (Len:%3d) : %s\n",
        $bOp, OpName($bOp), $bLen, unpack( "H40", $sWk );
  }
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->OpName
  #------------------------------------------------------------------------------
  sub OpName {
      my ($bOp) = @_;
      return ( defined $NameTbl{$bOp} ) ? $NameTbl{$bOp} : 'undef';
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Dump - A class for dumping Excel records.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
  
SPREADSHEET_PARSEEXCEL_DUMP

$fatpacked{"Spreadsheet/ParseExcel/FmtDefault.pm"} = <<'SPREADSHEET_PARSEEXCEL_FMTDEFAULT';
  package Spreadsheet::ParseExcel::FmtDefault;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtDefault - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Spreadsheet::ParseExcel::Utility qw(ExcelFmt);
  our $VERSION = '0.59';
  
  my %hFmtDefault = (
      0x00 => '@',
      0x01 => '0',
      0x02 => '0.00',
      0x03 => '#,##0',
      0x04 => '#,##0.00',
      0x05 => '($#,##0_);($#,##0)',
      0x06 => '($#,##0_);[RED]($#,##0)',
      0x07 => '($#,##0.00_);($#,##0.00_)',
      0x08 => '($#,##0.00_);[RED]($#,##0.00_)',
      0x09 => '0%',
      0x0A => '0.00%',
      0x0B => '0.00E+00',
      0x0C => '# ?/?',
      0x0D => '# ??/??',
      0x0E => 'yyyy-mm-dd',      # Was 'm-d-yy', which is bad as system default
      0x0F => 'd-mmm-yy',
      0x10 => 'd-mmm',
      0x11 => 'mmm-yy',
      0x12 => 'h:mm AM/PM',
      0x13 => 'h:mm:ss AM/PM',
      0x14 => 'h:mm',
      0x15 => 'h:mm:ss',
      0x16 => 'm-d-yy h:mm',
  
      #0x17-0x24 -- Differs in Natinal
      0x25 => '(#,##0_);(#,##0)',
      0x26 => '(#,##0_);[RED](#,##0)',
      0x27 => '(#,##0.00);(#,##0.00)',
      0x28 => '(#,##0.00);[RED](#,##0.00)',
      0x29 => '_(*#,##0_);_(*(#,##0);_(*"-"_);_(@_)',
      0x2A => '_($*#,##0_);_($*(#,##0);_(*"-"_);_(@_)',
      0x2B => '_(*#,##0.00_);_(*(#,##0.00);_(*"-"??_);_(@_)',
      0x2C => '_($*#,##0.00_);_($*(#,##0.00);_(*"-"??_);_(@_)',
      0x2D => 'mm:ss',
      0x2E => '[h]:mm:ss',
      0x2F => 'mm:ss.0',
      0x30 => '##0.0E+0',
      0x31 => '@',
  );
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub new {
      my ( $sPkg, %hKey ) = @_;
      my $oThis = {};
      bless $oThis;
      return $oThis;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $oThis, $sTxt, $sCode ) = @_;
      return $sTxt if ( ( !defined($sCode) ) || ( $sCode eq '_native_' ) );
      return pack( 'U*', unpack( 'n*', $sTxt ) );
  }
  
  #------------------------------------------------------------------------------
  # FmtStringDef (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub FmtStringDef {
      my ( $oThis, $iFmtIdx, $oBook, $rhFmt ) = @_;
      my $sFmtStr = $oBook->{FormatStr}->{$iFmtIdx};
  
      if ( !( defined($sFmtStr) ) && defined($rhFmt) ) {
          $sFmtStr = $rhFmt->{$iFmtIdx};
      }
      $sFmtStr = $hFmtDefault{$iFmtIdx} unless ($sFmtStr);
      return $sFmtStr;
  }
  
  #------------------------------------------------------------------------------
  # FmtString (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub FmtString {
      my ( $oThis, $oCell, $oBook ) = @_;
  
      my $sFmtStr =
        $oThis->FmtStringDef( $oBook->{Format}[ $oCell->{FormatNo} ]->{FmtIdx},
          $oBook );
  
      # Special case for cells that use Lotus123 style leading
      # apostrophe to designate text formatting.
      if ( $oBook->{Format}[ $oCell->{FormatNo} ]->{Key123} ) {
          $sFmtStr = '@';
      }
  
      unless ( defined($sFmtStr) ) {
          if ( $oCell->{Type} eq 'Numeric' ) {
              if ( int( $oCell->{Val} ) != $oCell->{Val} ) {
                  $sFmtStr = '0.00';
              }
              else {
                  $sFmtStr = '0';
              }
          }
          elsif ( $oCell->{Type} eq 'Date' ) {
              if ( int( $oCell->{Val} ) <= 0 ) {
                  $sFmtStr = 'h:mm:ss';
              }
              else {
                  $sFmtStr = 'yyyy-mm-dd';
              }
          }
          else {
              $sFmtStr = '@';
          }
      }
      return $sFmtStr;
  }
  
  #------------------------------------------------------------------------------
  # ValFmt (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub ValFmt {
      my ( $oThis, $oCell, $oBook ) = @_;
  
      my ( $Dt, $iFmtIdx, $iNumeric, $Flg1904 );
  
      if ( $oCell->{Type} eq 'Text' ) {
          $Dt =
            ( ( defined $oCell->{Val} ) && ( $oCell->{Val} ne '' ) )
            ? $oThis->TextFmt( $oCell->{Val}, $oCell->{Code} )
            : '';
  
          return $Dt;
      }
      else {
          $Dt      = $oCell->{Val};
          $Flg1904 = $oBook->{Flg1904};
          my $sFmtStr = $oThis->FmtString( $oCell, $oBook );
  
          return ExcelFmt( $sFmtStr, $Dt, $Flg1904, $oCell->{Type} );
      }
  }
  
  #------------------------------------------------------------------------------
  # ChkType (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub ChkType {
      my ( $oPkg, $iNumeric, $iFmtIdx ) = @_;
      if ($iNumeric) {
          if (   ( ( $iFmtIdx >= 0x0E ) && ( $iFmtIdx <= 0x16 ) )
              || ( ( $iFmtIdx >= 0x2D ) && ( $iFmtIdx <= 0x2F ) ) )
          {
              return "Date";
          }
          else {
              return "Numeric";
          }
      }
      else {
          return "Text";
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtDefault - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTDEFAULT

$fatpacked{"Spreadsheet/ParseExcel/FmtJapan.pm"} = <<'SPREADSHEET_PARSEEXCEL_FMTJAPAN';
  package Spreadsheet::ParseExcel::FmtJapan;
  use utf8;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtJapan - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Encode qw(find_encoding decode);
  use base 'Spreadsheet::ParseExcel::FmtDefault';
  our $VERSION = '0.59';
  
  my %FormatTable = (
      0x00 => '@',
      0x01 => '0',
      0x02 => '0.00',
      0x03 => '#,##0',
      0x04 => '#,##0.00',
      0x05 => '(\\#,##0_);(\\#,##0)',
      0x06 => '(\\#,##0_);[RED](\\#,##0)',
      0x07 => '(\\#,##0.00_);(\\#,##0.00_)',
      0x08 => '(\\#,##0.00_);[RED](\\#,##0.00_)',
      0x09 => '0%',
      0x0A => '0.00%',
      0x0B => '0.00E+00',
      0x0C => '# ?/?',
      0x0D => '# ??/??',
  
      #    0x0E => 'm/d/yy',
      0x0E => 'yyyy/m/d',
      0x0F => 'd-mmm-yy',
      0x10 => 'd-mmm',
      0x11 => 'mmm-yy',
      0x12 => 'h:mm AM/PM',
      0x13 => 'h:mm:ss AM/PM',
      0x14 => 'h:mm',
      0x15 => 'h:mm:ss',
  
      #    0x16 => 'm/d/yy h:mm',
      0x16 => 'yyyy/m/d h:mm',
  
      #0x17-0x24 -- Differs in Natinal
      0x1E => 'm/d/yy',
      0x1F => 'yyyy"年"m"月"d"日"',
      0x20 => 'h"時"mm"分"',
      0x21 => 'h"時"mm"分"ss"秒"',
  
      #0x17-0x24 -- Differs in Natinal
      0x25 => '(#,##0_);(#,##0)',
      0x26 => '(#,##0_);[RED](#,##0)',
      0x27 => '(#,##0.00);(#,##0.00)',
      0x28 => '(#,##0.00);[RED](#,##0.00)',
      0x29 => '_(*#,##0_);_(*(#,##0);_(*"-"_);_(@_)',
      0x2A => '_(\\*#,##0_);_(\\*(#,##0);_(*"-"_);_(@_)',
      0x2B => '_(*#,##0.00_);_(*(#,##0.00);_(*"-"??_);_(@_)',
      0x2C => '_(\\*#,##0.00_);_(\\*(#,##0.00);_(*"-"??_);_(@_)',
      0x2D => 'mm:ss',
      0x2E => '[h]:mm:ss',
      0x2F => 'mm:ss.0',
      0x30 => '##0.0E+0',
      0x31 => '@',
  
      0x37 => 'yyyy"年"m"月"',
      0x38 => 'm"月"d"日"',
      0x39 => 'ge.m.d',
      0x3A => 'ggge"年"m"月"d"日"',
  );
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  sub new {
      my ( $class, %args ) = @_;
      my $encoding = $args{Code} || $args{encoding};
      my $self = { Code => $encoding };
      if($encoding){
          $self->{encoding} = find_encoding($encoding eq 'sjis' ? 'cp932' : $encoding)
              or do{
                  require Carp;
                  Carp::croak(qq{Unknown encoding '$encoding'});
              };
      }
      return bless $self, $class;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $self, $text, $input_encoding ) = @_;
      if(!defined $input_encoding){
          $input_encoding = 'utf8';
      }
      elsif($input_encoding eq '_native_'){
          $input_encoding = 'cp932'; # Shift_JIS in Microsoft products
      }
      $text = decode($input_encoding, $text);
      return $self->{Code} ? $self->{encoding}->encode($text) : $text;
  }
  #------------------------------------------------------------------------------
  # FmtStringDef (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  sub FmtStringDef {
      my ( $self, $format_index, $book ) = @_;
      return $self->SUPER::FmtStringDef( $format_index, $book, \%FormatTable );
  }
  
  #------------------------------------------------------------------------------
  # CnvNengo (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  
  # Convert A.D. into Japanese Nengo (aka Gengo)
  
  my @Nengo = (
  	{
  		name      => '平成', # Heisei
  		abbr_name => 'H',
  
  		base      => 1988,
  		start     => 19890108,
  	},
  	{
  		name      => '昭和', # Showa
  		abbr_name => 'S',
  
  		base      => 1925,
  		start     => 19261225,
  	},
  	{
  		name      => '大正', # Taisho
  		abbr_name => 'T',
  
  		base      => 1911,
  		start     => 19120730,
  	},
  	{
  		name      => '明治', # Meiji
  		abbr_name => 'M',
  
  		base      => 1867,
  		start     => 18680908,
  	},
  );
  
  # Usage: CnvNengo(name => @tm) or CnvNeng(abbr_name => @tm)
  sub CnvNengo {
      my ( $kind, @tm ) = @_;
      my $year = $tm[5] + 1900;
      my $wk = ($year * 10000) + ($tm[4] * 100) + ($tm[3] * 1);
      #my $wk = sprintf( '%04d%02d%02d', $year, $tm[4], $tm[3] );
      foreach my $nengo(@Nengo){
          if( $wk >= $nengo->{start} ){
              return $nengo->{$kind} . ($year - $nengo->{base});
          }
      }
      return $year;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtJapan - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTJAPAN

$fatpacked{"Spreadsheet/ParseExcel/FmtJapan2.pm"} = <<'SPREADSHEET_PARSEEXCEL_FMTJAPAN2';
  package Spreadsheet::ParseExcel::FmtJapan2;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtJapan2 - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Jcode;
  use Unicode::Map;
  use base 'Spreadsheet::ParseExcel::FmtJapan';
  our $VERSION = '0.59';
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtJapan2)
  #------------------------------------------------------------------------------
  sub new {
      my ( $sPkg, %hKey ) = @_;
      my $oMap = Unicode::Map->new('CP932Excel');
      die "NO MAP FILE CP932Excel!!"
        unless ( -r Unicode::Map->mapping("CP932Excel") );
  
      my $oThis = {
          Code    => $hKey{Code},
          _UniMap => $oMap,
      };
      bless $oThis;
      $oThis->SUPER::new(%hKey);
      return $oThis;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtJapan2)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $oThis, $sTxt, $sCode ) = @_;
  
      #    $sCode = 'sjis' if((! defined($sCode)) || ($sCode eq '_native_'));
      if ( $oThis->{Code} ) {
          if ( !defined($sCode) ) {
              $sTxt =~ s/(.)/\x00$1/sg;
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
          }
          elsif ( $sCode eq 'ucs2' ) {
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
          }
          return Jcode::convert( $sTxt, $oThis->{Code}, 'sjis' );
      }
      else {
          return $sTxt;
      }
  }
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtJapan2 - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTJAPAN2

$fatpacked{"Spreadsheet/ParseExcel/FmtUnicode.pm"} = <<'SPREADSHEET_PARSEEXCEL_FMTUNICODE';
  package Spreadsheet::ParseExcel::FmtUnicode;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtUnicode - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Unicode::Map;
  use base 'Spreadsheet::ParseExcel::FmtDefault';
  
  our $VERSION = '0.59';
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtUnicode)
  #------------------------------------------------------------------------------
  sub new {
      my ( $sPkg, %hKey ) = @_;
      my $sMap = $hKey{Unicode_Map};
      my $oMap;
      $oMap = Unicode::Map->new($sMap) if $sMap;
      my $oThis = {
          Unicode_Map => $sMap,
          _UniMap     => $oMap,
      };
      bless $oThis;
      return $oThis;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtUnicode)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $oThis, $sTxt, $sCode ) = @_;
      if ( $oThis->{_UniMap} ) {
          if ( !defined($sCode) ) {
              my $sSv = $sTxt;
              $sTxt =~ s/(.)/\x00$1/sg;
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
              $sTxt = $sSv unless ($sTxt);
          }
          elsif ( $sCode eq 'ucs2' ) {
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
          }
  
          #        $sTxt = $oThis->{_UniMap}->from_unicode($sTxt)
          #                     if(defined($sCode) && $sCode eq 'ucs2');
          return $sTxt;
      }
      else {
          return $sTxt;
      }
  }
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtUnicode - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTUNICODE

$fatpacked{"Spreadsheet/ParseExcel/Font.pm"} = <<'SPREADSHEET_PARSEEXCEL_FONT';
  package Spreadsheet::ParseExcel::Font;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Font - A class for Cell fonts.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.59';
  
  sub new {
      my ( $class, %rhIni ) = @_;
      my $self = \%rhIni;
  
      bless $self, $class;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Font - A class for Cell fonts.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
  
SPREADSHEET_PARSEEXCEL_FONT

$fatpacked{"Spreadsheet/ParseExcel/Format.pm"} = <<'SPREADSHEET_PARSEEXCEL_FORMAT';
  package Spreadsheet::ParseExcel::Format;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Format - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.59';
  
  sub new {
      my ( $class, %rhIni ) = @_;
      my $self = \%rhIni;
  
      bless $self, $class;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Format - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FORMAT

$fatpacked{"Spreadsheet/ParseExcel/SaveParser.pm"} = <<'SPREADSHEET_PARSEEXCEL_SAVEPARSER';
  package Spreadsheet::ParseExcel::SaveParser;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::SaveParser - Rewrite an existing Excel file.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Spreadsheet::ParseExcel;
  use Spreadsheet::ParseExcel::SaveParser::Workbook;
  use Spreadsheet::ParseExcel::SaveParser::Worksheet;
  use Spreadsheet::WriteExcel;
  use base 'Spreadsheet::ParseExcel';
  
  our $VERSION = '0.59';
  
  ###############################################################################
  #
  # new()
  #
  sub new {
  
      my ( $package, %params ) = @_;
      $package->SUPER::new(%params);
  }
  
  ###############################################################################
  #
  # Create()
  #
  sub Create {
  
      my ( $self, $formatter ) = @_;
  
      #0. New $workbook
      my $workbook = Spreadsheet::ParseExcel::Workbook->new();
      $workbook->{SheetCount} = 0;
  
      # User specified formater class.
      if ($formatter) {
          $workbook->{FmtClass} = $formatter;
      }
      else {
          $workbook->{FmtClass} = Spreadsheet::ParseExcel::FmtDefault->new();
      }
  
      return Spreadsheet::ParseExcel::SaveParser::Workbook->new($workbook);
  }
  
  ###############################################################################
  #
  # Parse()
  #
  sub Parse {
  
      my ( $self, $sFile, $formatter ) = @_;
  
      my $workbook = $self->SUPER::Parse( $sFile, $formatter );
  
      return undef unless defined $workbook;
      return Spreadsheet::ParseExcel::SaveParser::Workbook->new($workbook);
  }
  
  ###############################################################################
  #
  # SaveAs()
  #
  sub SaveAs {
  
      my ( $self, $workbook, $filename ) = @_;
  
      $workbook->SaveAs($filename);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::SaveParser - Rewrite an existing Excel file.
  
  =head1 SYNOPSIS
  
  
  
  Say we start with an Excel file that looks like this:
  
      -----------------------------------------------------
     |   |      A      |      B      |      C      |
      -----------------------------------------------------
     | 1 | Hello       | ...         | ...         |  ...
     | 2 | World       | ...         | ...         |  ...
     | 3 | *Bold text* | ...         | ...         |  ...
     | 4 | ...         | ...         | ...         |  ...
     | 5 | ...         | ...         | ...         |  ...
  
  
  Then we process it with the following program:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
  
      use Spreadsheet::ParseExcel;
      use Spreadsheet::ParseExcel::SaveParser;
  
  
      # Open an existing file with SaveParser
      my $parser   = Spreadsheet::ParseExcel::SaveParser->new();
      my $template = $parser->Parse('template.xls');
  
  
      # Get the first worksheet.
      my $worksheet = $template->worksheet(0);
      my $row  = 0;
      my $col  = 0;
  
  
      # Overwrite the string in cell A1
      $worksheet->AddCell( $row, $col, 'New string' );
  
  
      # Add a new string in cell B1
      $worksheet->AddCell( $row, $col + 1, 'Newer' );
  
  
      # Add a new string in cell C1 with the format from cell A3.
      my $cell = $worksheet->get_cell( $row + 2, $col );
      my $format_number = $cell->{FormatNo};
  
      $worksheet->AddCell( $row, $col + 2, 'Newest', $format_number );
  
  
      # Write over the existing file or write a new file.
      $template->SaveAs('newfile.xls');
  
  
  We should now have an Excel file that looks like this:
  
      -----------------------------------------------------
     |   |      A      |      B      |      C      |
      -----------------------------------------------------
     | 1 | New string  | Newer       | *Newest*    |  ...
     | 2 | World       | ...         | ...         |  ...
     | 3 | *Bold text* | ...         | ...         |  ...
     | 4 | ...         | ...         | ...         |  ...
     | 5 | ...         | ...         | ...         |  ...
  
  
  
  =head1 DESCRIPTION
  
  The C<Spreadsheet::ParseExcel::SaveParser> module rewrite an existing Excel file by reading it with C<Spreadsheet::ParseExcel> and rewriting it with C<Spreadsheet::WriteExcel>.
  
  =head1 METHODS
  
  =head1 Parser
  
  =head2 new()
  
      $parse = new Spreadsheet::ParseExcel::SaveParser();
  
  Constructor.
  
  =head2 Parse()
  
      $workbook = $parse->Parse($sFileName);
  
      $workbook = $parse->Parse($sFileName , $formatter);
  
  Returns a L</Workbook> object. If an error occurs, returns undef.
  
  The optional C<$formatter> is a Formatter Class to format the value of cells.
  
  
  =head1 Workbook
  
  The C<Parse()> method returns a C<Spreadsheet::ParseExcel::SaveParser::Workbook> object.
  
  This is a subclass of the L<Spreadsheet::ParseExcel::Workbook> and has the following methods:
  
  =head2 worksheets()
  
  Returns an array of L</Worksheet> objects. This was most commonly used to iterate over the worksheets in a workbook:
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
  =head2 worksheet()
  
  The C<worksheet()> method returns a single C<Worksheet> object using either its name or index:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  Returns C<undef> if the sheet name or index doesn't exist.
  
  
  =head2 AddWorksheet()
  
      $workbook = $workbook->AddWorksheet($name, %properties);
  
  Create a new Worksheet object of type C<Spreadsheet::ParseExcel::Worksheet>.
  
  The C<%properties> hash contains the properties of new Worksheet.
  
  
  =head2 AddFont
  
      $workbook = $workbook->AddFont(%properties);
  
  Create new Font object of type C<Spreadsheet::ParseExcel::Font>.
  
  The C<%properties> hash contains the properties of new Font.
  
  
  =head2 AddFormat
  
      $workbook = $workbook->AddFormat(%properties);
  
  The C<%properties> hash contains the properties of new Font.
  
  
  =head1 Worksheet
  
  Spreadsheet::ParseExcel::SaveParser::Worksheet
  
  Worksheet is a subclass of Spreadsheet::ParseExcel::Worksheet.
  And has these methods :
  
  
  The C<Worksbook::worksheet()> method returns a C<Spreadsheet::ParseExcel::SaveParser::Worksheet> object.
  
  This is a subclass of the L<Spreadsheet::ParseExcel::Worksheet> and has the following methods:
  
  
  =head1 AddCell
  
      $workbook = $worksheet->AddCell($row, $col, $value, $format [$encoding]);
  
  Create new Cell object of type C<Spreadsheet::ParseExcel::Cell>.
  
  The C<$format> parameter is the format number rather than a full format object.
  
  To specify just same as another cell,
  you can set it like below:
  
      $row            = 0;
      $col            = 0;
      $worksheet      = $template->worksheet(0);
      $cell           = $worksheet->get_cell( $row, $col );
      $format_number  = $cell->{FormatNo};
  
      $worksheet->AddCell($row +1, $coll, 'New data', $format_number);
  
  
  
  
  =head1 TODO
  
  Please note that this module is currently (versions 0.50-0.60) undergoing a major
  restructuring and rewriting.
  
  =head1 Known Problems
  
  
  You can only rewrite the features that Spreadsheet::WriteExcel supports so
  macros, graphs and some other features in the original Excel file will be lost.
  Also, formulas aren't rewritten, only the result of a formula is written.
  
  Only last print area will remain. (Others will be removed)
  
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2002 Kawai Takanori and Nippon-RAD Co. OP Division
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  
  =cut
SPREADSHEET_PARSEEXCEL_SAVEPARSER

$fatpacked{"Spreadsheet/ParseExcel/SaveParser/Workbook.pm"} = <<'SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKBOOK';
  package Spreadsheet::ParseExcel::SaveParser::Workbook;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::SaveParser::Workbook - A class for SaveParser Workbooks.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use base 'Spreadsheet::ParseExcel::Workbook';
  our $VERSION = '0.59';
  
  #==============================================================================
  # Spreadsheet::ParseExcel::SaveParser::Workbook
  #==============================================================================
  
  sub new {
      my ( $sPkg, $oBook ) = @_;
      return undef unless ( defined $oBook );
      my %oThis = %$oBook;
      bless \%oThis, $sPkg;
  
      # re-bless worksheets (and set their _Book properties !!!)
      my $sWkP = ref($sPkg) || "$sPkg";
      $sWkP =~ s/Workbook$/Worksheet/;
      map { bless( $_, $sWkP ); } @{ $oThis{Worksheet} };
      map { $_->{_Book} = \%oThis; } @{ $oThis{Worksheet} };
      return \%oThis;
  }
  
  #------------------------------------------------------------------------------
  # Parse (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub Parse {
      my ( $sClass, $sFile, $oWkFmt ) = @_;
      my $oBook = Spreadsheet::ParseExcel::Workbook->Parse( $sFile, $oWkFmt );
      bless $oBook, $sClass;
  
      # re-bless worksheets (and set their _Book properties !!!)
      my $sWkP = ref($sClass) || "$sClass";
      $sWkP =~ s/Workbook$/Worksheet/;
      map { bless( $_, $sWkP ); } @{ $oBook->{Worksheet} };
      map { $_->{_Book} = $oBook; } @{ $oBook->{Worksheet} };
      return $oBook;
  }
  
  #------------------------------------------------------------------------------
  # SaveAs (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub SaveAs {
      my ( $oBook, $sName ) = @_;
  
      # Create a new Excel workbook
      my $oWrEx = Spreadsheet::WriteExcel->new($sName);
      $oWrEx->compatibility_mode();
      my %hFmt;
  
      my $iNo  = 0;
      my @aAlH = (
          'left', 'left',    'center', 'right',
          'fill', 'justify', 'merge',  'equal_space'
      );
      my @aAlV = ( 'top', 'vcenter', 'bottom', 'vjustify', 'vequal_space' );
  
      foreach my $pFmt ( @{ $oBook->{Format} } ) {
          my $oFmt = $oWrEx->addformat();    # Add Formats
          unless ( $pFmt->{Style} ) {
              $hFmt{$iNo} = $oFmt;
              my $rFont = $pFmt->{Font};
  
              $oFmt->set_font( $rFont->{Name} );
              $oFmt->set_size( $rFont->{Height} );
              $oFmt->set_color( $rFont->{Color} );
              $oFmt->set_bold( $rFont->{Bold} );
              $oFmt->set_italic( $rFont->{Italic} );
              $oFmt->set_underline( $rFont->{Underline} );
              $oFmt->set_font_strikeout( $rFont->{Strikeout} );
              $oFmt->set_font_script( $rFont->{Super} );
  
              $oFmt->set_hidden( $rFont->{Hidden} );    #Add
  
              $oFmt->set_locked( $pFmt->{Lock} );
  
              $oFmt->set_align( $aAlH[ $pFmt->{AlignH} ] );
              $oFmt->set_align( $aAlV[ $pFmt->{AlignV} ] );
  
              $oFmt->set_rotation( $pFmt->{Rotate} );
  
              $oFmt->set_num_format(
                  $oBook->{FmtClass}->FmtStringDef( $pFmt->{FmtIdx}, $oBook ) );
  
              $oFmt->set_text_wrap( $pFmt->{Wrap} );
  
              $oFmt->set_pattern( $pFmt->{Fill}->[0] );
              $oFmt->set_fg_color( $pFmt->{Fill}->[1] )
                if ( ( $pFmt->{Fill}->[1] >= 8 )
                  && ( $pFmt->{Fill}->[1] <= 63 ) );
              $oFmt->set_bg_color( $pFmt->{Fill}->[2] )
                if ( ( $pFmt->{Fill}->[2] >= 8 )
                  && ( $pFmt->{Fill}->[2] <= 63 ) );
  
              $oFmt->set_left(
                  ( $pFmt->{BdrStyle}->[0] > 7 ) ? 3 : $pFmt->{BdrStyle}->[0] );
              $oFmt->set_right(
                  ( $pFmt->{BdrStyle}->[1] > 7 ) ? 3 : $pFmt->{BdrStyle}->[1] );
              $oFmt->set_top(
                  ( $pFmt->{BdrStyle}->[2] > 7 ) ? 3 : $pFmt->{BdrStyle}->[2] );
              $oFmt->set_bottom(
                  ( $pFmt->{BdrStyle}->[3] > 7 ) ? 3 : $pFmt->{BdrStyle}->[3] );
  
              $oFmt->set_left_color( $pFmt->{BdrColor}->[0] )
                if ( ( $pFmt->{BdrColor}->[0] >= 8 )
                  && ( $pFmt->{BdrColor}->[0] <= 63 ) );
              $oFmt->set_right_color( $pFmt->{BdrColor}->[1] )
                if ( ( $pFmt->{BdrColor}->[1] >= 8 )
                  && ( $pFmt->{BdrColor}->[1] <= 63 ) );
              $oFmt->set_top_color( $pFmt->{BdrColor}->[2] )
                if ( ( $pFmt->{BdrColor}->[2] >= 8 )
                  && ( $pFmt->{BdrColor}->[2] <= 63 ) );
              $oFmt->set_bottom_color( $pFmt->{BdrColor}->[3] )
                if ( ( $pFmt->{BdrColor}->[3] >= 8 )
                  && ( $pFmt->{BdrColor}->[3] <= 63 ) );
          }
          $iNo++;
      }
      for ( my $iSheet = 0 ; $iSheet < $oBook->{SheetCount} ; $iSheet++ ) {
          my $oWkS = $oBook->{Worksheet}[$iSheet];
          my $oWrS = $oWrEx->addworksheet( $oWkS->{Name} );
  
          #Landscape
          if ( !$oWkS->{Landscape} ) {    # Landscape (0:Horizontal, 1:Vertical)
              $oWrS->set_landscape();
          }
          else {
              $oWrS->set_portrait();
          }
  
          #Protect
          if ( defined $oWkS->{Protect} )
          {    # Protect ('':NoPassword, Password:Password)
              if ( $oWkS->{Protect} ne '' ) {
                  $oWrS->protect( $oWkS->{Protect} );
              }
              else {
                  $oWrS->protect();
              }
          }
          if ( ( $oWkS->{FitWidth} == 1 ) and ( $oWkS->{FitHeight} == 1 ) ) {
  
              # Pages on fit with width and Heigt
              $oWrS->fit_to_pages( $oWkS->{FitWidth}, $oWkS->{FitHeight} );
  
              #Print Scale
              $oWrS->set_print_scale( $oWkS->{Scale} );
          }
          else {
  
              #Print Scale
              $oWrS->set_print_scale( $oWkS->{Scale} );
  
              # Pages on fit with width and Heigt
              $oWrS->fit_to_pages( $oWkS->{FitWidth}, $oWkS->{FitHeight} );
          }
  
          # Paper Size
          $oWrS->set_paper( $oWkS->{PaperSize} );
  
          # Margin
          $oWrS->set_margin_left( $oWkS->{LeftMargin} );
          $oWrS->set_margin_right( $oWkS->{RightMargin} );
          $oWrS->set_margin_top( $oWkS->{TopMargin} );
          $oWrS->set_margin_bottom( $oWkS->{BottomMargin} );
  
          # HCenter
          $oWrS->center_horizontally() if ( $oWkS->{HCenter} );
  
          # VCenter
          $oWrS->center_vertically() if ( $oWkS->{VCenter} );
  
          # Header, Footer
          $oWrS->set_header( $oWkS->{Header}, $oWkS->{HeaderMargin} );
          $oWrS->set_footer( $oWkS->{Footer}, $oWkS->{FooterMargin} );
  
          # Print Area
          if ( ref( $oBook->{PrintArea}[$iSheet] ) eq 'ARRAY' ) {
              my $raP;
              for $raP ( @{ $oBook->{PrintArea}[$iSheet] } ) {
                  $oWrS->print_area(@$raP);
              }
          }
  
          # Print Title
          my $raW;
          foreach $raW ( @{ $oBook->{PrintTitle}[$iSheet]->{Row} } ) {
              $oWrS->repeat_rows(@$raW);
          }
          foreach $raW ( @{ $oBook->{PrintTitle}[$iSheet]->{Column} } ) {
              $oWrS->repeat_columns(@$raW);
          }
  
          # Print Gridlines
          if ( $oWkS->{PrintGrid} == 1 ) {
              $oWrS->hide_gridlines(0);
          }
          else {
              $oWrS->hide_gridlines(1);
          }
  
          # Print Headings
          if ( $oWkS->{PrintHeaders} ) {
              $oWrS->print_row_col_headers();
          }
  
          # Horizontal Page Breaks
          $oWrS->set_h_pagebreaks( @{ $oWkS->{HPageBreak} } );
  
          # Veritical Page Breaks
          $oWrS->set_v_pagebreaks( @{ $oWkS->{VPageBreak} } );
  
  
  
  #        PageStart    => $oWkS->{PageStart},            # Page number for start
  #        UsePage      => $oWkS->{UsePage},              # Use own start page number
  #        NoColor      => $oWkS->{NoColor},               # Print in blcak-white
  #        Draft        => $oWkS->{Draft},                 # Print in draft mode
  #        Notes        => $oWkS->{Notes},                 # Print notes
  #        LeftToRight  => $oWkS->{LeftToRight},           # Left to Right
  
  
          for (
              my $iC = $oWkS->{MinCol} ;
              defined $oWkS->{MaxCol} && $iC <= $oWkS->{MaxCol} ;
              $iC++
            )
          {
              if ( defined $oWkS->{ColWidth}[$iC] ) {
                  if ( $oWkS->{ColWidth}[$iC] > 0 ) {
                      $oWrS->set_column( $iC, $iC, $oWkS->{ColWidth}[$iC] )
                        ;    #, undef, 1) ;
                  }
                  else {
                      $oWrS->set_column( $iC, $iC, 0, undef, 1 );
                  }
              }
          }
          for (
              my $iR = $oWkS->{MinRow} ;
              defined $oWkS->{MaxRow} && $iR <= $oWkS->{MaxRow} ;
              $iR++
            )
          {
              $oWrS->set_row( $iR, $oWkS->{RowHeight}[$iR] );
              for (
                  my $iC = $oWkS->{MinCol} ;
                  defined $oWkS->{MaxCol} && $iC <= $oWkS->{MaxCol} ;
                  $iC++
                )
              {
  
                  my $oWkC = $oWkS->{Cells}[$iR][$iC];
                  if ($oWkC) {
                      if ( $oWkC->{Merged} ) {
                          my $oFmtN = $oWrEx->addformat();
                          $oFmtN->copy( $hFmt{ $oWkC->{FormatNo} } );
                          $oFmtN->set_merge(1);
                          $oWrS->write(
                              $iR,
                              $iC,
                              $oBook->{FmtClass}
                                ->TextFmt( $oWkC->{Val}, $oWkC->{Code} ),
                              $oFmtN
                          );
                      }
                      else {
                          $oWrS->write(
                              $iR,
                              $iC,
                              $oBook->{FmtClass}
                                ->TextFmt( $oWkC->{Val}, $oWkC->{Code} ),
                              $hFmt{ $oWkC->{FormatNo} }
                          );
                      }
                  }
              }
          }
      }
      return $oWrEx;
  }
  
  #------------------------------------------------------------------------------
  # AddWorksheet (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddWorksheet {
      my ( $oBook, $sName, %hAttr ) = @_;
      $oBook->AddFormat if ( $#{ $oBook->{Format} } < 0 );
      $hAttr{Name}         ||= $sName;
      $hAttr{LeftMargin}   ||= 0;
      $hAttr{RightMargin}  ||= 0;
      $hAttr{TopMargin}    ||= 0;
      $hAttr{BottomMargin} ||= 0;
      $hAttr{HeaderMargin} ||= 0;
      $hAttr{FooterMargin} ||= 0;
      $hAttr{FitWidth}     ||= 0;
      $hAttr{FitHeight}    ||= 0;
      $hAttr{PrintGrid}    ||= 0;
      my $oWkS = Spreadsheet::ParseExcel::SaveParser::Worksheet->new(%hAttr);
      $oWkS->{_Book}                              = $oBook;
      $oWkS->{_SheetNo}                           = $oBook->{SheetCount};
      $oBook->{Worksheet}[ $oBook->{SheetCount} ] = $oWkS;
      $oBook->{SheetCount}++;
      return $oWkS;    #$oBook->{SheetCount} - 1;
  }
  
  #------------------------------------------------------------------------------
  # AddFont (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddFont {
      my ( $oBook, %hAttr ) = @_;
      $hAttr{Name}      ||= 'Arial';
      $hAttr{Height}    ||= 10;
      $hAttr{Bold}      ||= 0;
      $hAttr{Italic}    ||= 0;
      $hAttr{Underline} ||= 0;
      $hAttr{Strikeout} ||= 0;
      $hAttr{Super}     ||= 0;
      push @{ $oBook->{Font} }, Spreadsheet::ParseExcel::Font->new(%hAttr);
      return $#{ $oBook->{Font} };
  }
  
  #------------------------------------------------------------------------------
  # AddFormat (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddFormat {
      my ( $oBook, %hAttr ) = @_;
      $hAttr{Fill}     ||= [ 0, 0, 0 ];
      $hAttr{BdrStyle} ||= [ 0, 0, 0, 0 ];
      $hAttr{BdrColor} ||= [ 0, 0, 0, 0 ];
      $hAttr{AlignH}    ||= 0;
      $hAttr{AlignV}    ||= 0;
      $hAttr{Rotate}    ||= 0;
      $hAttr{Landscape} ||= 0;
      $hAttr{FmtIdx}    ||= 0;
  
      if ( !defined( $hAttr{Font} ) ) {
          my $oFont;
          if ( defined $hAttr{FontNo} ) {
              $oFont = $oBook->{Font}[ $hAttr{FontNo} ];
          }
          elsif ( !defined $oFont ) {
              if ( $#{ $oBook->{Font} } >= 0 ) {
                  $oFont = $oBook->{Font}[0];
              }
              else {
                  my $iNo = $oBook->AddFont;
                  $oFont = $oBook->{Font}[$iNo];
              }
          }
          $hAttr{Font} = $oFont;
      }
      push @{ $oBook->{Format} }, Spreadsheet::ParseExcel::Format->new(%hAttr);
      return $#{ $oBook->{Format} };
  }
  
  #------------------------------------------------------------------------------
  # AddCell (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddCell {
      my ( $oBook, $iSheet, $iR, $iC, $sVal, $oCell, $sCode ) = @_;
      my %rhKey;
      $oCell ||= 0;
      my $iFmt =
        ( UNIVERSAL::isa( $oCell, 'Spreadsheet::ParseExcel::Cell' ) )
        ? $oCell->{FormatNo}
        : ( ref($oCell) ) ? 0
        :                   $oCell + 0;
      $rhKey{FormatNo}    = $iFmt;
      $rhKey{Format}      = $oBook->{Format}[$iFmt];
      $rhKey{Val}         = $sVal;
      $rhKey{Code}        = $sCode || '_native_';
      $oBook->{_CurSheet} = $iSheet;
      my $oNewCell =
        Spreadsheet::ParseExcel::_NewCell( $oBook, $iR, $iC, %rhKey );
      Spreadsheet::ParseExcel::_SetDimension( $oBook, $iR, $iC, $iC );
      return $oNewCell;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::SaveParser::Workbook - A class for SaveParser Workbooks.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKBOOK

$fatpacked{"Spreadsheet/ParseExcel/SaveParser/Worksheet.pm"} = <<'SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKSHEET';
  package Spreadsheet::ParseExcel::SaveParser::Worksheet;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::SaveParser::Worksheet - A class for SaveParser Worksheets.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  #==============================================================================
  # Spreadsheet::ParseExcel::SaveParser::Worksheet
  #==============================================================================
  
  use base 'Spreadsheet::ParseExcel::Worksheet';
  our $VERSION = '0.59';
  
  sub new {
      my ( $sClass, %rhIni ) = @_;
      $sClass->SUPER::new(%rhIni);    # returns object
  }
  
  #------------------------------------------------------------------------------
  # AddCell (for Spreadsheet::ParseExcel::SaveParser::Worksheet)
  #------------------------------------------------------------------------------
  sub AddCell {
      my ( $oSelf, $iR, $iC, $sVal, $oCell, $sCode ) = @_;
      $oSelf->{_Book}
        ->AddCell( $oSelf->{_SheetNo}, $iR, $iC, $sVal, $oCell, $sCode );
  }
  
  #------------------------------------------------------------------------------
  # Protect (for Spreadsheet::ParseExcel::SaveParser::Worksheet)
  #  - Password = undef   ->  No protect
  #  - Password = ''      ->  Protected. No password
  #  - Password = $pwd    ->  Protected. Password = $pwd
  #------------------------------------------------------------------------------
  sub Protect {
      my ( $oSelf, $sPassword ) = @_;
      $oSelf->{Protect} = $sPassword;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::SaveParser::Worksheet - A class for SaveParser Worksheets.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKSHEET

$fatpacked{"Spreadsheet/ParseExcel/Simple.pm"} = <<'SPREADSHEET_PARSEEXCEL_SIMPLE';
  package Spreadsheet::ParseExcel::Simple;
  
  $VERSION = '1.04';
  
  use strict;
  use Spreadsheet::ParseExcel;
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Simple - A simple interface to Excel data
  
  =head1 SYNOPSIS
  
    my $xls = Spreadsheet::ParseExcel::Simple->read('spreadsheet.xls');
    foreach my $sheet ($xls->sheets) {
       while ($sheet->has_data) {  
           my @data = $sheet->next_row;
       }
    }
  
  =head1 DESCRIPTION
  
  This provides an abstraction to the Spreadsheet::ParseExcel module for
  simple reading of values.
  
  You simply loop over the sheets, and fetch rows to arrays.
  
  For anything more complex, you probably want to use
  Spreadsheet::ParseExcel directly.
  
  =head1 BOOK METHODS
  
  =head2 read
  
    my $xls = Spreadsheet::ParseExcel::Simple->read('spreadsheet.xls');
  
  This opens the spreadsheet specified for you. Returns undef if we cannot
  read the book.
  
  =head2 sheets
  
    @sheets = $xls->sheets;
  
  Each spreadsheet can contain one or more worksheets. This fetches them
  all back. You can then iterate over them, or jump straight to the one
  you wish to play with.
  
  =head2 book
  
  	my $book = $xls->book;
  
  The Spreadsheet::ParseExcel object we are working with. You can use this
  if you need to manipulate it in ways that this interface doesn't allow.
  
  =head1 SHEET METHODS
  
  These methods can be called on each sheet returned from $xls->sheets:
  
  =head2 has_data
  
    if ($sheet->has_data) { ... }
  
  This lets us know if there are more rows in this sheet that we haven't
  read yet. This allows us to differentiate between an empty row, and 
  the end of the sheet.
  
  =head2 next_row
  
    my @data = $sheet->next_row;
  
  Fetch the next row of data back.
  
  =head2 sheet
  
  	my $obj = $sheet->sheet;
  
  The underlying Spreadsheet::ParseExcel object for the worksheet. You can
  use this if you need to manipulate it in ways that this interface
  doesn't allow (e.g. asking it for the sheet's name).
  
  =head1 AUTHOR
  
  Tony Bowden
  
  =head1 BUGS and QUERIES
  
  Please direct all correspondence regarding this module to:
    bug-Spreadsheet-ParseExcel-Simple@rt.cpan.org
  
  =head1 COPYRIGHT AND LICENSE
  
    Copyright (C) 2001-2005 Tony Bowden.
  
    This program is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License; either version 2 of the License,
    or (at your option) any later version.
  
    This program is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.
  
  =head1 SEE ALSO
  
  L<Spreadsheet::ParseExcel>. 
  
  =cut
  
  sub read {
    my $class = shift;
    my $book = Spreadsheet::ParseExcel->new->Parse(shift) or return;
    bless { book => $book }, $class;
  }
  
  sub book { shift->{book} }
  
  sub sheets {
    map Spreadsheet::ParseExcel::Simple::_Sheet->new($_), 
     @{shift->{book}->{Worksheet}};
  }
  
  package Spreadsheet::ParseExcel::Simple::_Sheet;
  
  sub new {
    my $class = shift;
    my $sheet = shift;
    bless {
      sheet => $sheet,
      row   => $sheet->{MinRow} || 0,
    }, $class;
  }
  
  sub sheet { shift->{sheet} }
  
  sub has_data { 
    my $self = shift;
    defined $self->{sheet}->{MaxRow} and ($self->{row} <= $self->{sheet}->{MaxRow});
  }
  
  sub next_row {
    map { $_ ? $_->Value : "" } @{$_[0]->{sheet}->{Cells}[$_[0]->{row}++]};
  }
  
  1;
  
SPREADSHEET_PARSEEXCEL_SIMPLE

$fatpacked{"Spreadsheet/ParseExcel/Utility.pm"} = <<'SPREADSHEET_PARSEEXCEL_UTILITY';
  package Spreadsheet::ParseExcel::Utility;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Utility - Utility functions for ParseExcel.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  require Exporter;
  use vars qw(@ISA @EXPORT_OK);
  @ISA       = qw(Exporter);
  @EXPORT_OK = qw(ExcelFmt LocaltimeExcel ExcelLocaltime
    col2int int2col sheetRef xls2csv);
  
  our $VERSION = '0.59';
  
  my $qrNUMBER = qr/(^[+-]?\d+(\.\d+)?$)|(^[+-]?\d+\.?(\d*)[eE][+-](\d+))$/;
  
  ###############################################################################
  #
  # ExcelFmt()
  #
  # This function takes an Excel style number format and converts a number into
  # that format. for example: 'hh:mm:ss AM/PM' + 0.01023148 = '12:14:44 AM'.
  #
  # It does this with a type of templating mechanism. The format string is parsed
  # to identify tokens that need to be replaced and their position within the
  # string is recorded. These can be thought of as placeholders. The number is
  # then converted to the required formats and substituted into the placeholders.
  #
  # Interested parties should refer to the Excel documentation on cell formats for
  # more information: http://office.microsoft.com/en-us/excel/HP051995001033.aspx
  # The Microsoft documentation for the Excel Binary File Format, [MS-XLS].pdf,
  # also contains a ABNF grammar for number format strings.
  #
  # Maintainers notes:
  # ==================
  #
  # Note on format subsections:
  # A format string can contain 4 possible sub-sections separated by semi-colons:
  # Positive numbers, negative numbers, zero values, and text.
  # For example: _(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
  #
  # Note on conditional formats.
  # A number format in Excel can have a conditional expression such as:
  #     [>9999999](000)000-0000;000-0000
  # This is equivalent to the following in Perl:
  #     $format = $number > 9999999 ? '(000)000-0000' : '000-0000';
  # Nested conditionals are also possible but we don't support them.
  #
  # Efficiency: The excessive use of substr() isn't very efficient. However,
  # it probably doesn't merit rewriting this function with a parser or regular
  # expressions and \G.
  #
  # TODO: I think the single quote handling may not be required. Check.
  #
  sub ExcelFmt {
  
      my ( $format_str, $number, $is_1904, $number_type, $want_subformats ) = @_;
  
      # Return text strings without further formatting.
      return $number unless $number =~ $qrNUMBER;
  
      # Handle OpenOffice.org GENERAL format.
      $format_str = '@' if uc($format_str) eq "GENERAL";
  
      # Check for a conditional at the start of the format. See notes above.
      my $conditional;
      if ( $format_str =~ /^\[([<>=][^\]]+)\](.*)$/ ) {
          $conditional = $1;
          $format_str  = $2;
      }
  
      # Ignore the underscore token which is used to indicate a padding space.
      $format_str =~ s/_/ /g;
  
      # Split the format string into 4 possible sub-sections: positive numbers,
      # negative numbers, zero values, and text. See notes above.
      my @formats;
      my $section      = 0;
      my $double_quote = 0;
      my $single_quote = 0;
  
      # Initial parsing of the format string to remove escape characters. This
      # also handles quoted strings. See note about single quotes above.
    CHARACTER:
      for my $char ( split //, $format_str ) {
  
          if ( $double_quote or $single_quote ) {
              $formats[$section] .= $char;
              $double_quote = 0 if $char eq '"';
              $single_quote = 0;
              next CHARACTER;
          }
  
          if ( $char eq ';' ) {
              $section++;
              next CHARACTER;
          }
          elsif ( $char eq '"' ) {
              $double_quote = 1;
          }
          elsif ( $char eq '!' ) {
              $single_quote = 1;
          }
          elsif ( $char eq '\\' ) {
              $single_quote = 1;
          }
          elsif ( $char eq '(' ) {
              next CHARACTER;    # Ignore.
          }
          elsif ( $char eq ')' ) {
              next CHARACTER;    # Ignore.
          }
  
          # Convert upper case OpenOffice.org date/time formats to lowercase..
          $char = lc($char) if $char =~ /[DMYHS]/;
  
          $formats[$section] .= $char;
      }
  
      # Select the appropriate format from the 4 possible sub-sections:
      # positive numbers, negative numbers, zero values, and text.
      # We ignore the Text section since non-numeric values are returned
      # unformatted at the start of the function.
      my $format;
      $section = 0;
  
      if ( @formats == 1 ) {
          $section = 0;
      }
      elsif ( @formats == 2 ) {
          if ( $number < 0 ) {
              $section = 1;
          }
          else {
              $section = 0;
          }
      }
      elsif ( @formats == 3 ) {
          if ( $number == 0 ) {
              $section = 2;
          }
          elsif ( $number < 0 ) {
              $section = 1;
          }
          else {
              $section = 0;
          }
      }
      else {
          $section = 0;
      }
  
      # Override the previous choice if the format is conditional.
      if ($conditional) {
  
          # TODO. Replace string eval with a function.
          $section = eval "$number $conditional" ? 0 : 1;
      }
  
      # We now have the required format.
      $format = $formats[$section];
  
      # The format string can contain one of the following colours:
      # [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]
      # or the string [ColorX] where x is a colour index from 1 to 56.
      # We don't use the colour but we return it to the caller.
      #
      my $color = '';
      if ( $format =~ s/^(\[[A-Z][a-z]{2,}(\d{1,2})?\])// ) {
          $color = $1;
      }
  
      # Remove the locale, such as [$-409], from the format string.
      my $locale = '';
      if ( $format =~ s/^(\[\$?-\d+\])// ) {
          $locale = $1;
      }
  
      # Replace currency locale, such as [$$-409], with $ in the format string.
      # See the RT#60547 test cases in 21_number_format_user.t.
      if ( $format =~ s/(\[\$([^-]+)(-\d+)?\])/$2/s ) {
          $locale = $1;
      }
  
  
      # Remove leading # from '# ?/?', '# ??/??' fraction formats.
      $format =~ s{# \?}{?}g;
  
      # Parse the format string and create an AoA of placeholders that contain
      # the parts of the string to be replaced. The format of the information
      # stored is: [ $token, $start_pos, $end_pos, $option_info ].
      #
      my $format_mode  = '';    # Either: '', 'number', 'date'
      my $pos          = 0;     # Character position within format string.
      my @placeholders = ();    # Arefs with parts of the format to be replaced.
      my $token        = '';    # The actual format extracted from the total str.
      my $start_pos;            # A position variable. Initial parser position.
      my $token_start = -1;     # A position variable.
      my $decimal_pos = -1;     # Position of the punctuation char "." or ",".
      my $comma_count = 0;      # Count of the commas in the format.
      my $is_fraction = 0;      # Number format is a fraction.
      my $is_currency = 0;      # Number format is a currency.
      my $is_percent  = 0;      # Number format is a percentage.
      my $is_12_hour  = 0;      # Time format is using 12 hour clock.
      my $seen_dot    = 0;      # Treat only the first "." as the decimal point.
  
      # Parse the format.
    PARSER:
      while ( $pos < length $format ) {
          $start_pos = $pos;
          my $char = substr( $format, $pos, 1 );
  
          # Ignore control format characters such as '#0+-.?eE,%'. However,
          # only ignore '.' if it is the first one encountered. RT 45502.
          if ( ( !$seen_dot && $char !~ /[#0\+\-\.\?eE\,\%]/ )
              || $char !~ /[#0\+\-\?eE\,\%]/ )
          {
  
              if ( $token_start != -1 ) {
                  push @placeholders,
                    [
                      substr( $format, $token_start, $pos - $token_start ),
                      $decimal_pos, $pos - $token_start
                    ];
                  $token_start = -1;
              }
          }
  
          # Processing for quoted strings within the format. See notes above.
          if ( $char eq '"' ) {
              $double_quote = $double_quote ? 0 : 1;
              $pos++;
              next PARSER;
          }
          elsif ( $char eq '!' ) {
              $single_quote = 1;
              $pos++;
              next PARSER;
          }
          elsif ( $char eq '\\' ) {
              if ( $single_quote != 1 ) {
                  $single_quote = 1;
                  $pos++;
                  next PARSER;
              }
          }
  
          if (   ( defined($double_quote) and ($double_quote) )
              or ( defined($single_quote) and ($single_quote) )
              or ( $seen_dot && $char eq '.' ) )
          {
              $single_quote = 0;
              if (
                  ( $format_mode ne 'date' )
                  and (  ( substr( $format, $pos, 2 ) eq "\x81\xA2" )
                      || ( substr( $format, $pos, 2 ) eq "\x81\xA3" )
                      || ( substr( $format, $pos, 2 ) eq "\xA2\xA4" )
                      || ( substr( $format, $pos, 2 ) eq "\xA2\xA5" ) )
                )
              {
  
                  # The above matches are currency symbols.
                  push @placeholders,
                    [ substr( $format, $pos, 2 ), length($token), 2 ];
                  $is_currency = 1;
                  $pos += 2;
              }
              else {
                  $pos++;
              }
          }
          elsif (
              ( $char =~ /[#0\+\.\?eE\,\%]/ )
              || (    ( $format_mode ne 'date' )
                  and ( ( $char eq '-' ) || ( $char eq '(' ) || ( $char eq ')' ) )
              )
            )
          {
              $format_mode = 'number' unless $format_mode;
              if ( substr( $format, $pos, 1 ) =~ /[#0]/ ) {
                  if (
                      substr( $format, $pos ) =~
                      /^([#0]+[\.]?[0#]*[eE][\+\-][0#]+)/ )
                  {
                      push @placeholders, [ $1, $pos, length($1) ];
                      $pos += length($1);
                  }
                  else {
                      if ( $token_start == -1 ) {
                          $token_start = $pos;
                          $decimal_pos = length($token);
                      }
                  }
              }
              elsif ( substr( $format, $pos, 1 ) eq '?' ) {
  
                  # Look for a fraction format like ?/? or ??/??
                  if ( $token_start != -1 ) {
                      push @placeholders,
                        [
                          substr(
                              $format, $token_start, $pos - $token_start + 1
                          ),
                          $decimal_pos,
                          $pos - $token_start + 1
                        ];
                  }
                  $token_start = $pos;
  
                  # Find the end of the fraction format.
                FRACTION:
                  while ( $pos < length($format) ) {
                      if ( substr( $format, $pos, 1 ) eq '/' ) {
                          $is_fraction = 1;
                      }
                      elsif ( substr( $format, $pos, 1 ) eq '?' ) {
                          $pos++;
                          next FRACTION;
                      }
                      else {
                          if ( $is_fraction
                              && ( substr( $format, $pos, 1 ) =~ /[0-9]/ ) )
                          {
  
                              # TODO: Could invert if() logic and remove this.
                              $pos++;
                              next FRACTION;
                          }
                          else {
                              last FRACTION;
                          }
                      }
                      $pos++;
                  }
                  $pos--;
  
                  push @placeholders,
                    [
                      substr( $format, $token_start, $pos - $token_start + 1 ),
                      length($token), $pos - $token_start + 1
                    ];
                  $token_start = -1;
              }
              elsif ( substr( $format, $pos, 3 ) =~ /^[eE][\+\-][0#]$/ ) {
                  if ( substr( $format, $pos ) =~ /([eE][\+\-][0#]+)/ ) {
                      push @placeholders, [ $1, $pos, length($1) ];
                      $pos += length($1);
                  }
                  $token_start = -1;
              }
              else {
                  if ( $token_start != -1 ) {
                      push @placeholders,
                        [
                          substr( $format, $token_start, $pos - $token_start ),
                          $decimal_pos, $pos - $token_start
                        ];
                      $token_start = -1;
                  }
                  if ( substr( $format, $pos, 1 ) =~ /[\+\-]/ ) {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                      $is_currency = 1;
                  }
                  elsif ( substr( $format, $pos, 1 ) eq '.' ) {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                      $seen_dot = 1;
                  }
                  elsif ( substr( $format, $pos, 1 ) eq ',' ) {
                      $comma_count++;
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                  }
                  elsif ( substr( $format, $pos, 1 ) eq '%' ) {
                      $is_percent = 1;
                  }
                  elsif (( substr( $format, $pos, 1 ) eq '(' )
                      || ( substr( $format, $pos, 1 ) eq ')' ) )
                  {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                      $is_currency = 1;
                  }
              }
              $pos++;
          }
          elsif ( $char =~ /[ymdhsapg]/i ) {
              $format_mode = 'date' unless $format_mode;
              if ( substr( $format, $pos, 5 ) =~ /am\/pm/i ) {
                  push @placeholders, [ 'am/pm', length($token), 5 ];
                  $is_12_hour = 1;
                  $pos += 5;
              }
              elsif ( substr( $format, $pos, 3 ) =~ /a\/p/i ) {
                  push @placeholders, [ 'a/p', length($token), 3 ];
                  $is_12_hour = 1;
                  $pos += 3;
              }
              elsif ( substr( $format, $pos, 5 ) eq 'mmmmm' ) {
                  push @placeholders, [ 'mmmmm', length($token), 5 ];
                  $pos += 5;
              }
              elsif (( substr( $format, $pos, 4 ) eq 'mmmm' )
                  || ( substr( $format, $pos, 4 ) eq 'dddd' )
                  || ( substr( $format, $pos, 4 ) eq 'yyyy' )
                  || ( substr( $format, $pos, 4 ) eq 'ggge' ) )
              {
                  push @placeholders,
                    [ substr( $format, $pos, 4 ), length($token), 4 ];
                  $pos += 4;
              }
              elsif (( substr( $format, $pos, 3 ) eq 'ddd' )
                  || ( substr( $format, $pos, 3 ) eq 'mmm' )
                  || ( substr( $format, $pos, 3 ) eq 'yyy' ) )
              {
                  push @placeholders,
                    [ substr( $format, $pos, 3 ), length($token), 3 ];
                  $pos += 3;
              }
              elsif (( substr( $format, $pos, 2 ) eq 'yy' )
                  || ( substr( $format, $pos, 2 ) eq 'mm' )
                  || ( substr( $format, $pos, 2 ) eq 'dd' )
                  || ( substr( $format, $pos, 2 ) eq 'hh' )
                  || ( substr( $format, $pos, 2 ) eq 'ss' )
                  || ( substr( $format, $pos, 2 ) eq 'ge' ) )
              {
                  if (
                         ( substr( $format, $pos, 2 ) eq 'mm' )
                      && (@placeholders)
                      && (   ( $placeholders[-1]->[0] eq 'h' )
                          or ( $placeholders[-1]->[0] eq 'hh' ) )
                    )
                  {
  
                      # For this case 'm' is minutes not months.
                      push @placeholders, [ 'mm', length($token), 2, 'minutes' ];
                  }
                  else {
                      push @placeholders,
                        [ substr( $format, $pos, 2 ), length($token), 2 ];
                  }
                  if (   ( substr( $format, $pos, 2 ) eq 'ss' )
                      && ( @placeholders > 1 ) )
                  {
                      if (   ( $placeholders[-2]->[0] eq 'm' )
                          || ( $placeholders[-2]->[0] eq 'mm' ) )
                      {
  
                          # For this case 'm' is minutes not months.
                          push( @{ $placeholders[-2] }, 'minutes' );
                      }
                  }
                  $pos += 2;
              }
              elsif (( substr( $format, $pos, 1 ) eq 'm' )
                  || ( substr( $format, $pos, 1 ) eq 'd' )
                  || ( substr( $format, $pos, 1 ) eq 'h' )
                  || ( substr( $format, $pos, 1 ) eq 's' ) )
              {
                  if (
                         ( substr( $format, $pos, 1 ) eq 'm' )
                      && (@placeholders)
                      && (   ( $placeholders[-1]->[0] eq 'h' )
                          or ( $placeholders[-1]->[0] eq 'hh' ) )
                    )
                  {
  
                      # For this case 'm' is minutes not months.
                      push @placeholders, [ 'm', length($token), 1, 'minutes' ];
                  }
                  else {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                  }
                  if (   ( substr( $format, $pos, 1 ) eq 's' )
                      && ( @placeholders > 1 ) )
                  {
                      if (   ( $placeholders[-2]->[0] eq 'm' )
                          || ( $placeholders[-2]->[0] eq 'mm' ) )
                      {
  
                          # For this case 'm' is minutes not months.
                          push( @{ $placeholders[-2] }, 'minutes' );
                      }
                  }
                  $pos += 1;
              }
          }
          elsif ( ( substr( $format, $pos, 3 ) eq '[h]' ) ) {
              $format_mode = 'date' unless $format_mode;
              push @placeholders, [ '[h]', length($token), 3 ];
              $pos += 3;
          }
          elsif ( ( substr( $format, $pos, 4 ) eq '[mm]' ) ) {
              $format_mode = 'date' unless $format_mode;
              push @placeholders, [ '[mm]', length($token), 4 ];
              $pos += 4;
          }
          elsif ( $char eq '@' ) {
              push @placeholders, [ '@', length($token), 1 ];
              $pos++;
          }
          elsif ( $char eq '*' ) {
              push @placeholders,
                [ substr( $format, $pos, 1 ), length($token), 1 ];
          }
          else {
              $pos++;
          }
          $pos++ if ( $pos == $start_pos );    #No Format match
          $token .= substr( $format, $start_pos, $pos - $start_pos );
  
      }    # End of parsing.
  
      # Copy the located format string to a result string that we will perform
      # the substitutions on and return to the user.
      my $result = $token;
  
      # Add a placeholder between the decimal/comma and end of the token, if any.
      if ( $token_start != -1 ) {
          push @placeholders,
            [
              substr( $format, $token_start, $pos - $token_start + 1 ),
              $decimal_pos, $pos - $token_start + 1
            ];
      }
  
      #
      # In the next sections we process date, number and text formats. We take a
      # format such as yyyy/mm/dd and replace it with something like 2008/12/25.
      #
      if ( ( $format_mode eq 'date' ) && ( $number =~ $qrNUMBER ) ) {
  
          # The maximum allowable date in Excel is 9999-12-31T23:59:59.000 which
          # equates to 2958465.999+ in the 1900 epoch and 2957003.999+ in the
          # 1904 epoch. We use 0 as the minimum in both epochs. The 1904 system
          # actually supports negative numbers but that isn't worth the effort.
          my $min_date = 0;
          my $max_date = 2958466;
          $max_date = 2957004 if $is_1904;
  
          if ( $number < $min_date || $number >= $max_date ) {
              return $number;    # Return unformatted number.
          }
  
          # Process date formats.
          my @time = ExcelLocaltime( $number, $is_1904 );
  
          #    0     1     2      3     4       5      6      7
          my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;
  
          $month++;              # localtime() zero indexed month.
          $year += 1900;         # localtime() year.
  
          my @full_month_name = qw(
            None January February March April May June July
            August September October November December
          );
          my @short_month_name = qw(
            None Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
          );
          my @full_day_name = qw(
            Sunday Monday Tuesday Wednesday Thursday Friday Saturday
          );
          my @short_day_name = qw(
            Sun Mon Tue Wed Thu Fri Sat
          );
  
          # Replace the placeholders in the template such as yyyy mm dd with
          # actual numbers or strings.
          my $replacement;
          for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {
              my $placeholder = $placeholders[$i];
  
              if ( $placeholder->[-1] eq 'minutes' ) {
  
                  # For this case 'm/mm' is minutes not months.
                  if ( $placeholder->[0] eq 'mm' ) {
                      $replacement = sprintf( "%02d", $min );
                  }
                  else {
                      $replacement = sprintf( "%d", $min );
                  }
              }
              elsif ( $placeholder->[0] eq 'yyyy' ) {
  
                  # 4 digit Year. 2000 -> 2000.
                  $replacement = sprintf( '%04d', $year );
              }
              elsif ( $placeholder->[0] eq 'yy' ) {
  
                  # 2 digit Year. 2000 -> 00.
                  $replacement = sprintf( '%02d', $year % 100 );
              }
              elsif ( $placeholder->[0] eq 'mmmmm' ) {
  
                  # First character of the month name. 1 -> J.
                  $replacement = substr( $short_month_name[$month], 0, 1 );
              }
              elsif ( $placeholder->[0] eq 'mmmm' ) {
  
                  # Full month name. 1 -> January.
                  $replacement = $full_month_name[$month];
              }
              elsif ( $placeholder->[0] eq 'mmm' ) {
  
                  # Short month name. 1 -> Jan.
                  $replacement = $short_month_name[$month];
              }
              elsif ( $placeholder->[0] eq 'mm' ) {
  
                  # 2 digit month. 1 -> 01.
                  $replacement = sprintf( '%02d', $month );
              }
              elsif ( $placeholder->[0] eq 'm' ) {
  
                  # 1 digit month. 1 -> 1.
                  $replacement = sprintf( '%d', $month );
              }
              elsif ( $placeholder->[0] eq 'dddd' ) {
  
                  # Full day name. Wednesday (for example.)
                  $replacement = $full_day_name[$wday];
              }
              elsif ( $placeholder->[0] eq 'ddd' ) {
  
                  # Short day name. Wed (for example.)
                  $replacement = $short_day_name[$wday];
              }
              elsif ( $placeholder->[0] eq 'dd' ) {
  
                  # 2 digit day. 1 -> 01.
                  $replacement = sprintf( '%02d', $day );
              }
              elsif ( $placeholder->[0] eq 'd' ) {
  
                  # 1 digit day. 1 -> 1.
                  $replacement = sprintf( '%d', $day );
              }
              elsif ( $placeholder->[0] eq 'hh' ) {
  
                  # 2 digit hour.
                  if ($is_12_hour) {
                      my $hour_tmp = $hour % 12;
                      $hour_tmp = 12 if $hour % 12 == 0;
                      $replacement = sprintf( '%d', $hour_tmp );
                  }
                  else {
                      $replacement = sprintf( '%02d', $hour );
                  }
              }
              elsif ( $placeholder->[0] eq 'h' ) {
  
                  # 1 digit hour.
                  if ($is_12_hour) {
                      my $hour_tmp = $hour % 12;
                      $hour_tmp = 12 if $hour % 12 == 0;
                      $replacement = sprintf( '%2d', $hour_tmp );
                  }
                  else {
                      $replacement = sprintf( '%d', $hour );
                  }
              }
              elsif ( $placeholder->[0] eq 'ss' ) {
  
                  # 2 digit seconds.
                  $replacement = sprintf( '%02d', $sec );
              }
              elsif ( $placeholder->[0] eq 's' ) {
  
                  # 1 digit seconds.
                  $replacement = sprintf( '%d', $sec );
              }
              elsif ( $placeholder->[0] eq 'am/pm' ) {
  
                  # AM/PM.
                  $replacement = ( $hour >= 12 ) ? 'PM' : 'AM';
              }
              elsif ( $placeholder->[0] eq 'a/p' ) {
  
                  # AM/PM.
                  $replacement = ( $hour >= 12 ) ? 'P' : 'A';
              }
              elsif ( $placeholder->[0] eq '.' ) {
  
                  # Decimal point for seconds.
                  $replacement = '.';
              }
              elsif ( $placeholder->[0] =~ /(^0+$)/ ) {
  
                  # Milliseconds. For example h:ss.000.
                  my $length = length($1);
                  $replacement =
                    substr( sprintf( "%.${length}f", $msec / 1000 ), 2, $length );
              }
              elsif ( $placeholder->[0] eq '[h]' ) {
  
                  # Hours modulus 24. 25 displays as 25 not as 1.
                  $replacement = sprintf( '%d', int($number) * 24 + $hour );
              }
              elsif ( $placeholder->[0] eq '[mm]' ) {
  
                  # Mins modulus 60. 72 displays as 72 not as 12.
                  $replacement =
                    sprintf( '%d', ( int($number) * 24 + $hour ) * 60 + $min );
              }
              elsif ( $placeholder->[0] eq 'ge' ) {
                  require Spreadsheet::ParseExcel::FmtJapan;
                  # Japanese Nengo (aka Gengo) in initialism (abbr. name)
                   $replacement =
                    Spreadsheet::ParseExcel::FmtJapan::CnvNengo( abbr_name => @time );
              }
              elsif ( $placeholder->[0] eq 'ggge' ) {
                  require Spreadsheet::ParseExcel::FmtJapan;
                  # Japanese Nengo (aka Gengo) in Kanji (full name)
                   $replacement =
                    Spreadsheet::ParseExcel::FmtJapan::CnvNengo( name => @time );
              }
              elsif ( $placeholder->[0] eq '@' ) {
  
                  # Text format.
                  $replacement = $number;
              }
  
              # Substitute the replacement string back into the template.
              substr( $result, $placeholder->[1], $placeholder->[2],
                  $replacement );
          }
      }
      elsif ( ( $format_mode eq 'number' ) && ( $number =~ $qrNUMBER ) ) {
  
          # Process non date formats.
          if (@placeholders) {
              while ( $placeholders[-1]->[0] eq ',' ) {
                  $comma_count--;
                  substr(
                      $result,
                      $placeholders[-1]->[1],
                      $placeholders[-1]->[2], ''
                  );
                  $number /= 1000;
                  pop @placeholders;
              }
  
              my $number_format = join( '', map { $_->[0] } @placeholders );
              my $number_result;
              my $str_length    = 0;
              my $engineering   = 0;
              my $is_decimal    = 0;
              my $is_integer    = 0;
              my $after_decimal = undef;
  
              for my $token ( split //, $number_format ) {
                  if ( $token eq '.' ) {
                      $str_length++;
                      $is_decimal = 1;
                  }
                  elsif ( ( $token eq 'E' ) || ( $token eq 'e' ) ) {
                      $engineering = 1;
                  }
                  elsif ( $token eq '0' ) {
                      $str_length++;
                      $after_decimal++ if $is_decimal;
                      $is_integer = 1;
                  }
                  elsif ( $token eq '#' ) {
                      $after_decimal++ if $is_decimal;
                      $is_integer = 1;
                  }
                  elsif ( $token eq '?' ) {
                      $after_decimal++ if $is_decimal;
                  }
              }
  
              $number *= 100.0 if $is_percent;
  
              my $data = ($is_currency) ? abs($number) : $number + 0;
  
              if ($is_fraction) {
                  $number_result = sprintf( "%0${str_length}d", int($data) );
              }
              else {
                  if ($is_decimal) {
  
                      if ( defined $after_decimal ) {
                          $number_result =
                            sprintf "%0${str_length}.${after_decimal}f", $data;
                      }
                      else {
                          $number_result = sprintf "%0${str_length}f", $data;
                      }
  
                      # Fix for Perl and sprintf not rounding up like Excel.
                      # http://rt.cpan.org/Public/Bug/Display.html?id=45626
                      if ( $data =~ /^${number_result}5/ ) {
                          $number_result =
                            sprintf "%0${str_length}.${after_decimal}f",
                            $data . '1';
                      }
                  }
                  else {
                      $number_result = sprintf( "%0${str_length}.0f", $data );
                  }
              }
  
              $number_result = AddComma($number_result) if $comma_count > 0;
  
              my $number_length = length($number_result);
              my $decimal_pos   = -1;
              my $replacement;
  
              for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {
                  my $placeholder = $placeholders[$i];
  
                  if ( $placeholder->[0] =~
                      /([#0]*)([\.]?)([0#]*)([eE])([\+\-])([0#]+)/ )
                  {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          MakeE( $placeholder->[0], $number ) );
                  }
                  elsif ( $placeholder->[0] =~ /\// ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          MakeFraction( $placeholder->[0], $number, $is_integer )
                      );
                  }
                  elsif ( $placeholder->[0] eq '.' ) {
                      $number_length--;
                      $decimal_pos = $number_length;
                  }
                  elsif ( $placeholder->[0] eq '+' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          ( $number > 0 )
                          ? '+'
                          : ( ( $number == 0 ) ? '+' : '-' ) );
                  }
                  elsif ( $placeholder->[0] eq '-' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          ( $number > 0 )
                          ? ''
                          : ( ( $number == 0 ) ? '' : '-' ) );
                  }
                  elsif ( $placeholder->[0] eq '@' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          $number );
                  }
                  elsif ( $placeholder->[0] eq '*' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2], '' );
                  }
                  elsif (( $placeholder->[0] eq "\xA2\xA4" )
                      or ( $placeholder->[0] eq "\xA2\xA5" )
                      or ( $placeholder->[0] eq "\x81\xA2" )
                      or ( $placeholder->[0] eq "\x81\xA3" ) )
                  {
                      substr(
                          $result,           $placeholder->[1],
                          $placeholder->[2], $placeholder->[0]
                      );
                  }
                  elsif (( $placeholder->[0] eq '(' )
                      or ( $placeholder->[0] eq ')' ) )
                  {
                      substr(
                          $result,           $placeholder->[1],
                          $placeholder->[2], $placeholder->[0]
                      );
                  }
                  else {
                      if ( $number_length > 0 ) {
                          if ( $i <= 0 ) {
                              $replacement =
                                substr( $number_result, 0, $number_length );
                              $number_length = 0;
                          }
                          else {
                              my $real_part_length = length( $placeholder->[0] );
                              if ( $decimal_pos >= 0 ) {
                                  my $format = $placeholder->[0];
                                  $format =~ s/^#+//;
                                  $real_part_length = length $format;
                                  $real_part_length =
                                    ( $number_length <= $real_part_length )
                                    ? $number_length
                                    : $real_part_length;
                              }
                              else {
                                  $real_part_length =
                                    ( $number_length <= $real_part_length )
                                    ? $number_length
                                    : $real_part_length;
                              }
                              $replacement =
                                substr( $number_result,
                                  $number_length - $real_part_length,
                                  $real_part_length );
                              $number_length -= $real_part_length;
                          }
                      }
                      else {
                          $replacement = '';
                      }
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          "\x00" . $replacement );
                  }
              }
              $replacement =
                ( $number_length > 0 )
                ? substr( $number_result, 0, $number_length )
                : '';
              $result =~ s/\x00/$replacement/;
              $result =~ s/\x00//g;
          }
      }
      else {
  
          # Process text formats
          my $is_text = 0;
          for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {
              my $placeholder = $placeholders[$i];
              if ( $placeholder->[0] eq '@' ) {
                  substr( $result, $placeholder->[1], $placeholder->[2],
                      $number );
                  $is_text++;
              }
              else {
                  substr( $result, $placeholder->[1], $placeholder->[2], '' );
              }
          }
  
          $result = $number unless $is_text;
  
      }    # End of placeholder substitutions.
  
      # Trim the leading and trailing whitespace from the results.
      $result =~ s/^\s+//;
      $result =~ s/\s+$//;
  
      # Fix for negative currency.
      $result =~ s/^\$\-/\-\$/;
      $result =~ s/^\$ \-/\-\$ /;
  
      # Return color and locale strings if required.
      if ($want_subformats) {
          return ( $result, $color, $locale );
      }
      else {
          return $result;
      }
  }
  
  #------------------------------------------------------------------------------
  # AddComma (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub AddComma {
      my ($sNum) = @_;
  
      if ( $sNum =~ /^([^\d]*)(\d\d\d\d+)(\.*.*)$/ ) {
          my ( $sPre, $sObj, $sAft ) = ( $1, $2, $3 );
          for ( my $i = length($sObj) - 3 ; $i > 0 ; $i -= 3 ) {
              substr( $sObj, $i, 0, ',' );
          }
          return $sPre . $sObj . $sAft;
      }
      else {
          return $sNum;
      }
  }
  
  #------------------------------------------------------------------------------
  # MakeFraction (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub MakeFraction {
      my ( $sFmt, $iData, $iFlg ) = @_;
      my $iBunbo;
      my $iShou;
  
      #1. Init
      # print "FLG: $iFlg\n";
      if ($iFlg) {
          $iShou = $iData - int($iData);
          return '' if ( $iShou == 0 );
      }
      else {
          $iShou = $iData;
      }
      $iShou = abs($iShou);
      my $sSWk;
  
      #2.Calc BUNBO
      #2.1 BUNBO defined
      if ( $sFmt =~ /\/(\d+)$/ ) {
          $iBunbo = $1;
          return sprintf( "%d/%d", $iShou * $iBunbo, $iBunbo );
      }
      else {
  
          #2.2 Calc BUNBO
          $sFmt =~ /\/(\?+)$/;
          my $iKeta = length($1);
          my $iSWk  = 1;
          my $sSWk  = '';
          my $iBunsi;
          for ( my $iBunbo = 2 ; $iBunbo < 10**$iKeta ; $iBunbo++ ) {
              $iBunsi = int( $iShou * $iBunbo + 0.5 );
              my $iCmp = abs( $iShou - ( $iBunsi / $iBunbo ) );
              if ( $iCmp < $iSWk ) {
                  $iSWk = $iCmp;
                  $sSWk = sprintf( "%d/%d", $iBunsi, $iBunbo );
                  last if ( $iSWk == 0 );
              }
          }
          return $sSWk;
      }
  }
  
  #------------------------------------------------------------------------------
  # MakeE (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub MakeE {
      my ( $sFmt, $iData ) = @_;
  
      $sFmt =~ /(([#0]*)[\.]?[#0]*)([eE])([\+\-][0#]+)/;
      my ( $sKari, $iKeta, $sE, $sSisu ) = ( $1, length($2), $3, $4 );
      $iKeta = 1 if ( $iKeta <= 0 );
  
      my $iLog10 = 0;
      $iLog10 = ( $iData == 0 ) ? 0 : ( log( abs($iData) ) / log(10) );
      $iLog10 = (
          int( $iLog10 / $iKeta ) +
            ( ( ( $iLog10 - int( $iLog10 / $iKeta ) ) < 0 ) ? -1 : 0 ) ) * $iKeta;
  
      my $sUe = ExcelFmt( $sKari, $iData * ( 10**( $iLog10 * -1 ) ), 0 );
      my $sShita = ExcelFmt( $sSisu, $iLog10, 0 );
      return $sUe . $sE . $sShita;
  }
  
  #------------------------------------------------------------------------------
  # LeapYear (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub LeapYear {
      my ($iYear) = @_;
      return 1 if ( $iYear == 1900 );    #Special for Excel
      return ( ( ( $iYear % 4 ) == 0 )
            && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) )
        ? 1
        : 0;
  }
  
  #------------------------------------------------------------------------------
  # LocaltimeExcel (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub LocaltimeExcel {
      my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec, $flg1904 )
        = @_;
  
      #0. Init
      $iMon++;
      $iYear += 1900;
  
      #1. Calc Time
      my $iTime;
      $iTime = $iHour;
      $iTime *= 60;
      $iTime += $iMin;
      $iTime *= 60;
      $iTime += $iSec;
      $iTime += $iMSec / 1000.0 if ( defined($iMSec) );
      $iTime /= 86400.0;    #3600*24(1day in seconds)
      my $iY;
      my $iYDays;
  
      #2. Calc Days
      if ($flg1904) {
          $iY = 1904;
          $iTime--;         #Start from Jan 1st
          $iYDays = 366;
      }
      else {
          $iY     = 1900;
          $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)
      }
      while ( $iY < $iYear ) {
          $iTime += $iYDays;
          $iY++;
          $iYDays = ( LeapYear($iY) ) ? 366 : 365;
      }
      for ( my $iM = 1 ; $iM < $iMon ; $iM++ ) {
          if (   $iM == 1
              || $iM == 3
              || $iM == 5
              || $iM == 7
              || $iM == 8
              || $iM == 10
              || $iM == 12 )
          {
              $iTime += 31;
          }
          elsif ( $iM == 4 || $iM == 6 || $iM == 9 || $iM == 11 ) {
              $iTime += 30;
          }
          elsif ( $iM == 2 ) {
              $iTime += ( LeapYear($iYear) ) ? 29 : 28;
          }
      }
      $iTime += $iDay;
      return $iTime;
  }
  
  #------------------------------------------------------------------------------
  # ExcelLocaltime (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub ExcelLocaltime {
  
      my ( $dObj, $flg1904 ) = @_;
      my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );
      my ( $iDt, $iTime, $iYDays );
  
      $iDt   = int($dObj);
      $iTime = $dObj - $iDt;
  
      #1. Calc Days
      if ($flg1904) {
          $iYear = 1904;
          $iDt++;    #Start from Jan 1st
          $iYDays = 366;
          $iwDay = ( ( $iDt + 4 ) % 7 );
      }
      else {
          $iYear  = 1900;
          $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)
          $iwDay = ( ( $iDt + 6 ) % 7 );
      }
      while ( $iDt > $iYDays ) {
          $iDt -= $iYDays;
          $iYear++;
          $iYDays =
            (      ( ( $iYear % 4 ) == 0 )
                && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) ) ? 366 : 365;
      }
      $iYear -= 1900;       # Localtime year is relative to 1900.
  
      for ( $iMon = 1 ; $iMon < 12 ; $iMon++ ) {
          my $iMD;
          if (   $iMon == 1
              || $iMon == 3
              || $iMon == 5
              || $iMon == 7
              || $iMon == 8
              || $iMon == 10
              || $iMon == 12 )
          {
              $iMD = 31;
          }
          elsif ( $iMon == 4 || $iMon == 6 || $iMon == 9 || $iMon == 11 ) {
              $iMD = 30;
          }
          elsif ( $iMon == 2 ) {
              $iMD = ( ( $iYear % 4 ) == 0 ) ? 29 : 28;
          }
          last if ( $iDt <= $iMD );
          $iDt -= $iMD;
      }
  
      $iMon -= 1;    # Localtime month is 0 based.
  
      #2. Calc Time
      $iDay = $iDt;
      $iTime += ( 0.0005 / 86400.0 );
      $iTime *= 24.0;
      $iHour = int($iTime);
      $iTime -= $iHour;
      $iTime *= 60.0;
      $iMin = int($iTime);
      $iTime -= $iMin;
      $iTime *= 60.0;
      $iSec = int($iTime);
      $iTime -= $iSec;
      $iTime *= 1000.0;
      $iMSec = int($iTime);
  
      return ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );
  }
  
  # -----------------------------------------------------------------------------
  # col2int (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  # converts a excel row letter into an int for use in an array
  sub col2int {
      my $result = 0;
      my $str    = shift;
      my $incr   = 0;
  
      for ( my $i = length($str) ; $i > 0 ; $i-- ) {
          my $char = substr( $str, $i - 1 );
          my $curr += ord( lc($char) ) - ord('a') + 1;
          $curr *= $incr if ($incr);
          $result += $curr;
          $incr   += 26;
      }
  
      # this is one out as we range 0..x-1 not 1..x
      $result--;
  
      return $result;
  }
  
  # -----------------------------------------------------------------------------
  # int2col (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  ### int2col
  # convert a column number into column letters
  # @note this is quite a brute force coarse method
  #   does not manage values over 701 (ZZ)
  # @arg number, to convert
  # @returns string, column name
  #
  sub int2col {
      my $out = "";
      my $val = shift;
  
      do {
          $out .= chr( ( $val % 26 ) + ord('A') );
          $val = int( $val / 26 ) - 1;
      } while ( $val >= 0 );
  
      return scalar reverse $out;
  }
  
  # -----------------------------------------------------------------------------
  # sheetRef (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  # -----------------------------------------------------------------------------
  ### sheetRef
  # convert an excel letter-number address into a useful array address
  # @note that also Excel uses X-Y notation, we normally use Y-X in arrays
  # @args $str, excel coord eg. A2
  # @returns an array - 2 elements - column, row, or undefined
  #
  sub sheetRef {
      my $str = shift;
      my @ret;
  
      $str =~ m/^(\D+)(\d+)$/;
  
      if ( $1 && $2 ) {
          push( @ret, $2 - 1, col2int($1) );
      }
      if ( $ret[0] < 0 ) {
          undef @ret;
      }
  
      return @ret;
  }
  
  # -----------------------------------------------------------------------------
  # xls2csv (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  ### xls2csv
  # convert a chunk of an excel file into csv text chunk
  # @args $param, sheet-colrow:colrow (1-A1:B2 or A1:B2 for sheet 1
  # @args $rotate, 0 or 1 decides if output should be rotated or not
  # @returns string containing a chunk of csv
  #
  sub xls2csv {
      my ( $filename, $regions, $rotate ) = @_;
      my $sheet = 0;
  
      # We need Text::CSV_XS for proper CSV handling.
      require Text::CSV_XS;
  
      # extract any sheet number from the region string
      $regions =~ m/^(\d+)-(.*)/;
  
      if ($2) {
          $sheet   = $1 - 1;
          $regions = $2;
      }
  
      # now extract the start and end regions
      $regions =~ m/(.*):(.*)/;
  
      if ( !$1 || !$2 ) {
          print STDERR "Bad Params";
          return "";
      }
  
      my @start = sheetRef($1);
      my @end   = sheetRef($2);
      if ( !@start ) {
          print STDERR "Bad coorinates - $1";
          return "";
      }
      if ( !@end ) {
          print STDERR "Bad coorinates - $2";
          return "";
      }
  
      if ( $start[1] > $end[1] ) {
          print STDERR "Bad COLUMN ordering\n";
          print STDERR "Start column " . int2col( $start[1] );
          print STDERR " after end column " . int2col( $end[1] ) . "\n";
          return "";
      }
      if ( $start[0] > $end[0] ) {
          print STDERR "Bad ROW ordering\n";
          print STDERR "Start row " . ( $start[0] + 1 );
          print STDERR " after end row " . ( $end[0] + 1 ) . "\n";
          exit;
      }
  
      # start the excel object now
      my $oExcel = new Spreadsheet::ParseExcel;
      my $oBook  = $oExcel->Parse($filename);
  
      # open the sheet
      my $oWkS = $oBook->{Worksheet}[$sheet];
  
      # now check that the region exists in the file
      # if not truncate to the possible region
      # output a warning msg
      if ( $start[1] < $oWkS->{MinCol} ) {
          print STDERR int2col( $start[1] )
            . " < min col "
            . int2col( $oWkS->{MinCol} )
            . " Resetting\n";
          $start[1] = $oWkS->{MinCol};
      }
      if ( $end[1] > $oWkS->{MaxCol} ) {
          print STDERR int2col( $end[1] )
            . " > max col "
            . int2col( $oWkS->{MaxCol} )
            . " Resetting\n";
          $end[1] = $oWkS->{MaxCol};
      }
      if ( $start[0] < $oWkS->{MinRow} ) {
          print STDERR ""
            . ( $start[0] + 1 )
            . " < min row "
            . ( $oWkS->{MinRow} + 1 )
            . " Resetting\n";
          $start[0] = $oWkS->{MinCol};
      }
      if ( $end[0] > $oWkS->{MaxRow} ) {
          print STDERR ""
            . ( $end[0] + 1 )
            . " > max row "
            . ( $oWkS->{MaxRow} + 1 )
            . " Resetting\n";
          $end[0] = $oWkS->{MaxRow};
  
      }
  
      my $x1 = $start[1];
      my $y1 = $start[0];
      my $x2 = $end[1];
      my $y2 = $end[0];
  
      my @cell_data;
      my $row = 0;
  
      if ( !$rotate ) {
          for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {
              for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {
                  my $cell = $oWkS->{Cells}[$y][$x];
  
                  my $value;
                  if ( defined $cell ) {
                      $value .= $cell->value();
                  }
                  else {
                      $value = '';
                  }
  
                  push @{ $cell_data[$row] }, $value;
              }
              $row++;
          }
      }
      else {
          for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {
              for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {
                  my $cell = $oWkS->{Cells}[$y][$x];
  
                  my $value;
                  if ( defined $cell ) {
                      $value .= $cell->value();
                  }
                  else {
                      $value = '';
                  }
  
                  push @{ $cell_data[$row] }, $value;
              }
              $row++;
          }
      }
  
      # Create the CSV output string.
      my $csv = Text::CSV_XS->new( { binary => 1, eol => $/ } );
      my $output = "";
  
      for my $row (@cell_data) {
          $csv->combine(@$row);
          $output .= $csv->string();
      }
  
      return $output;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Utility - Utility functions for Spreadsheet::ParseExcel.
  
  =head1 SYNOPSIS
  
      use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);
  
      # Convert localtime to Excel time
      my $datetime = LocaltimeExcel(11, 10, 12, 23, 2, 64); # 1964-3-23 12:10:11
  
      print $datetime, "\n"; # 23459.5070717593 (Excel date/time format)
  
      # Convert Excel Time to localtime
      my @time = ExcelLocaltime($datetime);
      print join(":", @time), "\n";   # 11:10:12:23:2:64:1:0
  
      # Formatting
      print ExcelFmt('yyyy-mm-dd', $datetime), "\n"; # 1964-3-23
      print ExcelFmt('m-d-yy',     $datetime), "\n"; # 3-23-64
      print ExcelFmt('#,##0',      $datetime), "\n"; # 23,460
      print ExcelFmt('#,##0.00',   $datetime), "\n"; # 23,459.51
  
  =head1 DESCRIPTION
  
  The C<Spreadsheet::ParseExcel::Utility> module provides utility functions for working with ParseExcel and Excel data.
  
  =head1 Functions
  
  C<Spreadsheet::ParseExcel::Utility> can export the following functions:
  
      ExcelFmt
      ExcelLocaltime
      LocaltimeExcel
      col2int
      int2col
      sheetRef
      xls2csv
  
  These functions must be imported implicitly:
  
      # Just one function.
      use Spreadsheet::ParseExcel::Utility 'col2int';
  
      # More than one.
      use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);
  
  
  =head2 ExcelFmt($format_string, $number, $is_1904)
  
  Excel stores data such as dates and currency values as numbers. The way these numbers are displayed is controlled by the number format string for the cell. For example a cell with a number format of C<'$#,##0.00'> for currency and a value of 1234.567 would be displayed as follows:
  
      '$#,##0.00' + 1234.567 = '$1,234.57'.
  
  The C<ExcelFmt()> function tries to emulate this formatting so that the user can convert raw numbers returned by C<Spreadsheet::ParseExel> to a desired format. For example:
  
      print ExcelFmt('$#,##0.00', 1234.567); # $1,234.57.
  
  The syntax of the function is:
  
      my $text = ExcelFmt($format_string, $number, $is_1904);
  
  Where C<$format_string> is an Excel number format string, C<$number> is a real or integer number and C<is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.
  
  C<ExcelFmt()> is also used internally to convert numbers returned by the C<Cell::unformatted()> method to the formatted value returned by the C<Cell::value()> method:
  
  
      my $cell = $worksheet->get_cell( 0, 0 );
  
      print $cell->unformatted(), "\n"; # 1234.567
      print $cell->value(),       "\n"; # $1,234.57
  
  The most common usage for C<ExcelFmt> is to convert numbers to dates. Dates and times in Excel are represented by real numbers, for example "1 Jan 2001 12:30 PM" is represented by the number 36892.521. The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day. By applying an Excel number format the number is converted to the desired string representation:
  
      print ExcelFmt('d mmm yyyy h:mm AM/PM', 36892.521);  # 1 Jan 2001 12:30 PM
  
  C<$is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch. Excel for Windows generally uses 1900 and Excel for Mac OS uses 1904. The C<$is1904> flag isn't required very often by a casual user and can usually be ignored.
  
  
  =head2 ExcelLocaltime($excel_datetime, $is_1904)
  
  The C<ExcelLocaltime()> function converts from an Excel date/time number to a C<localtime()>-like array of values:
  
          my @time = ExcelLocaltime($excel_datetime);
  
          #    0     1     2      3     4       5      6      7
          my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;
  
  The array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. This means that you will usually need to do the following:
  
          $month++;
          $year += 1900;
  
  See also Perl's documentation for L<localtime()|perlfunc>:
  
  The C<$is_1904> flag is an optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.
  
  =head2 LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec, $is_1904)
  
  The C<LocaltimeExcel()> function converts from a C<localtime()>-like array of values to an Excel date/time number:
  
      $excel_datetime = LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec);
  
  The array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. See also Perl's documentation for L<localtime()|perlfunc>:
  
  The C<$wday> and C<$msec> elements are usually optional. This time elements can also be zeroed if they aren't of interest:
  
                                      # sec, min, hour, day, month, year
      $excel_datetime = LocaltimeExcel( 0,   0,   0,    1,   0,     101 );
  
      print ExcelFmt('d mmm yyyy', $excel_datetime);  # 1 Jan 2001
  
  The C<$is_1904> flag is also optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.
  
  
  =head2 col2int($column)
  
  The C<col2int()> function converts an Excel column letter to an zero-indexed column number:
  
      print col2int('A');  # 0
      print col2int('AA'); # 26
  
  This function was contributed by Kevin Mulholland.
  
  
  =head2 int2col($column_number)
  
  The C<int2col()> function converts an zero-indexed Excel column number to a column letter:
  
      print int2col(0);  # 'A'
      print int2col(26); # 'AA'
  
  This function was contributed by Kevin Mulholland.
  
  
  =head2 sheetRef($cell_string)
  
  The C<sheetRef()> function converts an Excel cell reference in 'A1' notation to a zero-indexed C<(row, col)> pair.
  
      my ($row, $col) = sheetRef('A1'); # ( 0, 0 )
      my ($row, $col) = sheetRef('C2'); # ( 1, 2 )
  
  This function was contributed by Kevin Mulholland.
  
  
  =head2 xls2csv($filename, $region, $rotate)
  
  The C<xls2csv()> function converts a section of an Excel file into a CSV text string.
  
      $csv_text = xls2csv($filename, $region, $rotate);
  
  Where:
  
      $region = "sheet-colrow:colrow"
      For example '1-A1:B2' means 'A1:B2' for sheet 1.
  
      and
  
      $rotate  = 0 or 1 (output is rotated/transposed or not)
  
  This function requires C<Text::CSV_XS> to be installed. It was contributed by Kevin Mulholland along with the C<xls2csv> script in the C<sample> directory of the distro.
  
  See also the following xls2csv utilities: Ken Prows' C<xls2csv>: http://search.cpan.org/~ken/xls2csv/script/xls2csv and H.Merijn Brand's C<xls2csv> (which is part of Spreadsheet::Read): http://search.cpan.org/~hmbrand/Spreadsheet-Read/
  
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_UTILITY

$fatpacked{"Spreadsheet/ParseExcel/Workbook.pm"} = <<'SPREADSHEET_PARSEEXCEL_WORKBOOK';
  package Spreadsheet::ParseExcel::Workbook;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Workbook - A class for Workbooks.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.59';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
      my ($class) = @_;
      my $self = {};
      bless $self, $class;
  }
  
  ###############################################################################
  #
  # worksheet()
  #
  # This method returns a single Worksheet object using either its name or index.
  #
  sub worksheet {
      my ( $oBook, $sName ) = @_;
      my $oWkS;
      foreach $oWkS ( @{ $oBook->{Worksheet} } ) {
          return $oWkS if ( $oWkS->{Name} eq $sName );
      }
      if ( $sName =~ /^\d+$/ ) {
          return $oBook->{Worksheet}->[$sName];
      }
      return undef;
  }
  
  ###############################################################################
  #
  # worksheets()
  #
  # Returns an array ofWorksheet objects.
  #
  sub worksheets {
      my $self = shift;
  
      return @{ $self->{Worksheet} };
  }
  
  ###############################################################################
  #
  # worksheet_count()
  #
  # Returns the number Woksheet objects in the Workbook.
  #
  sub worksheet_count {
  
      my $self = shift;
  
      return $self->{SheetCount};
  }
  
  ###############################################################################
  #
  # get_filename()
  #
  # Returns the name of the Excel file of C<undef> if the data was read from a filehandle rather than a file.
  #
  sub get_filename {
  
      my $self = shift;
  
      return $self->{File};
  }
  
  ###############################################################################
  #
  # get_print_areas()
  #
  # Returns an array ref of print areas.
  #
  # TODO. This should really be a Worksheet method.
  #
  sub get_print_areas {
  
      my $self = shift;
  
      return $self->{PrintArea};
  }
  
  ###############################################################################
  #
  # get_print_titles()
  #
  # Returns an array ref of print title hash refs.
  #
  # TODO. This should really be a Worksheet method.
  #
  sub get_print_titles {
  
      my $self = shift;
  
      return $self->{PrintTitle};
  }
  
  ###############################################################################
  #
  # using_1904_date()
  #
  # Returns true if the Excel file is using the 1904 date epoch.
  #
  sub using_1904_date {
  
      my $self = shift;
  
      return $self->{Flg1904};
  }
  
  ###############################################################################
  #
  # ParseAbort()
  #
  # Todo
  #
  sub ParseAbort {
      my ( $self, $val ) = @_;
      $self->{_ParseAbort} = $val;
  }
  
  ###############################################################################
  #
  # Parse(). Deprecated.
  #
  # Syntactic wrapper around Spreadsheet::ParseExcel::Parse().
  # This method is *deprecated* since it doesn't conform to the the current
  # error handling in the S::PE Parse() method.
  #
  sub Parse {
  
      my ( $class, $source, $formatter ) = @_;
      my $excel = Spreadsheet::ParseExcel->new();
      my $workbook = $excel->Parse( $source, $formatter );
      $workbook->{_Excel} = $excel;
      return $workbook;
  }
  
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *Worksheet = *worksheet;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Workbook - A class for Workbooks.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for L<Spreadsheet::ParseExcel>.
  
  
  =head1 Methods
  
  The following Workbook methods are available:
  
      $workbook->worksheets()
      $workbook->worksheet()
      $workbook->worksheet_count()
      $workbook->get_filename()
      $workbook->get_print_areas()
      $workbook->get_print_titles()
      $workbook->using_1904_date()
  
  
  =head2 worksheets()
  
  The C<worksheets()> method returns an array of Worksheet objects. This was most commonly used to iterate over the worksheets in a workbook:
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
  
  =head2 worksheet()
  
  The C<worksheet()> method returns a single C<Worksheet> object using either its name or index:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  Returns C<undef> if the sheet name or index doesn't exist.
  
  
  =head2 worksheet_count()
  
  The C<worksheet_count()> method returns the number of Woksheet objects in the Workbook.
  
      my $worksheet_count = $workbook->worksheet_count();
  
  
  =head2 get_filename()
  
  The C<get_filename()> method returns the name of the Excel file of C<undef> if the data was read from a filehandle rather than a file.
  
      my $filename = $workbook->get_filename();
  
  
  =head2 get_print_areas()
  
  The C<get_print_areas()> method returns an array ref of print areas.
  
      my $print_areas = $workbook->get_print_areas();
  
  Each print area is as follows:
  
      [ $start_row, $start_col, $end_row, $end_col ]
  
  Returns undef if there are no print areas.
  
  
  =head2 get_print_titles()
  
  The C<get_print_titles()> method returns an array ref of print title hash refs.
  
      my $print_titles = $workbook->get_print_titles();
  
  Each print title array ref is as follows:
  
      {
          Row    => [ $start_row, $end_row ],
          Column => [ $start_col, $end_col ],
      }
  
  
  Returns undef if there are no print titles.
  
  
  =head2 using_1904_date()
  
  The C<using_1904_date()> method returns true if the Excel file is using the 1904 date epoch instead of the 1900 epoch.
  
      my $using_1904_date = $workbook->using_1904_date();
  
   The Windows version of Excel generally uses the 1900 epoch while the Mac version of Excel generally uses the 1904 epoch.
  
  Returns 0 if the 1900 epoch is in use.
  
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_WORKBOOK

$fatpacked{"Spreadsheet/ParseExcel/Worksheet.pm"} = <<'SPREADSHEET_PARSEEXCEL_WORKSHEET';
  package Spreadsheet::ParseExcel::Worksheet;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Worksheet - A class for Worksheets.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2009      John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  use Scalar::Util qw(weaken);
  
  our $VERSION = '0.59';
  
  ###############################################################################
  #
  # new()
  #
  sub new {
  
      my ( $class, %properties ) = @_;
  
      my $self = \%properties;
  
      weaken $self->{_Book};
  
      $self->{Cells}       = undef;
      $self->{DefColWidth} = 8.43;
  
      return bless $self, $class;
  }
  
  ###############################################################################
  #
  # get_cell( $row, $col )
  #
  # Returns the Cell object at row $row and column $col, if defined.
  #
  sub get_cell {
  
      my ( $self, $row, $col ) = @_;
  
      if (   !defined $row
          || !defined $col
          || !defined $self->{MaxRow}
          || !defined $self->{MaxCol} )
      {
  
          # Return undef if no arguments are given or if no cells are defined.
          return undef;
      }
      elsif ($row < $self->{MinRow}
          || $row > $self->{MaxRow}
          || $col < $self->{MinCol}
          || $col > $self->{MaxCol} )
      {
  
          # Return undef if outside allowable row/col range.
          return undef;
      }
      else {
  
          # Return the Cell object.
          return $self->{Cells}->[$row]->[$col];
      }
  }
  
  ###############################################################################
  #
  # row_range()
  #
  # Returns a two-element list ($min, $max) containing the minimum and maximum
  # defined rows in the worksheet.
  #
  # If there is no row defined $max is smaller than $min.
  #
  sub row_range {
  
      my $self = shift;
  
      my $min = $self->{MinRow} || 0;
      my $max = defined( $self->{MaxRow} ) ? $self->{MaxRow} : ( $min - 1 );
  
      return ( $min, $max );
  }
  
  ###############################################################################
  #
  # col_range()
  #
  # Returns a two-element list ($min, $max) containing the minimum and maximum
  # defined cols in the worksheet.
  #
  # If there is no column defined $max is smaller than $min.
  #
  sub col_range {
  
      my $self = shift;
  
      my $min = $self->{MinCol} || 0;
      my $max = defined( $self->{MaxCol} ) ? $self->{MaxCol} : ( $min - 1 );
  
      return ( $min, $max );
  }
  
  ###############################################################################
  #
  # get_name()
  #
  # Returns the name of the worksheet.
  #
  sub get_name {
  
      my $self = shift;
  
      return $self->{Name};
  }
  
  ###############################################################################
  #
  # sheet_num()
  #
  sub sheet_num {
  
      my $self = shift;
  
      return $self->{_SheetNo};
  }
  
  ###############################################################################
  #
  # get_h_pagebreaks()
  #
  # Returns an array ref of row numbers where a horizontal page break occurs.
  #
  sub get_h_pagebreaks {
  
      my $self = shift;
  
      return $self->{HPageBreak};
  }
  
  ###############################################################################
  #
  # get_v_pagebreaks()
  #
  # Returns an array ref of column numbers where a vertical page break occurs.
  #
  sub get_v_pagebreaks {
  
      my $self = shift;
  
      return $self->{VPageBreak};
  }
  
  ###############################################################################
  #
  # get_merged_areas()
  #
  # Returns an array ref of cells that are merged.
  #
  sub get_merged_areas {
  
      my $self = shift;
  
      return $self->{MergedArea};
  }
  
  ###############################################################################
  #
  # get_row_heights()
  #
  # Returns an array_ref of row heights.
  #
  sub get_row_heights {
  
      my $self = shift;
  
      return @{ $self->{RowHeight} };
  }
  
  ###############################################################################
  #
  # get_col_widths()
  #
  # Returns an array_ref of column widths.
  #
  sub get_col_widths {
  
      my $self = shift;
  
      return @{ $self->{ColWidth} };
  }
  
  ###############################################################################
  #
  # get_default_row_height()
  #
  # Returns the default row height for the worksheet. Generally 12.75.
  #
  sub get_default_row_height {
  
      my $self = shift;
  
      return $self->{DefRowHeight};
  }
  
  ###############################################################################
  #
  # get_default_col_width()
  #
  # Returns the default column width for the worksheet. Generally 8.43.
  #
  sub get_default_col_width {
  
      my $self = shift;
  
      return $self->{DefColWidth};
  }
  
  ###############################################################################
  #
  # _get_row_properties()
  #
  # Returns an array_ref of row properties.
  # TODO. This is a placeholder for a future method.
  #
  sub _get_row_properties {
  
      my $self = shift;
  
      return $self->{RowProperties};
  }
  
  ###############################################################################
  #
  # _get_col_properties()
  #
  # Returns an array_ref of column properties.
  # TODO. This is a placeholder for a future method.
  #
  sub _get_col_properties {
  
      my $self = shift;
  
      return $self->{ColProperties};
  }
  
  ###############################################################################
  #
  # get_header()
  #
  # Returns the worksheet header string.
  #
  sub get_header {
  
      my $self = shift;
  
      return $self->{Header};
  }
  
  ###############################################################################
  #
  # get_footer()
  #
  # Returns the worksheet footer string.
  #
  sub get_footer {
  
      my $self = shift;
  
      return $self->{Footer};
  }
  
  ###############################################################################
  #
  # get_margin_left()
  #
  # Returns the left margin of the worksheet in inches.
  #
  sub get_margin_left {
  
      my $self = shift;
  
      return $self->{LeftMargin};
  }
  
  ###############################################################################
  #
  # get_margin_right()
  #
  # Returns the right margin of the worksheet in inches.
  #
  sub get_margin_right {
  
      my $self = shift;
  
      return $self->{RightMargin};
  }
  
  ###############################################################################
  #
  # get_margin_top()
  #
  # Returns the top margin of the worksheet in inches.
  #
  sub get_margin_top {
  
      my $self = shift;
  
      return $self->{TopMargin};
  }
  
  ###############################################################################
  #
  # get_margin_bottom()
  #
  # Returns the bottom margin of the worksheet in inches.
  #
  sub get_margin_bottom {
  
      my $self = shift;
  
      return $self->{BottomMargin};
  }
  
  ###############################################################################
  #
  # get_margin_header()
  #
  # Returns the header margin of the worksheet in inches.
  #
  sub get_margin_header {
  
      my $self = shift;
  
      return $self->{HeaderMargin};
  }
  
  ###############################################################################
  #
  # get_margin_footer()
  #
  # Returns the footer margin of the worksheet in inches.
  #
  sub get_margin_footer {
  
      my $self = shift;
  
      return $self->{FooterMargin};
  }
  
  ###############################################################################
  #
  # get_paper()
  #
  # Returns the printer paper size.
  #
  sub get_paper {
  
      my $self = shift;
  
      return $self->{PaperSize};
  }
  
  ###############################################################################
  #
  # get_start_page()
  #
  # Returns the page number that printing will start from.
  #
  sub get_start_page {
  
      my $self = shift;
  
      # Only return the page number if the "First page number" option is set.
      if ( $self->{UsePage} ) {
          return $self->{PageStart};
      }
      else {
          return 0;
      }
  }
  
  ###############################################################################
  #
  # get_print_order()
  #
  # Returns the Worksheet page printing order.
  #
  sub get_print_order {
  
      my $self = shift;
  
      return $self->{LeftToRight};
  }
  
  ###############################################################################
  #
  # get_print_scale()
  #
  # Returns the workbook scale for printing.
  #
  sub get_print_scale {
  
      my $self = shift;
  
      return $self->{Scale};
  }
  
  ###############################################################################
  #
  # get_fit_to_pages()
  #
  # Returns the number of pages wide and high that the printed worksheet page
  # will fit to.
  #
  sub get_fit_to_pages {
  
      my $self = shift;
  
      if ( !$self->{PageFit} ) {
          return ( 0, 0 );
      }
      else {
          return ( $self->{FitWidth}, $self->{FitHeight} );
      }
  }
  
  ###############################################################################
  #
  # is_portrait()
  #
  # Returns true if the worksheet has been set for printing in portrait mode.
  #
  sub is_portrait {
  
      my $self = shift;
  
      return $self->{Landscape};
  }
  
  ###############################################################################
  #
  # is_centered_horizontally()
  #
  # Returns true if the worksheet has been centered horizontally for printing.
  #
  sub is_centered_horizontally {
  
      my $self = shift;
  
      return $self->{HCenter};
  }
  
  ###############################################################################
  #
  # is_centered_vertically()
  #
  # Returns true if the worksheet has been centered vertically for printing.
  #
  sub is_centered_vertically {
  
      my $self = shift;
  
      return $self->{HCenter};
  }
  
  ###############################################################################
  #
  # is_print_gridlines()
  #
  # Returns true if the worksheet print "gridlines" option is turned on.
  #
  sub is_print_gridlines {
  
      my $self = shift;
  
      return $self->{PrintGrid};
  }
  
  ###############################################################################
  #
  # is_print_row_col_headers()
  #
  # Returns true if the worksheet print "row and column headings" option is on.
  #
  sub is_print_row_col_headers {
  
      my $self = shift;
  
      return $self->{PrintHeaders};
  }
  
  ###############################################################################
  #
  # is_print_black_and_white()
  #
  # Returns true if the worksheet print "black and white" option is turned on.
  #
  sub is_print_black_and_white {
  
      my $self = shift;
  
      return $self->{NoColor};
  }
  
  ###############################################################################
  #
  # is_print_draft()
  #
  # Returns true if the worksheet print "draft" option is turned on.
  #
  sub is_print_draft {
  
      my $self = shift;
  
      return $self->{Draft};
  }
  
  ###############################################################################
  #
  # is_print_comments()
  #
  # Returns true if the worksheet print "comments" option is turned on.
  #
  sub is_print_comments {
  
      my $self = shift;
  
      return $self->{Notes};
  }
  
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *sheetNo  = *sheet_num;
      *Cell     = *get_cell;
      *RowRange = *row_range;
      *ColRange = *col_range;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Worksheet - A class for Worksheets.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Spreadsheet::ParseExcel>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 Methods
  
  The C<Spreadsheet::ParseExcel::Worksheet> class encapsulates the properties of an Excel worksheet. It has the following methods:
  
      $worksheet->get_cell()
      $worksheet->row_range()
      $worksheet->col_range()
      $worksheet->get_name()
      $worksheet->get_h_pagebreaks()
      $worksheet->get_v_pagebreaks()
      $worksheet->get_merged_areas()
      $worksheet->get_row_heights()
      $worksheet->get_col_widths()
      $worksheet->get_default_row_height()
      $worksheet->get_default_col_width()
      $worksheet->get_header()
      $worksheet->get_footer()
      $worksheet->get_margin_left()
      $worksheet->get_margin_right()
      $worksheet->get_margin_top()
      $worksheet->get_margin_bottom()
      $worksheet->get_margin_header()
      $worksheet->get_margin_footer()
      $worksheet->get_paper()
      $worksheet->get_start_page()
      $worksheet->get_print_order()
      $worksheet->get_print_scale()
      $worksheet->get_fit_to_pages()
      $worksheet->is_portrait()
      $worksheet->is_centered_horizontally()
      $worksheet->is_centered_vertically()
      $worksheet->is_print_gridlines()
      $worksheet->is_print_row_col_headers()
      $worksheet->is_print_black_and_white()
      $worksheet->is_print_draft()
      $worksheet->is_print_comments()
  
  
  =head2 get_cell($row, $col)
  
  Return the L</Cell> object at row C<$row> and column C<$col> if it is defined. Otherwise returns undef.
  
      my $cell = $worksheet->get_cell($row, $col);
  
  =head2 row_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum defined rows in the worksheet. If there is no row defined C<$max> is smaller than C<$min>.
  
      my ( $row_min, $row_max ) = $worksheet->row_range();
  
  =head2 col_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum of defined columns in the worksheet. If there is no column defined C<$max> is smaller than C<$min>.
  
      my ( $col_min, $col_max ) = $worksheet->col_range();
  
  
  =head2 get_name()
  
  The C<get_name()> method returns the name of the worksheet.
  
      my $name = $worksheet->get_name();
  
  
  =head2 get_h_pagebreaks()
  
  The C<get_h_pagebreaks()> method returns an array ref of row numbers where a horizontal page break occurs.
  
      my $h_pagebreaks = $worksheet->get_h_pagebreaks();
  
  Returns C<undef> if there are no pagebreaks.
  
  
  =head2 get_v_pagebreaks()
  
  The C<get_v_pagebreaks()> method returns an array ref of column numbers where a vertical page break occurs.
  
      my $v_pagebreaks = $worksheet->get_v_pagebreaks();
  
  Returns C<undef> if there are no pagebreaks.
  
  
  =head2 get_merged_areas()
  
  The C<get_merged_areas()> method returns an array ref of cells that are merged.
  
      my $merged_areas = $worksheet->get_merged_areas();
  
  Each merged area is represented as follows:
  
      [ $start_row, $start_col, $end_row, $end_col]
  
  Returns C<undef> if there are no merged areas.
  
  
  =head2 get_row_heights()
  
  The C<get_row_heights()> method returns an array_ref of row heights.
  
      my $row_heights = $worksheet->get_row_heights();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_col_widths()
  
  The C<get_col_widths()> method returns an array_ref of column widths.
  
      my $col_widths = $worksheet->get_col_widths();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_default_row_height()
  
  The C<get_default_row_height()> method returns the default row height for the worksheet. Generally 12.75.
  
      my $default_row_height = $worksheet->get_default_row_height();
  
  
  =head2 get_default_col_width()
  
  The C<get_default_col_width()> method returns the default column width for the worksheet. Generally 8.43.
  
      my $default_col_width = $worksheet->get_default_col_width();
  
  
  =head2 get_header()
  
  The C<get_header()> method returns the worksheet header string. This string can contain control codes for alignment and font properties. Refer to the Excel on-line help on headers and footers or to the Spreadsheet::WriteExcel documentation for set_header().
  
      my $header = $worksheet->get_header();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_footer()
  
  The C<get_footer()> method returns the worksheet footer string. This string can contain control codes for alignment and font properties. Refer to the Excel on-line help on headers and footers or to the Spreadsheet::WriteExcel documentation for set_header().
  
      my $footer = $worksheet->get_footer();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_left()
  
  The C<get_margin_left()> method returns the left margin of the worksheet in inches.
  
      my $margin_left = $worksheet->get_margin_left();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_right()
  
  The C<get_margin_right()> method returns the right margin of the worksheet in inches.
  
      my $margin_right = $worksheet->get_margin_right();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_top()
  
  The C<get_margin_top()> method returns the top margin of the worksheet in inches.
  
      my $margin_top = $worksheet->get_margin_top();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_bottom()
  
  The C<get_margin_bottom()> method returns the bottom margin of the worksheet in inches.
  
      my $margin_bottom = $worksheet->get_margin_bottom();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_header()
  
  The C<get_margin_header()> method returns the header margin of the worksheet in inches.
  
      my $margin_header = $worksheet->get_margin_header();
  
  Returns a default value of 0.5 if not set.
  
  
  =head2 get_margin_footer()
  
  The C<get_margin_footer()> method returns the footer margin of the worksheet in inches.
  
      my $margin_footer = $worksheet->get_margin_footer();
  
  Returns a default value of 0.5 if not set.
  
  
  =head2 get_paper()
  
  The C<get_paper()> method returns the printer paper size.
  
      my $paper = $worksheet->get_paper();
  
  The value corresponds to the formats shown below:
  
      Index   Paper format            Paper size
      =====   ============            ==========
        0     Printer default         -
        1     Letter                  8 1/2 x 11 in
        2     Letter Small            8 1/2 x 11 in
        3     Tabloid                 11 x 17 in
        4     Ledger                  17 x 11 in
        5     Legal                   8 1/2 x 14 in
        6     Statement               5 1/2 x 8 1/2 in
        7     Executive               7 1/4 x 10 1/2 in
        8     A3                      297 x 420 mm
        9     A4                      210 x 297 mm
       10     A4 Small                210 x 297 mm
       11     A5                      148 x 210 mm
       12     B4                      250 x 354 mm
       13     B5                      182 x 257 mm
       14     Folio                   8 1/2 x 13 in
       15     Quarto                  215 x 275 mm
       16     -                       10x14 in
       17     -                       11x17 in
       18     Note                    8 1/2 x 11 in
       19     Envelope  9             3 7/8 x 8 7/8
       20     Envelope 10             4 1/8 x 9 1/2
       21     Envelope 11             4 1/2 x 10 3/8
       22     Envelope 12             4 3/4 x 11
       23     Envelope 14             5 x 11 1/2
       24     C size sheet            -
       25     D size sheet            -
       26     E size sheet            -
       27     Envelope DL             110 x 220 mm
       28     Envelope C3             324 x 458 mm
       29     Envelope C4             229 x 324 mm
       30     Envelope C5             162 x 229 mm
       31     Envelope C6             114 x 162 mm
       32     Envelope C65            114 x 229 mm
       33     Envelope B4             250 x 353 mm
       34     Envelope B5             176 x 250 mm
       35     Envelope B6             176 x 125 mm
       36     Envelope                110 x 230 mm
       37     Monarch                 3.875 x 7.5 in
       38     Envelope                3 5/8 x 6 1/2 in
       39     Fanfold                 14 7/8 x 11 in
       40     German Std Fanfold      8 1/2 x 12 in
       41     German Legal Fanfold    8 1/2 x 13 in
       256    User defined
  
  The two most common paper sizes are C<1 = "US Letter"> and C<9 = A4>. Returns 9 by default.
  
  
  =head2 get_start_page()
  
  The C<get_start_page()> method returns the page number that printing will start from.
  
      my $start_page = $worksheet->get_start_page();
  
  Returns 0 if the property isn't set.
  
  
  =head2 get_print_order()
  
  The C<get_print_order()> method returns 0 if the worksheet print "page order" is "Down then over" (the default) or 1 if it is "Over then down".
  
      my $print_order = $worksheet->get_print_order();
  
  
  =head2 get_print_scale()
  
  The C<get_print_scale()> method returns the workbook scale for printing. The print scale fctor can be in the range 10 .. 400.
  
      my $print_scale = $worksheet->get_print_scale();
  
  Returns 100 by default.
  
  
  =head2 get_fit_to_pages()
  
  The C<get_fit_to_pages()> method returns the number of pages wide and high that the printed worksheet page will fit to.
  
      my ($pages_wide, $pages_high) = $worksheet->get_fit_to_pages();
  
  Returns (0, 0) if the property isn't set.
  
  
  =head2 is_portrait()
  
  The C<is_portrait()> method returns true if the worksheet has been set for printing in portrait mode.
  
      my $is_portrait = $worksheet->is_portrait();
  
  Returns 0 if the worksheet has been set for printing in horizontal mode.
  
  
  =head2 is_centered_horizontally()
  
  The C<is_centered_horizontally()> method returns true if the worksheet has been centered horizontally for printing.
  
      my $is_centered_horizontally = $worksheet->is_centered_horizontally();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_centered_vertically()
  
  The C<is_centered_vertically()> method returns true if the worksheet has been centered vertically for printing.
  
      my $is_centered_vertically = $worksheet->is_centered_vertically();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_gridlines()
  
  The C<is_print_gridlines()> method returns true if the worksheet print "gridlines" option is turned on.
  
      my $is_print_gridlines = $worksheet->is_print_gridlines();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_row_col_headers()
  
  The C<is_print_row_col_headers()> method returns true if the worksheet print "row and column headings" option is turned on.
  
      my $is_print_row_col_headers = $worksheet->is_print_row_col_headers();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_black_and_white()
  
  The C<is_print_black_and_white()> method returns true if the worksheet print "black and white" option is turned on.
  
      my $is_print_black_and_white = $worksheet->is_print_black_and_white();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_draft()
  
  The C<is_print_draft()> method returns true if the worksheet print "draft" option is turned on.
  
      my $is_print_draft = $worksheet->is_print_draft();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_comments()
  
  The C<is_print_comments()> method returns true if the worksheet print "comments" option is turned on.
  
      my $is_print_comments = $worksheet->is_print_comments();
  
  Returns 0 if the property isn't set.
  
  
  =head1 AUTHOR
  
  Maintainer 0.40+: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2010 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_WORKSHEET

$fatpacked{"Spreadsheet/WriteExcel.pm"} = <<'SPREADSHEET_WRITEEXCEL';
  package Spreadsheet::WriteExcel;
  
  ###############################################################################
  #
  # WriteExcel.
  #
  # Spreadsheet::WriteExcel - Write to a cross-platform Excel binary file.
  #
  # Copyright 2000-2012, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Workbook;
  
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Workbook Exporter);
  
  $VERSION = '2.38'; # A farewell to arms.
  
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor. Wrapper for a Workbook object.
  # uses: Spreadsheet::WriteExcel::BIFFwriter
  #       Spreadsheet::WriteExcel::Chart
  #       Spreadsheet::WriteExcel::OLEwriter
  #       Spreadsheet::WriteExcel::Workbook
  #       Spreadsheet::WriteExcel::Worksheet
  #       Spreadsheet::WriteExcel::Format
  #       Spreadsheet::WriteExcel::Formula
  #       Spreadsheet::WriteExcel::Properties
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Workbook->new(@_);
  
      # Check for file creation failures before re-blessing
      bless  $self, $class if defined $self;
  
      return $self;
  }
  
  
  1;
  
  
  __END__
  
  
  
  =head1 NAME
  
  Spreadsheet::WriteExcel - Write to a cross-platform Excel binary file.
  
  =head1 VERSION
  
  This document refers to version 2.38 of Spreadsheet::WriteExcel, released November 22, 2012.
  
  
  
  
  =head1 SYNOPSIS
  
  To write a string, a formatted string, a number and a formula to the first worksheet in an Excel workbook called perl.xls:
  
      use Spreadsheet::WriteExcel;
  
      # Create a new Excel workbook
      my $workbook = Spreadsheet::WriteExcel->new('perl.xls');
  
      # Add a worksheet
      $worksheet = $workbook->add_worksheet();
  
      #  Add and define a format
      $format = $workbook->add_format(); # Add a format
      $format->set_bold();
      $format->set_color('red');
      $format->set_align('center');
  
      # Write a formatted and unformatted string, row and column notation.
      $col = $row = 0;
      $worksheet->write($row, $col, 'Hi Excel!', $format);
      $worksheet->write(1,    $col, 'Hi Excel!');
  
      # Write a number and a formula using A1 notation
      $worksheet->write('A3', 1.2345);
      $worksheet->write('A4', '=SIN(PI()/4)');
  
  
  
  
  =head1 DESCRIPTION
  
  The Spreadsheet::WriteExcel Perl module can be used to create a cross-platform Excel binary file. Multiple worksheets can be added to a workbook and formatting can be applied to cells. Text, numbers, formulas, hyperlinks, images and charts can be written to the cells.
  
  The file produced by this module is compatible with Excel 97, 2000, 2002, 2003 and 2007.
  
  The module will work on the majority of Windows, UNIX and Mac platforms. Generated files are also compatible with the Linux/UNIX spreadsheet applications Gnumeric and OpenOffice.org.
  
  This module cannot be used to write to an existing Excel file (See L</MODIFYING AND REWRITING EXCEL FILES>).
  
  For the Excel 2007+ xlsx file format see the L<Excel::Writer::XLSX> module.
  
  
  
  =head1 QUICK START
  
  Spreadsheet::WriteExcel tries to provide an interface to as many of Excel's features as possible. As a result there is a lot of documentation to accompany the interface and it can be difficult at first glance to see what it important and what is not. So for those of you who prefer to assemble Ikea furniture first and then read the instructions, here are three easy steps:
  
  1. Create a new Excel I<workbook> (i.e. file) using C<new()>.
  
  2. Add a I<worksheet> to the new workbook using C<add_worksheet()>.
  
  3. Write to the worksheet using C<write()>.
  
  Like this:
  
      use Spreadsheet::WriteExcel;                             # Step 0
  
      my $workbook = Spreadsheet::WriteExcel->new('perl.xls'); # Step 1
      $worksheet   = $workbook->add_worksheet();               # Step 2
      $worksheet->write('A1', 'Hi Excel!');                    # Step 3
  
  This will create an Excel file called C<perl.xls> with a single worksheet and the text C<'Hi Excel!'> in the relevant cell. And that's it. Okay, so there is actually a zeroth step as well, but C<use module> goes without saying. There are also more than 80 examples that come with the distribution and which you can use to get you started. See L</EXAMPLES>.
  
  Those of you who read the instructions first and assemble the furniture afterwards will know how to proceed. ;-)
  
  
  
  
  =head1 WORKBOOK METHODS
  
  The Spreadsheet::WriteExcel module provides an object oriented interface to a new Excel workbook. The following methods are available through a new workbook.
  
      new()
      add_worksheet()
      add_format()
      add_chart()
      add_chart_ext()
      close()
      compatibility_mode()
      set_properties()
      define_name()
      set_tempdir()
      set_custom_color()
      sheets()
      set_1904()
      set_codepage()
  
  If you are unfamiliar with object oriented interfaces or the way that they are implemented in Perl have a look at C<perlobj> and C<perltoot> in the main Perl documentation.
  
  
  
  
  =head2 new()
  
  A new Excel workbook is created using the C<new()> constructor which accepts either a filename or a filehandle as a parameter. The following example creates a new Excel file based on a filename:
  
      my $workbook  = Spreadsheet::WriteExcel->new('filename.xls');
      my $worksheet = $workbook->add_worksheet();
      $worksheet->write(0, 0, 'Hi Excel!');
  
  Here are some other examples of using C<new()> with filenames:
  
      my $workbook1 = Spreadsheet::WriteExcel->new($filename);
      my $workbook2 = Spreadsheet::WriteExcel->new('/tmp/filename.xls');
      my $workbook3 = Spreadsheet::WriteExcel->new("c:\\tmp\\filename.xls");
      my $workbook4 = Spreadsheet::WriteExcel->new('c:\tmp\filename.xls');
  
  The last two examples demonstrates how to create a file on DOS or Windows where it is necessary to either escape the directory separator C<\> or to use single quotes to ensure that it isn't interpolated. For more information  see C<perlfaq5: Why can't I use "C:\temp\foo" in DOS paths?>.
  
  The C<new()> constructor returns a Spreadsheet::WriteExcel object that you can use to add worksheets and store data. It should be noted that although C<my> is not specifically required it defines the scope of the new workbook variable and, in the majority of cases, ensures that the workbook is closed properly without explicitly calling the C<close()> method.
  
  If the file cannot be created, due to file permissions or some other reason,  C<new> will return C<undef>. Therefore, it is good practice to check the return value of C<new> before proceeding. As usual the Perl variable C<$!> will be set if there is a file creation error. You will also see one of the warning messages detailed in L</DIAGNOSTICS>:
  
      my $workbook  = Spreadsheet::WriteExcel->new('protected.xls');
      die "Problems creating new Excel file: $!" unless defined $workbook;
  
  You can also pass a valid filehandle to the C<new()> constructor. For example in a CGI program you could do something like this:
  
      binmode(STDOUT);
      my $workbook  = Spreadsheet::WriteExcel->new(\*STDOUT);
  
  The requirement for C<binmode()> is explained below.
  
  See also, the C<cgi.pl> program in the C<examples> directory of the distro.
  
  However, this special case will not work in C<mod_perl> programs where you will have to do something like the following:
  
      # mod_perl 1
      ...
      tie *XLS, 'Apache';
      binmode(XLS);
      my $workbook  = Spreadsheet::WriteExcel->new(\*XLS);
      ...
  
      # mod_perl 2
      ...
      tie *XLS => $r;  # Tie to the Apache::RequestRec object
      binmode(*XLS);
      my $workbook  = Spreadsheet::WriteExcel->new(\*XLS);
      ...
  
  See also, the C<mod_perl1.pl> and C<mod_perl2.pl> programs in the C<examples> directory of the distro.
  
  Filehandles can also be useful if you want to stream an Excel file over a socket or if you want to store an Excel file in a scalar.
  
  For example here is a way to write an Excel file to a scalar with C<perl 5.8>:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      # Requires perl 5.8 or later
      open my $fh, '>', \my $str or die "Failed to open filehandle: $!";
  
      my $workbook  = Spreadsheet::WriteExcel->new($fh);
      my $worksheet = $workbook->add_worksheet();
  
      $worksheet->write(0, 0,  'Hi Excel!');
  
      $workbook->close();
  
      # The Excel file in now in $str. Remember to binmode() the output
      # filehandle before printing it.
      binmode STDOUT;
      print $str;
  
  See also the C<write_to_scalar.pl> and C<filehandle.pl> programs in the C<examples> directory of the distro.
  
  B<Note about the requirement for> C<binmode()>. An Excel file is comprised of binary data. Therefore, if you are using a filehandle you should ensure that you C<binmode()> it prior to passing it to C<new()>.You should do this regardless of whether you are on a Windows platform or not. This applies especially to users of perl 5.8 on systems where C<UTF-8> is likely to be in operation such as RedHat Linux 9. If your program, either intentionally or not, writes C<UTF-8> data to a filehandle that is passed to C<new()> it will corrupt the Excel file that is created.
  
  You don't have to worry about C<binmode()> if you are using filenames instead of filehandles. Spreadsheet::WriteExcel performs the C<binmode()> internally when it converts the filename to a filehandle. For more information about C<binmode()> see C<perlfunc> and C<perlopentut> in the main Perl documentation.
  
  
  
  
  
  =head2 add_worksheet($sheetname, $utf_16_be)
  
  At least one worksheet should be added to a new workbook. A worksheet is used to write data into cells:
  
      $worksheet1 = $workbook->add_worksheet();           # Sheet1
      $worksheet2 = $workbook->add_worksheet('Foglio2');  # Foglio2
      $worksheet3 = $workbook->add_worksheet('Data');     # Data
      $worksheet4 = $workbook->add_worksheet();           # Sheet4
  
  If C<$sheetname> is not specified the default Excel convention will be followed, i.e. Sheet1, Sheet2, etc. The C<$utf_16_be> parameter is optional, see below.
  
  The worksheet name must be a valid Excel worksheet name, i.e. it cannot contain any of the following characters, C<[ ] : * ? / \> and it must be less than 32 characters. In addition, you cannot use the same, case insensitive, C<$sheetname> for more than one worksheet.
  
  On systems with C<perl 5.8> and later the C<add_worksheet()> method will also handle strings in C<UTF-8> format.
  
      $worksheet = $workbook->add_worksheet("\x{263a}"); # Smiley
  
  On earlier Perl systems your can specify C<UTF-16BE> worksheet names using an additional optional parameter:
  
      my $name = pack 'n', 0x263a;
      $worksheet = $workbook->add_worksheet($name, 1);   # Smiley
  
  
  
  
  =head2 add_format(%properties)
  
  The C<add_format()> method can be used to create new Format objects which are used to apply formatting to a cell. You can either define the properties at creation time via a hash of property values or later via method calls.
  
      $format1 = $workbook->add_format(%props); # Set properties at creation
      $format2 = $workbook->add_format();       # Set properties later
  
  See the L</CELL FORMATTING> section for more details about Format properties and how to set them.
  
  
  
  
  =head2 add_chart(%properties)
  
  This method is use to create a new chart either as a standalone worksheet (the default) or as an embeddable object that can be inserted into a worksheet via the C<insert_chart()> Worksheet method.
  
      my $chart = $workbook->add_chart( type => 'column' );
  
  The properties that can be set are:
  
      type     (required)
      name     (optional)
      embedded (optional)
  
  =over
  
  =item * C<type>
  
  This is a required parameter. It defines the type of chart that will be created.
  
      my $chart = $workbook->add_chart( type => 'line' );
  
  The available types are:
  
      area
      bar
      column
      line
      pie
      scatter
      stock
  
  =item * C<name>
  
  Set the name for the chart sheet. The name property is optional and if it isn't supplied will default to C<Chart1 .. n>. The name must be a valid Excel worksheet name. See C<add_worksheet()> for more details on valid sheet names. The C<name> property can be omitted for embedded charts.
  
      my $chart = $workbook->add_chart( type => 'line', name => 'Results Chart' );
  
  =item * C<embedded>
  
  Specifies that the Chart object will be inserted in a worksheet via the C<insert_chart()> Worksheet method. It is an error to try insert a Chart that doesn't have this flag set.
  
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the chart.
      ...
  
      # Insert the chart into the a worksheet.
      $worksheet->insert_chart( 'E2', $chart );
  
  =back
  
  See L<Spreadsheet::WriteExcel::Chart> for details on how to configure the chart object once it is created. See also the C<chart_*.pl> programs in the examples directory of the distro.
  
  
  
  
  =head2 add_chart_ext($chart_data, $chartname)
  
  This method is use to include externally generated charts in a Spreadsheet::WriteExcel file.
  
      my $chart = $workbook->add_chart_ext('chart01.bin', 'Chart1');
  
  This feature is semi-deprecated in favour of the "native" charts created using C<add_chart()>. Read C<external_charts.txt> (or C<.pod>) in the external_charts directory of the distro for a full explanation.
  
  
  
  
  =head2 close()
  
  In general your Excel file will be closed automatically when your program ends or when the Workbook object goes out of scope, however the C<close()> method can be used to explicitly close an Excel file.
  
      $workbook->close();
  
  An explicit C<close()> is required if the file must be closed prior to performing some external action on it such as copying it, reading its size or attaching it to an email.
  
  In addition, C<close()> may be required to prevent perl's garbage collector from disposing of the Workbook, Worksheet and Format objects in the wrong order. Situations where this can occur are:
  
  =over 4
  
  =item *
  
  If C<my()> was not used to declare the scope of a workbook variable created using C<new()>.
  
  =item *
  
  If the C<new()>, C<add_worksheet()> or C<add_format()> methods are called in subroutines.
  
  =back
  
  The reason for this is that Spreadsheet::WriteExcel relies on Perl's C<DESTROY> mechanism to trigger destructor methods in a specific sequence. This may not happen in cases where the Workbook, Worksheet and Format variables are not lexically scoped or where they have different lexical scopes.
  
  In general, if you create a file with a size of 0 bytes or you fail to create a file you need to call C<close()>.
  
  The return value of C<close()> is the same as that returned by perl when it closes the file created by C<new()>. This allows you to handle error conditions in the usual way:
  
      $workbook->close() or die "Error closing file: $!";
  
  
  
  
  =head2 compatibility_mode()
  
  This method is used to improve compatibility with third party applications that read Excel files.
  
      $workbook->compatibility_mode();
  
  An Excel file is comprised of binary records that describe properties of a spreadsheet. Excel is reasonably liberal about this and, outside of a core subset, it doesn't require every possible record to be present when it reads a file. This is also true of Gnumeric and OpenOffice.Org Calc.
  
  Spreadsheet::WriteExcel takes advantage of this fact to omit some records in order to minimise the amount of data stored in memory and to simplify and speed up the writing of files. However, some third party applications that read Excel files often expect certain records to be present. In "compatibility mode" Spreadsheet::WriteExcel writes these records and tries to be as close to an Excel generated file as possible.
  
  Applications that require C<compatibility_mode()> are Apache POI, Apple Numbers, and Quickoffice on Nokia, Palm and other devices. You should also use C<compatibility_mode()> if your Excel file will be used as an external data source by another Excel file.
  
  If you encounter other situations that require C<compatibility_mode()>, please let me know.
  
  It should be noted that C<compatibility_mode()> requires additional data to be stored in memory and additional processing. This incurs a memory and speed penalty and may not be suitable for very large files (>20MB).
  
  You must call C<compatibility_mode()> before calling C<add_worksheet()>.
  
  
  
  
  =head2 set_properties()
  
  The C<set_properties> method can be used to set the document properties of the Excel file created by C<Spreadsheet::WriteExcel>. These properties are visible when you use the C<< File->Properties >> menu option in Excel and are also available to external applications that read or index windows files.
  
  The properties should be passed as a hash of values as follows:
  
      $workbook->set_properties(
          title    => 'This is an example spreadsheet',
          author   => 'John McNamara',
          comments => 'Created with Perl and Spreadsheet::WriteExcel',
      );
  
  The properties that can be set are:
  
      title
      subject
      author
      manager
      company
      category
      keywords
      comments
  
  User defined properties are not supported due to effort required.
  
  In perl 5.8+ you can also pass UTF-8 strings as properties. See L</UNICODE IN EXCEL>.
  
      my $smiley = chr 0x263A;
  
      $workbook->set_properties(
          subject => "Happy now? $smiley",
      );
  
  With older versions of perl you can use a module to convert a non-ASCII string to a binary representation of UTF-8 and then pass an additional C<utf8> flag to C<set_properties()>:
  
      my $smiley = pack 'H*', 'E298BA';
  
      $workbook->set_properties(
          subject => "Happy now? $smiley",
          utf8    => 1,
      );
  
  Usually Spreadsheet::WriteExcel allows you to use UTF-16 with pre 5.8 versions of perl. However, document properties don't support UTF-16 for these type of strings.
  
  In order to promote the usefulness of Perl and the Spreadsheet::WriteExcel module consider adding a comment such as the following when using document properties:
  
      $workbook->set_properties(
          ...,
          comments => 'Created with Perl and Spreadsheet::WriteExcel',
          ...,
      );
  
  This feature requires that the C<OLE::Storage_Lite> module is installed (which is usually the case for a standard Spreadsheet::WriteExcel installation). However, this also means that the resulting OLE document may B<possibly> be buggy for files less than 7MB since it hasn't been as rigorously tested in that domain. As a result of this C<set_properties> is currently incompatible with Gnumeric for files less than 7MB. This is being investigated. If you encounter any problems with this features let me know.
  
  For convenience it is possible to pass either a hash or hash ref of arguments to this method.
  
  See also the C<properties.pl> program in the examples directory of the distro.
  
  
  
  
  =head2 define_name()
  
  This method is used to defined a name that can be used to represent a value, a single cell or a range of cells in a workbook.
  
      $workbook->define_name('Exchange_rate', '=0.96');
      $workbook->define_name('Sales',         '=Sheet1!$G$1:$H$10');
      $workbook->define_name('Sheet2!Sales',  '=Sheet2!$G$1:$G$10');
  
  See the defined_name.pl program in the examples dir of the distro.
  
  Note: This currently a beta feature. More documentation and examples will be added.
  
  
  
  
  =head2 set_tempdir()
  
  For speed and efficiency C<Spreadsheet::WriteExcel> stores worksheet data in temporary files prior to assembling the final workbook.
  
  If Spreadsheet::WriteExcel is unable to create these temporary files it will store the required data in memory. This can be slow for large files.
  
  The problem occurs mainly with IIS on Windows although it could feasibly occur on Unix systems as well. The problem generally occurs because the default temp file directory is defined as C<C:/> or some other directory that IIS doesn't provide write access to.
  
  To check if this might be a problem on a particular system you can run a simple test program with C<-w> or C<use warnings>. This will generate a warning if the module cannot create the required temporary files:
  
      #!/usr/bin/perl -w
  
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new('test.xls');
      my $worksheet = $workbook->add_worksheet();
  
  To avoid this problem the C<set_tempdir()> method can be used to specify a directory that is accessible for the creation of temporary files.
  
  The C<File::Temp> module is used to create the temporary files. File::Temp uses C<File::Spec> to determine an appropriate location for these files such as C</tmp> or C<c:\windows\temp>. You can find out which directory is used on your system as follows:
  
      perl -MFile::Spec -le "print File::Spec->tmpdir"
  
  Even if the default temporary file directory is accessible you may wish to specify an alternative location for security or maintenance reasons:
  
      $workbook->set_tempdir('/tmp/writeexcel');
      $workbook->set_tempdir('c:\windows\temp\writeexcel');
  
  The directory for the temporary file must exist, C<set_tempdir()> will not create a new directory.
  
  One disadvantage of using the C<set_tempdir()> method is that on some Windows systems it will limit you to approximately 800 concurrent tempfiles. This means that a single program running on one of these systems will be limited to creating a total of 800 workbook and worksheet objects. You can run multiple, non-concurrent programs to work around this if necessary.
  
  
  
  
  =head2 set_custom_color($index, $red, $green, $blue)
  
  The C<set_custom_color()> method can be used to override one of the built-in palette values with a more suitable colour.
  
  The value for C<$index> should be in the range 8..63, see L</COLOURS IN EXCEL>.
  
  The default named colours use the following indices:
  
       8   =>   black
       9   =>   white
      10   =>   red
      11   =>   lime
      12   =>   blue
      13   =>   yellow
      14   =>   magenta
      15   =>   cyan
      16   =>   brown
      17   =>   green
      18   =>   navy
      20   =>   purple
      22   =>   silver
      23   =>   gray
      33   =>   pink
      53   =>   orange
  
  A new colour is set using its RGB (red green blue) components. The C<$red>, C<$green> and C<$blue> values must be in the range 0..255. You can determine the required values in Excel using the C<Tools-E<gt>Options-E<gt>Colors-E<gt>Modify> dialog.
  
  The C<set_custom_color()> workbook method can also be used with a HTML style C<#rrggbb> hex value:
  
      $workbook->set_custom_color(40, 255,  102,  0   ); # Orange
      $workbook->set_custom_color(40, 0xFF, 0x66, 0x00); # Same thing
      $workbook->set_custom_color(40, '#FF6600'       ); # Same thing
  
      my $font = $workbook->add_format(color => 40); # Use the modified colour
  
  The return value from C<set_custom_color()> is the index of the colour that was changed:
  
      my $ferrari = $workbook->set_custom_color(40, 216, 12, 12);
  
      my $format  = $workbook->add_format(
                                          bg_color => $ferrari,
                                          pattern  => 1,
                                          border   => 1
                                        );
  
  
  
  
  =head2 sheets(0, 1, ...)
  
  The C<sheets()> method returns a list, or a sliced list, of the worksheets in a workbook.
  
  If no arguments are passed the method returns a list of all the worksheets in the workbook. This is useful if you want to repeat an operation on each worksheet:
  
      foreach $worksheet ($workbook->sheets()) {
         print $worksheet->get_name();
      }
  
  
  You can also specify a slice list to return one or more worksheet objects:
  
      $worksheet = $workbook->sheets(0);
      $worksheet->write('A1', 'Hello');
  
  
  Or since return value from C<sheets()> is a reference to a worksheet object you can write the above example as:
  
      $workbook->sheets(0)->write('A1', 'Hello');
  
  
  The following example returns the first and last worksheet in a workbook:
  
      foreach $worksheet ($workbook->sheets(0, -1)) {
         # Do something
      }
  
  
  Array slices are explained in the perldata manpage.
  
  
  
  
  =head2 set_1904()
  
  Excel stores dates as real numbers where the integer part stores the number of days since the epoch and the fractional part stores the percentage of the day. The epoch can be either 1900 or 1904. Excel for Windows uses 1900 and Excel for Macintosh uses 1904. However, Excel on either platform will convert automatically between one system and the other.
  
  Spreadsheet::WriteExcel stores dates in the 1900 format by default. If you wish to change this you can call the C<set_1904()> workbook method. You can query the current value by calling the C<get_1904()> workbook method. This returns 0 for 1900 and 1 for 1904.
  
  See also L</DATES AND TIME IN EXCEL> for more information about working with Excel's date system.
  
  In general you probably won't need to use C<set_1904()>.
  
  
  
  
  =head2 set_codepage($codepage)
  
  The default code page or character set used by Spreadsheet::WriteExcel is ANSI. This is also the default used by Excel for Windows. Occasionally however it may be necessary to change the code page via the C<set_codepage()> method.
  
  Changing the code page may be required if your are using Spreadsheet::WriteExcel on the Macintosh and you are using characters outside the ASCII 128 character set:
  
      $workbook->set_codepage(1); # ANSI, MS Windows
      $workbook->set_codepage(2); # Apple Macintosh
  
  The C<set_codepage()> method is rarely required.
  
  
  
  
  =head1 WORKSHEET METHODS
  
  A new worksheet is created by calling the C<add_worksheet()> method from a workbook object:
  
      $worksheet1 = $workbook->add_worksheet();
      $worksheet2 = $workbook->add_worksheet();
  
  The following methods are available through a new worksheet:
  
      write()
      write_number()
      write_string()
      write_utf16be_string()
      write_utf16le_string()
      keep_leading_zeros()
      write_blank()
      write_row()
      write_col()
      write_date_time()
      write_url()
      write_url_range()
      write_formula()
      store_formula()
      repeat_formula()
      write_comment()
      show_comments()
      add_write_handler()
      insert_image()
      insert_chart()
      data_validation()
      get_name()
      activate()
      select()
      hide()
      set_first_sheet()
      protect()
      set_selection()
      set_row()
      set_column()
      outline_settings()
      freeze_panes()
      split_panes()
      merge_range()
      set_zoom()
      right_to_left()
      hide_zero()
      set_tab_color()
      autofilter()
  
  
  
  
  =head2 Cell notation
  
  Spreadsheet::WriteExcel supports two forms of notation to designate the position of cells: Row-column notation and A1 notation.
  
  Row-column notation uses a zero based index for both row and column while A1 notation uses the standard Excel alphanumeric sequence of column letter and 1-based row. For example:
  
      (0, 0)      # The top left cell in row-column notation.
      ('A1')      # The top left cell in A1 notation.
  
      (1999, 29)  # Row-column notation.
      ('AD2000')  # The same cell in A1 notation.
  
  Row-column notation is useful if you are referring to cells programmatically:
  
      for my $i (0 .. 9) {
          $worksheet->write($i, 0, 'Hello'); # Cells A1 to A10
      }
  
  A1 notation is useful for setting up a worksheet manually and for working with formulas:
  
      $worksheet->write('H1', 200);
      $worksheet->write('H2', '=H1+1');
  
  In formulas and applicable methods you can also use the C<A:A> column notation:
  
      $worksheet->write('A1', '=SUM(B:B)');
  
  The C<Spreadsheet::WriteExcel::Utility> module that is included in the distro contains helper functions for dealing with A1 notation, for example:
  
      use Spreadsheet::WriteExcel::Utility;
  
      ($row, $col)    = xl_cell_to_rowcol('C2');  # (1, 2)
      $str            = xl_rowcol_to_cell(1, 2);  # C2
  
  For simplicity, the parameter lists for the worksheet method calls in the following sections are given in terms of row-column notation. In all cases it is also possible to use A1 notation.
  
  Note: in Excel it is also possible to use a R1C1 notation. This is not supported by Spreadsheet::WriteExcel.
  
  
  
  
  =head2 write($row, $column, $token, $format)
  
  Excel makes a distinction between data types such as strings, numbers, blanks, formulas and hyperlinks. To simplify the process of writing data the C<write()> method acts as a general alias for several more specific methods:
  
      write_string()
      write_number()
      write_blank()
      write_formula()
      write_url()
      write_row()
      write_col()
  
  The general rule is that if the data looks like a I<something> then a I<something> is written. Here are some examples in both row-column and A1 notation:
  
                                                        # Same as:
      $worksheet->write(0, 0, 'Hello'                ); # write_string()
      $worksheet->write(1, 0, 'One'                  ); # write_string()
      $worksheet->write(2, 0,  2                     ); # write_number()
      $worksheet->write(3, 0,  3.00001               ); # write_number()
      $worksheet->write(4, 0,  ""                    ); # write_blank()
      $worksheet->write(5, 0,  ''                    ); # write_blank()
      $worksheet->write(6, 0,  undef                 ); # write_blank()
      $worksheet->write(7, 0                         ); # write_blank()
      $worksheet->write(8, 0,  'http://www.perl.com/'); # write_url()
      $worksheet->write('A9',  'ftp://ftp.cpan.org/' ); # write_url()
      $worksheet->write('A10', 'internal:Sheet1!A1'  ); # write_url()
      $worksheet->write('A11', 'external:c:\foo.xls' ); # write_url()
      $worksheet->write('A12', '=A3 + 3*A4'          ); # write_formula()
      $worksheet->write('A13', '=SIN(PI()/4)'        ); # write_formula()
      $worksheet->write('A14', \@array               ); # write_row()
      $worksheet->write('A15', [\@array]             ); # write_col()
  
      # And if the keep_leading_zeros property is set:
      $worksheet->write('A16', '2'                   ); # write_number()
      $worksheet->write('A17', '02'                  ); # write_string()
      $worksheet->write('A18', '00002'               ); # write_string()
  
  
  The "looks like" rule is defined by regular expressions:
  
  C<write_number()> if C<$token> is a number based on the following regex: C<$token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/>.
  
  C<write_string()> if C<keep_leading_zeros()> is set and C<$token> is an integer with leading zeros based on the following regex: C<$token =~ /^0\d+$/>.
  
  C<write_blank()> if C<$token> is undef or a blank string: C<undef>, C<""> or C<''>.
  
  C<write_url()> if C<$token> is a http, https, ftp or mailto URL based on the following regexes: C<$token =~ m|^[fh]tt?ps?://|> or  C<$token =~ m|^mailto:|>.
  
  C<write_url()> if C<$token> is an internal or external sheet reference based on the following regex: C<$token =~ m[^(in|ex)ternal:]>.
  
  C<write_formula()> if the first character of C<$token> is C<"=">.
  
  C<write_row()> if C<$token> is an array ref.
  
  C<write_col()> if C<$token> is an array ref of array refs.
  
  C<write_string()> if none of the previous conditions apply.
  
  The C<$format> parameter is optional. It should be a valid Format object, see L</CELL FORMATTING>:
  
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color('red');
      $format->set_align('center');
  
      $worksheet->write(4, 0, 'Hello', $format); # Formatted string
  
  The write() method will ignore empty strings or C<undef> tokens unless a format is also supplied. As such you needn't worry about special handling for empty or C<undef> values in your data. See also the C<write_blank()> method.
  
  One problem with the C<write()> method is that occasionally data looks like a number but you don't want it treated as a number. For example, zip codes or ID numbers often start with a leading zero. If you write this data as a number then the leading zero(s) will be stripped. You can change this default behaviour by using the C<keep_leading_zeros()> method. While this property is in place any integers with leading zeros will be treated as strings and the zeros will be preserved. See the C<keep_leading_zeros()> section for a full discussion of this issue.
  
  You can also add your own data handlers to the C<write()> method using C<add_write_handler()>.
  
  On systems with C<perl 5.8> and later the C<write()> method will also handle Unicode strings in C<UTF-8> format.
  
  The C<write> methods return:
  
      0 for success.
     -1 for insufficient number of arguments.
     -2 for row or column out of bounds.
     -3 for string too long.
  
  
  
  
  =head2 write_number($row, $column, $number, $format)
  
  Write an integer or a float to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_number(0, 0,  123456);
      $worksheet->write_number('A2',  2.3451);
  
  See the note about L</Cell notation>. The C<$format> parameter is optional.
  
  In general it is sufficient to use the C<write()> method.
  
  
  
  
  =head2 write_string($row, $column, $string, $format)
  
  Write a string to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_string(0, 0, 'Your text here' );
      $worksheet->write_string('A2', 'or here' );
  
  The maximum string size is 32767 characters. However the maximum string segment that Excel can display in a cell is 1000. All 32767 characters can be displayed in the formula bar.
  
  The C<$format> parameter is optional.
  
  On systems with C<perl 5.8> and later the C<write()> method will also handle strings in C<UTF-8> format. With older perls you can also write Unicode in C<UTF16> format via the C<write_utf16be_string()> method. See also the C<unicode_*.pl> programs in the examples directory of the distro.
  
  In general it is sufficient to use the C<write()> method. However, you may sometimes wish to use the C<write_string()> method to write data that looks like a number but that you don't want treated as a number. For example, zip codes or phone numbers:
  
      # Write as a plain string
      $worksheet->write_string('A1', '01209');
  
  However, if the user edits this string Excel may convert it back to a number. To get around this you can use the Excel text format C<@>:
  
      # Format as a string. Doesn't change to a number when edited
      my $format1 = $workbook->add_format(num_format => '@');
      $worksheet->write_string('A2', '01209', $format1);
  
  See also the note about L</Cell notation>.
  
  
  
  
  =head2 write_utf16be_string($row, $column, $string, $format)
  
  This method is used to write C<UTF-16BE> strings to a cell in Excel. It is functionally the same as the C<write_string()> method except that the string should be in C<UTF-16BE> Unicode format. It is generally easier, when using Spreadsheet::WriteExcel, to write unicode strings in C<UTF-8> format, see L</UNICODE IN EXCEL>. The C<write_utf16be_string()> method is mainly of use in versions of perl prior to 5.8.
  
  
  The following is a simple example showing how to write some Unicode strings in C<UTF-16BE> format:
  
      #!/usr/bin/perl -w
  
  
      use strict;
      use Spreadsheet::WriteExcel;
      use Unicode::Map();
  
      my $workbook  = Spreadsheet::WriteExcel->new('utf_16_be.xls');
      my $worksheet = $workbook->add_worksheet();
  
      # Increase the column width for clarity
      $worksheet->set_column('A:A', 25);
  
  
      # Write a Unicode character
      #
      my $smiley = pack 'n', 0x263a;
  
      # Increase the font size for legibility.
      my $big_font = $workbook->add_format(size => 72);
  
      $worksheet->write_utf16be_string('A3', $smiley, $big_font);
  
  
  
      # Write a phrase in Cyrillic using a hex-encoded string
      #
      my $str = pack 'H*', '042d0442043e0020044404400430043704300020043d' .
                           '043000200440044304410441043a043e043c0021';
  
      $worksheet->write_utf16be_string('A5', $str);
  
  
  
      # Map a string to UTF-16BE using an external module.
      #
      my $map   = Unicode::Map->new('ISO-8859-1');
      my $utf16 = $map->to_unicode('Hello world!');
  
      $worksheet->write_utf16be_string('A7', $utf16);
  
  You can convert ASCII encodings to the required C<UTF-16BE> format using one of the many Unicode modules on CPAN. For example C<Unicode::Map> and C<Unicode::String>: L<http://search.cpan.org/author/MSCHWARTZ/Unicode-Map/Map.pm> and L<http://search.cpan.org/author/GAAS/Unicode-String/String.pm>.
  
  For a full list of the Perl Unicode modules see: L<http://search.cpan.org/search?query=unicode&mode=all>.
  
  C<UTF-16BE> is the format most often returned by C<Perl> modules that generate C<UTF-16>. To write C<UTF-16> strings in little-endian format use the C<write_utf16be_string_le()> method below.
  
  The C<write_utf16be_string()> method was previously called C<write_unicode()>. That, overly general, name is still supported but deprecated.
  
  See also the C<unicode_*.pl> programs in the examples directory of the distro.
  
  
  
  
  =head2 write_utf16le_string($row, $column, $string, $format)
  
  This method is the same as C<write_utf16be()> except that the string should be 16-bit characters in little-endian format. This is generally referred to as C<UTF-16LE>. See L</UNICODE IN EXCEL>.
  
  C<UTF-16> data can be changed from little-endian to big-endian format (and vice-versa) as follows:
  
      $utf16be = pack 'n*', unpack 'v*', $utf16le;
  
  
  
  
  =head2 keep_leading_zeros()
  
  This method changes the default handling of integers with leading zeros when using the C<write()> method.
  
  The C<write()> method uses regular expressions to determine what type of data to write to an Excel worksheet. If the data looks like a number it writes a number using C<write_number()>. One problem with this approach is that occasionally data looks like a number but you don't want it treated as a number.
  
  Zip codes and ID numbers, for example, often start with a leading zero. If you write this data as a number then the leading zero(s) will be stripped. This is the also the default behaviour when you enter data manually in Excel.
  
  To get around this you can use one of three options. Write a formatted number, write the number as a string or use the C<keep_leading_zeros()> method to change the default behaviour of C<write()>:
  
      # Implicitly write a number, the leading zero is removed: 1209
      $worksheet->write('A1', '01209');
  
      # Write a zero padded number using a format: 01209
      my $format1 = $workbook->add_format(num_format => '00000');
      $worksheet->write('A2', '01209', $format1);
  
      # Write explicitly as a string: 01209
      $worksheet->write_string('A3', '01209');
  
      # Write implicitly as a string: 01209
      $worksheet->keep_leading_zeros();
      $worksheet->write('A4', '01209');
  
  
  The above code would generate a worksheet that looked like the following:
  
       -----------------------------------------------------------
      |   |     A     |     B     |     C     |     D     | ...
       -----------------------------------------------------------
      | 1 |      1209 |           |           |           | ...
      | 2 |     01209 |           |           |           | ...
      | 3 | 01209     |           |           |           | ...
      | 4 | 01209     |           |           |           | ...
  
  
  The examples are on different sides of the cells due to the fact that Excel displays strings with a left justification and numbers with a right justification by default. You can change this by using a format to justify the data, see L</CELL FORMATTING>.
  
  It should be noted that if the user edits the data in examples C<A3> and C<A4> the strings will revert back to numbers. Again this is Excel's default behaviour. To avoid this you can use the text format C<@>:
  
      # Format as a string (01209)
      my $format2 = $workbook->add_format(num_format => '@');
      $worksheet->write_string('A5', '01209', $format2);
  
  The C<keep_leading_zeros()> property is off by default. The C<keep_leading_zeros()> method takes 0 or 1 as an argument. It defaults to 1 if an argument isn't specified:
  
      $worksheet->keep_leading_zeros();  # Set on
      $worksheet->keep_leading_zeros(1); # Set on
      $worksheet->keep_leading_zeros(0); # Set off
  
  See also the C<add_write_handler()> method.
  
  
  =head2 write_blank($row, $column, $format)
  
  Write a blank cell specified by C<$row> and C<$column>:
  
      $worksheet->write_blank(0, 0, $format);
  
  This method is used to add formatting to a cell which doesn't contain a string or number value.
  
  Excel differentiates between an "Empty" cell and a "Blank" cell. An "Empty" cell is a cell which doesn't contain data whilst a "Blank" cell is a cell which doesn't contain data but does contain formatting. Excel stores "Blank" cells but ignores "Empty" cells.
  
  As such, if you write an empty cell without formatting it is ignored:
  
      $worksheet->write('A1',  undef, $format); # write_blank()
      $worksheet->write('A2',  undef         ); # Ignored
  
  This seemingly uninteresting fact means that you can write arrays of data without special treatment for undef or empty string values.
  
  See the note about L</Cell notation>.
  
  
  
  
  =head2 write_row($row, $column, $array_ref, $format)
  
  The C<write_row()> method can be used to write a 1D or 2D array of data in one go. This is useful for converting the results of a database query into an Excel worksheet. You must pass a reference to the array of data rather than the array itself. The C<write()> method is then called for each element of the data. For example:
  
      @array      = ('awk', 'gawk', 'mawk');
      $array_ref  = \@array;
  
      $worksheet->write_row(0, 0, $array_ref);
  
      # The above example is equivalent to:
      $worksheet->write(0, 0, $array[0]);
      $worksheet->write(0, 1, $array[1]);
      $worksheet->write(0, 2, $array[2]);
  
  
  Note: For convenience the C<write()> method behaves in the same way as C<write_row()> if it is passed an array reference. Therefore the following two method calls are equivalent:
  
      $worksheet->write_row('A1', $array_ref); # Write a row of data
      $worksheet->write(    'A1', $array_ref); # Same thing
  
  As with all of the write methods the C<$format> parameter is optional. If a format is specified it is applied to all the elements of the data array.
  
  Array references within the data will be treated as columns. This allows you to write 2D arrays of data in one go. For example:
  
      @eec =  (
                  ['maggie', 'milly', 'molly', 'may'  ],
                  [13,       14,      15,      16     ],
                  ['shell',  'star',  'crab',  'stone']
              );
  
      $worksheet->write_row('A1', \@eec);
  
  
  Would produce a worksheet as follows:
  
       -----------------------------------------------------------
      |   |    A    |    B    |    C    |    D    |    E    | ...
       -----------------------------------------------------------
      | 1 | maggie  | 13      | shell   | ...     |  ...    | ...
      | 2 | milly   | 14      | star    | ...     |  ...    | ...
      | 3 | molly   | 15      | crab    | ...     |  ...    | ...
      | 4 | may     | 16      | stone   | ...     |  ...    | ...
      | 5 | ...     | ...     | ...     | ...     |  ...    | ...
      | 6 | ...     | ...     | ...     | ...     |  ...    | ...
  
  
  To write the data in a row-column order refer to the C<write_col()> method below.
  
  Any C<undef> values in the data will be ignored unless a format is applied to the data, in which case a formatted blank cell will be written. In either case the appropriate row or column value will still be incremented.
  
  To find out more about array references refer to C<perlref> and C<perlreftut> in the main Perl documentation. To find out more about 2D arrays or "lists of lists" refer to C<perllol>.
  
  The C<write_row()> method returns the first error encountered when writing the elements of the data or zero if no errors were encountered. See the return values described for the C<write()> method above.
  
  See also the C<write_arrays.pl> program in the C<examples> directory of the distro.
  
  The C<write_row()> method allows the following idiomatic conversion of a text file to an Excel file:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new('file.xls');
      my $worksheet = $workbook->add_worksheet();
  
      open INPUT, 'file.txt' or die "Couldn't open file: $!";
  
      $worksheet->write($.-1, 0, [split]) while <INPUT>;
  
  
  
  
  =head2 write_col($row, $column, $array_ref, $format)
  
  The C<write_col()> method can be used to write a 1D or 2D array of data in one go. This is useful for converting the results of a database query into an Excel worksheet. You must pass a reference to the array of data rather than the array itself. The C<write()> method is then called for each element of the data. For example:
  
      @array      = ('awk', 'gawk', 'mawk');
      $array_ref  = \@array;
  
      $worksheet->write_col(0, 0, $array_ref);
  
      # The above example is equivalent to:
      $worksheet->write(0, 0, $array[0]);
      $worksheet->write(1, 0, $array[1]);
      $worksheet->write(2, 0, $array[2]);
  
  As with all of the write methods the C<$format> parameter is optional. If a format is specified it is applied to all the elements of the data array.
  
  Array references within the data will be treated as rows. This allows you to write 2D arrays of data in one go. For example:
  
      @eec =  (
                  ['maggie', 'milly', 'molly', 'may'  ],
                  [13,       14,      15,      16     ],
                  ['shell',  'star',  'crab',  'stone']
              );
  
      $worksheet->write_col('A1', \@eec);
  
  
  Would produce a worksheet as follows:
  
       -----------------------------------------------------------
      |   |    A    |    B    |    C    |    D    |    E    | ...
       -----------------------------------------------------------
      | 1 | maggie  | milly   | molly   | may     |  ...    | ...
      | 2 | 13      | 14      | 15      | 16      |  ...    | ...
      | 3 | shell   | star    | crab    | stone   |  ...    | ...
      | 4 | ...     | ...     | ...     | ...     |  ...    | ...
      | 5 | ...     | ...     | ...     | ...     |  ...    | ...
      | 6 | ...     | ...     | ...     | ...     |  ...    | ...
  
  
  To write the data in a column-row order refer to the C<write_row()> method above.
  
  Any C<undef> values in the data will be ignored unless a format is applied to the data, in which case a formatted blank cell will be written. In either case the appropriate row or column value will still be incremented.
  
  As noted above the C<write()> method can be used as a synonym for C<write_row()> and C<write_row()> handles nested array refs as columns. Therefore, the following two method calls are equivalent although the more explicit call to C<write_col()> would be preferable for maintainability:
  
      $worksheet->write_col('A1', $array_ref    ); # Write a column of data
      $worksheet->write(    'A1', [ $array_ref ]); # Same thing
  
  To find out more about array references refer to C<perlref> and C<perlreftut> in the main Perl documentation. To find out more about 2D arrays or "lists of lists" refer to C<perllol>.
  
  The C<write_col()> method returns the first error encountered when writing the elements of the data or zero if no errors were encountered. See the return values described for the C<write()> method above.
  
  See also the C<write_arrays.pl> program in the C<examples> directory of the distro.
  
  
  
  
  =head2 write_date_time($row, $col, $date_string, $format)
  
  The C<write_date_time()> method can be used to write a date or time to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_date_time('A1', '2004-05-13T23:20', $date_format);
  
  The C<$date_string> should be in the following format:
  
      yyyy-mm-ddThh:mm:ss.sss
  
  This conforms to an ISO8601 date but it should be noted that the full range of ISO8601 formats are not supported.
  
  The following variations on the C<$date_string> parameter are permitted:
  
      yyyy-mm-ddThh:mm:ss.sss         # Standard format
      yyyy-mm-ddT                     # No time
                Thh:mm:ss.sss         # No date
      yyyy-mm-ddThh:mm:ss.sssZ        # Additional Z (but not time zones)
      yyyy-mm-ddThh:mm:ss             # No fractional seconds
      yyyy-mm-ddThh:mm                # No seconds
  
  Note that the C<T> is required in all cases.
  
  A date should always have a C<$format>, otherwise it will appear as a number, see L</DATES AND TIME IN EXCEL> and L</CELL FORMATTING>. Here is a typical example:
  
      my $date_format = $workbook->add_format(num_format => 'mm/dd/yy');
      $worksheet->write_date_time('A1', '2004-05-13T23:20', $date_format);
  
  Valid dates should be in the range 1900-01-01 to 9999-12-31, for the 1900 epoch and 1904-01-01 to 9999-12-31, for the 1904 epoch. As with Excel, dates outside these ranges will be written as a string.
  
  See also the date_time.pl program in the C<examples> directory of the distro.
  
  
  
  
  =head2 write_url($row, $col, $url, $label, $format)
  
  Write a hyperlink to a URL in the cell specified by C<$row> and C<$column>. The hyperlink is comprised of two elements: the visible label and the invisible link. The visible label is the same as the link unless an alternative label is specified. The parameters C<$label> and the C<$format> are optional and their position is interchangeable.
  
  The label is written using the C<write()> method. Therefore it is possible to write strings, numbers or formulas as labels.
  
  There are four web style URI's supported: C<http://>, C<https://>, C<ftp://> and  C<mailto:>:
  
      $worksheet->write_url(0, 0,  'ftp://www.perl.org/'                  );
      $worksheet->write_url(1, 0,  'http://www.perl.com/', 'Perl home'    );
      $worksheet->write_url('A3',  'http://www.perl.com/', $format        );
      $worksheet->write_url('A4',  'http://www.perl.com/', 'Perl', $format);
      $worksheet->write_url('A5',  'mailto:jmcnamara@cpan.org'            );
  
  There are two local URIs supported: C<internal:> and C<external:>. These are used for hyperlinks to internal worksheet references or external workbook and worksheet references:
  
      $worksheet->write_url('A6',  'internal:Sheet2!A1'                   );
      $worksheet->write_url('A7',  'internal:Sheet2!A1',   $format        );
      $worksheet->write_url('A8',  'internal:Sheet2!A1:B2'                );
      $worksheet->write_url('A9',  q{internal:'Sales Data'!A1}            );
      $worksheet->write_url('A10', 'external:c:\temp\foo.xls'             );
      $worksheet->write_url('A11', 'external:c:\temp\foo.xls#Sheet2!A1'   );
      $worksheet->write_url('A12', 'external:..\..\..\foo.xls'            );
      $worksheet->write_url('A13', 'external:..\..\..\foo.xls#Sheet2!A1'  );
      $worksheet->write_url('A13', 'external:\\\\NETWORK\share\foo.xls'   );
  
  All of the these URI types are recognised by the C<write()> method, see above.
  
  Worksheet references are typically of the form C<Sheet1!A1>. You can also refer to a worksheet range using the standard Excel notation: C<Sheet1!A1:B2>.
  
  In external links the workbook and worksheet name must be separated by the C<#> character: C<external:Workbook.xls#Sheet1!A1'>.
  
  You can also link to a named range in the target worksheet. For example say you have a named range called C<my_name> in the workbook C<c:\temp\foo.xls> you could link to it as follows:
  
      $worksheet->write_url('A14', 'external:c:\temp\foo.xls#my_name');
  
  Note, you cannot currently create named ranges with C<Spreadsheet::WriteExcel>.
  
  Excel requires that worksheet names containing spaces or non alphanumeric characters are single quoted as follows C<'Sales Data'!A1>. If you need to do this in a single quoted string then you can either escape the single quotes C<\'> or use the quote operator C<q{}> as described in C<perlop> in the main Perl documentation.
  
  Links to network files are also supported. MS/Novell Network files normally begin with two back slashes as follows C<\\NETWORK\etc>. In order to generate this in a single or double quoted string you will have to escape the backslashes,  C<'\\\\NETWORK\etc'>.
  
  If you are using double quote strings then you should be careful to escape anything that looks like a metacharacter. For more information  see C<perlfaq5: Why can't I use "C:\temp\foo" in DOS paths?>.
  
  Finally, you can avoid most of these quoting problems by using forward slashes. These are translated internally to backslashes:
  
      $worksheet->write_url('A14', "external:c:/temp/foo.xls"             );
      $worksheet->write_url('A15', 'external://NETWORK/share/foo.xls'     );
  
  See also, the note about L</Cell notation>.
  
  
  
  
  =head2 write_url_range($row1, $col1, $row2, $col2, $url, $string, $format)
  
  This method is essentially the same as the C<write_url()> method described above. The main difference is that you can specify a link for a range of cells:
  
      $worksheet->write_url(0, 0, 0, 3, 'ftp://www.perl.org/'              );
      $worksheet->write_url(1, 0, 0, 3, 'http://www.perl.com/', 'Perl home');
      $worksheet->write_url('A3:D3',    'internal:Sheet2!A1'               );
      $worksheet->write_url('A4:D4',    'external:c:\temp\foo.xls'         );
  
  
  This method is generally only required when used in conjunction with merged cells. See the C<merge_range()> method and the C<merge> property of a Format object, L</CELL FORMATTING>.
  
  There is no way to force this behaviour through the C<write()> method.
  
  The parameters C<$string> and the C<$format> are optional and their position is interchangeable. However, they are applied only to the first cell in the range.
  
  See also, the note about L</Cell notation>.
  
  
  
  
  =head2 write_formula($row, $column, $formula, $format, $value)
  
  Write a formula or function to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_formula(0, 0, '=$B$3 + B4'  );
      $worksheet->write_formula(1, 0, '=SIN(PI()/4)');
      $worksheet->write_formula(2, 0, '=SUM(B1:B5)' );
      $worksheet->write_formula('A4', '=IF(A3>1,"Yes", "No")'   );
      $worksheet->write_formula('A5', '=AVERAGE(1, 2, 3, 4)'    );
      $worksheet->write_formula('A6', '=DATEVALUE("1-Jan-2001")');
  
  See the note about L</Cell notation>. For more information about writing Excel formulas see L</FORMULAS AND FUNCTIONS IN EXCEL>
  
  See also the section "Improving performance when working with formulas" and the C<store_formula()> and C<repeat_formula()> methods.
  
  If required, it is also possible to specify the calculated value of the formula. This is occasionally necessary when working with non-Excel applications that don't calculate the value of the formula. The calculated C<$value> is added at the end of the argument list:
  
      $worksheet->write('A1', '=2+2', $format, 4);
  
  However, this probably isn't something that will ever need to do. If you do use this feature then do so with care.
  
  
  
  
  =head2 store_formula($formula)
  
  The C<store_formula()> method is used in conjunction with C<repeat_formula()> to speed up the generation of repeated formulas. See "Improving performance when working with formulas" in L</FORMULAS AND FUNCTIONS IN EXCEL>.
  
  The C<store_formula()> method pre-parses a textual representation of a formula and stores it for use at a later stage by the C<repeat_formula()> method.
  
  C<store_formula()> carries the same speed penalty as C<write_formula()>. However, in practice it will be used less frequently.
  
  The return value of this method is a scalar that can be thought of as a reference to a formula.
  
      my $sin = $worksheet->store_formula('=SIN(A1)');
      my $cos = $worksheet->store_formula('=COS(A1)');
  
      $worksheet->repeat_formula('B1', $sin, $format, 'A1', 'A2');
      $worksheet->repeat_formula('C1', $cos, $format, 'A1', 'A2');
  
  Although C<store_formula()> is a worksheet method the return value can be used in any worksheet:
  
      my $now = $worksheet->store_formula('=NOW()');
  
      $worksheet1->repeat_formula('B1', $now);
      $worksheet2->repeat_formula('B1', $now);
      $worksheet3->repeat_formula('B1', $now);
  
  
  
  =head2 repeat_formula($row, $col, $formula, $format, ($pattern => $replace, ...))
  
  
  The C<repeat_formula()> method is used in conjunction with C<store_formula()> to speed up the generation of repeated formulas.  See "Improving performance when working with formulas" in L</FORMULAS AND FUNCTIONS IN EXCEL>.
  
  In many respects C<repeat_formula()> behaves like C<write_formula()> except that it is significantly faster.
  
  The C<repeat_formula()> method creates a new formula based on the pre-parsed tokens returned by C<store_formula()>. The new formula is generated by substituting C<$pattern>, C<$replace> pairs in the stored formula:
  
      my $formula = $worksheet->store_formula('=A1 * 3 + 50');
  
      for my $row (0..99) {
          $worksheet->repeat_formula($row, 1, $formula, $format, 'A1', 'A'.($row +1));
      }
  
  It should be noted that C<repeat_formula()> doesn't modify the tokens. In the above example the substitution is always made against the original token, C<A1>, which doesn't change.
  
  As usual, you can use C<undef> if you don't wish to specify a C<$format>:
  
      $worksheet->repeat_formula('B2', $formula, $format, 'A1', 'A2');
      $worksheet->repeat_formula('B3', $formula, undef,   'A1', 'A3');
  
  The substitutions are made from left to right and you can use as many C<$pattern>, C<$replace> pairs as you need. However, each substitution is made only once:
  
      my $formula = $worksheet->store_formula('=A1 + A1');
  
      # Gives '=B1 + A1'
      $worksheet->repeat_formula('B1', $formula, undef, 'A1', 'B1');
  
      # Gives '=B1 + B1'
      $worksheet->repeat_formula('B2', $formula, undef, ('A1', 'B1') x 2);
  
  Since the C<$pattern> is interpolated each time that it is used it is worth using the C<qr> operator to quote the pattern. The C<qr> operator is explained in the C<perlop> man page.
  
      $worksheet->repeat_formula('B1', $formula, $format, qr/A1/, 'A2');
  
  Care should be taken with the values that are substituted. The formula returned by C<repeat_formula()> contains several other tokens in addition to those in the formula and these might also match the  pattern that you are trying to replace. In particular you should avoid substituting a single 0, 1, 2 or 3.
  
  You should also be careful to avoid false matches. For example the following snippet is meant to change the stored formula in steps from C<=A1 + SIN(A1)> to C<=A10 + SIN(A10)>.
  
      my $formula = $worksheet->store_formula('=A1 + SIN(A1)');
  
      for my $row (1 .. 10) {
          $worksheet->repeat_formula($row -1, 1, $formula, undef,
                                      qw/A1/, 'A' . $row,   #! Bad.
                                      qw/A1/, 'A' . $row    #! Bad.
                                    );
      }
  
  However it contains a bug. In the last iteration of the loop when C<$row> is 10 the following substitutions will occur:
  
      s/A1/A10/;    changes    =A1 + SIN(A1)     to    =A10 + SIN(A1)
      s/A1/A10/;    changes    =A10 + SIN(A1)    to    =A100 + SIN(A1) # !!
  
  The solution in this case is to use a more explicit match such as C<qw/^A1$/>:
  
          $worksheet->repeat_formula($row -1, 1, $formula, undef,
                                      qw/^A1$/, 'A' . $row,
                                      qw/^A1$/, 'A' . $row
                                    );
  
  Another similar problem occurs due to the fact that substitutions are made in order. For example the following snippet is meant to change the stored formula from C<=A10 + A11>  to C<=A11 + A12>:
  
      my $formula = $worksheet->store_formula('=A10 + A11');
  
      $worksheet->repeat_formula('A1', $formula, undef,
                                  qw/A10/, 'A11',   #! Bad.
                                  qw/A11/, 'A12'    #! Bad.
                                );
  
  However, the actual substitution yields C<=A12 + A11>:
  
      s/A10/A11/;    changes    =A10 + A11    to    =A11 + A11
      s/A11/A12/;    changes    =A11 + A11    to    =A12 + A11 # !!
  
  The solution here would be to reverse the order of the substitutions or to start with a stored formula that won't yield a false match such as C<=X10 + Y11>:
  
      my $formula = $worksheet->store_formula('=X10 + Y11');
  
      $worksheet->repeat_formula('A1', $formula, undef,
                                  qw/X10/, 'A11',
                                  qw/Y11/, 'A12'
                                );
  
  
  If you think that you have a problem related to a false match you can check the tokens that you are substituting against as follows.
  
      my $formula = $worksheet->store_formula('=A1*5+4');
      print "@$formula\n";
  
  See also the C<repeat.pl> program in the C<examples> directory of the distro.
  
  
  
  
  =head2 write_comment($row, $column, $string, ...)
  
  The C<write_comment()> method is used to add a comment to a cell. A cell comment is indicated in Excel by a small red triangle in the upper right-hand corner of the cell. Moving the cursor over the red triangle will reveal the comment.
  
  The following example shows how to add a comment to a cell:
  
      $worksheet->write        (2, 2, 'Hello');
      $worksheet->write_comment(2, 2, 'This is a comment.');
  
  As usual you can replace the C<$row> and C<$column> parameters with an C<A1> cell reference. See the note about L</Cell notation>.
  
      $worksheet->write        ('C3', 'Hello');
      $worksheet->write_comment('C3', 'This is a comment.');
  
  On systems with C<perl 5.8> and later the C<write_comment()> method will also handle strings in C<UTF-8> format.
  
      $worksheet->write_comment('C3', "\x{263a}");       # Smiley
      $worksheet->write_comment('C4', 'Comment ca va?');
  
  In addition to the basic 3 argument form of C<write_comment()> you can pass in several optional key/value pairs to control the format of the comment. For example:
  
      $worksheet->write_comment('C3', 'Hello', visible => 1, author => 'Perl');
  
  Most of these options are quite specific and in general the default comment behaviour will be all that you need. However, should you need greater control over the format of the cell comment the following options are available:
  
      encoding
      author
      author_encoding
      visible
      x_scale
      width
      y_scale
      height
      color
      start_cell
      start_row
      start_col
      x_offset
      y_offset
  
  
  =over 4
  
  =item Option: encoding
  
  This option is used to indicate that the comment string is encoded as C<UTF-16BE>.
  
      my $comment = pack 'n', 0x263a; # UTF-16BE Smiley symbol
  
      $worksheet->write_comment('C3', $comment, encoding => 1);
  
  If you wish to use Unicode characters in the comment string then the preferred method is to use perl 5.8 and C<UTF-8> strings, see L</UNICODE IN EXCEL>.
  
  
  =item Option: author
  
  This option is used to indicate who the author of the comment is. Excel displays the author of the comment in the status bar at the bottom of the worksheet. This is usually of interest in corporate environments where several people might review and provide comments to a workbook.
  
      $worksheet->write_comment('C3', 'Atonement', author => 'Ian McEwan');
  
  
  =item Option: author_encoding
  
  This option is used to indicate that the author string is encoded as C<UTF-16BE>.
  
  
  =item Option: visible
  
  This option is used to make a cell comment visible when the worksheet is opened. The default behaviour in Excel is that comments are initially hidden. However, it is also possible in Excel to make individual or all comments visible. In Spreadsheet::WriteExcel individual comments can be made visible as follows:
  
      $worksheet->write_comment('C3', 'Hello', visible => 1);
  
  It is possible to make all comments in a worksheet visible using the C<show_comments()> worksheet method (see below). Alternatively, if all of the cell comments have been made visible you can hide individual comments:
  
      $worksheet->write_comment('C3', 'Hello', visible => 0);
  
  
  =item Option: x_scale
  
  This option is used to set the width of the cell comment box as a factor of the default width.
  
      $worksheet->write_comment('C3', 'Hello', x_scale => 2);
      $worksheet->write_comment('C4', 'Hello', x_scale => 4.2);
  
  
  =item Option: width
  
  This option is used to set the width of the cell comment box explicitly in pixels.
  
      $worksheet->write_comment('C3', 'Hello', width => 200);
  
  
  =item Option: y_scale
  
  This option is used to set the height of the cell comment box as a factor of the default height.
  
      $worksheet->write_comment('C3', 'Hello', y_scale => 2);
      $worksheet->write_comment('C4', 'Hello', y_scale => 4.2);
  
  
  =item Option: height
  
  This option is used to set the height of the cell comment box explicitly in pixels.
  
      $worksheet->write_comment('C3', 'Hello', height => 200);
  
  
  =item Option: color
  
  This option is used to set the background colour of cell comment box. You can use one of the named colours recognised by Spreadsheet::WriteExcel or a colour index. See L</COLOURS IN EXCEL>.
  
      $worksheet->write_comment('C3', 'Hello', color => 'green');
      $worksheet->write_comment('C4', 'Hello', color => 0x35);    # Orange
  
  
  =item Option: start_cell
  
  This option is used to set the cell in which the comment will appear. By default Excel displays comments one cell to the right and one cell above the cell to which the comment relates. However, you can change this behaviour if you wish. In the following example the comment which would appear by default in cell C<D2> is moved to C<E2>.
  
      $worksheet->write_comment('C3', 'Hello', start_cell => 'E2');
  
  
  =item Option: start_row
  
  This option is used to set the row in which the comment will appear. See the C<start_cell> option above. The row is zero indexed.
  
      $worksheet->write_comment('C3', 'Hello', start_row => 0);
  
  
  =item Option: start_col
  
  This option is used to set the column in which the comment will appear. See the C<start_cell> option above. The column is zero indexed.
  
      $worksheet->write_comment('C3', 'Hello', start_col => 4);
  
  
  =item Option: x_offset
  
  This option is used to change the x offset, in pixels, of a comment within a cell:
  
      $worksheet->write_comment('C3', $comment, x_offset => 30);
  
  
  =item Option: y_offset
  
  This option is used to change the y offset, in pixels, of a comment within a cell:
  
      $worksheet->write_comment('C3', $comment, x_offset => 30);
  
  
  =back
  
  You can apply as many of these options as you require.
  
  See also L</ROW HEIGHTS AND WORKSHEET OBJECTS>.
  
  
  
  
  =head2 show_comments()
  
  This method is used to make all cell comments visible when a worksheet is opened.
  
  Individual comments can be made visible using the C<visible> parameter of the C<write_comment> method (see above):
  
      $worksheet->write_comment('C3', 'Hello', visible => 1);
  
  If all of the cell comments have been made visible you can hide individual comments as follows:
  
      $worksheet->write_comment('C3', 'Hello', visible => 0);
  
  
  
  
  =head2 add_write_handler($re, $code_ref)
  
  This method is used to extend the Spreadsheet::WriteExcel write() method to handle user defined data.
  
  If you refer to the section on C<write()> above you will see that it acts as an alias for several more specific C<write_*> methods. However, it doesn't always act in exactly the way that you would like it to.
  
  One solution is to filter the input data yourself and call the appropriate C<write_*> method. Another approach is to use the C<add_write_handler()> method to add your own automated behaviour to C<write()>.
  
  The C<add_write_handler()> method take two arguments, C<$re>, a regular expression to match incoming data and C<$code_ref> a callback function to handle the matched data:
  
      $worksheet->add_write_handler(qr/^\d\d\d\d$/, \&my_write);
  
  (In the these examples the C<qr> operator is used to quote the regular expression strings, see L<perlop> for more details).
  
  The method is used as follows. say you wished to write 7 digit ID numbers as a string so that any leading zeros were preserved*, you could do something like the following:
  
      $worksheet->add_write_handler(qr/^\d{7}$/, \&write_my_id);
  
  
      sub write_my_id {
          my $worksheet = shift;
          return $worksheet->write_string(@_);
      }
  
  * You could also use the C<keep_leading_zeros()> method for this.
  
  Then if you call C<write()> with an appropriate string it will be handled automatically:
  
      # Writes 0000000. It would normally be written as a number; 0.
      $worksheet->write('A1', '0000000');
  
  The callback function will receive a reference to the calling worksheet and all of the other arguments that were passed to C<write()>. The callback will see an C<@_> argument list that looks like the following:
  
      $_[0]   A ref to the calling worksheet. *
      $_[1]   Zero based row number.
      $_[2]   Zero based column number.
      $_[3]   A number or string or token.
      $_[4]   A format ref if any.
      $_[5]   Any other arguments.
      ...
  
      *  It is good style to shift this off the list so the @_ is the same
         as the argument list seen by write().
  
  Your callback should C<return()> the return value of the C<write_*> method that was called or C<undef> to indicate that you rejected the match and want C<write()> to continue as normal.
  
  So for example if you wished to apply the previous filter only to ID values that occur in the first column you could modify your callback function as follows:
  
  
      sub write_my_id {
          my $worksheet = shift;
          my $col       = $_[1];
  
          if ($col == 0) {
              return $worksheet->write_string(@_);
          }
          else {
              # Reject the match and return control to write()
              return undef;
          }
      }
  
  Now, you will get different behaviour for the first column and other columns:
  
      $worksheet->write('A1', '0000000'); # Writes 0000000
      $worksheet->write('B1', '0000000'); # Writes 0
  
  
  You may add more than one handler in which case they will be called in the order that they were added.
  
  Note, the C<add_write_handler()> method is particularly suited for handling dates.
  
  See the C<write_handler 1-4> programs in the C<examples> directory for further examples.
  
  
  
  
  =head2 insert_image($row, $col, $filename, $x, $y, $scale_x, $scale_y)
  
  This method can be used to insert a image into a worksheet. The image can be in PNG, JPEG or BMP format. The C<$x>, C<$y>, C<$scale_x> and C<$scale_y> parameters are optional.
  
      $worksheet1->insert_image('A1', 'perl.bmp');
      $worksheet2->insert_image('A1', '../images/perl.bmp');
      $worksheet3->insert_image('A1', '.c:\images\perl.bmp');
  
  The parameters C<$x> and C<$y> can be used to specify an offset from the top left hand corner of the cell specified by C<$row> and C<$col>. The offset values are in pixels.
  
      $worksheet1->insert_image('A1', 'perl.bmp', 32, 10);
  
  The default width of a cell is 63 pixels. The default height of a cell is 17 pixels. The pixels offsets can be calculated using the following relationships:
  
      Wp = int(12We)   if We <  1
      Wp = int(7We +5) if We >= 1
      Hp = int(4/3He)
  
      where:
      We is the cell width in Excels units
      Wp is width in pixels
      He is the cell height in Excels units
      Hp is height in pixels
  
  The offsets can be greater than the width or height of the underlying cell. This can be occasionally useful if you wish to align two or more images relative to the same cell.
  
  The parameters C<$scale_x> and C<$scale_y> can be used to scale the inserted image horizontally and vertically:
  
      # Scale the inserted image: width x 2.0, height x 0.8
      $worksheet->insert_image('A1', 'perl.bmp', 0, 0, 2, 0.8);
  
  See also the C<images.pl> program in the C<examples> directory of the distro.
  
  BMP images must be 24 bit, true colour, bitmaps. In general it is best to avoid BMP images since they aren't compressed. The older C<insert_bitmap()> method is still supported but deprecated.
  
  See also L</ROW HEIGHTS AND WORKSHEET OBJECTS>.
  
  
  
  
  =head2 insert_chart($row, $col, $chart, $x, $y, $scale_x, $scale_y)
  
  This method can be used to insert a Chart object into a worksheet. The Chart must be created by the C<add_chart()> Workbook method  and it must have the C<embedded> option set.
  
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the chart.
      ...
  
      # Insert the chart into the a worksheet.
      $worksheet->insert_chart('E2', $chart);
  
  See C<add_chart()> for details on how to create the Chart object and L<Spreadsheet::WriteExcel::Chart> for details on how to configure it. See also the C<chart_*.pl> programs in the examples directory of the distro.
  
  The C<$x>, C<$y>, C<$scale_x> and C<$scale_y> parameters are optional.
  
  The parameters C<$x> and C<$y> can be used to specify an offset from the top left hand corner of the cell specified by C<$row> and C<$col>. The offset values are in pixels. See the C<insert_image> method above for more information on sizes.
  
      $worksheet1->insert_chart('E2', $chart, 3, 3);
  
  The parameters C<$scale_x> and C<$scale_y> can be used to scale the inserted image horizontally and vertically:
  
      # Scale the width by 120% and the height by 150%
      $worksheet->insert_chart('E2', $chart, 0, 0, 1.2, 1.5);
  
  The easiest way to calculate the required scaling is to create a test chart worksheet with Spreadsheet::WriteExcel. Then open the file, select the chart and drag the corner to get the required size. While holding down the mouse the scale of the resized chart is shown to the left of the formula bar.
  
  See also L</ROW HEIGHTS AND WORKSHEET OBJECTS>.
  
  
  
  
  =head2 embed_chart($row, $col, $filename, $x, $y, $scale_x, $scale_y)
  
  This method can be used to insert a externally generated chart into a worksheet. The chart must first be extracted from an existing Excel file. This feature is semi-deprecated in favour of the "native" charts created using C<add_chart()>. Read C<external_charts.txt> (or C<.pod>) in the external_charts directory of the distro for a full explanation.
  
  Here is an example:
  
      $worksheet->embed_chart('B2', 'sales_chart.bin');
  
  The C<$x>, C<$y>, C<$scale_x> and C<$scale_y> parameters are optional. See C<insert_chart()> above for details.
  
  
  
  
  =head2 data_validation()
  
  The C<data_validation()> method is used to construct an Excel data validation or to limit the user input to a dropdown list of values.
  
  
      $worksheet->data_validation('B3',
          {
              validate => 'integer',
              criteria => '>',
              value    => 100,
          });
  
      $worksheet->data_validation('B5:B9',
          {
              validate => 'list',
              value    => ['open', 'high', 'close'],
          });
  
  This method contains a lot of parameters and is described in detail in a separate section L</DATA VALIDATION IN EXCEL>.
  
  
  See also the C<data_validate.pl> program in the examples directory of the distro
  
  
  
  
  =head2 get_name()
  
  The C<get_name()> method is used to retrieve the name of a worksheet. For example:
  
      foreach my $sheet ($workbook->sheets()) {
          print $sheet->get_name();
      }
  
  For reasons related to the design of Spreadsheet::WriteExcel and to the internals of Excel there is no C<set_name()> method. The only way to set the worksheet name is via the C<add_worksheet()> method.
  
  
  
  
  =head2 activate()
  
  The C<activate()> method is used to specify which worksheet is initially visible in a multi-sheet workbook:
  
      $worksheet1 = $workbook->add_worksheet('To');
      $worksheet2 = $workbook->add_worksheet('the');
      $worksheet3 = $workbook->add_worksheet('wind');
  
      $worksheet3->activate();
  
  This is similar to the Excel VBA activate method. More than one worksheet can be selected via the C<select()> method, see below, however only one worksheet can be active.
  
  The default active worksheet is the first worksheet.
  
  
  
  
  =head2 select()
  
  The C<select()> method is used to indicate that a worksheet is selected in a multi-sheet workbook:
  
      $worksheet1->activate();
      $worksheet2->select();
      $worksheet3->select();
  
  A selected worksheet has its tab highlighted. Selecting worksheets is a way of grouping them together so that, for example, several worksheets could be printed in one go. A worksheet that has been activated via the C<activate()> method will also appear as selected.
  
  
  
  
  =head2 hide()
  
  The C<hide()> method is used to hide a worksheet:
  
      $worksheet2->hide();
  
  You may wish to hide a worksheet in order to avoid confusing a user with intermediate data or calculations.
  
  A hidden worksheet can not be activated or selected so this method is mutually exclusive with the C<activate()> and C<select()> methods. In addition, since the first worksheet will default to being the active worksheet, you cannot hide the first worksheet without activating another sheet:
  
      $worksheet2->activate();
      $worksheet1->hide();
  
  
  
  
  =head2 set_first_sheet()
  
  The C<activate()> method determines which worksheet is initially selected. However, if there are a large number of worksheets the selected worksheet may not appear on the screen. To avoid this you can select which is the leftmost visible worksheet using C<set_first_sheet()>:
  
      for (1..20) {
          $workbook->add_worksheet;
      }
  
      $worksheet21 = $workbook->add_worksheet();
      $worksheet22 = $workbook->add_worksheet();
  
      $worksheet21->set_first_sheet();
      $worksheet22->activate();
  
  This method is not required very often. The default value is the first worksheet.
  
  
  
  
  =head2 protect($password)
  
  The C<protect()> method is used to protect a worksheet from modification:
  
      $worksheet->protect();
  
  It can be turned off in Excel via the C<Tools-E<gt>Protection-E<gt>Unprotect Sheet> menu command.
  
  The C<protect()> method also has the effect of enabling a cell's C<locked> and C<hidden> properties if they have been set. A "locked" cell cannot be edited. A "hidden" cell will display the results of a formula but not the formula itself. In Excel a cell's locked property is on by default.
  
      # Set some format properties
      my $unlocked  = $workbook->add_format(locked => 0);
      my $hidden    = $workbook->add_format(hidden => 1);
  
      # Enable worksheet protection
      $worksheet->protect();
  
      # This cell cannot be edited, it is locked by default
      $worksheet->write('A1', '=1+2');
  
      # This cell can be edited
      $worksheet->write('A2', '=1+2', $unlocked);
  
      # The formula in this cell isn't visible
      $worksheet->write('A3', '=1+2', $hidden);
  
  See also the C<set_locked> and C<set_hidden> format methods in L</CELL FORMATTING>.
  
  You can optionally add a password to the worksheet protection:
  
      $worksheet->protect('drowssap');
  
  Note, the worksheet level password in Excel provides very weak protection. It does not encrypt your data in any way and it is very easy to deactivate. Therefore, do not use the above method if you wish to protect sensitive data or calculations. However, before you get worried, Excel's own workbook level password protection does provide strong encryption in Excel 97+. For technical reasons this will never be supported by C<Spreadsheet::WriteExcel>.
  
  
  
  
  =head2 set_selection($first_row, $first_col, $last_row, $last_col)
  
  This method can be used to specify which cell or cells are selected in a worksheet. The most common requirement is to select a single cell, in which case C<$last_row> and C<$last_col> can be omitted. The active cell within a selected range is determined by the order in which C<$first> and C<$last> are specified. It is also possible to specify a cell or a range using A1 notation. See the note about L</Cell notation>.
  
  Examples:
  
      $worksheet1->set_selection(3, 3);       # 1. Cell D4.
      $worksheet2->set_selection(3, 3, 6, 6); # 2. Cells D4 to G7.
      $worksheet3->set_selection(6, 6, 3, 3); # 3. Cells G7 to D4.
      $worksheet4->set_selection('D4');       # Same as 1.
      $worksheet5->set_selection('D4:G7');    # Same as 2.
      $worksheet6->set_selection('G7:D4');    # Same as 3.
  
  The default cell selections is (0, 0), 'A1'.
  
  
  
  
  =head2 set_row($row, $height, $format, $hidden, $level, $collapsed)
  
  This method can be used to change the default properties of a row. All parameters apart from C<$row> are optional.
  
  The most common use for this method is to change the height of a row:
  
      $worksheet->set_row(0, 20); # Row 1 height set to 20
  
  If you wish to set the format without changing the height you can pass C<undef> as the height parameter:
  
      $worksheet->set_row(0, undef, $format);
  
  The C<$format> parameter will be applied to any cells in the row that don't  have a format. For example
  
      $worksheet->set_row(0, undef, $format1);    # Set the format for row 1
      $worksheet->write('A1', 'Hello');           # Defaults to $format1
      $worksheet->write('B1', 'Hello', $format2); # Keeps $format2
  
  If you wish to define a row format in this way you should call the method before any calls to C<write()>. Calling it afterwards will overwrite any format that was previously specified.
  
  The C<$hidden> parameter should be set to 1 if you wish to hide a row. This can be used, for example, to hide intermediary steps in a complicated calculation:
  
      $worksheet->set_row(0, 20,    $format, 1);
      $worksheet->set_row(1, undef, undef,   1);
  
  The C<$level> parameter is used to set the outline level of the row. Outlines are described in L</OUTLINES AND GROUPING IN EXCEL>. Adjacent rows with the same outline level are grouped together into a single outline.
  
  The following example sets an outline level of 1 for rows 1 and 2 (zero-indexed):
  
      $worksheet->set_row(1, undef, undef, 0, 1);
      $worksheet->set_row(2, undef, undef, 0, 1);
  
  The C<$hidden> parameter can also be used to hide collapsed outlined rows when used in conjunction with the C<$level> parameter.
  
      $worksheet->set_row(1, undef, undef, 1, 1);
      $worksheet->set_row(2, undef, undef, 1, 1);
  
  For collapsed outlines you should also indicate which row has the collapsed C<+> symbol using the optional C<$collapsed> parameter.
  
      $worksheet->set_row(3, undef, undef, 0, 0, 1);
  
  For a more complete example see the C<outline.pl> and C<outline_collapsed.pl> programs in the examples directory of the distro.
  
  Excel allows up to 7 outline levels. Therefore the C<$level> parameter should be in the range C<0 E<lt>= $level E<lt>= 7>.
  
  
  
  
  =head2 set_column($first_col, $last_col, $width, $format, $hidden, $level, $collapsed)
  
  This method can be used to change the default properties of a single column or a range of columns. All parameters apart from C<$first_col> and C<$last_col> are optional.
  
  If C<set_column()> is applied to a single column the value of C<$first_col> and C<$last_col> should be the same. In the case where C<$last_col> is zero it is set to the same value as C<$first_col>.
  
  It is also possible, and generally clearer, to specify a column range using the form of A1 notation used for columns. See the note about L</Cell notation>.
  
  Examples:
  
      $worksheet->set_column(0, 0,  20); # Column  A   width set to 20
      $worksheet->set_column(1, 3,  30); # Columns B-D width set to 30
      $worksheet->set_column('E:E', 20); # Column  E   width set to 20
      $worksheet->set_column('F:H', 30); # Columns F-H width set to 30
  
  The width corresponds to the column width value that is specified in Excel. It is approximately equal to the length of a string in the default font of Arial 10. Unfortunately, there is no way to specify "AutoFit" for a column in the Excel file format. This feature is only available at runtime from within Excel.
  
  As usual the C<$format> parameter is optional, for additional information, see L</CELL FORMATTING>. If you wish to set the format without changing the width you can pass C<undef> as the width parameter:
  
      $worksheet->set_column(0, 0, undef, $format);
  
  The C<$format> parameter will be applied to any cells in the column that don't  have a format. For example
  
      $worksheet->set_column('A:A', undef, $format1); # Set format for col 1
      $worksheet->write('A1', 'Hello');               # Defaults to $format1
      $worksheet->write('A2', 'Hello', $format2);     # Keeps $format2
  
  If you wish to define a column format in this way you should call the method before any calls to C<write()>. If you call it afterwards it won't have any effect.
  
  A default row format takes precedence over a default column format
  
      $worksheet->set_row(0, undef,        $format1); # Set format for row 1
      $worksheet->set_column('A:A', undef, $format2); # Set format for col 1
      $worksheet->write('A1', 'Hello');               # Defaults to $format1
      $worksheet->write('A2', 'Hello');               # Defaults to $format2
  
  The C<$hidden> parameter should be set to 1 if you wish to hide a column. This can be used, for example, to hide intermediary steps in a complicated calculation:
  
      $worksheet->set_column('D:D', 20,    $format, 1);
      $worksheet->set_column('E:E', undef, undef,   1);
  
  The C<$level> parameter is used to set the outline level of the column. Outlines are described in L</OUTLINES AND GROUPING IN EXCEL>. Adjacent columns with the same outline level are grouped together into a single outline.
  
  The following example sets an outline level of 1 for columns B to G:
  
      $worksheet->set_column('B:G', undef, undef, 0, 1);
  
  The C<$hidden> parameter can also be used to hide collapsed outlined columns when used in conjunction with the C<$level> parameter.
  
      $worksheet->set_column('B:G', undef, undef, 1, 1);
  
  For collapsed outlines you should also indicate which row has the collapsed C<+> symbol using the optional C<$collapsed> parameter.
  
      $worksheet->set_column('H:H', undef, undef, 0, 0, 1);
  
  For a more complete example see the C<outline.pl> and C<outline_collapsed.pl> programs in the examples directory of the distro.
  
  Excel allows up to 7 outline levels. Therefore the C<$level> parameter should be in the range C<0 E<lt>= $level E<lt>= 7>.
  
  
  
  
  =head2 outline_settings($visible, $symbols_below, $symbols_right, $auto_style)
  
  The C<outline_settings()> method is used to control the appearance of outlines in Excel. Outlines are described in L</OUTLINES AND GROUPING IN EXCEL>.
  
  The C<$visible> parameter is used to control whether or not outlines are visible. Setting this parameter to 0 will cause all outlines on the worksheet to be hidden. They can be unhidden in Excel by means of the "Show Outline Symbols" command button. The default setting is 1 for visible outlines.
  
      $worksheet->outline_settings(0);
  
  The C<$symbols_below> parameter is used to control whether the row outline symbol will appear above or below the outline level bar. The default setting is 1 for symbols to appear below the outline level bar.
  
  The C<symbols_right> parameter is used to control whether the column outline symbol will appear to the left or the right of the outline level bar. The default setting is 1 for symbols to appear to the right of the outline level bar.
  
  The C<$auto_style> parameter is used to control whether the automatic outline generator in Excel uses automatic styles when creating an outline. This has no effect on a file generated by C<Spreadsheet::WriteExcel> but it does have an effect on how the worksheet behaves after it is created. The default setting is 0 for "Automatic Styles" to be turned off.
  
  The default settings for all of these parameters correspond to Excel's default parameters.
  
  
  The worksheet parameters controlled by C<outline_settings()> are rarely used.
  
  
  
  
  =head2 freeze_panes($row, $col, $top_row, $left_col)
  
  This method can be used to divide a worksheet into horizontal or vertical regions known as panes and to also "freeze" these panes so that the splitter bars are not visible. This is the same as the C<Window-E<gt>Freeze Panes> menu command in Excel
  
  The parameters C<$row> and C<$col> are used to specify the location of the split. It should be noted that the split is specified at the top or left of a cell and that the method uses zero based indexing. Therefore to freeze the first row of a worksheet it is necessary to specify the split at row 2 (which is 1 as the zero-based index). This might lead you to think that you are using a 1 based index but this is not the case.
  
  You can set one of the C<$row> and C<$col> parameters as zero if you do not want either a vertical or horizontal split.
  
  Examples:
  
      $worksheet->freeze_panes(1, 0); # Freeze the first row
      $worksheet->freeze_panes('A2'); # Same using A1 notation
      $worksheet->freeze_panes(0, 1); # Freeze the first column
      $worksheet->freeze_panes('B1'); # Same using A1 notation
      $worksheet->freeze_panes(1, 2); # Freeze first row and first 2 columns
      $worksheet->freeze_panes('C2'); # Same using A1 notation
  
  The parameters C<$top_row> and C<$left_col> are optional. They are used to specify the top-most or left-most visible row or column in the scrolling region of the panes. For example to freeze the first row and to have the scrolling region begin at row twenty:
  
      $worksheet->freeze_panes(1, 0, 20, 0);
  
  You cannot use A1 notation for the C<$top_row> and C<$left_col> parameters.
  
  
  See also the C<panes.pl> program in the C<examples> directory of the distribution.
  
  
  
  
  =head2 split_panes($y, $x, $top_row, $left_col)
  
  This method can be used to divide a worksheet into horizontal or vertical regions known as panes. This method is different from the C<freeze_panes()> method in that the splits between the panes will be visible to the user and each pane will have its own scroll bars.
  
  The parameters C<$y> and C<$x> are used to specify the vertical and horizontal position of the split. The units for C<$y> and C<$x> are the same as those used by Excel to specify row height and column width. However, the vertical and horizontal units are different from each other. Therefore you must specify the C<$y> and C<$x> parameters in terms of the row heights and column widths that you have set or the default values which are C<12.75> for a row and  C<8.43> for a column.
  
  You can set one of the C<$y> and C<$x> parameters as zero if you do not want either a vertical or horizontal split. The parameters C<$top_row> and C<$left_col> are optional. They are used to specify the top-most or left-most visible row or column in the bottom-right pane.
  
  Example:
  
      $worksheet->split_panes(12.75, 0,    1, 0); # First row
      $worksheet->split_panes(0,     8.43, 0, 1); # First column
      $worksheet->split_panes(12.75, 8.43, 1, 1); # First row and column
  
  You cannot use A1 notation with this method.
  
  See also the C<freeze_panes()> method and the C<panes.pl> program in the C<examples> directory of the distribution.
  
  
  Note: This C<split_panes()> method was called C<thaw_panes()> in older versions. The older name is still available for backwards compatibility.
  
  
  
  
  =head2 merge_range($first_row, $first_col, $last_row, $last_col, $token, $format, $utf_16_be)
  
  Merging cells can be achieved by setting the C<merge> property of a Format object, see L</CELL FORMATTING>. However, this only allows simple Excel5 style horizontal merging which Excel refers to as "center across selection".
  
  The C<merge_range()> method allows you to do Excel97+ style formatting where the cells can contain other types of alignment in addition to the merging:
  
      my $format = $workbook->add_format(
                                          border  => 6,
                                          valign  => 'vcenter',
                                          align   => 'center',
                                        );
  
      $worksheet->merge_range('B3:D4', 'Vertical and horizontal', $format);
  
  B<WARNING>. The format object that is used with a C<merge_range()> method call is marked internally as being associated with a merged range. It is a fatal error to use a merged format in a non-merged cell. Instead you should use separate formats for merged and non-merged cells. This restriction will be removed in a future release.
  
  The C<$utf_16_be> parameter is optional, see below.
  
  C<merge_range()> writes its C<$token> argument using the worksheet C<write()> method. Therefore it will handle numbers, strings, formulas or urls as required.
  
  Setting the C<merge> property of the format isn't required when you are using C<merge_range()>. In fact using it will exclude the use of any other horizontal alignment option.
  
  On systems with C<perl 5.8> and later the C<merge_range()> method will also handle strings in C<UTF-8> format.
  
      $worksheet->merge_range('B3:D4', "\x{263a}", $format); # Smiley
  
  On earlier Perl systems your can specify C<UTF-16BE> worksheet names using an additional optional parameter:
  
      my $str = pack 'n', 0x263a;
      $worksheet->merge_range('B3:D4', $str, $format, 1); # Smiley
  
  The full possibilities of this method are shown in the C<merge3.pl> to C<merge6.pl> programs in the C<examples> directory of the distribution.
  
  
  
  
  =head2 set_zoom($scale)
  
  Set the worksheet zoom factor in the range C<10 E<lt>= $scale E<lt>= 400>:
  
      $worksheet1->set_zoom(50);
      $worksheet2->set_zoom(75);
      $worksheet3->set_zoom(300);
      $worksheet4->set_zoom(400);
  
  The default zoom factor is 100. You cannot zoom to "Selection" because it is calculated by Excel at run-time.
  
  Note, C<set_zoom()> does not affect the scale of the printed page. For that you should use C<set_print_scale()>.
  
  
  
  
  =head2 right_to_left()
  
  The C<right_to_left()> method is used to change the default direction of the worksheet from left-to-right, with the A1 cell in the top left, to right-to-left, with the he A1 cell in the top right.
  
      $worksheet->right_to_left();
  
  This is useful when creating Arabic, Hebrew or other near or far eastern worksheets that use right-to-left as the default direction.
  
  
  
  
  =head2 hide_zero()
  
  The C<hide_zero()> method is used to hide any zero values that appear in cells.
  
      $worksheet->hide_zero();
  
  In Excel this option is found under Tools->Options->View.
  
  
  
  
  =head2 set_tab_color()
  
  The C<set_tab_color()> method is used to change the colour of the worksheet tab. This feature is only available in Excel 2002 and later. You can use one of the standard colour names provided by the Format object or a colour index. See L</COLOURS IN EXCEL> and the C<set_custom_color()> method.
  
      $worksheet1->set_tab_color('red');
      $worksheet2->set_tab_color(0x0C);
  
  See the C<tab_colors.pl> program in the examples directory of the distro.
  
  
  
  
  =head2 autofilter($first_row, $first_col, $last_row, $last_col)
  
  This method allows an autofilter to be added to a worksheet. An autofilter is a way of adding drop down lists to the headers of a 2D range of worksheet data. This in turn allow users to filter the data based on simple criteria so that some data is shown and some is hidden.
  
  To add an autofilter to a worksheet:
  
      $worksheet->autofilter(0, 0, 10, 3);
      $worksheet->autofilter('A1:D11');    # Same as above in A1 notation.
  
  Filter conditions can be applied using the C<filter_column()> method.
  
  See the C<autofilter.pl> program in the examples directory of the distro for a more detailed example.
  
  
  
  
  =head2 filter_column($column, $expression)
  
  
  The C<filter_column> method can be used to filter columns in a autofilter range based on simple conditions.
  
  B<NOTE:> It isn't sufficient to just specify the filter condition. You must also hide any rows that don't match the filter condition. Rows are hidden using the C<set_row()> C<visible> parameter. C<Spreadsheet::WriteExcel> cannot do this automatically since it isn't part of the file format. See the C<autofilter.pl> program in the examples directory of the distro for an example.
  
  The conditions for the filter are specified using simple expressions:
  
      $worksheet->filter_column('A', 'x > 2000');
      $worksheet->filter_column('B', 'x > 2000 and x < 5000');
  
  The C<$column> parameter can either be a zero indexed column number or a string column name.
  
  The following operators are available:
  
      Operator        Synonyms
         ==           =   eq  =~
         !=           <>  ne  !=
         >
         <
         >=
         <=
  
         and          &&
         or           ||
  
  The operator synonyms are just syntactic sugar to make you more comfortable using the expressions. It is important to remember that the expressions will be interpreted by Excel and not by perl.
  
  An expression can comprise a single statement or two statements separated by the C<and> and C<or> operators. For example:
  
      'x <  2000'
      'x >  2000'
      'x == 2000'
      'x >  2000 and x <  5000'
      'x == 2000 or  x == 5000'
  
  Filtering of blank or non-blank data can be achieved by using a value of C<Blanks> or C<NonBlanks> in the expression:
  
      'x == Blanks'
      'x == NonBlanks'
  
  Top 10 style filters can be specified using a expression like the following:
  
      Top|Bottom 1-500 Items|%
  
  For example:
  
      'Top    10 Items'
      'Bottom  5 Items'
      'Top    25 %'
      'Bottom 50 %'
  
  Excel also allows some simple string matching operations:
  
      'x =~ b*'   # begins with b
      'x !~ b*'   # doesn't begin with b
      'x =~ *b'   # ends with b
      'x !~ *b'   # doesn't end with b
      'x =~ *b*'  # contains b
      'x !~ *b*'  # doesn't contains b
  
  You can also use C<*> to match any character or number and C<?> to match any single character or number. No other regular expression quantifier is supported by Excel's filters. Excel's regular expression characters can be escaped using C<~>.
  
  The placeholder variable C<x> in the above examples can be replaced by any simple string. The actual placeholder name is ignored internally so the following are all equivalent:
  
      'x     < 2000'
      'col   < 2000'
      'Price < 2000'
  
  Also, note that a filter condition can only be applied to a column in a range specified by the C<autofilter()> Worksheet method.
  
  See the C<autofilter.pl> program in the examples directory of the distro for a more detailed example.
  
  
  
  
  =head1 PAGE SET-UP METHODS
  
  Page set-up methods affect the way that a worksheet looks when it is printed. They control features such as page headers and footers and margins. These methods are really just standard worksheet methods. They are documented here in a separate section for the sake of clarity.
  
  The following methods are available for page set-up:
  
      set_landscape()
      set_portrait()
      set_page_view()
      set_paper()
      center_horizontally()
      center_vertically()
      set_margins()
      set_header()
      set_footer()
      repeat_rows()
      repeat_columns()
      hide_gridlines()
      print_row_col_headers()
      print_area()
      print_across()
      fit_to_pages()
      set_start_page()
      set_print_scale()
      set_h_pagebreaks()
      set_v_pagebreaks()
  
  
  A common requirement when working with Spreadsheet::WriteExcel is to apply the same page set-up features to all of the worksheets in a workbook. To do this you can use the C<sheets()> method of the C<workbook> class to access the array of worksheets in a workbook:
  
      foreach $worksheet ($workbook->sheets()) {
         $worksheet->set_landscape();
      }
  
  
  
  
  =head2 set_landscape()
  
  This method is used to set the orientation of a worksheet's printed page to landscape:
  
      $worksheet->set_landscape(); # Landscape mode
  
  
  
  
  =head2 set_portrait()
  
  This method is used to set the orientation of a worksheet's printed page to portrait. The default worksheet orientation is portrait, so you won't generally need to call this method.
  
      $worksheet->set_portrait(); # Portrait mode
  
  
  
  =head2 set_page_view()
  
  This method is used to display the worksheet in "Page View" mode. This is currently only supported by Mac Excel, where it is the default.
  
      $worksheet->set_page_view();
  
  
  
  =head2 set_paper($index)
  
  This method is used to set the paper format for the printed output of a worksheet. The following paper styles are available:
  
      Index   Paper format            Paper size
      =====   ============            ==========
        0     Printer default         -
        1     Letter                  8 1/2 x 11 in
        2     Letter Small            8 1/2 x 11 in
        3     Tabloid                 11 x 17 in
        4     Ledger                  17 x 11 in
        5     Legal                   8 1/2 x 14 in
        6     Statement               5 1/2 x 8 1/2 in
        7     Executive               7 1/4 x 10 1/2 in
        8     A3                      297 x 420 mm
        9     A4                      210 x 297 mm
       10     A4 Small                210 x 297 mm
       11     A5                      148 x 210 mm
       12     B4                      250 x 354 mm
       13     B5                      182 x 257 mm
       14     Folio                   8 1/2 x 13 in
       15     Quarto                  215 x 275 mm
       16     -                       10x14 in
       17     -                       11x17 in
       18     Note                    8 1/2 x 11 in
       19     Envelope  9             3 7/8 x 8 7/8
       20     Envelope 10             4 1/8 x 9 1/2
       21     Envelope 11             4 1/2 x 10 3/8
       22     Envelope 12             4 3/4 x 11
       23     Envelope 14             5 x 11 1/2
       24     C size sheet            -
       25     D size sheet            -
       26     E size sheet            -
       27     Envelope DL             110 x 220 mm
       28     Envelope C3             324 x 458 mm
       29     Envelope C4             229 x 324 mm
       30     Envelope C5             162 x 229 mm
       31     Envelope C6             114 x 162 mm
       32     Envelope C65            114 x 229 mm
       33     Envelope B4             250 x 353 mm
       34     Envelope B5             176 x 250 mm
       35     Envelope B6             176 x 125 mm
       36     Envelope                110 x 230 mm
       37     Monarch                 3.875 x 7.5 in
       38     Envelope                3 5/8 x 6 1/2 in
       39     Fanfold                 14 7/8 x 11 in
       40     German Std Fanfold      8 1/2 x 12 in
       41     German Legal Fanfold    8 1/2 x 13 in
  
  
  Note, it is likely that not all of these paper types will be available to the end user since it will depend on the paper formats that the user's printer supports. Therefore, it is best to stick to standard paper types.
  
      $worksheet->set_paper(1); # US Letter
      $worksheet->set_paper(9); # A4
  
  If you do not specify a paper type the worksheet will print using the printer's default paper.
  
  
  
  
  =head2 center_horizontally()
  
  Center the worksheet data horizontally between the margins on the printed page:
  
      $worksheet->center_horizontally();
  
  
  
  
  =head2 center_vertically()
  
  Center the worksheet data vertically between the margins on the printed page:
  
      $worksheet->center_vertically();
  
  
  
  
  =head2 set_margins($inches)
  
  There are several methods available for setting the worksheet margins on the printed page:
  
      set_margins()        # Set all margins to the same value
      set_margins_LR()     # Set left and right margins to the same value
      set_margins_TB()     # Set top and bottom margins to the same value
      set_margin_left();   # Set left margin
      set_margin_right();  # Set right margin
      set_margin_top();    # Set top margin
      set_margin_bottom(); # Set bottom margin
  
  All of these methods take a distance in inches as a parameter. Note: 1 inch = 25.4mm. ;-) The default left and right margin is 0.75 inch. The default top and bottom margin is 1.00 inch.
  
  
  
  =head2 set_header($string, $margin)
  
  Headers and footers are generated using a C<$string> which is a combination of plain text and control characters. The C<$margin> parameter is optional.
  
  The available control character are:
  
      Control             Category            Description
      =======             ========            ===========
      &L                  Justification       Left
      &C                                      Center
      &R                                      Right
  
      &P                  Information         Page number
      &N                                      Total number of pages
      &D                                      Date
      &T                                      Time
      &F                                      File name
      &A                                      Worksheet name
      &Z                                      Workbook path
  
      &fontsize           Font                Font size
      &"font,style"                           Font name and style
      &U                                      Single underline
      &E                                      Double underline
      &S                                      Strikethrough
      &X                                      Superscript
      &Y                                      Subscript
  
      &&                  Miscellaneous       Literal ampersand &
  
  
  Text in headers and footers can be justified (aligned) to the left, center and right by prefixing the text with the control characters C<&L>, C<&C> and C<&R>.
  
  For example (with ASCII art representation of the results):
  
      $worksheet->set_header('&LHello');
  
       ---------------------------------------------------------------
      |                                                               |
      | Hello                                                         |
      |                                                               |
  
  
      $worksheet->set_header('&CHello');
  
       ---------------------------------------------------------------
      |                                                               |
      |                          Hello                                |
      |                                                               |
  
  
      $worksheet->set_header('&RHello');
  
       ---------------------------------------------------------------
      |                                                               |
      |                                                         Hello |
      |                                                               |
  
  
  For simple text, if you do not specify any justification the text will be centred. However, you must prefix the text with C<&C> if you specify a font name or any other formatting:
  
      $worksheet->set_header('Hello');
  
       ---------------------------------------------------------------
      |                                                               |
      |                          Hello                                |
      |                                                               |
  
  
  You can have text in each of the justification regions:
  
      $worksheet->set_header('&LCiao&CBello&RCielo');
  
       ---------------------------------------------------------------
      |                                                               |
      | Ciao                     Bello                          Cielo |
      |                                                               |
  
  
  The information control characters act as variables that Excel will update as the workbook or worksheet changes. Times and dates are in the users default format:
  
      $worksheet->set_header('&CPage &P of &N');
  
       ---------------------------------------------------------------
      |                                                               |
      |                        Page 1 of 6                            |
      |                                                               |
  
  
      $worksheet->set_header('&CUpdated at &T');
  
       ---------------------------------------------------------------
      |                                                               |
      |                    Updated at 12:30 PM                        |
      |                                                               |
  
  
  
  You can specify the font size of a section of the text by prefixing it with the control character C<&n> where C<n> is the font size:
  
      $worksheet1->set_header('&C&30Hello Big'  );
      $worksheet2->set_header('&C&10Hello Small');
  
  You can specify the font of a section of the text by prefixing it with the control sequence C<&"font,style"> where C<fontname> is a font name such as "Courier New" or "Times New Roman" and C<style> is one of the standard Windows font descriptions: "Regular", "Italic", "Bold" or "Bold Italic":
  
      $worksheet1->set_header('&C&"Courier New,Italic"Hello');
      $worksheet2->set_header('&C&"Courier New,Bold Italic"Hello');
      $worksheet3->set_header('&C&"Times New Roman,Regular"Hello');
  
  It is possible to combine all of these features together to create sophisticated headers and footers. As an aid to setting up complicated headers and footers you can record a page set-up as a macro in Excel and look at the format strings that VBA produces. Remember however that VBA uses two double quotes C<""> to indicate a single double quote. For the last example above the equivalent VBA code looks like this:
  
      .LeftHeader   = ""
      .CenterHeader = "&""Times New Roman,Regular""Hello"
      .RightHeader  = ""
  
  
  To include a single literal ampersand C<&> in a header or footer you should use a double ampersand C<&&>:
  
      $worksheet1->set_header('&CCuriouser && Curiouser - Attorneys at Law');
  
  As stated above the margin parameter is optional. As with the other margins the value should be in inches. The default header and footer margin is 0.50 inch. The header and footer margin size can be set as follows:
  
      $worksheet->set_header('&CHello', 0.75);
  
  The header and footer margins are independent of the top and bottom margins.
  
  Note, the header or footer string must be less than 255 characters. Strings longer than this will not be written and a warning will be generated.
  
  On systems with C<perl 5.8> and later the C<set_header()> method can also handle Unicode strings in C<UTF-8> format.
  
      $worksheet->set_header("&C\x{263a}")
  
  
  See, also the C<headers.pl> program in the C<examples> directory of the distribution.
  
  
  
  
  =head2 set_footer()
  
  The syntax of the C<set_footer()> method is the same as C<set_header()>,  see above.
  
  
  
  
  =head2 repeat_rows($first_row, $last_row)
  
  Set the number of rows to repeat at the top of each printed page.
  
  For large Excel documents it is often desirable to have the first row or rows of the worksheet print out at the top of each page. This can be achieved by using the C<repeat_rows()> method. The parameters C<$first_row> and C<$last_row> are zero based. The C<$last_row> parameter is optional if you only wish to specify one row:
  
      $worksheet1->repeat_rows(0);    # Repeat the first row
      $worksheet2->repeat_rows(0, 1); # Repeat the first two rows
  
  
  
  
  =head2 repeat_columns($first_col, $last_col)
  
  Set the columns to repeat at the left hand side of each printed page.
  
  For large Excel documents it is often desirable to have the first column or columns of the worksheet print out at the left hand side of each page. This can be achieved by using the C<repeat_columns()> method. The parameters C<$first_column> and C<$last_column> are zero based. The C<$last_column> parameter is optional if you only wish to specify one column. You can also specify the columns using A1 column notation, see the note about L</Cell notation>.
  
      $worksheet1->repeat_columns(0);     # Repeat the first column
      $worksheet2->repeat_columns(0, 1);  # Repeat the first two columns
      $worksheet3->repeat_columns('A:A'); # Repeat the first column
      $worksheet4->repeat_columns('A:B'); # Repeat the first two columns
  
  
  
  
  =head2 hide_gridlines($option)
  
  This method is used to hide the gridlines on the screen and printed page. Gridlines are the lines that divide the cells on a worksheet. Screen and printed gridlines are turned on by default in an Excel worksheet. If you have defined your own cell borders you may wish to hide the default gridlines.
  
      $worksheet->hide_gridlines();
  
  The following values of C<$option> are valid:
  
      0 : Don't hide gridlines
      1 : Hide printed gridlines only
      2 : Hide screen and printed gridlines
  
  If you don't supply an argument or use C<undef> the default option is 1, i.e. only the printed gridlines are hidden.
  
  
  
  
  =head2 print_row_col_headers()
  
  Set the option to print the row and column headers on the printed page.
  
  An Excel worksheet looks something like the following;
  
       ------------------------------------------
      |   |   A   |   B   |   C   |   D   |  ...
       ------------------------------------------
      | 1 |       |       |       |       |  ...
      | 2 |       |       |       |       |  ...
      | 3 |       |       |       |       |  ...
      | 4 |       |       |       |       |  ...
      |...|  ...  |  ...  |  ...  |  ...  |  ...
  
  The headers are the letters and numbers at the top and the left of the worksheet. Since these headers serve mainly as a indication of position on the worksheet they generally do not appear on the printed page. If you wish to have them printed you can use the C<print_row_col_headers()> method :
  
      $worksheet->print_row_col_headers();
  
  Do not confuse these headers with page headers as described in the C<set_header()> section above.
  
  
  
  
  =head2 print_area($first_row, $first_col, $last_row, $last_col)
  
  This method is used to specify the area of the worksheet that will be printed. All four parameters must be specified. You can also use A1 notation, see the note about L</Cell notation>.
  
  
      $worksheet1->print_area('A1:H20');    # Cells A1 to H20
      $worksheet2->print_area(0, 0, 19, 7); # The same
      $worksheet2->print_area('A:H');       # Columns A to H if rows have data
  
  
  
  
  =head2 print_across()
  
  The C<print_across> method is used to change the default print direction. This is referred to by Excel as the sheet "page order".
  
      $worksheet->print_across();
  
  The default page order is shown below for a worksheet that extends over 4 pages. The order is called "down then across":
  
      [1] [3]
      [2] [4]
  
  However, by using the C<print_across> method the print order will be changed to "across then down":
  
      [1] [2]
      [3] [4]
  
  
  
  
  =head2 fit_to_pages($width, $height)
  
  The C<fit_to_pages()> method is used to fit the printed area to a specific number of pages both vertically and horizontally. If the printed area exceeds the specified number of pages it will be scaled down to fit. This guarantees that the printed area will always appear on the specified number of pages even if the page size or margins change.
  
      $worksheet1->fit_to_pages(1, 1); # Fit to 1x1 pages
      $worksheet2->fit_to_pages(2, 1); # Fit to 2x1 pages
      $worksheet3->fit_to_pages(1, 2); # Fit to 1x2 pages
  
  The print area can be defined using the C<print_area()> method as described above.
  
  A common requirement is to fit the printed output to I<n> pages wide but have the height be as long as necessary. To achieve this set the C<$height> to zero or leave it blank:
  
      $worksheet1->fit_to_pages(1, 0); # 1 page wide and as long as necessary
      $worksheet2->fit_to_pages(1);    # The same
  
  
  Note that although it is valid to use both C<fit_to_pages()> and C<set_print_scale()> on the same worksheet only one of these options can be active at a time. The last method call made will set the active option.
  
  Note that C<fit_to_pages()> will override any manual page breaks that are defined in the worksheet.
  
  
  
  
  =head2 set_start_page($start_page)
  
  The C<set_start_page()> method is used to set the number of the starting page when the worksheet is printed out. The default value is 1.
  
      $worksheet->set_start_page(2);
  
  
  
  
  =head2 set_print_scale($scale)
  
  Set the scale factor of the printed page. Scale factors in the range C<10 E<lt>= $scale E<lt>= 400> are valid:
  
      $worksheet1->set_print_scale(50);
      $worksheet2->set_print_scale(75);
      $worksheet3->set_print_scale(300);
      $worksheet4->set_print_scale(400);
  
  The default scale factor is 100. Note, C<set_print_scale()> does not affect the scale of the visible page in Excel. For that you should use C<set_zoom()>.
  
  Note also that although it is valid to use both C<fit_to_pages()> and C<set_print_scale()> on the same worksheet only one of these options can be active at a time. The last method call made will set the active option.
  
  
  
  
  =head2 set_h_pagebreaks(@breaks)
  
  Add horizontal page breaks to a worksheet. A page break causes all the data that follows it to be printed on the next page. Horizontal page breaks act between rows. To create a page break between rows 20 and 21 you must specify the break at row 21. However in zero index notation this is actually row 20. So you can pretend for a small while that you are using 1 index notation:
  
      $worksheet1->set_h_pagebreaks(20); # Break between row 20 and 21
  
  The C<set_h_pagebreaks()> method will accept a list of page breaks and you can call it more than once:
  
      $worksheet2->set_h_pagebreaks( 20,  40,  60,  80, 100); # Add breaks
      $worksheet2->set_h_pagebreaks(120, 140, 160, 180, 200); # Add some more
  
  Note: If you specify the "fit to page" option via the C<fit_to_pages()> method it will override all manual page breaks.
  
  There is a silent limitation of about 1000 horizontal page breaks per worksheet in line with an Excel internal limitation.
  
  
  
  
  =head2 set_v_pagebreaks(@breaks)
  
  Add vertical page breaks to a worksheet. A page break causes all the data that follows it to be printed on the next page. Vertical page breaks act between columns. To create a page break between columns 20 and 21 you must specify the break at column 21. However in zero index notation this is actually column 20. So you can pretend for a small while that you are using 1 index notation:
  
      $worksheet1->set_v_pagebreaks(20); # Break between column 20 and 21
  
  The C<set_v_pagebreaks()> method will accept a list of page breaks and you can call it more than once:
  
      $worksheet2->set_v_pagebreaks( 20,  40,  60,  80, 100); # Add breaks
      $worksheet2->set_v_pagebreaks(120, 140, 160, 180, 200); # Add some more
  
  Note: If you specify the "fit to page" option via the C<fit_to_pages()> method it will override all manual page breaks.
  
  
  
  
  =head1 CELL FORMATTING
  
  This section describes the methods and properties that are available for formatting cells in Excel. The properties of a cell that can be formatted include: fonts, colours, patterns, borders, alignment and number formatting.
  
  
  =head2 Creating and using a Format object
  
  Cell formatting is defined through a Format object. Format objects are created by calling the workbook C<add_format()> method as follows:
  
      my $format1 = $workbook->add_format();       # Set properties later
      my $format2 = $workbook->add_format(%props); # Set at creation
  
  The format object holds all the formatting properties that can be applied to a cell, a row or a column. The process of setting these properties is discussed in the next section.
  
  Once a Format object has been constructed and its properties have been set it can be passed as an argument to the worksheet C<write> methods as follows:
  
      $worksheet->write(0, 0, 'One', $format);
      $worksheet->write_string(1, 0, 'Two', $format);
      $worksheet->write_number(2, 0, 3, $format);
      $worksheet->write_blank(3, 0, $format);
  
  Formats can also be passed to the worksheet C<set_row()> and C<set_column()> methods to define the default property for a row or column.
  
      $worksheet->set_row(0, 15, $format);
      $worksheet->set_column(0, 0, 15, $format);
  
  
  
  
  =head2 Format methods and Format properties
  
  The following table shows the Excel format categories, the formatting properties that can be applied and the equivalent object method:
  
  
      Category   Description       Property        Method Name
      --------   -----------       --------        -----------
      Font       Font type         font            set_font()
                 Font size         size            set_size()
                 Font color        color           set_color()
                 Bold              bold            set_bold()
                 Italic            italic          set_italic()
                 Underline         underline       set_underline()
                 Strikeout         font_strikeout  set_font_strikeout()
                 Super/Subscript   font_script     set_font_script()
                 Outline           font_outline    set_font_outline()
                 Shadow            font_shadow     set_font_shadow()
  
      Number     Numeric format    num_format      set_num_format()
  
      Protection Lock cells        locked          set_locked()
                 Hide formulas     hidden          set_hidden()
  
      Alignment  Horizontal align  align           set_align()
                 Vertical align    valign          set_align()
                 Rotation          rotation        set_rotation()
                 Text wrap         text_wrap       set_text_wrap()
                 Justify last      text_justlast   set_text_justlast()
                 Center across     center_across   set_center_across()
                 Indentation       indent          set_indent()
                 Shrink to fit     shrink          set_shrink()
  
      Pattern    Cell pattern      pattern         set_pattern()
                 Background color  bg_color        set_bg_color()
                 Foreground color  fg_color        set_fg_color()
  
      Border     Cell border       border          set_border()
                 Bottom border     bottom          set_bottom()
                 Top border        top             set_top()
                 Left border       left            set_left()
                 Right border      right           set_right()
                 Border color      border_color    set_border_color()
                 Bottom color      bottom_color    set_bottom_color()
                 Top color         top_color       set_top_color()
                 Left color        left_color      set_left_color()
                 Right color       right_color     set_right_color()
  
  There are two ways of setting Format properties: by using the object method interface or by setting the property directly. For example, a typical use of the method interface would be as follows:
  
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color('red');
  
  By comparison the properties can be set directly by passing a hash of properties to the Format constructor:
  
      my $format = $workbook->add_format(bold => 1, color => 'red');
  
  or after the Format has been constructed by means of the C<set_format_properties()> method as follows:
  
      my $format = $workbook->add_format();
      $format->set_format_properties(bold => 1, color => 'red');
  
  You can also store the properties in one or more named hashes and pass them to the required method:
  
      my %font    = (
                      font  => 'Arial',
                      size  => 12,
                      color => 'blue',
                      bold  => 1,
                    );
  
      my %shading = (
                      bg_color => 'green',
                      pattern  => 1,
                    );
  
  
      my $format1 = $workbook->add_format(%font);           # Font only
      my $format2 = $workbook->add_format(%font, %shading); # Font and shading
  
  
  The provision of two ways of setting properties might lead you to wonder which is the best way. The method mechanism may be better is you prefer setting properties via method calls (which the author did when the code was first written) otherwise passing properties to the constructor has proved to be a little more flexible and self documenting in practice. An additional advantage of working with property hashes is that it allows you to share formatting between workbook objects as shown in the example above.
  
  The Perl/Tk style of adding properties is also supported:
  
      my %font    = (
                      -font      => 'Arial',
                      -size      => 12,
                      -color     => 'blue',
                      -bold      => 1,
                    );
  
  
  
  
  =head2 Working with formats
  
  The default format is Arial 10 with all other properties off.
  
  Each unique format in Spreadsheet::WriteExcel must have a corresponding Format object. It isn't possible to use a Format with a write() method and then redefine the Format for use at a later stage. This is because a Format is applied to a cell not in its current state but in its final state. Consider the following example:
  
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color('red');
      $worksheet->write('A1', 'Cell A1', $format);
      $format->set_color('green');
      $worksheet->write('B1', 'Cell B1', $format);
  
  Cell A1 is assigned the Format C<$format> which is initially set to the colour red. However, the colour is subsequently set to green. When Excel displays Cell A1 it will display the final state of the Format which in this case will be the colour green.
  
  In general a method call without an argument will turn a property on, for example:
  
      my $format1 = $workbook->add_format();
      $format1->set_bold();  # Turns bold on
      $format1->set_bold(1); # Also turns bold on
      $format1->set_bold(0); # Turns bold off
  
  
  
  
  =head1 FORMAT METHODS
  
  The Format object methods are described in more detail in the following sections. In addition, there is a Perl program called C<formats.pl> in the C<examples> directory of the WriteExcel distribution. This program creates an Excel workbook called C<formats.xls> which contains examples of almost all the format types.
  
  The following Format methods are available:
  
      set_font()
      set_size()
      set_color()
      set_bold()
      set_italic()
      set_underline()
      set_font_strikeout()
      set_font_script()
      set_font_outline()
      set_font_shadow()
      set_num_format()
      set_locked()
      set_hidden()
      set_align()
      set_rotation()
      set_text_wrap()
      set_text_justlast()
      set_center_across()
      set_indent()
      set_shrink()
      set_pattern()
      set_bg_color()
      set_fg_color()
      set_border()
      set_bottom()
      set_top()
      set_left()
      set_right()
      set_border_color()
      set_bottom_color()
      set_top_color()
      set_left_color()
      set_right_color()
  
  
  The above methods can also be applied directly as properties. For example C<< $format->set_bold() >> is equivalent to C<< $workbook->add_format(bold => 1) >>.
  
  
  =head2 set_format_properties(%properties)
  
  The properties of an existing Format object can be also be set by means of C<set_format_properties()>:
  
      my $format = $workbook->add_format();
      $format->set_format_properties(bold => 1, color => 'red');
  
  However, this method is here mainly for legacy reasons. It is preferable to set the properties in the format constructor:
  
      my $format = $workbook->add_format(bold => 1, color => 'red');
  
  
  =head2 set_font($fontname)
  
      Default state:      Font is Arial
      Default action:     None
      Valid args:         Any valid font name
  
  Specify the font used:
  
      $format->set_font('Times New Roman');
  
  Excel can only display fonts that are installed on the system that it is running on. Therefore it is best to use the fonts that come as standard such as 'Arial', 'Times New Roman' and 'Courier New'. See also the Fonts worksheet created by formats.pl
  
  
  
  
  =head2 set_size()
  
      Default state:      Font size is 10
      Default action:     Set font size to 1
      Valid args:         Integer values from 1 to as big as your screen.
  
  
  Set the font size. Excel adjusts the height of a row to accommodate the largest font size in the row. You can also explicitly specify the height of a row using the set_row() worksheet method.
  
      my $format = $workbook->add_format();
      $format->set_size(30);
  
  
  
  
  
  =head2 set_color()
  
      Default state:      Excels default color, usually black
      Default action:     Set the default color
      Valid args:         Integers from 8..63 or the following strings:
                          'black'
                          'blue'
                          'brown'
                          'cyan'
                          'gray'
                          'green'
                          'lime'
                          'magenta'
                          'navy'
                          'orange'
                          'pink'
                          'purple'
                          'red'
                          'silver'
                          'white'
                          'yellow'
  
  Set the font colour. The C<set_color()> method is used as follows:
  
      my $format = $workbook->add_format();
      $format->set_color('red');
      $worksheet->write(0, 0, 'wheelbarrow', $format);
  
  Note: The C<set_color()> method is used to set the colour of the font in a cell. To set the colour of a cell use the C<set_bg_color()> and C<set_pattern()> methods.
  
  For additional examples see the 'Named colors' and 'Standard colors' worksheets created by formats.pl in the examples directory.
  
  See also L</COLOURS IN EXCEL>.
  
  
  
  
  =head2 set_bold()
  
      Default state:      bold is off
      Default action:     Turn bold on
      Valid args:         0, 1 [1]
  
  Set the bold property of the font:
  
      $format->set_bold();  # Turn bold on
  
  [1] Actually, values in the range 100..1000 are also valid. 400 is normal, 700 is bold and 1000 is very bold indeed. It is probably best to set the value to 1 and use normal bold.
  
  
  
  
  =head2 set_italic()
  
      Default state:      Italic is off
      Default action:     Turn italic on
      Valid args:         0, 1
  
  Set the italic property of the font:
  
      $format->set_italic();  # Turn italic on
  
  
  
  
  =head2 set_underline()
  
      Default state:      Underline is off
      Default action:     Turn on single underline
      Valid args:         0  = No underline
                          1  = Single underline
                          2  = Double underline
                          33 = Single accounting underline
                          34 = Double accounting underline
  
  Set the underline property of the font.
  
      $format->set_underline();   # Single underline
  
  
  
  
  =head2 set_font_strikeout()
  
      Default state:      Strikeout is off
      Default action:     Turn strikeout on
      Valid args:         0, 1
  
  Set the strikeout property of the font.
  
  
  
  
  =head2 set_font_script()
  
      Default state:      Super/Subscript is off
      Default action:     Turn Superscript on
      Valid args:         0  = Normal
                          1  = Superscript
                          2  = Subscript
  
  Set the superscript/subscript property of the font. This format is currently not very useful.
  
  
  
  
  =head2 set_font_outline()
  
      Default state:      Outline is off
      Default action:     Turn outline on
      Valid args:         0, 1
  
  Macintosh only.
  
  
  
  
  =head2 set_font_shadow()
  
      Default state:      Shadow is off
      Default action:     Turn shadow on
      Valid args:         0, 1
  
  Macintosh only.
  
  
  
  
  =head2 set_num_format()
  
      Default state:      General format
      Default action:     Format index 1
      Valid args:         See the following table
  
  This method is used to define the numerical format of a number in Excel. It controls whether a number is displayed as an integer, a floating point number, a date, a currency value or some other user defined format.
  
  The numerical format of a cell can be specified by using a format string or an index to one of Excel's built-in formats:
  
      my $format1 = $workbook->add_format();
      my $format2 = $workbook->add_format();
      $format1->set_num_format('d mmm yyyy'); # Format string
      $format2->set_num_format(0x0f);         # Format index
  
      $worksheet->write(0, 0, 36892.521, $format1);      # 1 Jan 2001
      $worksheet->write(0, 0, 36892.521, $format2);      # 1-Jan-01
  
  
  Using format strings you can define very sophisticated formatting of numbers.
  
      $format01->set_num_format('0.000');
      $worksheet->write(0,  0, 3.1415926, $format01);    # 3.142
  
      $format02->set_num_format('#,##0');
      $worksheet->write(1,  0, 1234.56,   $format02);    # 1,235
  
      $format03->set_num_format('#,##0.00');
      $worksheet->write(2,  0, 1234.56,   $format03);    # 1,234.56
  
      $format04->set_num_format('$0.00');
      $worksheet->write(3,  0, 49.99,     $format04);    # $49.99
  
      # Note you can use other currency symbols such as the pound or yen as well.
      # Other currencies may require the use of Unicode.
  
      $format07->set_num_format('mm/dd/yy');
      $worksheet->write(6,  0, 36892.521, $format07);    # 01/01/01
  
      $format08->set_num_format('mmm d yyyy');
      $worksheet->write(7,  0, 36892.521, $format08);    # Jan 1 2001
  
      $format09->set_num_format('d mmmm yyyy');
      $worksheet->write(8,  0, 36892.521, $format09);    # 1 January 2001
  
      $format10->set_num_format('dd/mm/yyyy hh:mm AM/PM');
      $worksheet->write(9,  0, 36892.521, $format10);    # 01/01/2001 12:30 AM
  
      $format11->set_num_format('0 "dollar and" .00 "cents"');
      $worksheet->write(10, 0, 1.87,      $format11);    # 1 dollar and .87 cents
  
      # Conditional formatting
      $format12->set_num_format('[Green]General;[Red]-General;General');
      $worksheet->write(11, 0, 123,       $format12);    # > 0 Green
      $worksheet->write(12, 0, -45,       $format12);    # < 0 Red
      $worksheet->write(13, 0, 0,         $format12);    # = 0 Default colour
  
      # Zip code
      $format13->set_num_format('00000');
      $worksheet->write(14, 0, '01209',   $format13);
  
  
  The number system used for dates is described in L</DATES AND TIME IN EXCEL>.
  
  The colour format should have one of the following values:
  
      [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]
  
  Alternatively you can specify the colour based on a colour index as follows: C<[Color n]>, where n is a standard Excel colour index - 7. See the 'Standard colors' worksheet created by formats.pl.
  
  For more information refer to the documentation on formatting in the C<docs> directory of the Spreadsheet::WriteExcel distro, the Excel on-line help or L<http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx>.
  
  You should ensure that the format string is valid in Excel prior to using it in WriteExcel.
  
  Excel's built-in formats are shown in the following table:
  
      Index   Index   Format String
      0       0x00    General
      1       0x01    0
      2       0x02    0.00
      3       0x03    #,##0
      4       0x04    #,##0.00
      5       0x05    ($#,##0_);($#,##0)
      6       0x06    ($#,##0_);[Red]($#,##0)
      7       0x07    ($#,##0.00_);($#,##0.00)
      8       0x08    ($#,##0.00_);[Red]($#,##0.00)
      9       0x09    0%
      10      0x0a    0.00%
      11      0x0b    0.00E+00
      12      0x0c    # ?/?
      13      0x0d    # ??/??
      14      0x0e    m/d/yy
      15      0x0f    d-mmm-yy
      16      0x10    d-mmm
      17      0x11    mmm-yy
      18      0x12    h:mm AM/PM
      19      0x13    h:mm:ss AM/PM
      20      0x14    h:mm
      21      0x15    h:mm:ss
      22      0x16    m/d/yy h:mm
      ..      ....    ...........
      37      0x25    (#,##0_);(#,##0)
      38      0x26    (#,##0_);[Red](#,##0)
      39      0x27    (#,##0.00_);(#,##0.00)
      40      0x28    (#,##0.00_);[Red](#,##0.00)
      41      0x29    _(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
      42      0x2a    _($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)
      43      0x2b    _(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)
      44      0x2c    _($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)
      45      0x2d    mm:ss
      46      0x2e    [h]:mm:ss
      47      0x2f    mm:ss.0
      48      0x30    ##0.0E+0
      49      0x31    @
  
  
  For examples of these formatting codes see the 'Numerical formats' worksheet created by formats.pl. See also the number_formats1.html and the number_formats2.html documents in the C<docs> directory of the distro.
  
  Note 1. Numeric formats 23 to 36 are not documented by Microsoft and may differ in international versions.
  
  Note 2. In Excel 5 the dollar sign appears as a dollar sign. In Excel 97-2000 it appears as the defined local currency symbol.
  
  Note 3. The red negative numeric formats display slightly differently in Excel 5 and Excel 97-2000.
  
  
  
  
  =head2 set_locked()
  
      Default state:      Cell locking is on
      Default action:     Turn locking on
      Valid args:         0, 1
  
  This property can be used to prevent modification of a cells contents. Following Excel's convention, cell locking is turned on by default. However, it only has an effect if the worksheet has been protected, see the worksheet C<protect()> method.
  
      my $locked  = $workbook->add_format();
      $locked->set_locked(1); # A non-op
  
      my $unlocked = $workbook->add_format();
      $locked->set_locked(0);
  
      # Enable worksheet protection
      $worksheet->protect();
  
      # This cell cannot be edited.
      $worksheet->write('A1', '=1+2', $locked);
  
      # This cell can be edited.
      $worksheet->write('A2', '=1+2', $unlocked);
  
  Note: This offers weak protection even with a password, see the note in relation to the C<protect()> method.
  
  
  
  
  =head2 set_hidden()
  
      Default state:      Formula hiding is off
      Default action:     Turn hiding on
      Valid args:         0, 1
  
  This property is used to hide a formula while still displaying its result. This is generally used to hide complex calculations from end users who are only interested in the result. It only has an effect if the worksheet has been protected, see the worksheet C<protect()> method.
  
      my $hidden = $workbook->add_format();
      $hidden->set_hidden();
  
      # Enable worksheet protection
      $worksheet->protect();
  
      # The formula in this cell isn't visible
      $worksheet->write('A1', '=1+2', $hidden);
  
  
  Note: This offers weak protection even with a password, see the note in relation to the C<protect()> method.
  
  
  
  
  =head2 set_align()
  
      Default state:      Alignment is off
      Default action:     Left alignment
      Valid args:         'left'              Horizontal
                          'center'
                          'right'
                          'fill'
                          'justify'
                          'center_across'
  
                          'top'               Vertical
                          'vcenter'
                          'bottom'
                          'vjustify'
  
  This method is used to set the horizontal and vertical text alignment within a cell. Vertical and horizontal alignments can be combined. The method is used as follows:
  
      my $format = $workbook->add_format();
      $format->set_align('center');
      $format->set_align('vcenter');
      $worksheet->set_row(0, 30);
      $worksheet->write(0, 0, 'X', $format);
  
  Text can be aligned across two or more adjacent cells using the C<center_across> property. However, for genuine merged cells it is better to use the C<merge_range()> worksheet method.
  
  The C<vjustify> (vertical justify) option can be used to provide automatic text wrapping in a cell. The height of the cell will be adjusted to accommodate the wrapped text. To specify where the text wraps use the C<set_text_wrap()> method.
  
  
  For further examples see the 'Alignment' worksheet created by formats.pl.
  
  
  
  
  =head2 set_center_across()
  
      Default state:      Center across selection is off
      Default action:     Turn center across on
      Valid args:         1
  
  Text can be aligned across two or more adjacent cells using the C<set_center_across()> method. This is an alias for the C<set_align('center_across')> method call.
  
  Only one cell should contain the text, the other cells should be blank:
  
      my $format = $workbook->add_format();
      $format->set_center_across();
  
      $worksheet->write(1, 1, 'Center across selection', $format);
      $worksheet->write_blank(1, 2, $format);
  
  See also the C<merge1.pl> to C<merge6.pl> programs in the C<examples> directory and the C<merge_range()> method.
  
  
  
  =head2 set_text_wrap()
  
      Default state:      Text wrap is off
      Default action:     Turn text wrap on
      Valid args:         0, 1
  
  
  Here is an example using the text wrap property, the escape character C<\n> is used to indicate the end of line:
  
      my $format = $workbook->add_format();
      $format->set_text_wrap();
      $worksheet->write(0, 0, "It's\na bum\nwrap", $format);
  
  Excel will adjust the height of the row to accommodate the wrapped text. A similar effect can be obtained without newlines using the C<set_align('vjustify')> method. See the C<textwrap.pl> program in the C<examples> directory.
  
  
  
  
  =head2 set_rotation()
  
      Default state:      Text rotation is off
      Default action:     None
      Valid args:         Integers in the range -90 to 90 and 270
  
  Set the rotation of the text in a cell. The rotation can be any angle in the range -90 to 90 degrees.
  
      my $format = $workbook->add_format();
      $format->set_rotation(30);
      $worksheet->write(0, 0, 'This text is rotated', $format);
  
  
  The angle 270 is also supported. This indicates text where the letters run from top to bottom.
  
  
  
  =head2 set_indent()
  
  
      Default state:      Text indentation is off
      Default action:     Indent text 1 level
      Valid args:         Positive integers
  
  
  This method can be used to indent text. The argument, which should be an integer, is taken as the level of indentation:
  
  
      my $format = $workbook->add_format();
      $format->set_indent(2);
      $worksheet->write(0, 0, 'This text is indented', $format);
  
  
  Indentation is a horizontal alignment property. It will override any other horizontal properties but it can be used in conjunction with vertical properties.
  
  
  
  
  =head2 set_shrink()
  
  
      Default state:      Text shrinking is off
      Default action:     Turn "shrink to fit" on
      Valid args:         1
  
  
  This method can be used to shrink text so that it fits in a cell.
  
  
      my $format = $workbook->add_format();
      $format->set_shrink();
      $worksheet->write(0, 0, 'Honey, I shrunk the text!', $format);
  
  
  
  
  =head2 set_text_justlast()
  
      Default state:      Justify last is off
      Default action:     Turn justify last on
      Valid args:         0, 1
  
  
  Only applies to Far Eastern versions of Excel.
  
  
  
  
  =head2 set_pattern()
  
      Default state:      Pattern is off
      Default action:     Solid fill is on
      Valid args:         0 .. 18
  
  Set the background pattern of a cell.
  
  Examples of the available patterns are shown in the 'Patterns' worksheet created by formats.pl. However, it is unlikely that you will ever need anything other than Pattern 1 which is a solid fill of the background color.
  
  
  
  
  =head2 set_bg_color()
  
      Default state:      Color is off
      Default action:     Solid fill.
      Valid args:         See set_color()
  
  The C<set_bg_color()> method can be used to set the background colour of a pattern. Patterns are defined via the C<set_pattern()> method. If a pattern hasn't been defined then a solid fill pattern is used as the default.
  
  Here is an example of how to set up a solid fill in a cell:
  
      my $format = $workbook->add_format();
  
      $format->set_pattern(); # This is optional when using a solid fill
  
      $format->set_bg_color('green');
      $worksheet->write('A1', 'Ray', $format);
  
  For further examples see the 'Patterns' worksheet created by formats.pl.
  
  
  
  
  =head2 set_fg_color()
  
      Default state:      Color is off
      Default action:     Solid fill.
      Valid args:         See set_color()
  
  
  The C<set_fg_color()> method can be used to set the foreground colour of a pattern.
  
  For further examples see the 'Patterns' worksheet created by formats.pl.
  
  
  
  
  =head2 set_border()
  
      Also applies to:    set_bottom()
                          set_top()
                          set_left()
                          set_right()
  
      Default state:      Border is off
      Default action:     Set border type 1
      Valid args:         0-13, See below.
  
  A cell border is comprised of a border on the bottom, top, left and right. These can be set to the same value using C<set_border()> or individually using the relevant method calls shown above.
  
  The following shows the border styles sorted by Spreadsheet::WriteExcel index number:
  
      Index   Name            Weight   Style
      =====   =============   ======   ===========
      0       None            0
      1       Continuous      1        -----------
      2       Continuous      2        -----------
      3       Dash            1        - - - - - -
      4       Dot             1        . . . . . .
      5       Continuous      3        -----------
      6       Double          3        ===========
      7       Continuous      0        -----------
      8       Dash            2        - - - - - -
      9       Dash Dot        1        - . - . - .
      10      Dash Dot        2        - . - . - .
      11      Dash Dot Dot    1        - . . - . .
      12      Dash Dot Dot    2        - . . - . .
      13      SlantDash Dot   2        / - . / - .
  
  
  The following shows the borders sorted by style:
  
      Name            Weight   Style         Index
      =============   ======   ===========   =====
      Continuous      0        -----------   7
      Continuous      1        -----------   1
      Continuous      2        -----------   2
      Continuous      3        -----------   5
      Dash            1        - - - - - -   3
      Dash            2        - - - - - -   8
      Dash Dot        1        - . - . - .   9
      Dash Dot        2        - . - . - .   10
      Dash Dot Dot    1        - . . - . .   11
      Dash Dot Dot    2        - . . - . .   12
      Dot             1        . . . . . .   4
      Double          3        ===========   6
      None            0                      0
      SlantDash Dot   2        / - . / - .   13
  
  
  The following shows the borders in the order shown in the Excel Dialog.
  
      Index   Style             Index   Style
      =====   =====             =====   =====
      0       None              12      - . . - . .
      7       -----------       13      / - . / - .
      4       . . . . . .       10      - . - . - .
      11      - . . - . .       8       - - - - - -
      9       - . - . - .       2       -----------
      3       - - - - - -       5       -----------
      1       -----------       6       ===========
  
  
  Examples of the available border styles are shown in the 'Borders' worksheet created by formats.pl.
  
  
  
  
  =head2 set_border_color()
  
      Also applies to:    set_bottom_color()
                          set_top_color()
                          set_left_color()
                          set_right_color()
  
      Default state:      Color is off
      Default action:     Undefined
      Valid args:         See set_color()
  
  
  Set the colour of the cell borders. A cell border is comprised of a border on the bottom, top, left and right. These can be set to the same colour using C<set_border_color()> or individually using the relevant method calls shown above. Examples of the border styles and colours are shown in the 'Borders' worksheet created by formats.pl.
  
  
  
  
  
  =head2 copy($format)
  
  
  This method is used to copy all of the properties from one Format object to another:
  
      my $lorry1 = $workbook->add_format();
      $lorry1->set_bold();
      $lorry1->set_italic();
      $lorry1->set_color('red');    # lorry1 is bold, italic and red
  
      my $lorry2 = $workbook->add_format();
      $lorry2->copy($lorry1);
      $lorry2->set_color('yellow'); # lorry2 is bold, italic and yellow
  
  The C<copy()> method is only useful if you are using the method interface to Format properties. It generally isn't required if you are setting Format properties directly using hashes.
  
  
  Note: this is not a copy constructor, both objects must exist prior to copying.
  
  
  
  
  =head1 UNICODE IN EXCEL
  
  The following is a brief introduction to handling Unicode in C<Spreadsheet::WriteExcel>.
  
  I<For a more general introduction to Unicode handling in Perl see> L<perlunitut> and L<perluniintro>.
  
  When using Spreadsheet::WriteExcel the best and easiest way to write unicode strings to an Excel file is to use C<UTF-8> encoded strings and perl 5.8 (or later). Spreadsheet::WriteExcel also allows you to write unicode strings using older perls but it generally requires more work, as explained below.
  
  Internally, Excel encodes unicode data as C<UTF-16LE> (where LE means little-endian). If you are using perl 5.8+ then Spreadsheet::WriteExcel will convert C<UTF-8> strings to C<UTF-16LE> when required. No further intervention is required from the programmer, for example:
  
      # perl 5.8+ example:
      my $smiley = "\x{263A}";
  
      $worksheet->write('A1', 'Hello world'); # ASCII
      $worksheet->write('A2', $smiley);       # UTF-8
  
  Spreadsheet::WriteExcel also lets you write unicode data as C<UTF-16>. Since the majority of CPAN modules default to C<UTF-16BE> (big-endian) Spreadsheet::WriteExcel also uses C<UTF-16BE> and converts it internally to C<UTF-16LE>:
  
      # perl 5.005 example:
      my $smiley = pack 'n', 0x263A;
  
      $worksheet->write               ('A3', 'Hello world'); # ASCII
      $worksheet->write_utf16be_string('A4', $smiley);       # UTF-16
  
  Although the above examples look similar there is an important difference. With C<uft8> and perl 5.8+ Spreadsheet::WriteExcel treats C<UTF-8> strings in exactly the same way as any other string. However, with C<UTF16> data we need to distinguish it from other strings either by calling a separate function or by passing an additional flag to indicate the data type.
  
  If you are dealing with non-ASCII characters that aren't in C<UTF-8> then perl 5.8+ provides useful tools in the guise of the C<Encode> module to help you to convert to the required format. For example:
  
      use Encode 'decode';
  
      my $string = 'some string with koi8-r characters';
         $string = decode('koi8-r', $string); # koi8-r to utf8
  
  Alternatively you can read data from an encoded file and convert it to C<UTF-8> as you read it in:
  
  
      my $file = 'unicode_koi8r.txt';
      open FH, '<:encoding(koi8-r)', $file  or die "Couldn't open $file: $!\n";
  
      my $row = 0;
      while (<FH>) {
          # Data read in is now in utf8 format.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
  
  These methodologies are explained in more detail in L<perlunitut>, L<perluniintro> and L<perlunicode>.
  
  See also the C<unicode_*.pl> programs in the examples directory of the distro.
  
  
  
  
  =head1 COLOURS IN EXCEL
  
  Excel provides a colour palette of 56 colours. In Spreadsheet::WriteExcel these colours are accessed via their palette index in the range 8..63. This index is used to set the colour of fonts, cell patterns and cell borders. For example:
  
      my $format = $workbook->add_format(
                                          color => 12, # index for blue
                                          font  => 'Arial',
                                          size  => 12,
                                          bold  => 1,
                                       );
  
  The most commonly used colours can also be accessed by name. The name acts as a simple alias for the colour index:
  
      black     =>    8
      blue      =>   12
      brown     =>   16
      cyan      =>   15
      gray      =>   23
      green     =>   17
      lime      =>   11
      magenta   =>   14
      navy      =>   18
      orange    =>   53
      pink      =>   33
      purple    =>   20
      red       =>   10
      silver    =>   22
      white     =>    9
      yellow    =>   13
  
  For example:
  
      my $font = $workbook->add_format(color => 'red');
  
  Users of VBA in Excel should note that the equivalent colour indices are in the range 1..56 instead of 8..63.
  
  If the default palette does not provide a required colour you can override one of the built-in values. This is achieved by using the C<set_custom_color()> workbook method to adjust the RGB (red green blue) components of the colour:
  
      my $ferrari = $workbook->set_custom_color(40, 216, 12, 12);
  
      my $format  = $workbook->add_format(
                                          bg_color => $ferrari,
                                          pattern  => 1,
                                          border   => 1
                                        );
  
      $worksheet->write_blank('A1', $format);
  
  The default Excel colour palette is shown in C<palette.html> in the C<docs> directory  of the distro. You can generate an Excel version of the palette using C<colors.pl> in the C<examples> directory.
  
  
  
  
  =head1 DATES AND TIME IN EXCEL
  
  There are two important things to understand about dates and times in Excel:
  
  =over 4
  
  =item 1 A date/time in Excel is a real number plus an Excel number format.
  
  =item 2 Spreadsheet::WriteExcel doesn't automatically convert date/time strings in C<write()> to an Excel date/time.
  
  =back
  
  These two points are explained in more detail below along with some suggestions on how to convert times and dates to the required format.
  
  
  =head2 An Excel date/time is a number plus a format
  
  If you write a date string with C<write()> then all you will get is a string:
  
      $worksheet->write('A1', '02/03/04'); # !! Writes a string not a date. !!
  
  Dates and times in Excel are represented by real numbers, for example "Jan 1 2001 12:30 AM" is represented by the number 36892.521.
  
  The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day.
  
  A date or time in Excel is just like any other number. To have the number display as a date you must apply an Excel number format to it. Here are some examples.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new('date_examples.xls');
      my $worksheet = $workbook->add_worksheet();
  
      $worksheet->set_column('A:A', 30); # For extra visibility.
  
      my $number    = 39506.5;
  
      $worksheet->write('A1', $number);            #     39506.5
  
      my $format2 = $workbook->add_format(num_format => 'dd/mm/yy');
      $worksheet->write('A2', $number , $format2); #     28/02/08
  
      my $format3 = $workbook->add_format(num_format => 'mm/dd/yy');
      $worksheet->write('A3', $number , $format3); #     02/28/08
  
      my $format4 = $workbook->add_format(num_format => 'd-m-yyyy');
      $worksheet->write('A4', $number , $format4); #     28-2-2008
  
      my $format5 = $workbook->add_format(num_format => 'dd/mm/yy hh:mm');
      $worksheet->write('A5', $number , $format5); #     28/02/08 12:00
  
      my $format6 = $workbook->add_format(num_format => 'd mmm yyyy');
      $worksheet->write('A6', $number , $format6); #     28 Feb 2008
  
      my $format7 = $workbook->add_format(num_format => 'mmm d yyyy hh:mm AM/PM');
      $worksheet->write('A7', $number , $format7); #     Feb 28 2008 12:00 PM
  
  
  =head2 Spreadsheet::WriteExcel doesn't automatically convert date/time strings
  
  Spreadsheet::WriteExcel doesn't automatically convert input date strings into Excel's formatted date numbers due to the large number of possible date formats and also due to the possibility of misinterpretation.
  
  For example, does C<02/03/04> mean March 2 2004, February 3 2004 or even March 4 2002.
  
  Therefore, in order to handle dates you will have to convert them to numbers and apply an Excel format. Some methods for converting dates are listed in the next section.
  
  The most direct way is to convert your dates to the ISO8601 C<yyyy-mm-ddThh:mm:ss.sss> date format and use the C<write_date_time()> worksheet method:
  
      $worksheet->write_date_time('A2', '2001-01-01T12:20', $format);
  
  See the C<write_date_time()> section of the documentation for more details.
  
  A general methodology for handling date strings with C<write_date_time()> is:
  
      1. Identify incoming date/time strings with a regex.
      2. Extract the component parts of the date/time using the same regex.
      3. Convert the date/time to the ISO8601 format.
      4. Write the date/time using write_date_time() and a number format.
  
  Here is an example:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook    = Spreadsheet::WriteExcel->new('example.xls');
      my $worksheet   = $workbook->add_worksheet();
  
      # Set the default format for dates.
      my $date_format = $workbook->add_format(num_format => 'mmm d yyyy');
  
      # Increase column width to improve visibility of data.
      $worksheet->set_column('A:C', 20);
  
      # Simulate reading from a data source.
      my $row = 0;
  
      while (<DATA>) {
          chomp;
  
          my $col  = 0;
          my @data = split ' ';
  
          for my $item (@data) {
  
              # Match dates in the following formats: d/m/yy, d/m/yyyy
              if ($item =~ qr[^(\d{1,2})/(\d{1,2})/(\d{4})$]) {
  
                  # Change to the date format required by write_date_time().
                  my $date = sprintf "%4d-%02d-%02dT", $3, $2, $1;
  
                  $worksheet->write_date_time($row, $col++, $date, $date_format);
              }
              else {
                  # Just plain data
                  $worksheet->write($row, $col++, $item);
              }
          }
          $row++;
      }
  
      __DATA__
      Item    Cost    Date
      Book    10      1/9/2007
      Beer    4       12/9/2007
      Bed     500     5/10/2007
  
  For a slightly more advanced solution you can modify the C<write()> method to handle date formats of your choice via the C<add_write_handler()> method. See the C<add_write_handler()> section of the docs and the write_handler3.pl and write_handler4.pl programs in the examples directory of the distro.
  
  
  =head2 Converting dates and times to an Excel date or time
  
  The C<write_date_time()> method above is just one way of handling dates and times.
  
  The L<Spreadsheet::WriteExcel::Utility> module which is included in the distro has date/time handling functions:
  
      use Spreadsheet::WriteExcel::Utility;
  
      $date           = xl_date_list(2002, 1, 1);         # 37257
      $date           = xl_parse_date("11 July 1997");    # 35622
      $time           = xl_parse_time('3:21:36 PM');      # 0.64
      $date           = xl_decode_date_EU("13 May 2002"); # 37389
  
  Note: some of these functions require additional CPAN modules.
  
  For date conversions using the CPAN C<DateTime> framework see L<DateTime::Format::Excel> L<http://search.cpan.org/search?dist=DateTime-Format-Excel>.
  
  
  
  
  =head1 OUTLINES AND GROUPING IN EXCEL
  
  
  Excel allows you to group rows or columns so that they can be hidden or displayed with a single mouse click. This feature is referred to as outlines.
  
  Outlines can reduce complex data down to a few salient sub-totals or summaries.
  
  This feature is best viewed in Excel but the following is an ASCII representation of what a worksheet with three outlines might look like. Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9 are grouped at level 1. The lines at the left hand side are called outline level bars.
  
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |  _  | 2 |   B   |       |       |       |  ...
       | |   | 3 |  (C)  |       |       |       |  ...
       | |   | 4 |  (D)  |       |       |       |  ...
       | -   | 5 |   E   |       |       |       |  ...
       |  _  | 6 |   F   |       |       |       |  ...
       | |   | 7 |  (G)  |       |       |       |  ...
       | |   | 8 |  (H)  |       |       |       |  ...
       | -   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking the minus sign on each of the level 2 outlines will collapse and hide the data as shown in the next figure. The minus sign changes to a plus sign to indicate that the data in the outline is hidden.
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |     | 2 |   B   |       |       |       |  ...
       | +   | 5 |   E   |       |       |       |  ...
       |     | 6 |   F   |       |       |       |  ...
       | +   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking on the minus sign on the level 1 outline will collapse the remaining rows as follows:
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
             | 1 |   A   |       |       |       |  ...
       +     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Grouping in C<Spreadsheet::WriteExcel> is achieved by setting the outline level via the C<set_row()> and C<set_column()> worksheet methods:
  
      set_row($row, $height, $format, $hidden, $level, $collapsed)
      set_column($first_col, $last_col, $width, $format, $hidden, $level, $collapsed)
  
  The following example sets an outline level of 1 for rows 1 and 2 (zero-indexed) and columns B to G. The parameters C<$height> and C<$XF> are assigned default values since they are undefined:
  
      $worksheet->set_row(1, undef, undef, 0, 1);
      $worksheet->set_row(2, undef, undef, 0, 1);
      $worksheet->set_column('B:G', undef, undef, 0, 1);
  
  Excel allows up to 7 outline levels. Therefore the C<$level> parameter should be in the range C<0 E<lt>= $level E<lt>= 7>.
  
  Rows and columns can be collapsed by setting the C<$hidden> flag for the hidden rows/columns and setting the C<$collapsed> flag for the row/column that has the collapsed C<+> symbol:
  
      $worksheet->set_row(1, undef, undef, 1, 1);
      $worksheet->set_row(2, undef, undef, 1, 1);
      $worksheet->set_row(3, undef, undef, 0, 0, 1);        # Collapsed flag.
  
      $worksheet->set_column('B:G', undef, undef, 1, 1);
      $worksheet->set_column('H:H', undef, undef, 0, 0, 1); # Collapsed flag.
  
  Note: Setting the C<$collapsed> flag is particularly important for compatibility with OpenOffice.org and Gnumeric.
  
  For a more complete example see the C<outline.pl> and C<outline_collapsed.pl> programs in the examples directory of the distro.
  
  Some additional outline properties can be set via the C<outline_settings()> worksheet method, see above.
  
  
  
  
  =head1 DATA VALIDATION IN EXCEL
  
  Data validation is a feature of Excel which allows you to restrict the data that a users enters in a cell and to display help and warning messages. It also allows you to restrict input to values in a drop down list.
  
  A typical use case might be to restrict data in a cell to integer values in a certain range, to provide a help message to indicate the required value and to issue a warning if the input data doesn't meet the stated criteria. In Spreadsheet::WriteExcel we could do that as follows:
  
      $worksheet->data_validation('B3',
          {
              validate        => 'integer',
              criteria        => 'between',
              minimum         => 1,
              maximum         => 100,
              input_title     => 'Input an integer:',
              input_message   => 'Between 1 and 100',
              error_message   => 'Sorry, try again.',
          });
  
  The above example would look like this in Excel: L<http://homepage.eircom.net/~jmcnamara/perl/data_validation.jpg>.
  
  =begin html
  
  <center>
  <img src="http://homepage.eircom.net/~jmcnamara/perl/data_validation.jpg" alt="The output from the above example"/>
  </center>
  
  =end html
  
  For more information on data validation see the following Microsoft support article "Description and examples of data validation in Excel": L<http://support.microsoft.com/kb/211485>.
  
  The following sections describe how to use the C<data_validation()> method and its various options.
  
  
  =head2 data_validation($row, $col, { parameter => 'value', ... })
  
  The C<data_validation()> method is used to construct an Excel data validation.
  
  It can be applied to a single cell or a range of cells. You can pass 3 parameters such as  C<($row, $col, {...})> or 5 parameters such as C<($first_row, $first_col, $last_row, $last_col, {...})>. You can also use C<A1> style notation. For example:
  
      $worksheet->data_validation(0, 0,       {...});
      $worksheet->data_validation(0, 0, 4, 1, {...});
  
      # Which are the same as:
  
      $worksheet->data_validation('A1',       {...});
      $worksheet->data_validation('A1:B5',    {...});
  
  See also the note about L</Cell notation> for more information.
  
  
  The last parameter in C<data_validation()> must be a hash ref containing the parameters that describe the type and style of the data validation. The allowable parameters are:
  
      validate
      criteria
      value | minimum | source
      maximum
      ignore_blank
      dropdown
  
      input_title
      input_message
      show_input
  
      error_title
      error_message
      error_type
      show_error
  
  These parameters are explained in the following sections. Most of the parameters are optional, however, you will generally require the three main options C<validate>, C<criteria> and C<value>.
  
      $worksheet->data_validation('B3',
          {
              validate => 'integer',
              criteria => '>',
              value    => 100,
          });
  
  The C<data_validation> method returns:
  
       0 for success.
      -1 for insufficient number of arguments.
      -2 for row or column out of bounds.
      -3 for incorrect parameter or value.
  
  
  =head2 validate
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<validate> parameter is used to set the type of data that you wish to validate. It is always required and it has no default value. Allowable values are:
  
      any
      integer
      decimal
      list
      date
      time
      length
      custom
  
  =over
  
  =item * B<any> is used to specify that the type of data is unrestricted. This is the same as not applying a data validation. It is only provided for completeness and isn't used very often in the context of Spreadsheet::WriteExcel.
  
  =item * B<integer> restricts the cell to integer values. Excel refers to this as 'whole number'.
  
      validate => 'integer',
      criteria => '>',
      value    => 100,
  
  =item * B<decimal> restricts the cell to decimal values.
  
      validate => 'decimal',
      criteria => '>',
      value    => 38.6,
  
  =item * B<list> restricts the cell to a set of user specified values. These can be passed in an array ref or as a cell range (named ranges aren't currently supported):
  
      validate => 'list',
      value    => ['open', 'high', 'close'],
      # Or like this:
      value    => 'B1:B3',
  
  Excel requires that range references are only to cells on the same worksheet.
  
  =item * B<date> restricts the cell to date values. Dates in Excel are expressed as integer values but you can also pass an ISO860 style string as used in C<write_date_time()>. See also L</DATES AND TIME IN EXCEL> for more information about working with Excel's dates.
  
      validate => 'date',
      criteria => '>',
      value    => 39653, # 24 July 2008
      # Or like this:
      value    => '2008-07-24T',
  
  =item * B<time> restricts the cell to time values. Times in Excel are expressed as decimal values but you can also pass an ISO860 style string as used in C<write_date_time()>. See also L</DATES AND TIME IN EXCEL> for more information about working with Excel's times.
  
      validate => 'time',
      criteria => '>',
      value    => 0.5, # Noon
      # Or like this:
      value    => 'T12:00:00',
  
  =item * B<length> restricts the cell data based on an integer string length. Excel refers to this as 'Text length'.
  
      validate => 'length',
      criteria => '>',
      value    => 10,
  
  =item * B<custom> restricts the cell based on an external Excel formula that returns a C<TRUE/FALSE> value.
  
      validate => 'custom',
      value    => '=IF(A10>B10,TRUE,FALSE)',
  
  =back
  
  
  =head2 criteria
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<criteria> parameter is used to set the criteria by which the data in the cell is validated. It is almost always required except for the C<list> and C<custom> validate options. It has no default value. Allowable values are:
  
      'between'
      'not between'
      'equal to'                  |  '=='  |  '='
      'not equal to'              |  '!='  |  '<>'
      'greater than'              |  '>'
      'less than'                 |  '<'
      'greater than or equal to'  |  '>='
      'less than or equal to'     |  '<='
  
  You can either use Excel's textual description strings, in the first column above, or the more common operator alternatives. The following are equivalent:
  
      validate => 'integer',
      criteria => 'greater than',
      value    => 100,
  
      validate => 'integer',
      criteria => '>',
      value    => 100,
  
  The C<list> and C<custom> validate options don't require a C<criteria>. If you specify one it will be ignored.
  
      validate => 'list',
      value    => ['open', 'high', 'close'],
  
      validate => 'custom',
      value    => '=IF(A10>B10,TRUE,FALSE)',
  
  
  =head2 value | minimum | source
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<value> parameter is used to set the limiting value to which the C<criteria> is applied. It is always required and it has no default value. You can also use the synonyms C<minimum> or C<source> to make the validation a little clearer and closer to Excel's description of the parameter:
  
      # Use 'value'
      validate => 'integer',
      criteria => '>',
      value    => 100,
  
      # Use 'minimum'
      validate => 'integer',
      criteria => 'between',
      minimum  => 1,
      maximum  => 100,
  
      # Use 'source'
      validate => 'list',
      source   => '$B$1:$B$3',
  
  
  =head2 maximum
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<maximum> parameter is used to set the upper limiting value when the C<criteria> is either C<'between'> or C<'not between'>:
  
      validate => 'integer',
      criteria => 'between',
      minimum  => 1,
      maximum  => 100,
  
  
  =head2 ignore_blank
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<ignore_blank> parameter is used to toggle on and off the 'Ignore blank' option in the Excel data validation dialog. When the option is on the data validation is not applied to blank data in the cell. It is on by default.
  
      ignore_blank => 0,  # Turn the option off
  
  
  =head2 dropdown
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<dropdown> parameter is used to toggle on and off the 'In-cell dropdown' option in the Excel data validation dialog. When the option is on a dropdown list will be shown for C<list> validations. It is on by default.
  
      dropdown => 0,      # Turn the option off
  
  
  =head2 input_title
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<input_title> parameter is used to set the title of the input message that is displayed when a cell is entered. It has no default value and is only displayed if the input message is displayed. See the C<input_message> parameter below.
  
      input_title   => 'This is the input title',
  
  The maximum title length is 32 characters. UTF8 strings are handled automatically in perl 5.8 and later.
  
  
  =head2 input_message
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<input_message> parameter is used to set the input message that is displayed when a cell is entered. It has no default value.
  
      validate      => 'integer',
      criteria      => 'between',
      minimum       => 1,
      maximum       => 100,
      input_title   => 'Enter the applied discount:',
      input_message => 'between 1 and 100',
  
  The message can be split over several lines using newlines, C<"\n"> in double quoted strings.
  
      input_message => "This is\na test.",
  
  The maximum message length is 255 characters. UTF8 strings are handled automatically in perl 5.8 and later.
  
  
  =head2 show_input
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<show_input> parameter is used to toggle on and off the 'Show input message when cell is selected' option in the Excel data validation dialog. When the option is off an input message is not displayed even if it has been set using C<input_message>. It is on by default.
  
      show_input => 0,      # Turn the option off
  
  
  =head2 error_title
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<error_title> parameter is used to set the title of the error message that is displayed when the data validation criteria is not met. The default error title is 'Microsoft Excel'.
  
      error_title   => 'Input value is not valid',
  
  The maximum title length is 32 characters. UTF8 strings are handled automatically in perl 5.8 and later.
  
  
  =head2 error_message
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<error_message> parameter is used to set the error message that is displayed when a cell is entered. The default error message is "The value you entered is not valid.\nA user has restricted values that can be entered into the cell.".
  
      validate      => 'integer',
      criteria      => 'between',
      minimum       => 1,
      maximum       => 100,
      error_title   => 'Input value is not valid',
      error_message => 'It should be an integer between 1 and 100',
  
  The message can be split over several lines using newlines, C<"\n"> in double quoted strings.
  
      input_message => "This is\na test.",
  
  The maximum message length is 255 characters. UTF8 strings are handled automatically in perl 5.8 and later.
  
  
  =head2 error_type
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<error_type> parameter is used to specify the type of error dialog that is displayed. There are 3 options:
  
      'stop'
      'warning'
      'information'
  
  The default is C<'stop'>.
  
  
  =head2 show_error
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<show_error> parameter is used to toggle on and off the 'Show error alert after invalid data is entered' option in the Excel data validation dialog. When the option is off an error message is not displayed even if it has been set using C<error_message>. It is on by default.
  
      show_error => 0,      # Turn the option off
  
  =head2 Data Validation Examples
  
  Example 1. Limiting input to an integer greater than a fixed value.
  
      $worksheet->data_validation('A1',
          {
              validate        => 'integer',
              criteria        => '>',
              value           => 0,
          });
  
  Example 2. Limiting input to an integer greater than a fixed value where the value is referenced from a cell.
  
      $worksheet->data_validation('A2',
          {
              validate        => 'integer',
              criteria        => '>',
              value           => '=E3',
          });
  
  Example 3. Limiting input to a decimal in a fixed range.
  
      $worksheet->data_validation('A3',
          {
              validate        => 'decimal',
              criteria        => 'between',
              minimum         => 0.1,
              maximum         => 0.5,
          });
  
  Example 4. Limiting input to a value in a dropdown list.
  
      $worksheet->data_validation('A4',
          {
              validate        => 'list',
              source          => ['open', 'high', 'close'],
          });
  
  Example 5. Limiting input to a value in a dropdown list where the list is specified as a cell range.
  
      $worksheet->data_validation('A5',
          {
              validate        => 'list',
              source          => '=E4:G4',
          });
  
  Example 6. Limiting input to a date in a fixed range.
  
      $worksheet->data_validation('A6',
          {
              validate        => 'date',
              criteria        => 'between',
              minimum         => '2008-01-01T',
              maximum         => '2008-12-12T',
          });
  
  Example 7. Displaying a message when the cell is selected.
  
      $worksheet->data_validation('A7',
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
          });
  
  See also the C<data_validate.pl> program in the examples directory of the distro.
  
  
  
  =head1 ROW HEIGHTS AND WORKSHEET OBJECTS
  
  The following relates to worksheet objects such as images, comments and charts.
  
  If you specify the height of a row that contains a worksheet object then Spreadsheet::WriteExcel will adjust the height of the object to maintain its default or user specified dimensions. In this way the object won't appear stretched or compressed in Excel.
  
  However, Excel can also adjust the height of a row automatically if it contains cells that have the text wrap property set or contain large fonts. In these cases the height of the row is unknown to Spreadsheet::WriteExcel at execution time and the scaling calculations it performs are incorrect. The effect of this is that the  object is stretched with the row when it is displayed in Excel.
  
  In order to avoid this issue you should use the C<set_row()> method to explicitly specify the height of any row that may otherwise be changed automatically by Excel.
  
  
  
  
  =head1 FORMULAS AND FUNCTIONS IN EXCEL
  
  
  =head2 Caveats
  
  The first thing to note is that there are still some outstanding issues with the implementation of formulas and functions:
  
      1. Writing a formula is much slower than writing the equivalent string.
      2. You cannot use array constants, i.e. {1;2;3}, in functions.
      3. Unary minus isn't supported.
      4. Whitespace is not preserved around operators.
      5. Named ranges are not supported.
      6. Array formulas are not supported.
  
  However, these constraints will be removed in future versions. They are here because of a trade-off between features and time. Also, it is possible to work around issue 1 using the C<store_formula()> and C<repeat_formula()> methods as described later in this section.
  
  
  
  =head2 Introduction
  
  The following is a brief introduction to formulas and functions in Excel and Spreadsheet::WriteExcel.
  
  A formula is a string that begins with an equals sign:
  
      '=A1+B1'
      '=AVERAGE(1, 2, 3)'
  
  The formula can contain numbers, strings, boolean values, cell references, cell ranges and functions. Named ranges are not supported. Formulas should be written as they appear in Excel, that is cells and functions must be in uppercase.
  
  Cells in Excel are referenced using the A1 notation system where the column is designated by a letter and the row by a number. Columns range from A to IV i.e. 0 to 255, rows range from 1 to 65536. The C<Spreadsheet::WriteExcel::Utility> module that is included in the distro contains helper functions for dealing with A1 notation, for example:
  
      use Spreadsheet::WriteExcel::Utility;
  
      ($row, $col) = xl_cell_to_rowcol('C2');  # (1, 2)
      $str         = xl_rowcol_to_cell(1, 2);  # C2
  
  The Excel C<$> notation in cell references is also supported. This allows you to specify whether a row or column is relative or absolute. This only has an effect if the cell is copied. The following examples show relative and absolute values.
  
      '=A1'   # Column and row are relative
      '=$A1'  # Column is absolute and row is relative
      '=A$1'  # Column is relative and row is absolute
      '=$A$1' # Column and row are absolute
  
  Formulas can also refer to cells in other worksheets of the current workbook. For example:
  
      '=Sheet2!A1'
      '=Sheet2!A1:A5'
      '=Sheet2:Sheet3!A1'
      '=Sheet2:Sheet3!A1:A5'
      q{='Test Data'!A1}
      q{='Test Data1:Test Data2'!A1}
  
  The sheet reference and the cell reference are separated by  C<!> the exclamation mark symbol. If worksheet names contain spaces, commas or parentheses then Excel requires that the name is enclosed in single quotes as shown in the last two examples above. In order to avoid using a lot of escape characters you can use the quote operator C<q{}> to protect the quotes. See C<perlop> in the main Perl documentation. Only valid sheet names that have been added using the C<add_worksheet()> method can be used in formulas. You cannot reference external workbooks.
  
  
  The following table lists the operators that are available in Excel's formulas. The majority of the operators are the same as Perl's, differences are indicated:
  
      Arithmetic operators:
      =====================
      Operator  Meaning                   Example
         +      Addition                  1+2
         -      Subtraction               2-1
         *      Multiplication            2*3
         /      Division                  1/4
         ^      Exponentiation            2^3      # Equivalent to **
         -      Unary minus               -(1+2)   # Not yet supported
         %      Percent (Not modulus)     13%      # Not supported, [1]
  
  
      Comparison operators:
      =====================
      Operator  Meaning                   Example
          =     Equal to                  A1 =  B1 # Equivalent to ==
          <>    Not equal to              A1 <> B1 # Equivalent to !=
          >     Greater than              A1 >  B1
          <     Less than                 A1 <  B1
          >=    Greater than or equal to  A1 >= B1
          <=    Less than or equal to     A1 <= B1
  
  
      String operator:
      ================
      Operator  Meaning                   Example
          &     Concatenation             "Hello " & "World!" # [2]
  
  
      Reference operators:
      ====================
      Operator  Meaning                   Example
          :     Range operator            A1:A4               # [3]
          ,     Union operator            SUM(1, 2+2, B3)     # [4]
  
  
      Notes:
      [1]: You can get a percentage with formatting and modulus with MOD().
      [2]: Equivalent to ("Hello " . "World!") in Perl.
      [3]: This range is equivalent to cells A1, A2, A3 and A4.
      [4]: The comma behaves like the list separator in Perl.
  
  The range and comma operators can have different symbols in non-English versions of Excel. These will be supported in a later version of Spreadsheet::WriteExcel. European users of Excel take note:
  
      $worksheet->write('A1', '=SUM(1; 2; 3)'); # Wrong!!
      $worksheet->write('A1', '=SUM(1, 2, 3)'); # Okay
  
  The following table lists all of the core functions supported by Excel 5 and Spreadsheet::WriteExcel. Any additional functions that are available through the "Analysis ToolPak" or other add-ins are not supported. These functions have all been tested to verify that they work.
  
      ABS           DB            INDIRECT      NORMINV       SLN
      ACOS          DCOUNT        INFO          NORMSDIST     SLOPE
      ACOSH         DCOUNTA       INT           NORMSINV      SMALL
      ADDRESS       DDB           INTERCEPT     NOT           SQRT
      AND           DEGREES       IPMT          NOW           STANDARDIZE
      AREAS         DEVSQ         IRR           NPER          STDEV
      ASIN          DGET          ISBLANK       NPV           STDEVP
      ASINH         DMAX          ISERR         ODD           STEYX
      ATAN          DMIN          ISERROR       OFFSET        SUBSTITUTE
      ATAN2         DOLLAR        ISLOGICAL     OR            SUBTOTAL
      ATANH         DPRODUCT      ISNA          PEARSON       SUM
      AVEDEV        DSTDEV        ISNONTEXT     PERCENTILE    SUMIF
      AVERAGE       DSTDEVP       ISNUMBER      PERCENTRANK   SUMPRODUCT
      BETADIST      DSUM          ISREF         PERMUT        SUMSQ
      BETAINV       DVAR          ISTEXT        PI            SUMX2MY2
      BINOMDIST     DVARP         KURT          PMT           SUMX2PY2
      CALL          ERROR.TYPE    LARGE         POISSON       SUMXMY2
      CEILING       EVEN          LEFT          POWER         SYD
      CELL          EXACT         LEN           PPMT          T
      CHAR          EXP           LINEST        PROB          TAN
      CHIDIST       EXPONDIST     LN            PRODUCT       TANH
      CHIINV        FACT          LOG           PROPER        TDIST
      CHITEST       FALSE         LOG10         PV            TEXT
      CHOOSE        FDIST         LOGEST        QUARTILE      TIME
      CLEAN         FIND          LOGINV        RADIANS       TIMEVALUE
      CODE          FINV          LOGNORMDIST   RAND          TINV
      COLUMN        FISHER        LOOKUP        RANK          TODAY
      COLUMNS       FISHERINV     LOWER         RATE          TRANSPOSE
      COMBIN        FIXED         MATCH         REGISTER.ID   TREND
      CONCATENATE   FLOOR         MAX           REPLACE       TRIM
      CONFIDENCE    FORECAST      MDETERM       REPT          TRIMMEAN
      CORREL        FREQUENCY     MEDIAN        RIGHT         TRUE
      COS           FTEST         MID           ROMAN         TRUNC
      COSH          FV            MIN           ROUND         TTEST
      COUNT         GAMMADIST     MINUTE        ROUNDDOWN     TYPE
      COUNTA        GAMMAINV      MINVERSE      ROUNDUP       UPPER
      COUNTBLANK    GAMMALN       MIRR          ROW           VALUE
      COUNTIF       GEOMEAN       MMULT         ROWS          VAR
      COVAR         GROWTH        MOD           RSQ           VARP
      CRITBINOM     HARMEAN       MODE          SEARCH        VDB
      DATE          HLOOKUP       MONTH         SECOND        VLOOKUP
      DATEVALUE     HOUR          N             SIGN          WEEKDAY
      DAVERAGE      HYPGEOMDIST   NA            SIN           WEIBULL
      DAY           IF            NEGBINOMDIST  SINH          YEAR
      DAYS360       INDEX         NORMDIST      SKEW          ZTEST
  
  You can also modify the module to support function names in the following languages: German, French, Spanish, Portuguese, Dutch, Finnish, Italian and Swedish. See the C<function_locale.pl> program in the C<examples> directory of the distro.
  
  For a general introduction to Excel's formulas and an explanation of the syntax of the function refer to the Excel help files or the following: L<http://office.microsoft.com/en-us/assistance/CH062528031033.aspx>.
  
  If your formula doesn't work in Spreadsheet::WriteExcel try the following:
  
      1. Verify that the formula works in Excel (or Gnumeric or OpenOffice.org).
      2. Ensure that it isn't on the Caveats list shown above.
      3. Ensure that cell references and formula names are in uppercase.
      4. Ensure that you are using ':' as the range operator, A1:A4.
      5. Ensure that you are using ',' as the union operator, SUM(1,2,3).
      6. Ensure that the function is in the above table.
  
  If you go through steps 1-6 and you still have a problem, mail me.
  
  
  
  
  =head2 Improving performance when working with formulas
  
  Writing a large number of formulas with Spreadsheet::WriteExcel can be slow. This is due to the fact that each formula has to be parsed and with the current implementation this is computationally expensive.
  
  However, in a lot of cases the formulas that you write will be quite similar, for example:
  
      $worksheet->write_formula('B1',    '=A1 * 3 + 50',    $format);
      $worksheet->write_formula('B2',    '=A2 * 3 + 50',    $format);
      ...
      ...
      $worksheet->write_formula('B99',   '=A999 * 3 + 50',  $format);
      $worksheet->write_formula('B1000', '=A1000 * 3 + 50', $format);
  
  In this example the cell reference changes in iterations from C<A1> to C<A1000>. The parser treats this variable as a I<token> and arranges it according to predefined rules. However, since the parser is oblivious to the value of the token, it is essentially performing the same calculation 1000 times. This is inefficient.
  
  The way to avoid this inefficiency and thereby speed up the writing of formulas is to parse the formula once and then repeatedly substitute similar tokens.
  
  A formula can be parsed and stored via the C<store_formula()> worksheet method. You can then use the C<repeat_formula()> method to substitute C<$pattern>, C<$replace> pairs in the stored formula:
  
      my $formula = $worksheet->store_formula('=A1 * 3 + 50');
  
      for my $row (0..999) {
          $worksheet->repeat_formula($row, 1, $formula, $format, 'A1', 'A'.($row +1));
      }
  
  On an arbitrary test machine this method was 10 times faster than the brute force method shown above.
  
  For more information about how Spreadsheet::WriteExcel parses and stores formulas see the C<Spreadsheet::WriteExcel::Formula> man page.
  
  It should be noted however that the overall speed of direct formula parsing will be improved in a future version.
  
  
  
  
  =head1 EXAMPLES
  
  See L<Spreadsheet::WriteExcel::Examples> for a full list of examples.
  
  
  =head2 Example 1
  
  The following example shows some of the basic features of Spreadsheet::WriteExcel.
  
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      # Create a new workbook called simple.xls and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('simple.xls');
      my $worksheet = $workbook->add_worksheet();
  
      # The general syntax is write($row, $column, $token). Note that row and
      # column are zero indexed
  
      # Write some text
      $worksheet->write(0, 0,  'Hi Excel!');
  
  
      # Write some numbers
      $worksheet->write(2, 0,  3);          # Writes 3
      $worksheet->write(3, 0,  3.00000);    # Writes 3
      $worksheet->write(4, 0,  3.00001);    # Writes 3.00001
      $worksheet->write(5, 0,  3.14159);    # TeX revision no.?
  
  
      # Write some formulas
      $worksheet->write(7, 0,  '=A3 + A6');
      $worksheet->write(8, 0,  '=IF(A5>3,"Yes", "No")');
  
  
      # Write a hyperlink
      $worksheet->write(10, 0, 'http://www.perl.com/');
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/a_simple.jpg" width="640" height="420" alt="Output from a_simple.pl" /></center></p>
  
  =end html
  
  
  
  
  =head2 Example 2
  
  The following is a general example which demonstrates some features of working with multiple worksheets.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      # Create a new Excel workbook
      my $workbook = Spreadsheet::WriteExcel->new('regions.xls');
  
      # Add some worksheets
      my $north = $workbook->add_worksheet('North');
      my $south = $workbook->add_worksheet('South');
      my $east  = $workbook->add_worksheet('East');
      my $west  = $workbook->add_worksheet('West');
  
      # Add a Format
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color('blue');
  
      # Add a caption to each worksheet
      foreach my $worksheet ($workbook->sheets()) {
          $worksheet->write(0, 0, 'Sales', $format);
      }
  
      # Write some data
      $north->write(0, 1, 200000);
      $south->write(0, 1, 100000);
      $east->write (0, 1, 150000);
      $west->write (0, 1, 100000);
  
      # Set the active worksheet
      $south->activate();
  
      # Set the width of the first column
      $south->set_column(0, 0, 20);
  
      # Set the active cell
      $south->set_selection(0, 1);
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/regions.jpg" width="640" height="420" alt="Output from regions.pl" /></center></p>
  
  =end html
  
  
  
  
  =head2 Example 3
  
  This example shows how to use a conditional numerical format with colours to indicate if a share price has gone up or down.
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('stocks.xls');
      my $worksheet = $workbook->add_worksheet();
  
      # Set the column width for columns 1, 2, 3 and 4
      $worksheet->set_column(0, 3, 15);
  
  
      # Create a format for the column headings
      my $header = $workbook->add_format();
      $header->set_bold();
      $header->set_size(12);
      $header->set_color('blue');
  
  
      # Create a format for the stock price
      my $f_price = $workbook->add_format();
      $f_price->set_align('left');
      $f_price->set_num_format('$0.00');
  
  
      # Create a format for the stock volume
      my $f_volume = $workbook->add_format();
      $f_volume->set_align('left');
      $f_volume->set_num_format('#,##0');
  
  
      # Create a format for the price change. This is an example of a
      # conditional format. The number is formatted as a percentage. If it is
      # positive it is formatted in green, if it is negative it is formatted
      # in red and if it is zero it is formatted as the default font colour
      # (in this case black). Note: the [Green] format produces an unappealing
      # lime green. Try [Color 10] instead for a dark green.
      #
      my $f_change = $workbook->add_format();
      $f_change->set_align('left');
      $f_change->set_num_format('[Green]0.0%;[Red]-0.0%;0.0%');
  
  
      # Write out the data
      $worksheet->write(0, 0, 'Company',$header);
      $worksheet->write(0, 1, 'Price',  $header);
      $worksheet->write(0, 2, 'Volume', $header);
      $worksheet->write(0, 3, 'Change', $header);
  
      $worksheet->write(1, 0, 'Damage Inc.'       );
      $worksheet->write(1, 1, 30.25,    $f_price ); # $30.25
      $worksheet->write(1, 2, 1234567,  $f_volume); # 1,234,567
      $worksheet->write(1, 3, 0.085,    $f_change); # 8.5% in green
  
      $worksheet->write(2, 0, 'Dump Corp.'        );
      $worksheet->write(2, 1, 1.56,     $f_price ); # $1.56
      $worksheet->write(2, 2, 7564,     $f_volume); # 7,564
      $worksheet->write(2, 3, -0.015,   $f_change); # -1.5% in red
  
      $worksheet->write(3, 0, 'Rev Ltd.'          );
      $worksheet->write(3, 1, 0.13,     $f_price ); # $0.13
      $worksheet->write(3, 2, 321,      $f_volume); # 321
      $worksheet->write(3, 3, 0,        $f_change); # 0 in the font color (black)
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/stocks.jpg" width="640" height="420" alt="Output from stocks.pl" /></center></p>
  
  =end html
  
  
  
  
  =head2 Example 4
  
  The following is a simple example of using functions.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('stats.xls');
      my $worksheet = $workbook->add_worksheet('Test data');
  
      # Set the column width for columns 1
      $worksheet->set_column(0, 0, 20);
  
  
      # Create a format for the headings
      my $format = $workbook->add_format();
      $format->set_bold();
  
  
      # Write the sample data
      $worksheet->write(0, 0, 'Sample', $format);
      $worksheet->write(0, 1, 1);
      $worksheet->write(0, 2, 2);
      $worksheet->write(0, 3, 3);
      $worksheet->write(0, 4, 4);
      $worksheet->write(0, 5, 5);
      $worksheet->write(0, 6, 6);
      $worksheet->write(0, 7, 7);
      $worksheet->write(0, 8, 8);
  
      $worksheet->write(1, 0, 'Length', $format);
      $worksheet->write(1, 1, 25.4);
      $worksheet->write(1, 2, 25.4);
      $worksheet->write(1, 3, 24.8);
      $worksheet->write(1, 4, 25.0);
      $worksheet->write(1, 5, 25.3);
      $worksheet->write(1, 6, 24.9);
      $worksheet->write(1, 7, 25.2);
      $worksheet->write(1, 8, 24.8);
  
      # Write some statistical functions
      $worksheet->write(4,  0, 'Count', $format);
      $worksheet->write(4,  1, '=COUNT(B1:I1)');
  
      $worksheet->write(5,  0, 'Sum', $format);
      $worksheet->write(5,  1, '=SUM(B2:I2)');
  
      $worksheet->write(6,  0, 'Average', $format);
      $worksheet->write(6,  1, '=AVERAGE(B2:I2)');
  
      $worksheet->write(7,  0, 'Min', $format);
      $worksheet->write(7,  1, '=MIN(B2:I2)');
  
      $worksheet->write(8,  0, 'Max', $format);
      $worksheet->write(8,  1, '=MAX(B2:I2)');
  
      $worksheet->write(9,  0, 'Standard Deviation', $format);
      $worksheet->write(9,  1, '=STDEV(B2:I2)');
  
      $worksheet->write(10, 0, 'Kurtosis', $format);
      $worksheet->write(10, 1, '=KURT(B2:I2)');
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/stats.jpg" width="640" height="420" alt="Output from stats.pl" /></center></p>
  
  =end html
  
  
  
  
  =head2 Example 5
  
  The following example converts a tab separated file called C<tab.txt> into an Excel file called C<tab.xls>.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      open (TABFILE, 'tab.txt') or die "tab.txt: $!";
  
      my $workbook  = Spreadsheet::WriteExcel->new('tab.xls');
      my $worksheet = $workbook->add_worksheet();
  
      # Row and column are zero indexed
      my $row = 0;
  
      while (<TABFILE>) {
          chomp;
          # Split on single tab
          my @Fld = split('\t', $_);
  
          my $col = 0;
          foreach my $token (@Fld) {
              $worksheet->write($row, $col, $token);
              $col++;
          }
          $row++;
      }
  
  
  NOTE: This is a simple conversion program for illustrative purposes only. For converting a CSV or Tab separated or any other type of delimited text file to Excel I recommend the more rigorous csv2xls program that is part of H.Merijn Brand's Text::CSV_XS module distro.
  
  See the examples/csv2xls link here: L<http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST>.
  
  
  
  
  =head2 Additional Examples
  
  The following is a description of the example files that are provided
  in the standard Spreadsheet::WriteExcel distribution. They demonstrate the
  different features and options of the module.
  See L<Spreadsheet::WriteExcel::Examples> for more details.
  
      Getting started
      ===============
      a_simple.pl             A get started example with some basic features.
      demo.pl                 A demo of some of the available features.
      regions.pl              A simple example of multiple worksheets.
      stats.pl                Basic formulas and functions.
      formats.pl              All the available formatting on several worksheets.
      bug_report.pl           A template for submitting bug reports.
  
  
      Advanced
      ========
      autofilter.pl           Examples of worksheet autofilters.
      autofit.pl              Simulate Excel's autofit for column widths.
      bigfile.pl              Write past the 7MB limit with OLE::Storage_Lite.
      cgi.pl                  A simple CGI program.
      chart_area.pl           A demo of area style charts.
      chart_bar.pl            A demo of bar (vertical histogram) style charts.
      chart_column.pl         A demo of column (histogram) style charts.
      chart_line.pl           A demo of line style charts.
      chart_pie.pl            A demo of pie style charts.
      chart_scatter.pl        A demo of scatter style charts.
      chart_stock.pl          A demo of stock style charts.
      chess.pl                An example of reusing formatting via properties.
      colors.pl               A demo of the colour palette and named colours.
      comments1.pl            Add comments to worksheet cells.
      comments2.pl            Add comments with advanced options.
      copyformat.pl           Example of copying a cell format.
      data_validate.pl        An example of data validation and dropdown lists.
      date_time.pl            Write dates and times with write_date_time().
      defined_name.pl         Example of how to create defined names.
      diag_border.pl          A simple example of diagonal cell borders.
      easter_egg.pl           Expose the Excel97 flight simulator.
      filehandle.pl           Examples of working with filehandles.
      formula_result.pl       Formulas with user specified results.
      headers.pl              Examples of worksheet headers and footers.
      hide_sheet.pl           Simple example of hiding a worksheet.
      hyperlink1.pl           Shows how to create web hyperlinks.
      hyperlink2.pl           Examples of internal and external hyperlinks.
      images.pl               Adding images to worksheets.
      indent.pl               An example of cell indentation.
      merge1.pl               A simple example of cell merging.
      merge2.pl               A simple example of cell merging with formatting.
      merge3.pl               Add hyperlinks to merged cells.
      merge4.pl               An advanced example of merging with formatting.
      merge5.pl               An advanced example of merging with formatting.
      merge6.pl               An example of merging with Unicode strings.
      mod_perl1.pl            A simple mod_perl 1 program.
      mod_perl2.pl            A simple mod_perl 2 program.
      outline.pl              An example of outlines and grouping.
      outline_collapsed.pl    An example of collapsed outlines.
      panes.pl                An examples of how to create panes.
      properties.pl           Add document properties to a workbook.
      protection.pl           Example of cell locking and formula hiding.
      repeat.pl               Example of writing repeated formulas.
      right_to_left.pl        Change default sheet direction to right to left.
      row_wrap.pl             How to wrap data from one worksheet onto another.
      sales.pl                An example of a simple sales spreadsheet.
      sendmail.pl             Send an Excel email attachment using Mail::Sender.
      stats_ext.pl            Same as stats.pl with external references.
      stocks.pl               Demonstrates conditional formatting.
      tab_colors.pl           Example of how to set worksheet tab colours.
      textwrap.pl             Demonstrates text wrapping options.
      win32ole.pl             A sample Win32::OLE example for comparison.
      write_arrays.pl         Example of writing 1D or 2D arrays of data.
      write_handler1.pl       Example of extending the write() method. Step 1.
      write_handler2.pl       Example of extending the write() method. Step 2.
      write_handler3.pl       Example of extending the write() method. Step 3.
      write_handler4.pl       Example of extending the write() method. Step 4.
      write_to_scalar.pl      Example of writing an Excel file to a Perl scalar.
  
  
      Unicode
      =======
      unicode_utf16.pl        Simple example of using Unicode UTF16 strings.
      unicode_utf16_japan.pl  Write Japanese Unicode strings using UTF-16.
      unicode_cyrillic.pl     Write Russian Cyrillic strings using UTF-8.
      unicode_list.pl         List the chars in a Unicode font.
      unicode_2022_jp.pl      Japanese: ISO-2022-JP to utf8 in perl 5.8.
      unicode_8859_11.pl      Thai:     ISO-8859_11 to utf8 in perl 5.8.
      unicode_8859_7.pl       Greek:    ISO-8859_7  to utf8 in perl 5.8.
      unicode_big5.pl         Chinese:  BIG5        to utf8 in perl 5.8.
      unicode_cp1251.pl       Russian:  CP1251      to utf8 in perl 5.8.
      unicode_cp1256.pl       Arabic:   CP1256      to utf8 in perl 5.8.
      unicode_koi8r.pl        Russian:  KOI8-R      to utf8 in perl 5.8.
      unicode_polish_utf8.pl  Polish :  UTF8        to utf8 in perl 5.8.
      unicode_shift_jis.pl    Japanese: Shift JIS   to utf8 in perl 5.8.
  
  
      Utility
      =======
      csv2xls.pl              Program to convert a CSV file to an Excel file.
      tab2xls.pl              Program to convert a tab separated file to xls.
      datecalc1.pl            Convert Unix/Perl time to Excel time.
      datecalc2.pl            Calculate an Excel date using Date::Calc.
      lecxe.pl                Convert Excel to WriteExcel using Win32::OLE.
  
  
      Developer
      =========
      convertA1.pl            Helper functions for dealing with A1 notation.
      function_locale.pl      Add non-English function names to Formula.pm.
      writeA1.pl              Example of how to extend the module.
  
  
  
  =head1 LIMITATIONS
  
  The following limits are imposed by Excel:
  
      Description                          Limit
      -----------------------------------  ------
      Maximum number of chars in a string  32767
      Maximum number of columns            256
      Maximum number of rows               65536
      Maximum chars in a sheet name        31
      Maximum chars in a header/footer     254
  
  For Excel 2007+ file limits see the L<Excel::Writer::XLSX> module.
  
  The minimum file size is 6K due to the OLE overhead. The maximum file size is approximately 7MB (7087104 bytes) of BIFF data. This can be extended by installing Takanori Kawai's OLE::Storage_Lite module L<http://search.cpan.org/search?dist=OLE-Storage_Lite> see the C<bigfile.pl> example in the C<examples> directory of the distro.
  
  
  
  
  =head1 DOWNLOADING
  
  The latest version of this module is always available at: L<http://search.cpan.org/search?dist=Spreadsheet-WriteExcel/>.
  
  
  
  
  =head1 REQUIREMENTS
  
  This module requires Perl >= 5.005, Parse::RecDescent, File::Temp and OLE::Storage_Lite:
  
      http://search.cpan.org/search?dist=Parse-RecDescent/ # For formulas.
      http://search.cpan.org/search?dist=File-Temp/        # For set_tempdir().
      http://search.cpan.org/search?dist=OLE-Storage_Lite/ # For files > 7MB.
  
  Note, these aren't strict requirements. Spreadsheet::WriteExcel will work without these modules if you don't use write_formula(), set_tempdir() or create files greater than 7MB. However, it is best to install them if possible and they will be installed automatically if you use a tool such as CPAN.pm or ppm.
  
  
  =head1 INSTALLATION
  
  See the INSTALL or install.html docs that come with the distribution or: L<http://search.cpan.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.31/INSTALL>.
  
  
  
  
  =head1 PORTABILITY
  
  Spreadsheet::WriteExcel will work on the majority of Windows, UNIX and Macintosh platforms. Specifically, the module will work on any system where perl packs floats in the 64 bit IEEE format. The float must also be in little-endian format but it will be reversed if necessary. Thus:
  
      print join(' ', map { sprintf '%#02x', $_ } unpack('C*', pack 'd', 1.2345)), "\n";
  
  should give (or in reverse order):
  
      0x8d 0x97 0x6e 0x12 0x83 0xc0 0xf3 0x3f
  
  In general, if you don't know whether your system supports a 64 bit IEEE float or not, it probably does. If your system doesn't, WriteExcel will C<croak()> with the message given in the L</DIAGNOSTICS> section. You can check which platforms the module has been tested on at the CPAN testers site: L<http://testers.cpan.org/search?request=dist&dist=Spreadsheet-WriteExcel>.
  
  
  
  
  =head1 DIAGNOSTICS
  
  
  =over 4
  
  =item Filename required by Spreadsheet::WriteExcel->new()
  
  A filename must be given in the constructor.
  
  =item Can't open filename. It may be in use or protected.
  
  The file cannot be opened for writing. The directory that you are writing to  may be protected or the file may be in use by another program.
  
  =item Unable to create tmp files via File::Temp::tempfile()...
  
  This is a C<-w> warning. You will see it if you are using Spreadsheet::WriteExcel in an environment where temporary files cannot be created, in which case all data will be stored in memory. The warning is for information only: it does not affect creation but it will affect the speed of execution for large files. See the C<set_tempdir> workbook method.
  
  
  =item Maximum file size, 7087104, exceeded.
  
  The current OLE implementation only supports a maximum BIFF file of this size. This limit can be extended, see the L</LIMITATIONS> section.
  
  =item Can't locate Parse/RecDescent.pm in @INC ...
  
  Spreadsheet::WriteExcel requires the Parse::RecDescent module. Download it from CPAN: L<http://search.cpan.org/search?dist=Parse-RecDescent>
  
  =item Couldn't parse formula ...
  
  There are a large number of warnings which relate to badly formed formulas and functions. See the L</FORMULAS AND FUNCTIONS IN EXCEL> section for suggestions on how to avoid these errors. You should also check the formula in Excel to ensure that it is valid.
  
  =item Required floating point format not supported on this platform.
  
  Operating system doesn't support 64 bit IEEE float or it is byte-ordered in a way unknown to WriteExcel.
  
  
  =item 'file.xls' cannot be accessed. The file may be read-only ...
  
  You may sometimes encounter the following error when trying to open a file in Excel: "file.xls cannot be accessed. The file may be read-only, or you may be trying to access a read-only location. Or, the server the document is stored on may not be responding."
  
  This error generally means that the Excel file has been corrupted. There are two likely causes of this: the file was FTPed in ASCII mode instead of binary mode or else the file was created with C<UTF-8> data returned by an XML parser. See L</Warning about XML::Parser and perl 5.6> for further details.
  
  =back
  
  
  
  
  =head1 THE EXCEL BINARY FORMAT
  
  The following is some general information about the Excel binary format for anyone who may be interested.
  
  Excel data is stored in the "Binary Interchange File Format" (BIFF) file format. Details of this format are given in "Excel 97-2007 Binary File Format Specification" L<http://www.microsoft.com/interop/docs/OfficeBinaryFormats.mspx>.
  
  Daniel Rentz of OpenOffice.org has also written a detailed description of the Excel workbook records, see L<http://sc.openoffice.org/excelfileformat.pdf>.
  
  Charles Wybble has collected together additional information about the Excel file format. See "The Chicago Project" at L<http://chicago.sourceforge.net/devel/>.
  
  The BIFF data is stored along with other data in an OLE Compound File. This is a structured storage which acts like a file system within a file. A Compound File is comprised of storages and streams which, to follow the file system analogy, are like directories and files.
  
  The OLE format is explained in the "Windows Compound Binary File Format Specification" L<http://www.microsoft.com/interop/docs/supportingtechnologies.mspx>
  
  The Digital Imaging Group have also detailed the OLE format in the JPEG2000 specification: see Appendix A of L<http://www.i3a.org/pdf/wg1n1017.pdf>.
  
  Please note that the provision of this information does not constitute an invitation to start hacking at the BIFF or OLE file formats. There are more interesting ways to waste your time. ;-)
  
  
  
  
  =head1 WRITING EXCEL FILES
  
  Depending on your requirements, background and general sensibilities you may prefer one of the following methods of getting data into Excel:
  
  =over 4
  
  =item * Win32::OLE module and office automation
  
  This requires a Windows platform and an installed copy of Excel. This is the most powerful and complete method for interfacing with Excel. See L<http://www.activestate.com/ASPN/Reference/Products/ActivePerl-5.6/faq/Windows/ActivePerl-Winfaq12.html> and L<http://www.activestate.com/ASPN/Reference/Products/ActivePerl-5.6/site/lib/Win32/OLE.html>. If your main platform is UNIX but you have the resources to set up a separate Win32/MSOffice server, you can convert office documents to text, postscript or PDF using Win32::OLE. For a demonstration of how to do this using Perl see Docserver: L<http://search.cpan.org/search?mode=module&query=docserver>.
  
  =item * CSV, comma separated variables or text
  
  If the file extension is C<csv>, Excel will open and convert this format automatically. Generating a valid CSV file isn't as easy as it seems. Have a look at the DBD::RAM, DBD::CSV, Text::xSV and Text::CSV_XS modules.
  
  =item * DBI with DBD::ADO or DBD::ODBC
  
  Excel files contain an internal index table that allows them to act like a database file. Using one of the standard Perl database modules you can connect to an Excel file as a database.
  
  =item * DBD::Excel
  
  You can also access Spreadsheet::WriteExcel using the standard DBI interface via Takanori Kawai's DBD::Excel module L<http://search.cpan.org/dist/DBD-Excel>
  
  =item * Spreadsheet::WriteExcelXML
  
  This module allows you to create an Excel XML file using the same interface as Spreadsheet::WriteExcel. See: L<http://search.cpan.org/dist/Spreadsheet-WriteExcelXML>
  
  =item * Excel::Template
  
  This module allows you to create an Excel file from an XML template in a manner similar to HTML::Template. See L<http://search.cpan.org/dist/Excel-Template/>.
  
  =item * Spreadsheet::WriteExcel::FromXML
  
  This module allows you to turn a simple XML file into an Excel file using Spreadsheet::WriteExcel as a back-end. The format of the XML file is defined by a supplied DTD: L<http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromXML>.
  
  =item * Spreadsheet::WriteExcel::Simple
  
  This provides an easier interface to Spreadsheet::WriteExcel: L<http://search.cpan.org/dist/Spreadsheet-WriteExcel-Simple>.
  
  =item * Spreadsheet::WriteExcel::FromDB
  
  This is a useful module for creating Excel files directly from a DB table: L<http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromDB>.
  
  =item * HTML tables
  
  This is an easy way of adding formatting via a text based format.
  
  =item * XML or HTML
  
  The Excel XML and HTML file specification are available from L<http://msdn.microsoft.com/library/officedev/ofxml2k/ofxml2k.htm>.
  
  =back
  
  For other Perl-Excel modules try the following search: L<http://search.cpan.org/search?mode=module&query=excel>.
  
  
  
  
  =head1 READING EXCEL FILES
  
  To read data from Excel files try:
  
  =over 4
  
  =item * Spreadsheet::ParseExcel
  
  This uses the OLE::Storage-Lite module to extract data from an Excel file. L<http://search.cpan.org/dist/Spreadsheet-ParseExcel>.
  
  =item * Spreadsheet::ParseExcel_XLHTML
  
  This module uses Spreadsheet::ParseExcel's interface but uses xlHtml (see below) to do the conversion: L<http://search.cpan.org/dist/Spreadsheet-ParseExcel_XLHTML>
  Spreadsheet::ParseExcel_XLHTML
  
  =item * xlHtml
  
  This is an open source "Excel to HTML Converter" C/C++ project at L<http://chicago.sourceforge.net/xlhtml/>.
  
  =item * DBD::Excel (reading)
  
  You can also access Spreadsheet::ParseExcel using the standard DBI interface via  Takanori Kawai's DBD::Excel module L<http://search.cpan.org/dist/DBD-Excel>.
  
  =item * Win32::OLE module and office automation (reading)
  
  See, the section L<WRITING EXCEL FILES>.
  
  =item * HTML tables (reading)
  
  If the files are saved from Excel in a HTML format the data can be accessed using HTML::TableExtract L<http://search.cpan.org/dist/HTML-TableExtract>.
  
  =item * DBI with DBD::ADO or DBD::ODBC.
  
  See, the section L<WRITING EXCEL FILES>.
  
  =item * XML::Excel
  
  Converts Excel files to XML using Spreadsheet::ParseExcel L<http://search.cpan.org/dist/XML-Excel>.
  
  =item * OLE::Storage, aka LAOLA
  
  This is a Perl interface to OLE file formats. In particular, the distro contains an Excel to HTML converter called Herbert, L<http://user.cs.tu-berlin.de/~schwartz/pmh/>. This has been superseded by the Spreadsheet::ParseExcel module.
  
  =back
  
  
  For other Perl-Excel modules try the following search: L<http://search.cpan.org/search?mode=module&query=excel>.
  
  If you wish to view Excel files on a UNIX/Linux platform check out the excellent Gnumeric spreadsheet application at L<http://www.gnome.org/projects/gnumeric/> or OpenOffice.org at L<http://www.openoffice.org/>.
  
  If you wish to view Excel files on a Windows platform which doesn't have Excel installed you can use the free Microsoft Excel Viewer L<http://office.microsoft.com/downloads/2000/xlviewer.aspx>.
  
  
  
  
  =head1 MODIFYING AND REWRITING EXCEL FILES
  
  An Excel file is a binary file within a binary file. It contains several interlinked checksums and changing even one byte can cause it to become corrupted.
  
  As such you cannot simply append or update an Excel file. The only way to achieve this is to read the entire file into memory, make the required changes or additions and then write the file out again.
  
  You can read and rewrite an Excel file using the Spreadsheet::ParseExcel::SaveParser module which is a wrapper around Spreadsheet::ParseExcel and Spreadsheet::WriteExcel. It is part of the Spreadsheet::ParseExcel package: L<http://search.cpan.org/search?dist=Spreadsheet-ParseExcel>.
  
  However, you can only rewrite the features that Spreadsheet::WriteExcel supports so macros, graphs and some other features in the original Excel file will be lost. Also, formulas aren't rewritten, only the result of a formula is written.
  
  Here is an example:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
      use Spreadsheet::ParseExcel::SaveParser;
  
      # Open the template with SaveParser
      my $parser   = new Spreadsheet::ParseExcel::SaveParser;
      my $template = $parser->Parse('template.xls');
  
      my $sheet    = 0;
      my $row      = 0;
      my $col      = 0;
  
      # Get the format from the cell
      my $format   = $template->{Worksheet}[$sheet]
                              ->{Cells}[$row][$col]
                              ->{FormatNo};
  
      # Write data to some cells
      $template->AddCell(0, $row,   $col,   1,     $format);
      $template->AddCell(0, $row+1, $col, "Hello", $format);
  
      # Add a new worksheet
      $template->AddWorksheet('New Data');
  
      # The SaveParser SaveAs() method returns a reference to a
      # Spreadsheet::WriteExcel object. If you wish you can then
      # use this to access any of the methods that aren't
      # available from the SaveParser object. If you don't need
      # to do this just use SaveAs().
      #
      my $workbook;
  
      {
          # SaveAs generates a lot of harmless warnings about unset
          # Worksheet properties. You can ignore them if you wish.
          local $^W = 0;
  
          # Rewrite the file or save as a new file
          $workbook = $template->SaveAs('new.xls');
      }
  
      # Use Spreadsheet::WriteExcel methods
      my $worksheet  = $workbook->sheets(0);
  
      $worksheet->write($row+2, $col, "World2");
  
      $workbook->close();
  
  
  
  
  =head1 Warning about XML::Parser and perl 5.6
  
  You must be careful when using Spreadsheet::WriteExcel in conjunction with perl 5.6 and XML::Parser (and other XML parsers) due to the fact that the data returned by the parser is generally in C<UTF-8> format.
  
  When C<UTF-8> strings are added to Spreadsheet::WriteExcel's internal data it causes the generated Excel file to become corrupt.
  
  Note, this doesn't affect perl 5.005 (which doesn't try to handle C<UTF-8>) or 5.8 (which handles it correctly).
  
  To avoid this problem you should upgrade to perl 5.8, if possible, or else you should convert the output data from XML::Parser to ASCII or ISO-8859-1 using one of the following methods:
  
      $new_str = pack 'C*', unpack 'U*', $utf8_str;
  
  
      use Unicode::MapUTF8 'from_utf8';
      $new_str = from_utf8({-str => $utf8_str, -charset => 'ISO-8859-1'});
  
  
  
  
  =head1 Warning about Office Service Pack 3
  
  If you have Office Service Pack 3 (SP3) installed you may see the following warning when you open a file created by Spreadsheet::WriteExcel:
  
      "File Error: data may have been lost".
  
  This is usually caused by multiple instances of data in a cell.
  
  SP3 changed Excel's default behaviour when it encounters multiple data in a cell so that it issues a warning when the file is opened and it displays the first data that was written. Prior to SP3 it didn't issue a warning and displayed the last data written.
  
  For a longer discussion and some workarounds see the following: L<http://groups.google.com/group/spreadsheet-writeexcel/browse_thread/thread/3dcea40e6620af3a>.
  
  
  
  
  =head1 BUGS
  
  Formulas are formulae.
  
  XML and C<UTF-8> data on perl 5.6 can cause Excel files created by Spreadsheet::WriteExcel to become corrupt. See L</Warning about XML::Parser and perl 5.6> for further details.
  
  The format object that is used with a C<merge_range()> method call is marked internally as being associated with a merged range. It is a fatal error to use a merged format in a non-merged cell. The current workaround is to use separate formats for merged and non-merged cell. This restriction will be removed in a future release.
  
  Nested formulas sometimes aren't parsed correctly and give a result of "#VALUE". If you come across a formula that parses like this, let me know.
  
  Spreadsheet::ParseExcel: All formulas created by Spreadsheet::WriteExcel are read as having a value of zero. This is because Spreadsheet::WriteExcel only stores the formula and not the calculated result.
  
  OpenOffice.org: No known issues in this release.
  
  Gnumeric: No known issues in this release.
  
  If you wish to submit a bug report run the C<bug_report.pl> program in the C<examples> directory of the distro.
  
  
  
  
  =head1 TO DO
  
  Spreadsheet::WriteExcel has been superseded by L<Excel::Writer::XLSX>. All new feature and enhancements will be added to that module.
  
  
  =head1 REPOSITORY
  
  The Spreadsheet::WriteExcel source code in host on github: L<http://github.com/jmcnamara/spreadsheet-writeexcel>.
  
  
  
  
  =head1 MAILING LIST
  
  There is a Google group for discussing and asking questions about Spreadsheet::WriteExcel. This is a good place to search to see if your question has been asked before:  L<http://groups.google.com/group/spreadsheet-writeexcel>.
  
  =begin html
  
  <center>
  <table style="background-color: #fff; padding: 5px;" cellspacing="0">
    <tr><td>
    <img src="http://groups.google.com/intl/en/images/logos/groups_logo_sm.gif"
           height="30" width="140" alt="Google Groups"/>
    </td></tr>
    <tr><td>
    <a href="http://groups.google.com/group/spreadsheet-writeexcel">Spreadsheet::WriteExcel</a>
    </td></tr>
  </table>
  </center>
  
  =end html
  
  
  
  Alternatively you can keep up to date with future releases by subscribing at:
  L<http://freshmeat.net/projects/writeexcel/>.
  
  
  
  
  =head1 DONATIONS
  
  If you'd care to donate to the Spreadsheet::WriteExcel project, you can do so via PayPal: L<http://tinyurl.com/7ayes>.
  
  
  
  
  =head1 SEE ALSO
  
  Spreadsheet::ParseExcel: L<http://search.cpan.org/dist/Spreadsheet-ParseExcel>.
  
  Spreadsheet-WriteExcel-FromXML: L<http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromXML>.
  
  Spreadsheet::WriteExcel::FromDB: L<http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromDB>.
  
  Excel::Template: L<http://search.cpan.org/~rkinyon/Excel-Template/>.
  
  DateTime::Format::Excel: L<http://search.cpan.org/dist/DateTime-Format-Excel>.
  
  "Reading and writing Excel files with Perl" by Teodor Zlatanov, at IBM developerWorks: L<http://www-106.ibm.com/developerworks/library/l-pexcel/>.
  
  "Excel-Dateien mit Perl erstellen - Controller im Gluck" by Peter Dintelmann and Christian Kirsch in the German Unix/web journal iX: L<http://www.heise.de/ix/artikel/2001/06/175/>.
  
  Spreadsheet::WriteExcel documentation in Japanese by Takanori Kawai. L<http://member.nifty.ne.jp/hippo2000/perltips/Spreadsheet/WriteExcel.htm>.
  
  Oesterly user brushes with fame:
  L<http://oesterly.com/releases/12102000.html>.
  
  The csv2xls program that is part of Text::CSV_XS:
  L<http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST>.
  
  
  
  =head1 ACKNOWLEDGMENTS
  
  
  The following people contributed to the debugging and testing of Spreadsheet::WriteExcel:
  
  Alexander Farber, Andre de Bruin, Arthur@ais, Artur Silveira da Cunha, Bob Rose, Borgar Olsen, Brian Foley, Brian White, Bob Mackay, Cedric Bouvier, Chad Johnson, CPAN testers, Damyan Ivanov, Daniel Berger, Daniel Gardner, Dmitry Kochurov, Eric Frazier, Ernesto Baschny, Felipe Perez Galiana, Gordon Simpson, Hanc Pavel, Harold Bamford, James Holmes, James Wilkinson, Johan Ekenberg, Johann Hanne, Jonathan Scott Duff, J.C. Wren, Kenneth Stacey, Keith Miller, Kyle Krom, Marc Rosenthal, Markus Schmitz, Michael Braig, Michael Buschauer, Mike Blazer, Michael Erickson, Michael W J West, Ning Xie, Paul J. Falbe, Paul Medynski, Peter Dintelmann, Pierre Laplante, Praveen Kotha, Reto Badertscher, Rich Sorden, Shane Ashby, Sharron McKenzie, Shenyu Zheng, Stephan Loescher, Steve Sapovits, Sven Passig, Svetoslav Marinov, Tamas Gulacsi, Troy Daniels, Vahe Sarkissian.
  
  The following people contributed patches, examples or Excel information:
  
  Andrew Benham, Bill Young, Cedric Bouvier, Charles Wybble, Daniel Rentz, David Robins, Franco Venturi, Guy Albertelli, Ian Penman, John Heitmann, Jon Guy, Kyle R. Burton, Pierre-Jean Vouette, Rubio, Marco Geri, Mark Fowler, Matisse Enzer, Sam Kington, Takanori Kawai, Tom O'Sullivan.
  
  Many thanks to Ron McKelvey, Ronzo Consulting for Siemens, who sponsored the development of the formula caching routines.
  
  Many thanks to Cassens Transport who sponsored the development of the embedded charts and autofilters.
  
  Additional thanks to Takanori Kawai for translating the documentation into Japanese.
  
  Gunnar Wolf maintains the Debian distro.
  
  Thanks to Damian Conway for the excellent Parse::RecDescent.
  
  Thanks to Tim Jenness for File::Temp.
  
  Thanks to Michael Meeks and Jody Goldberg for their work on Gnumeric.
  
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  Because this software is licensed free of charge, there is no warranty for the software, to the extent permitted by applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the software "as is" without warranty of any kind, either expressed or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and performance of the software is with you. Should the software prove defective, you assume the cost of all necessary servicing, repair, or correction.
  
  In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other party who may modify and/or redistribute the software as permitted by the above licence, be liable to you for damages, including any general, special, incidental, or consequential damages arising out of the use or inability to use the software (including but not limited to loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the software to operate with any other software), even if such holder or other party has been advised of the possibility of such damages.
  
  
  
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
      The ashtray says
      You were up all night.
      When you went to bed
      With your darkest mind.
      Your pillow wept
      And covered your eyes.
      And you finally slept
      While the sun caught fire.
  
      You've changed.
        -- Jeff Tweedy
  
  
  
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXII, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL

$fatpacked{"Spreadsheet/WriteExcel/BIFFwriter.pm"} = <<'SPREADSHEET_WRITEEXCEL_BIFFWRITER';
  package Spreadsheet::WriteExcel::BIFFwriter;
  
  ###############################################################################
  #
  # BIFFwriter - An abstract base class for Excel workbooks and worksheets.
  #
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use Exporter;
  use strict;
  
  
  
  
  
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # Class data.
  #
  my $byte_order   = '';
  my $BIFF_version = 0x0600;
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor
  #
  sub new {
  
      my $class  = $_[0];
  
      my $self   = {
                      _byte_order      => '',
                      _data            => '',
                      _datasize        => 0,
                      _limit           => 8224,
                      _ignore_continue => 0,
                   };
  
      bless $self, $class;
      $self->_set_byte_order();
      return $self;
  }
  
  
  ###############################################################################
  #
  # _set_byte_order()
  #
  # Determine the byte order and store it as class data to avoid
  # recalculating it for each call to new().
  #
  sub _set_byte_order {
  
      my $self    = shift;
  
      if ($byte_order eq ''){
          # Check if "pack" gives the required IEEE 64bit float
          my $teststr = pack "d", 1.2345;
          my @hexdata =(0x8D, 0x97, 0x6E, 0x12, 0x83, 0xC0, 0xF3, 0x3F);
          my $number  = pack "C8", @hexdata;
  
          if ($number eq $teststr) {
              $byte_order = 0;    # Little Endian
          }
          elsif ($number eq reverse($teststr)){
              $byte_order = 1;    # Big Endian
          }
          else {
              # Give up. I'll fix this in a later version.
              croak ( "Required floating point format not supported "  .
                      "on this platform. See the portability section " .
                      "of the documentation."
              );
          }
      }
      $self->{_byte_order} = $byte_order;
  }
  
  
  ###############################################################################
  #
  # _prepend($data)
  #
  # General storage function
  #
  sub _prepend {
  
      my $self    = shift;
      my $data    = join('', @_);
  
      $data = $self->_add_continue($data) if length($data) > $self->{_limit};
  
      $self->{_data}      = $data . $self->{_data};
      $self->{_datasize} += length($data);
  
      return $data;
  }
  
  
  ###############################################################################
  #
  # _append($data)
  #
  # General storage function
  #
  sub _append {
  
      my $self    = shift;
      my $data    = join('', @_);
  
      $data = $self->_add_continue($data) if length($data) > $self->{_limit};
  
      $self->{_data}      = $self->{_data} . $data;
      $self->{_datasize} += length($data);
  
      return $data;
  }
  
  
  ###############################################################################
  #
  # _store_bof($type)
  #
  # $type = 0x0005, Workbook
  # $type = 0x0010, Worksheet
  # $type = 0x0020, Chart
  #
  # Writes Excel BOF record to indicate the beginning of a stream or
  # sub-stream in the BIFF file.
  #
  sub _store_bof {
  
      my $self    = shift;
      my $record  = 0x0809;        # Record identifier
      my $length  = 0x0010;        # Number of bytes to follow
  
      my $version = $BIFF_version;
      my $type    = $_[0];
  
      # According to the SDK $build and $year should be set to zero.
      # However, this throws a warning in Excel 5. So, use these
      # magic numbers.
      my $build   = 0x0DBB;
      my $year    = 0x07CC;
  
      my $bfh     = 0x00000041;
      my $sfo     = 0x00000006;
  
      my $header  = pack("vv",   $record, $length);
      my $data    = pack("vvvvVV", $version, $type, $build, $year, $bfh, $sfo);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_eof()
  #
  # Writes Excel EOF record to indicate the end of a BIFF stream.
  #
  sub _store_eof {
  
      my $self      = shift;
      my $record    = 0x000A; # Record identifier
      my $length    = 0x0000; # Number of bytes to follow
  
      my $header    = pack("vv", $record, $length);
  
      $self->_append($header);
  }
  
  
  ###############################################################################
  #
  # _add_continue()
  #
  # Excel limits the size of BIFF records. In Excel 5 the limit is 2084 bytes. In
  # Excel 97 the limit is 8228 bytes. Records that are longer than these limits
  # must be split up into CONTINUE blocks.
  #
  # This function take a long BIFF record and inserts CONTINUE records as
  # necessary.
  #
  # Some records have their own specialised Continue blocks so there is also an
  # option to bypass this function.
  #
  sub _add_continue {
  
      my $self        = shift;
      my $data        = $_[0];
      my $limit       = $self->{_limit};
      my $record      = 0x003C; # Record identifier
      my $header;
      my $tmp;
  
      # Skip this if another method handles the continue blocks.
      return $data if $self->{_ignore_continue};
  
      # The first 2080/8224 bytes remain intact. However, we have to change
      # the length field of the record.
      #
      $tmp = substr($data, 0, $limit, "");
      substr($tmp, 2, 2, pack("v", $limit-4));
  
      # Strip out chunks of 2080/8224 bytes +4 for the header.
      while (length($data) > $limit) {
          $header  = pack("vv", $record, $limit);
          $tmp    .= $header;
          $tmp    .= substr($data, 0, $limit, "");
      }
  
      # Mop up the last of the data
      $header  = pack("vv", $record, length($data));
      $tmp    .= $header;
      $tmp    .= $data;
  
      return $tmp ;
  }
  
  
  ###############################################################################
  #
  # _add_mso_generic()
  #
  # Create a mso structure that is part of an Escher drawing object. These are
  # are used for images, comments and filters. This generic method is used by
  # other methods to create specific mso records.
  #
  # Returns the packed record.
  #
  sub _add_mso_generic {
  
      my $self        = shift;
      my $type        = $_[0];
      my $version     = $_[1];
      my $instance    = $_[2];
      my $data        = $_[3];
      my $length      = defined $_[4] ? $_[4] : length($data);
  
      # The header contains version and instance info packed into 2 bytes.
      my $header      = $version | ($instance << 4);
  
      my $record      = pack "vvV", $header, $type, $length;
         $record     .= $data;
  
      return $record;
  }
  
  
  ###############################################################################
  #
  # For debugging
  #
  sub _hexout {
  
      my $self = shift;
  
      print +(caller(1))[3], "\n";
  
      my $data = join '', @_;
  
      my @bytes = unpack("H*", $data) =~ /../g;
  
      while (@bytes > 16) {
          print join " ", splice @bytes, 0, 16;
          print "\n";
      }
      print join " ", @bytes, "\n\n";
  }
  
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  BIFFwriter - An abstract base class for Excel workbooks and worksheets.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::WriteExcel
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::WriteExcel.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
   MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL_BIFFWRITER

$fatpacked{"Spreadsheet/WriteExcel/Big.pm"} = <<'SPREADSHEET_WRITEEXCEL_BIG';
  package Spreadsheet::WriteExcel::Big;
  
  ###############################################################################
  #
  # WriteExcel::Big
  #
  # Spreadsheet::WriteExcel - Write formatted text and numbers to a
  # cross-platform Excel binary file.
  #
  # Copyright 2000-2010, John McNamara.
  #
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Workbook;
  
  
  
  
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Workbook Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor. Thin wrapper for a Workbook object.
  #
  # This module is no longer required directly and its use is deprecated. See
  # the Pod documentation below.
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Workbook->new(@_);
  
      # Check for file creation failures before re-blessing
      bless  $self, $class if defined $self;
  
      return $self;
  }
  
  
  1;
  
  
  __END__
  
  
  
  =head1 NAME
  
  
  Big - A class for creating Excel files > 7MB.
  
  
  =head1 SYNOPSIS
  
  Use of this module is deprecated. See below.
  
  
  =head1 DESCRIPTION
  
  The module was a sub-class of Spreadsheet::WriteExcel used for creating Excel files greater than 7MB. However, it is no longer required and is now deprecated.
  
  As of version 2.17 Spreadsheet::WriteExcel can create files larger than 7MB directly if OLE::Storage_Lite is installed.
  
  This module only exists for backwards compatibility. If your programs use ::Big you should convert them to use Spreadsheet::WritExcel directly.
  
  
  =head1 REQUIREMENTS
  
  L<OLE::Storage_Lite>.
  
  
  =head1 AUTHOR
  
  
  John McNamara jmcnamara@cpan.org
  
  
  =head1 COPYRIGHT
  
  
   MM-MMX, John McNamara.
  
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL_BIG

$fatpacked{"Spreadsheet/WriteExcel/Chart.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART';
  package Spreadsheet::WriteExcel::Chart;
  
  ###############################################################################
  #
  # Chart - A writer class for Excel Charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use Exporter;
  use strict;
  use Carp;
  use FileHandle;
  use Spreadsheet::WriteExcel::Worksheet;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Worksheet);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # Formatting information.
  #
  # perltidy with options: -mbl=2 -pt=0 -nola
  #
  # Any camel case Hungarian notation style variable names in the BIFF record
  # writing sub-routines below are for similarity with names used in the Excel
  # documentation. Otherwise lowercase underscore style names are used.
  #
  
  
  ###############################################################################
  #
  # The chart class hierarchy is as follows. Chart.pm acts as a factory for the
  # sub-classes.
  #
  #
  #     Spreadsheet::WriteExcel::BIFFwriter
  #                     ^
  #                     |
  #     Spreadsheet::WriteExcel::Worksheet
  #                     ^
  #                     |
  #     Spreadsheet::WriteExcel::Chart
  #                     ^
  #                     |
  #     Spreadsheet::WriteExcel::Chart::* (sub-types)
  #
  
  
  ###############################################################################
  #
  # factory()
  #
  # Factory method for returning chart objects based on their class type.
  #
  sub factory {
  
      my $current_class  = shift;
      my $chart_subclass = shift;
  
      $chart_subclass = ucfirst lc $chart_subclass;
  
      my $module = "Spreadsheet::WriteExcel::Chart::" . $chart_subclass;
  
      eval "require $module";
  
      # TODO. Need to re-raise this error from Workbook::add_chart().
      die "Chart type '$chart_subclass' not supported in add_chart()\n" if $@;
  
      return $module->new( @_ );
  }
  
  
  ###############################################################################
  #
  # new()
  #
  # Default constructor for sub-classes.
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Worksheet->new( @_ );
  
      $self->{_sheet_type}  = 0x0200;
      $self->{_orientation} = 0x0;
      $self->{_series}      = [];
      $self->{_embedded}    = 0;
  
      bless $self, $class;
      $self->_set_default_properties();
      $self->_set_default_config_data();
      return $self;
  }
  
  
  ###############################################################################
  #
  # Public methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # add_series()
  #
  # Add a series and it's properties to a chart.
  #
  sub add_series {
  
      my $self = shift;
      my %arg  = @_;
  
      croak "Must specify 'values' in add_series()" if !exists $arg{values};
  
      # Parse the ranges to validate them and extract salient information.
      my @value_data    = $self->_parse_series_formula( $arg{values} );
      my @category_data = $self->_parse_series_formula( $arg{categories} );
      my $name_formula  = $self->_parse_series_formula( $arg{name_formula} );
  
      # Default category count to the same as the value count if not defined.
      if ( !defined $category_data[1] ) {
          $category_data[1] = $value_data[1];
      }
  
      # Add the parsed data to the user supplied data.
      %arg = (
          @_,
          _values       => \@value_data,
          _categories   => \@category_data,
          _name_formula => $name_formula
      );
  
      # Encode the Series name.
      my ( $name, $encoding ) =
        $self->_encode_utf16( $arg{name}, $arg{name_encoding} );
  
      $arg{name}          = $name;
      $arg{name_encoding} = $encoding;
  
      push @{ $self->{_series} }, \%arg;
  }
  
  
  ###############################################################################
  #
  # set_x_axis()
  #
  # Set the properties of the X-axis.
  #
  sub set_x_axis {
  
      my $self = shift;
      my %arg  = @_;
  
      my ( $name, $encoding ) =
        $self->_encode_utf16( $arg{name}, $arg{name_encoding} );
  
      my $formula = $self->_parse_series_formula( $arg{name_formula} );
  
      $self->{_x_axis_name}     = $name;
      $self->{_x_axis_encoding} = $encoding;
      $self->{_x_axis_formula}  = $formula;
  }
  
  
  ###############################################################################
  #
  # set_y_axis()
  #
  # Set the properties of the Y-axis.
  #
  sub set_y_axis {
  
      my $self = shift;
      my %arg  = @_;
  
      my ( $name, $encoding ) =
        $self->_encode_utf16( $arg{name}, $arg{name_encoding} );
  
      my $formula = $self->_parse_series_formula( $arg{name_formula} );
  
      $self->{_y_axis_name}     = $name;
      $self->{_y_axis_encoding} = $encoding;
      $self->{_y_axis_formula}  = $formula;
  }
  
  
  ###############################################################################
  #
  # set_title()
  #
  # Set the properties of the chart title.
  #
  sub set_title {
  
      my $self = shift;
      my %arg  = @_;
  
      my ( $name, $encoding ) =
        $self->_encode_utf16( $arg{name}, $arg{name_encoding} );
  
      my $formula = $self->_parse_series_formula( $arg{name_formula} );
  
      $self->{_title_name}     = $name;
      $self->{_title_encoding} = $encoding;
      $self->{_title_formula}  = $formula;
  }
  
  
  ###############################################################################
  #
  # set_legend()
  #
  # Set the properties of the chart legend.
  #
  sub set_legend {
  
      my $self = shift;
      my %arg  = @_;
  
      if ( defined $arg{position} ) {
          if ( lc $arg{position} eq 'none' ) {
              $self->{_legend}->{_visible} = 0;
          }
      }
  }
  
  
  ###############################################################################
  #
  # set_plotarea()
  #
  # Set the properties of the chart plotarea.
  #
  sub set_plotarea {
  
      my $self = shift;
      my %arg  = @_;
      return unless keys %arg;
  
      my $area = $self->{_plotarea};
  
      # Set the plotarea visibility.
      if ( defined $arg{visible} ) {
          $area->{_visible} = $arg{visible};
          return if !$area->{_visible};
      }
  
      # TODO. could move this out of if statement.
      $area->{_bg_color_index} = 0x08;
  
      # Set the chart background colour.
      if ( defined $arg{color} ) {
          my ( $index, $rgb ) = $self->_get_color_indices( $arg{color} );
          if ( defined $index ) {
              $area->{_fg_color_index} = $index;
              $area->{_fg_color_rgb}   = $rgb;
              $area->{_bg_color_index} = 0x08;
              $area->{_bg_color_rgb}   = 0x000000;
          }
      }
  
      # Set the border line colour.
      if ( defined $arg{line_color} ) {
          my ( $index, $rgb ) = $self->_get_color_indices( $arg{line_color} );
          if ( defined $index ) {
              $area->{_line_color_index} = $index;
              $area->{_line_color_rgb}   = $rgb;
          }
      }
  
      # Set the border line pattern.
      if ( defined $arg{line_pattern} ) {
          my $pattern = $self->_get_line_pattern( $arg{line_pattern} );
          $area->{_line_pattern} = $pattern;
      }
  
      # Set the border line weight.
      if ( defined $arg{line_weight} ) {
          my $weight = $self->_get_line_weight( $arg{line_weight} );
          $area->{_line_weight} = $weight;
      }
  }
  
  
  ###############################################################################
  #
  # set_chartarea()
  #
  # Set the properties of the chart chartarea.
  #
  sub set_chartarea {
  
      my $self = shift;
      my %arg  = @_;
      return unless keys %arg;
  
      my $area = $self->{_chartarea};
  
      # Embedded automatic line weight has a different default value.
      $area->{_line_weight} = 0xFFFF if $self->{_embedded};
  
  
      # Set the chart background colour.
      if ( defined $arg{color} ) {
          my ( $index, $rgb ) = $self->_get_color_indices( $arg{color} );
          if ( defined $index ) {
              $area->{_fg_color_index} = $index;
              $area->{_fg_color_rgb}   = $rgb;
              $area->{_bg_color_index} = 0x08;
              $area->{_bg_color_rgb}   = 0x000000;
              $area->{_area_pattern}   = 1;
              $area->{_area_options}   = 0x0000 if $self->{_embedded};
              $area->{_visible}        = 1;
          }
      }
  
      # Set the border line colour.
      if ( defined $arg{line_color} ) {
          my ( $index, $rgb ) = $self->_get_color_indices( $arg{line_color} );
          if ( defined $index ) {
              $area->{_line_color_index} = $index;
              $area->{_line_color_rgb}   = $rgb;
              $area->{_line_pattern}     = 0x00;
              $area->{_line_options}     = 0x0000;
              $area->{_visible}          = 1;
          }
      }
  
      # Set the border line pattern.
      if ( defined $arg{line_pattern} ) {
          my $pattern = $self->_get_line_pattern( $arg{line_pattern} );
          $area->{_line_pattern}     = $pattern;
          $area->{_line_options}     = 0x0000;
          $area->{_line_color_index} = 0x4F if !defined $arg{line_color};
          $area->{_visible}          = 1;
      }
  
      # Set the border line weight.
      if ( defined $arg{line_weight} ) {
          my $weight = $self->_get_line_weight( $arg{line_weight} );
          $area->{_line_weight}      = $weight;
          $area->{_line_options}     = 0x0000;
          $area->{_line_pattern}     = 0x00 if !defined $arg{line_pattern};
          $area->{_line_color_index} = 0x4F if !defined $arg{line_color};
          $area->{_visible}          = 1;
      }
  }
  
  
  ###############################################################################
  #
  # Internal methods. The following section of methods are used for the internal
  # structuring of the Chart object and file format.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _prepend(), overridden.
  #
  # The parent Worksheet class needs to store some data in memory and some in
  # temporary files for efficiency. The Chart* classes don't need to do this
  # since they are dealing with smaller amounts of data so we override
  # _prepend() to turn it into an _append() method. This allows for a more
  # natural method calling order.
  #
  sub _prepend {
  
      my $self = shift;
  
      $self->{_using_tmpfile} = 0;
  
      return $self->_append( @_ );
  }
  
  
  ###############################################################################
  #
  # _close(), overridden.
  #
  # Create and store the Chart data structures.
  #
  sub _close {
  
      my $self = shift;
  
      # Ignore any data that has been written so far since it is probably
      # from unwanted Worksheet method calls.
      $self->{_data} = '';
  
      # TODO. Check for charts without a series?
  
      # Store the chart BOF.
      $self->_store_bof( 0x0020 );
  
      # Store the tab color.
      $self->_store_tab_color();
  
      # Store the page header
      $self->_store_header();
  
      # Store the page footer
      $self->_store_footer();
  
      # Store the page horizontal centering
      $self->_store_hcenter();
  
      # Store the page vertical centering
      $self->_store_vcenter();
  
      # Store the left margin
      $self->_store_margin_left();
  
      # Store the right margin
      $self->_store_margin_right();
  
      # Store the top margin
      $self->_store_margin_top();
  
      # Store the bottom margin
      $self->_store_margin_bottom();
  
      # Store the page setup
      $self->_store_setup();
  
      # Store the sheet password
      $self->_store_password();
  
      # Start of Chart specific records.
  
      # Store the FBI font records.
      $self->_store_fbi( @{ $self->{_config}->{_font_numbers} } );
      $self->_store_fbi( @{ $self->{_config}->{_font_series} } );
      $self->_store_fbi( @{ $self->{_config}->{_font_title} } );
      $self->_store_fbi( @{ $self->{_config}->{_font_axes} } );
  
      # Ignore UNITS record.
  
      # Store the Chart sub-stream.
      $self->_store_chart_stream();
  
      # Append the sheet dimensions
      $self->_store_dimensions();
  
      # TODO add SINDEX and NUMBER records.
  
      if ( !$self->{_embedded} ) {
          $self->_store_window2();
      }
  
      # Store the sheet SCL record.
      if ( !$self->{_embedded} ) {
          $self->_store_zoom();
      }
  
      $self->_store_eof();
  }
  
  
  ###############################################################################
  #
  # _store_window2(), overridden.
  #
  # Write BIFF record Window2. Note, this overrides the parent Worksheet
  # record because the Chart version of the record is smaller and is used
  # mainly to indicate if the chart tab is selected or not.
  #
  sub _store_window2 {
  
      use integer;    # Avoid << shift bug in Perl 5.6.0 on HP-UX
  
      my $self = shift;
  
      my $record  = 0x023E;    # Record identifier
      my $length  = 0x000A;    # Number of bytes to follow
      my $grbit   = 0x0000;    # Option flags
      my $rwTop   = 0x0000;    # Top visible row
      my $colLeft = 0x0000;    # Leftmost visible column
      my $rgbHdr  = 0x0000;    # Row/col heading, grid color
  
      # The options flags that comprise $grbit
      my $fDspFmla       = 0;                     # 0 - bit
      my $fDspGrid       = 0;                     # 1
      my $fDspRwCol      = 0;                     # 2
      my $fFrozen        = 0;                     # 3
      my $fDspZeros      = 0;                     # 4
      my $fDefaultHdr    = 0;                     # 5
      my $fArabic        = 0;                     # 6
      my $fDspGuts       = 0;                     # 7
      my $fFrozenNoSplit = 0;                     # 0 - bit
      my $fSelected      = $self->{_selected};    # 1
      my $fPaged         = 0;                     # 2
      my $fBreakPreview  = 0;                     # 3
  
      #<<< Perltidy ignore this.
      $grbit             = $fDspFmla;
      $grbit            |= $fDspGrid       << 1;
      $grbit            |= $fDspRwCol      << 2;
      $grbit            |= $fFrozen        << 3;
      $grbit            |= $fDspZeros      << 4;
      $grbit            |= $fDefaultHdr    << 5;
      $grbit            |= $fArabic        << 6;
      $grbit            |= $fDspGuts       << 7;
      $grbit            |= $fFrozenNoSplit << 8;
      $grbit            |= $fSelected      << 9;
      $grbit            |= $fPaged         << 10;
      $grbit            |= $fBreakPreview  << 11;
      #>>>
  
      my $header = pack( "vv", $record, $length );
      my $data = pack( "vvvV", $grbit, $rwTop, $colLeft, $rgbHdr );
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _parse_series_formula()
  #
  # Parse the formula used to define a series. We also extract some range
  # information required for _store_series() and the SERIES record.
  #
  sub _parse_series_formula {
  
      my $self = shift;
  
      my $formula  = $_[0];
      my $encoding = 0;
      my $length   = 0;
      my $count    = 0;
      my @tokens;
  
      return '' if !defined $formula;
  
      # Strip the = sign at the beginning of the formula string
      $formula =~ s(^=)();
  
      # Parse the formula using the parser in Formula.pm
      my $parser = $self->{_parser};
  
      # In order to raise formula errors from the point of view of the calling
      # program we use an eval block and re-raise the error from here.
      #
      eval { @tokens = $parser->parse_formula( $formula ) };
  
      if ( $@ ) {
          $@ =~ s/\n$//;    # Strip the \n used in the Formula.pm die().
          croak $@;         # Re-raise the error.
      }
  
      # Force ranges to be a reference class.
      s/_ref3d/_ref3dR/     for @tokens;
      s/_range3d/_range3dR/ for @tokens;
      s/_name/_nameR/       for @tokens;
  
      # Parse the tokens into a formula string.
      $formula = $parser->parse_tokens( @tokens );
  
      # Return formula for a single cell as used by title and series name.
      if ( ord $formula == 0x3A ) {
          return $formula;
      }
  
      # Extract the range from the parse formula.
      if ( ord $formula == 0x3B ) {
          my ( $ptg, $ext_ref, $row_1, $row_2, $col_1, $col_2 ) = unpack 'Cv5',
            $formula;
  
          # TODO. Remove high bit on relative references.
          $count = $row_2 - $row_1 + 1;
      }
  
      return ( $formula, $count );
  }
  
  ###############################################################################
  #
  # _encode_utf16()
  #
  # Convert UTF8 strings used in the chart to UTF16.
  #
  sub _encode_utf16 {
  
      my $self = shift;
  
      my $string = shift;
      my $encoding = shift || 0;
  
      # Exit if the $string isn't defined, i.e., hasn't been set by user.
      return ( undef, undef ) if !defined $string;
  
      # Return if encoding is set, i.e., string has been manually encoded.
      #return ( undef, undef ) if $string == 1;
  
      # Handle utf8 strings in perl 5.8.
      if ( $] >= 5.008 ) {
          require Encode;
  
          if ( Encode::is_utf8( $string ) ) {
              $string = Encode::encode( "UTF-16BE", $string );
              $encoding = 1;
          }
      }
  
      # Chart strings are limited to 255 characters.
      my $limit = $encoding ? 255 * 2 : 255;
  
      if ( length $string >= $limit ) {
  
          # truncate the string and raise a warning.
          $string = substr $string, 0, $limit;
          carp 'Chart strings must be less than 256 characters. '
            . 'String truncated';
      }
  
      return ( $string, $encoding );
  }
  
  
  ###############################################################################
  #
  # _get_color_indices()
  #
  # Convert the user specified colour index or string to an colour index and
  # RGB colour number.
  #
  sub _get_color_indices {
  
      my $self  = shift;
      my $color = shift;
      my $index;
      my $rgb;
  
      return ( undef, undef ) if !defined $color;
  
      my %colors = (
          aqua    => 0x0F,
          cyan    => 0x0F,
          black   => 0x08,
          blue    => 0x0C,
          brown   => 0x10,
          magenta => 0x0E,
          fuchsia => 0x0E,
          gray    => 0x17,
          grey    => 0x17,
          green   => 0x11,
          lime    => 0x0B,
          navy    => 0x12,
          orange  => 0x35,
          pink    => 0x21,
          purple  => 0x14,
          red     => 0x0A,
          silver  => 0x16,
          white   => 0x09,
          yellow  => 0x0D,
      );
  
  
      # Check for the various supported colour index/name possibilities.
      if ( exists $colors{$color} ) {
  
          # Colour matches one of the supported colour names.
          $index = $colors{$color};
      }
      elsif ( $color =~ m/\D/ ) {
  
          # Return undef if $color is a string but not one of the supported ones.
          return ( undef, undef );
      }
      elsif ( $color < 8 || $color > 63 ) {
  
          # Return undef if index is out of range.
          return ( undef, undef );
      }
      else {
  
          # We should have a valid color index in a valid range.
          $index = $color;
      }
  
      $rgb = $self->_get_color_rbg( $index );
      return ( $index, $rgb );
  }
  
  
  ###############################################################################
  #
  # _get_color_rbg()
  #
  # Get the RedGreenBlue number for the colour index from the Workbook palette.
  #
  sub _get_color_rbg {
  
      my $self  = shift;
      my $index = shift;
  
      # Adjust colour index from 8-63 (user range) to 0-55 (Excel range).
      $index -= 8;
  
      my @red_green_blue = @{ $self->{_palette}->[$index] };
      return unpack 'V', pack 'C*', @red_green_blue;
  }
  
  
  ###############################################################################
  #
  # _get_line_pattern()
  #
  # Get the Excel chart index for line pattern that corresponds to the user
  # defined value.
  #
  sub _get_line_pattern {
  
      my $self    = shift;
      my $value   = lc shift;
      my $default = 0;
      my $pattern;
  
      my %patterns = (
          0              => 5,
          1              => 0,
          2              => 1,
          3              => 2,
          4              => 3,
          5              => 4,
          6              => 7,
          7              => 6,
          8              => 8,
          'solid'        => 0,
          'dash'         => 1,
          'dot'          => 2,
          'dash-dot'     => 3,
          'dash-dot-dot' => 4,
          'none'         => 5,
          'dark-gray'    => 6,
          'medium-gray'  => 7,
          'light-gray'   => 8,
      );
  
      if ( exists $patterns{$value} ) {
          $pattern = $patterns{$value};
      }
      else {
          $pattern = $default;
      }
  
      return $pattern;
  }
  
  
  ###############################################################################
  #
  # _get_line_weight()
  #
  # Get the Excel chart index for line weight that corresponds to the user
  # defined value.
  #
  sub _get_line_weight {
  
      my $self    = shift;
      my $value   = lc shift;
      my $default = 0;
      my $weight;
  
      my %weights = (
          1          => -1,
          2          => 0,
          3          => 1,
          4          => 2,
          'hairline' => -1,
          'narrow'   => 0,
          'medium'   => 1,
          'wide'     => 2,
      );
  
      if ( exists $weights{$value} ) {
          $weight = $weights{$value};
      }
      else {
          $weight = $default;
      }
  
      return $weight;
  }
  
  
  ###############################################################################
  #
  # _store_chart_stream()
  #
  # Store the CHART record and it's substreams.
  #
  sub _store_chart_stream {
  
      my $self = shift;
  
      $self->_store_chart( @{ $self->{_config}->{_chart} } );
  
      $self->_store_begin();
  
      # Store the chart SCL record.
      if ( !$self->{_embedded} ) {
          $self->_store_zoom();
      }
  
      $self->_store_plotgrowth();
  
      if ( $self->{_chartarea}->{_visible} ) {
          $self->_store_chartarea_frame_stream();
      }
  
      # Store SERIES stream for each series.
      my $index = 0;
      for my $series ( @{ $self->{_series} } ) {
  
          $self->_store_series_stream(
              _index            => $index,
              _value_formula    => $series->{_values}->[0],
              _value_count      => $series->{_values}->[1],
              _category_count   => $series->{_categories}->[1],
              _category_formula => $series->{_categories}->[0],
              _name             => $series->{name},
              _name_encoding    => $series->{name_encoding},
              _name_formula     => $series->{_name_formula},
          );
  
          $index++;
      }
  
      $self->_store_shtprops();
  
      # Write the TEXT streams.
      for my $font_index ( 5 .. 6 ) {
          $self->_store_defaulttext();
          $self->_store_series_text_stream( $font_index );
      }
  
      $self->_store_axesused( 1 );
      $self->_store_axisparent_stream();
  
      if ( defined $self->{_title_name} || defined $self->{_title_formula} ) {
          $self->_store_title_text_stream();
      }
  
      $self->_store_end();
  
  }
  
  
  ###############################################################################
  #
  # _store_series_stream()
  #
  # Write the SERIES chart substream.
  #
  sub _store_series_stream {
  
      my $self = shift;
      my %arg  = @_;
  
      my $name_type     = $arg{_name_formula}     ? 2 : 1;
      my $value_type    = $arg{_value_formula}    ? 2 : 0;
      my $category_type = $arg{_category_formula} ? 2 : 0;
  
      $self->_store_series( $arg{_value_count}, $arg{_category_count} );
  
      $self->_store_begin();
  
      # Store the Series name AI record.
      $self->_store_ai( 0, $name_type, $arg{_name_formula} );
      if ( defined $arg{_name} ) {
          $self->_store_seriestext( $arg{_name}, $arg{_name_encoding} );
      }
  
      $self->_store_ai( 1, $value_type,    $arg{_value_formula} );
      $self->_store_ai( 2, $category_type, $arg{_category_formula} );
      $self->_store_ai( 3, 1,              '' );
  
      $self->_store_dataformat_stream( $arg{_index}, $arg{_index}, 0xFFFF );
      $self->_store_sertocrt( 0 );
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_dataformat_stream()
  #
  # Write the DATAFORMAT chart substream.
  #
  sub _store_dataformat_stream {
  
      my $self = shift;
  
      my $series_index = shift;
  
      $self->_store_dataformat( $series_index, $series_index, 0xFFFF );
  
      $self->_store_begin();
      $self->_store_3dbarshape();
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_series_text_stream()
  #
  # Write the series TEXT substream.
  #
  sub _store_series_text_stream {
  
      my $self = shift;
  
      my $font_index = shift;
  
      $self->_store_text( @{ $self->{_config}->{_series_text} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_series_text_pos} } );
      $self->_store_fontx( $font_index );
      $self->_store_ai( 0, 1, '' );
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_x_axis_text_stream()
  #
  # Write the X-axis TEXT substream.
  #
  sub _store_x_axis_text_stream {
  
      my $self = shift;
  
      my $formula = $self->{_x_axis_formula};
      my $ai_type = $formula ? 2 : 1;
  
      $self->_store_text( @{ $self->{_config}->{_x_axis_text} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_x_axis_text_pos} } );
      $self->_store_fontx( 8 );
      $self->_store_ai( 0, $ai_type, $formula );
  
      if ( defined $self->{_x_axis_name} ) {
          $self->_store_seriestext( $self->{_x_axis_name},
              $self->{_x_axis_encoding},
          );
      }
  
      $self->_store_objectlink( 3 );
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_y_axis_text_stream()
  #
  # Write the Y-axis TEXT substream.
  #
  sub _store_y_axis_text_stream {
  
      my $self = shift;
  
      my $formula = $self->{_y_axis_formula};
      my $ai_type = $formula ? 2 : 1;
  
      $self->_store_text( @{ $self->{_config}->{_y_axis_text} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_y_axis_text_pos} } );
      $self->_store_fontx( 8 );
      $self->_store_ai( 0, $ai_type, $formula );
  
      if ( defined $self->{_y_axis_name} ) {
          $self->_store_seriestext( $self->{_y_axis_name},
              $self->{_y_axis_encoding},
          );
      }
  
      $self->_store_objectlink( 2 );
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_legend_text_stream()
  #
  # Write the legend TEXT substream.
  #
  sub _store_legend_text_stream {
  
      my $self = shift;
  
      $self->_store_text( @{ $self->{_config}->{_legend_text} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_legend_text_pos} } );
      $self->_store_ai( 0, 1, '' );
  
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_title_text_stream()
  #
  # Write the title TEXT substream.
  #
  sub _store_title_text_stream {
  
      my $self = shift;
  
      my $formula = $self->{_title_formula};
      my $ai_type = $formula ? 2 : 1;
  
      $self->_store_text( @{ $self->{_config}->{_title_text} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_title_text_pos} } );
      $self->_store_fontx( 7 );
      $self->_store_ai( 0, $ai_type, $formula );
  
      if ( defined $self->{_title_name} ) {
          $self->_store_seriestext( $self->{_title_name},
              $self->{_title_encoding},
          );
      }
  
      $self->_store_objectlink( 1 );
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_axisparent_stream()
  #
  # Write the AXISPARENT chart substream.
  #
  sub _store_axisparent_stream {
  
      my $self = shift;
  
      $self->_store_axisparent( @{ $self->{_config}->{_axisparent} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_axisparent_pos} } );
      $self->_store_axis_category_stream();
      $self->_store_axis_values_stream();
  
      if ( defined $self->{_x_axis_name} || defined $self->{_x_axis_formula} ) {
          $self->_store_x_axis_text_stream();
      }
  
      if ( defined $self->{_y_axis_name} || defined $self->{_y_axis_formula} ) {
          $self->_store_y_axis_text_stream();
      }
  
      if ( $self->{_plotarea}->{_visible} ) {
          $self->_store_plotarea();
          $self->_store_plotarea_frame_stream();
      }
  
      $self->_store_chartformat_stream();
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_axis_category_stream()
  #
  # Write the AXIS chart substream for the chart category.
  #
  sub _store_axis_category_stream {
  
      my $self = shift;
  
      $self->_store_axis( 0 );
  
      $self->_store_begin();
      $self->_store_catserrange();
      $self->_store_axcext();
      $self->_store_tick();
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_axis_values_stream()
  #
  # Write the AXIS chart substream for the chart values.
  #
  sub _store_axis_values_stream {
  
      my $self = shift;
  
      $self->_store_axis( 1 );
  
      $self->_store_begin();
      $self->_store_valuerange();
      $self->_store_tick();
      $self->_store_axislineformat();
      $self->_store_lineformat( 0x00000000, 0x0000, 0xFFFF, 0x0009, 0x004D );
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_plotarea_frame_stream()
  #
  # Write the FRAME chart substream for the plotarea.
  #
  sub _store_plotarea_frame_stream {
  
      my $self = shift;
  
      my $area = $self->{_plotarea};
  
      $self->_store_frame( 0x00, 0x03 );
      $self->_store_begin();
  
      $self->_store_lineformat(
          $area->{_line_color_rgb}, $area->{_line_pattern},
          $area->{_line_weight},    $area->{_line_options},
          $area->{_line_color_index}
      );
  
      $self->_store_areaformat(
          $area->{_fg_color_rgb},   $area->{_bg_color_rgb},
          $area->{_area_pattern},   $area->{_area_options},
          $area->{_fg_color_index}, $area->{_bg_color_index}
      );
  
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_chartarea_frame_stream()
  #
  # Write the FRAME chart substream for the chartarea.
  #
  sub _store_chartarea_frame_stream {
  
      my $self = shift;
  
      my $area = $self->{_chartarea};
  
      $self->_store_frame( 0x00, 0x02 );
      $self->_store_begin();
  
      $self->_store_lineformat(
          $area->{_line_color_rgb}, $area->{_line_pattern},
          $area->{_line_weight},    $area->{_line_options},
          $area->{_line_color_index}
      );
  
      $self->_store_areaformat(
          $area->{_fg_color_rgb},   $area->{_bg_color_rgb},
          $area->{_area_pattern},   $area->{_area_options},
          $area->{_fg_color_index}, $area->{_bg_color_index}
      );
  
      $self->_store_end();
  }
  
  ###############################################################################
  #
  # _store_chartformat_stream()
  #
  # Write the CHARTFORMAT chart substream.
  #
  sub _store_chartformat_stream {
  
      my $self = shift;
  
      # The _vary_data_color is set by classes that need it, like Pie.
      $self->_store_chartformat( $self->{_vary_data_color} );
  
      $self->_store_begin();
  
      # Store the BIFF record that will define the chart type.
      $self->_store_chart_type();
  
      # Note, the CHARTFORMATLINK record is only written by Excel.
  
      if ( $self->{_legend}->{_visible} ) {
          $self->_store_legend_stream();
      }
  
      $self->_store_marker_dataformat_stream();
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # This is an abstract method that is overridden by the sub-classes to define
  # the chart types such as Column, Line, Pie, etc.
  #
  sub _store_chart_type {
  
  }
  
  
  ###############################################################################
  #
  # _store_marker_dataformat_stream()
  #
  # This is an abstract method that is overridden by the sub-classes to define
  # properties of markers, linetypes, pie formats and other.
  #
  sub _store_marker_dataformat_stream {
  
  }
  
  
  ###############################################################################
  #
  # _store_legend_stream()
  #
  # Write the LEGEND chart substream.
  #
  sub _store_legend_stream {
  
      my $self = shift;
  
      $self->_store_legend( @{ $self->{_config}->{_legend} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_legend_pos} } );
      $self->_store_legend_text_stream();
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # BIFF Records.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _store_3dbarshape()
  #
  # Write the 3DBARSHAPE chart BIFF record.
  #
  sub _store_3dbarshape {
  
      my $self = shift;
  
      my $record = 0x105F;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $riser  = 0x00;      # Shape of base.
      my $taper  = 0x00;      # Column taper type.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'C', $riser;
      $data .= pack 'C', $taper;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_ai()
  #
  # Write the AI chart BIFF record.
  #
  sub _store_ai {
  
      my $self = shift;
  
      my $record       = 0x1051;        # Record identifier.
      my $length       = 0x0008;        # Number of bytes to follow.
      my $id           = $_[0];         # Link index.
      my $type         = $_[1];         # Reference type.
      my $formula      = $_[2];         # Pre-parsed formula.
      my $format_index = $_[3] || 0;    # Num format index.
      my $grbit        = 0x0000;        # Option flags.
  
      my $formula_length = length $formula;
  
      $length += $formula_length;
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'C', $id;
      $data .= pack 'C', $type;
      $data .= pack 'v', $grbit;
      $data .= pack 'v', $format_index;
      $data .= pack 'v', $formula_length;
      $data .= $formula;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_areaformat()
  #
  # Write the AREAFORMAT chart BIFF record. Contains the patterns and colours
  # of a chart area.
  #
  sub _store_areaformat {
  
      my $self = shift;
  
      my $record    = 0x100A;    # Record identifier.
      my $length    = 0x0010;    # Number of bytes to follow.
      my $rgbFore   = $_[0];     # Foreground RGB colour.
      my $rgbBack   = $_[1];     # Background RGB colour.
      my $pattern   = $_[2];     # Pattern.
      my $grbit     = $_[3];     # Option flags.
      my $indexFore = $_[4];     # Index to Foreground colour.
      my $indexBack = $_[5];     # Index to Background colour.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'V', $rgbFore;
      $data .= pack 'V', $rgbBack;
      $data .= pack 'v', $pattern;
      $data .= pack 'v', $grbit;
      $data .= pack 'v', $indexFore;
      $data .= pack 'v', $indexBack;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_axcext()
  #
  # Write the AXCEXT chart BIFF record.
  #
  sub _store_axcext {
  
      my $self = shift;
  
      my $record       = 0x1062;    # Record identifier.
      my $length       = 0x0012;    # Number of bytes to follow.
      my $catMin       = 0x0000;    # Minimum category on axis.
      my $catMax       = 0x0000;    # Maximum category on axis.
      my $catMajor     = 0x0001;    # Value of major unit.
      my $unitMajor    = 0x0000;    # Units of major unit.
      my $catMinor     = 0x0001;    # Value of minor unit.
      my $unitMinor    = 0x0000;    # Units of minor unit.
      my $unitBase     = 0x0000;    # Base unit of axis.
      my $catCrossDate = 0x0000;    # Crossing point.
      my $grbit        = 0x00EF;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $catMin;
      $data .= pack 'v', $catMax;
      $data .= pack 'v', $catMajor;
      $data .= pack 'v', $unitMajor;
      $data .= pack 'v', $catMinor;
      $data .= pack 'v', $unitMinor;
      $data .= pack 'v', $unitBase;
      $data .= pack 'v', $catCrossDate;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_axesused()
  #
  # Write the AXESUSED chart BIFF record.
  #
  sub _store_axesused {
  
      my $self = shift;
  
      my $record   = 0x1046;    # Record identifier.
      my $length   = 0x0002;    # Number of bytes to follow.
      my $num_axes = $_[0];     # Number of axes used.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $num_axes;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_axis()
  #
  # Write the AXIS chart BIFF record to define the axis type.
  #
  sub _store_axis {
  
      my $self = shift;
  
      my $record    = 0x101D;        # Record identifier.
      my $length    = 0x0012;        # Number of bytes to follow.
      my $type      = $_[0];         # Axis type.
      my $reserved1 = 0x00000000;    # Reserved.
      my $reserved2 = 0x00000000;    # Reserved.
      my $reserved3 = 0x00000000;    # Reserved.
      my $reserved4 = 0x00000000;    # Reserved.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $type;
      $data .= pack 'V', $reserved1;
      $data .= pack 'V', $reserved2;
      $data .= pack 'V', $reserved3;
      $data .= pack 'V', $reserved4;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_axislineformat()
  #
  # Write the AXISLINEFORMAT chart BIFF record.
  #
  sub _store_axislineformat {
  
      my $self = shift;
  
      my $record      = 0x1021;    # Record identifier.
      my $length      = 0x0002;    # Number of bytes to follow.
      my $line_format = 0x0001;    # Axis line format.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $line_format;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_axisparent()
  #
  # Write the AXISPARENT chart BIFF record.
  #
  sub _store_axisparent {
  
      my $self = shift;
  
      my $record = 0x1041;    # Record identifier.
      my $length = 0x0012;    # Number of bytes to follow.
      my $iax    = $_[0];     # Axis index.
      my $x      = $_[1];     # X-coord.
      my $y      = $_[2];     # Y-coord.
      my $dx     = $_[3];     # Length of x axis.
      my $dy     = $_[4];     # Length of y axis.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $iax;
      $data .= pack 'V', $x;
      $data .= pack 'V', $y;
      $data .= pack 'V', $dx;
      $data .= pack 'V', $dy;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_begin()
  #
  # Write the BEGIN chart BIFF record to indicate the start of a sub stream.
  #
  sub _store_begin {
  
      my $self = shift;
  
      my $record = 0x1033;    # Record identifier.
      my $length = 0x0000;    # Number of bytes to follow.
  
      my $header = pack 'vv', $record, $length;
  
      $self->_append( $header );
  }
  
  
  ###############################################################################
  #
  # _store_catserrange()
  #
  # Write the CATSERRANGE chart BIFF record.
  #
  sub _store_catserrange {
  
      my $self = shift;
  
      my $record   = 0x1020;    # Record identifier.
      my $length   = 0x0008;    # Number of bytes to follow.
      my $catCross = 0x0001;    # Value/category crossing.
      my $catLabel = 0x0001;    # Frequency of labels.
      my $catMark  = 0x0001;    # Frequency of ticks.
      my $grbit    = 0x0001;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $catCross;
      $data .= pack 'v', $catLabel;
      $data .= pack 'v', $catMark;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_chart()
  #
  # Write the CHART BIFF record. This indicates the start of the chart sub-stream
  # and contains dimensions of the chart on the display. Units are in 1/72 inch
  # and are 2 byte integer with 2 byte fraction.
  #
  sub _store_chart {
  
      my $self = shift;
  
      my $record = 0x1002;    # Record identifier.
      my $length = 0x0010;    # Number of bytes to follow.
      my $x_pos  = $_[0];     # X pos of top left corner.
      my $y_pos  = $_[1];     # Y pos of top left corner.
      my $dx     = $_[2];     # X size.
      my $dy     = $_[3];     # Y size.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'V', $x_pos;
      $data .= pack 'V', $y_pos;
      $data .= pack 'V', $dx;
      $data .= pack 'V', $dy;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_chartformat()
  #
  # Write the CHARTFORMAT chart BIFF record. The parent record for formatting
  # of a chart group.
  #
  sub _store_chartformat {
  
      my $self = shift;
  
      my $record    = 0x1014;        # Record identifier.
      my $length    = 0x0014;        # Number of bytes to follow.
      my $reserved1 = 0x00000000;    # Reserved.
      my $reserved2 = 0x00000000;    # Reserved.
      my $reserved3 = 0x00000000;    # Reserved.
      my $reserved4 = 0x00000000;    # Reserved.
      my $grbit     = $_[0] || 0;    # Option flags.
      my $icrt      = 0x0000;        # Drawing order.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'V', $reserved1;
      $data .= pack 'V', $reserved2;
      $data .= pack 'V', $reserved3;
      $data .= pack 'V', $reserved4;
      $data .= pack 'v', $grbit;
      $data .= pack 'v', $icrt;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_chartline()
  #
  # Write the CHARTLINE chart BIFF record.
  #
  sub _store_chartline {
  
      my $self = shift;
  
      my $record = 0x101C;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $type   = 0x0001;    # Drop/hi-lo line type.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $type;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_charttext()
  #
  # Write the TEXT chart BIFF record.
  #
  sub _store_charttext {
  
      my $self = shift;
  
      my $record           = 0x1025;        # Record identifier.
      my $length           = 0x0020;        # Number of bytes to follow.
      my $horz_align       = 0x02;          # Horizontal alignment.
      my $vert_align       = 0x02;          # Vertical alignment.
      my $bg_mode          = 0x0001;        # Background display.
      my $text_color_rgb   = 0x00000000;    # Text RGB colour.
      my $text_x           = 0xFFFFFF46;    # Text x-pos.
      my $text_y           = 0xFFFFFF06;    # Text y-pos.
      my $text_dx          = 0x00000000;    # Width.
      my $text_dy          = 0x00000000;    # Height.
      my $grbit1           = 0x00B1;        # Options
      my $text_color_index = 0x004D;        # Auto Colour.
      my $grbit2           = 0x0000;        # Data label placement.
      my $rotation         = 0x0000;        # Text rotation.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'C', $horz_align;
      $data .= pack 'C', $vert_align;
      $data .= pack 'v', $bg_mode;
      $data .= pack 'V', $text_color_rgb;
      $data .= pack 'V', $text_x;
      $data .= pack 'V', $text_y;
      $data .= pack 'V', $text_dx;
      $data .= pack 'V', $text_dy;
      $data .= pack 'v', $grbit1;
      $data .= pack 'v', $text_color_index;
      $data .= pack 'v', $grbit2;
      $data .= pack 'v', $rotation;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_dataformat()
  #
  # Write the DATAFORMAT chart BIFF record. This record specifies the series
  # that the subsequent sub stream refers to.
  #
  sub _store_dataformat {
  
      my $self = shift;
  
      my $record        = 0x1006;    # Record identifier.
      my $length        = 0x0008;    # Number of bytes to follow.
      my $series_index  = $_[0];     # Series index.
      my $series_number = $_[1];     # Series number. (Same as index).
      my $point_number  = $_[2];     # Point number.
      my $grbit         = 0x0000;    # Format flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $point_number;
      $data .= pack 'v', $series_index;
      $data .= pack 'v', $series_number;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_defaulttext()
  #
  # Write the DEFAULTTEXT chart BIFF record. Identifier for subsequent TEXT
  # record.
  #
  sub _store_defaulttext {
  
      my $self = shift;
  
      my $record = 0x1024;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $type   = 0x0002;    # Type.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $type;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_dropbar()
  #
  # Write the DROPBAR chart BIFF record.
  #
  sub _store_dropbar {
  
      my $self = shift;
  
      my $record      = 0x103D;    # Record identifier.
      my $length      = 0x0002;    # Number of bytes to follow.
      my $percent_gap = 0x0096;    # Drop bar width gap (%).
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $percent_gap;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_end()
  #
  # Write the END chart BIFF record to indicate the end of a sub stream.
  #
  sub _store_end {
  
      my $self = shift;
  
      my $record = 0x1034;    # Record identifier.
      my $length = 0x0000;    # Number of bytes to follow.
  
      my $header = pack 'vv', $record, $length;
  
      $self->_append( $header );
  }
  
  
  ###############################################################################
  #
  # _store_fbi()
  #
  # Write the FBI chart BIFF record. Specifies the font information at the time
  # it was applied to the chart.
  #
  sub _store_fbi {
  
      my $self = shift;
  
      my $record       = 0x1060;        # Record identifier.
      my $length       = 0x000A;        # Number of bytes to follow.
      my $index        = $_[0];         # Font index.
      my $height       = $_[1] * 20;    # Default font height in twips.
      my $width_basis  = $_[2];         # Width basis, in twips.
      my $height_basis = $_[3];         # Height basis, in twips.
      my $scale_basis  = $_[4];         # Scale by chart area or plot area.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $width_basis;
      $data .= pack 'v', $height_basis;
      $data .= pack 'v', $height;
      $data .= pack 'v', $scale_basis;
      $data .= pack 'v', $index;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_fontx()
  #
  # Write the FONTX chart BIFF record which contains the index of the FONT
  # record in the Workbook.
  #
  sub _store_fontx {
  
      my $self = shift;
  
      my $record = 0x1026;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $index  = $_[0];     # Font index.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $index;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_frame()
  #
  # Write the FRAME chart BIFF record.
  #
  sub _store_frame {
  
      my $self = shift;
  
      my $record     = 0x1032;    # Record identifier.
      my $length     = 0x0004;    # Number of bytes to follow.
      my $frame_type = $_[0];     # Frame type.
      my $grbit      = $_[1];     # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $frame_type;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_legend()
  #
  # Write the LEGEND chart BIFF record. The Marcus Horan method.
  #
  sub _store_legend {
  
      my $self = shift;
  
      my $record   = 0x1015;    # Record identifier.
      my $length   = 0x0014;    # Number of bytes to follow.
      my $x        = $_[0];     # X-position.
      my $y        = $_[1];     # Y-position.
      my $width    = $_[2];     # Width.
      my $height   = $_[3];     # Height.
      my $wType    = $_[4];     # Type.
      my $wSpacing = $_[5];     # Spacing.
      my $grbit    = $_[6];     # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'V', $x;
      $data .= pack 'V', $y;
      $data .= pack 'V', $width;
      $data .= pack 'V', $height;
      $data .= pack 'C', $wType;
      $data .= pack 'C', $wSpacing;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_lineformat()
  #
  # Write the LINEFORMAT chart BIFF record.
  #
  sub _store_lineformat {
  
      my $self = shift;
  
      my $record = 0x1007;    # Record identifier.
      my $length = 0x000C;    # Number of bytes to follow.
      my $rgb    = $_[0];     # Line RGB colour.
      my $lns    = $_[1];     # Line pattern.
      my $we     = $_[2];     # Line weight.
      my $grbit  = $_[3];     # Option flags.
      my $index  = $_[4];     # Index to colour of line.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'V', $rgb;
      $data .= pack 'v', $lns;
      $data .= pack 'v', $we;
      $data .= pack 'v', $grbit;
      $data .= pack 'v', $index;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_markerformat()
  #
  # Write the MARKERFORMAT chart BIFF record.
  #
  sub _store_markerformat {
  
      my $self = shift;
  
      my $record  = 0x1009;    # Record identifier.
      my $length  = 0x0014;    # Number of bytes to follow.
      my $rgbFore = $_[0];     # Foreground RGB color.
      my $rgbBack = $_[1];     # Background RGB color.
      my $marker  = $_[2];     # Type of marker.
      my $grbit   = $_[3];     # Format flags.
      my $icvFore = $_[4];     # Color index marker border.
      my $icvBack = $_[5];     # Color index marker fill.
      my $miSize  = $_[6];     # Size of line markers.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'V', $rgbFore;
      $data .= pack 'V', $rgbBack;
      $data .= pack 'v', $marker;
      $data .= pack 'v', $grbit;
      $data .= pack 'v', $icvFore;
      $data .= pack 'v', $icvBack;
      $data .= pack 'V', $miSize;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_objectlink()
  #
  # Write the OBJECTLINK chart BIFF record.
  #
  sub _store_objectlink {
  
      my $self = shift;
  
      my $record      = 0x1027;    # Record identifier.
      my $length      = 0x0006;    # Number of bytes to follow.
      my $link_type   = $_[0];     # Object text link type.
      my $link_index1 = 0x0000;    # Link index 1.
      my $link_index2 = 0x0000;    # Link index 2.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $link_type;
      $data .= pack 'v', $link_index1;
      $data .= pack 'v', $link_index2;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_pieformat()
  #
  # Write the PIEFORMAT chart BIFF record.
  #
  sub _store_pieformat {
  
      my $self = shift;
  
      my $record  = 0x100B;    # Record identifier.
      my $length  = 0x0002;    # Number of bytes to follow.
      my $percent = 0x0000;    # Distance % from center.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $percent;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_plotarea()
  #
  # Write the PLOTAREA chart BIFF record. This indicates that the subsequent
  # FRAME record belongs to a plot area.
  #
  sub _store_plotarea {
  
      my $self = shift;
  
      my $record = 0x1035;    # Record identifier.
      my $length = 0x0000;    # Number of bytes to follow.
  
      my $header = pack 'vv', $record, $length;
  
      $self->_append( $header );
  }
  
  
  ###############################################################################
  #
  # _store_plotgrowth()
  #
  # Write the PLOTGROWTH chart BIFF record.
  #
  sub _store_plotgrowth {
  
      my $self = shift;
  
      my $record  = 0x1064;        # Record identifier.
      my $length  = 0x0008;        # Number of bytes to follow.
      my $dx_plot = 0x00010000;    # Horz growth for font scale.
      my $dy_plot = 0x00010000;    # Vert growth for font scale.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'V', $dx_plot;
      $data .= pack 'V', $dy_plot;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_pos()
  #
  # Write the POS chart BIFF record. Generally not required when using
  # automatic positioning.
  #
  sub _store_pos {
  
      my $self = shift;
  
      my $record  = 0x104F;    # Record identifier.
      my $length  = 0x0014;    # Number of bytes to follow.
      my $mdTopLt = $_[0];     # Top left.
      my $mdBotRt = $_[1];     # Bottom right.
      my $x1      = $_[2];     # X coordinate.
      my $y1      = $_[3];     # Y coordinate.
      my $x2      = $_[4];     # Width.
      my $y2      = $_[5];     # Height.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $mdTopLt;
      $data .= pack 'v', $mdBotRt;
      $data .= pack 'V', $x1;
      $data .= pack 'V', $y1;
      $data .= pack 'V', $x2;
      $data .= pack 'V', $y2;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_serauxtrend()
  #
  # Write the SERAUXTREND chart BIFF record.
  #
  sub _store_serauxtrend {
  
      my $self = shift;
  
      my $record     = 0x104B;    # Record identifier.
      my $length     = 0x001C;    # Number of bytes to follow.
      my $reg_type   = $_[0];     # Regression type.
      my $poly_order = $_[1];     # Polynomial order.
      my $equation   = $_[2];     # Display equation.
      my $r_squared  = $_[3];     # Display R-squared.
      my $intercept;              # Forced intercept.
      my $forecast;               # Forecast forward.
      my $backcast;               # Forecast backward.
  
      # TODO. When supported, intercept needs to be NAN if not used.
      # Also need to reverse doubles.
      $intercept = pack 'H*', 'FFFFFFFF0001FFFF';
      $forecast  = pack 'H*', '0000000000000000';
      $backcast  = pack 'H*', '0000000000000000';
  
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'C', $reg_type;
      $data .= pack 'C', $poly_order;
      $data .= $intercept;
      $data .= pack 'C', $equation;
      $data .= pack 'C', $r_squared;
      $data .= $forecast;
      $data .= $backcast;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_series()
  #
  # Write the SERIES chart BIFF record.
  #
  sub _store_series {
  
      my $self = shift;
  
      my $record         = 0x1003;    # Record identifier.
      my $length         = 0x000C;    # Number of bytes to follow.
      my $category_type  = 0x0001;    # Type: category.
      my $value_type     = 0x0001;    # Type: value.
      my $category_count = $_[0];     # Num of categories.
      my $value_count    = $_[1];     # Num of values.
      my $bubble_type    = 0x0001;    # Type: bubble.
      my $bubble_count   = 0x0000;    # Num of bubble values.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $category_type;
      $data .= pack 'v', $value_type;
      $data .= pack 'v', $category_count;
      $data .= pack 'v', $value_count;
      $data .= pack 'v', $bubble_type;
      $data .= pack 'v', $bubble_count;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_seriestext()
  #
  # Write the SERIESTEXT chart BIFF record.
  #
  sub _store_seriestext {
  
      my $self = shift;
  
      my $record   = 0x100D;         # Record identifier.
      my $length   = 0x0000;         # Number of bytes to follow.
      my $id       = 0x0000;         # Text id.
      my $str      = $_[0];          # Text.
      my $encoding = $_[1];          # String encoding.
      my $cch      = length $str;    # String length.
  
      # Character length is num of chars not num of bytes
      $cch /= 2 if $encoding;
  
      # Change the UTF-16 name from BE to LE
      $str = pack 'n*', unpack 'v*', $str if $encoding;
  
      $length = 4 + length( $str );
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $id;
      $data .= pack 'C', $cch;
      $data .= pack 'C', $encoding;
  
      $self->_append( $header, $data, $str );
  }
  
  
  ###############################################################################
  #
  # _store_serparent()
  #
  # Write the SERPARENT chart BIFF record.
  #
  sub _store_serparent {
  
      my $self = shift;
  
      my $record = 0x104A;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $series = $_[0];     # Series parent.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $series;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_sertocrt()
  #
  # Write the SERTOCRT chart BIFF record to indicate the chart group index.
  #
  sub _store_sertocrt {
  
      my $self = shift;
  
      my $record     = 0x1045;    # Record identifier.
      my $length     = 0x0002;    # Number of bytes to follow.
      my $chartgroup = 0x0000;    # Chart group index.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $chartgroup;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_shtprops()
  #
  # Write the SHTPROPS chart BIFF record.
  #
  sub _store_shtprops {
  
      my $self = shift;
  
      my $record      = 0x1044;    # Record identifier.
      my $length      = 0x0004;    # Number of bytes to follow.
      my $grbit       = 0x000E;    # Option flags.
      my $empty_cells = 0x0000;    # Empty cell handling.
  
      $grbit = 0x000A if $self->{_embedded};
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $grbit;
      $data .= pack 'v', $empty_cells;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_text()
  #
  # Write the TEXT chart BIFF record.
  #
  sub _store_text {
  
      my $self = shift;
  
      my $record   = 0x1025;           # Record identifier.
      my $length   = 0x0020;           # Number of bytes to follow.
      my $at       = 0x02;             # Horizontal alignment.
      my $vat      = 0x02;             # Vertical alignment.
      my $wBkgMode = 0x0001;           # Background display.
      my $rgbText  = 0x0000;           # Text RGB colour.
      my $x        = $_[0];            # Text x-pos.
      my $y        = $_[1];            # Text y-pos.
      my $dx       = $_[2];            # Width.
      my $dy       = $_[3];            # Height.
      my $grbit1   = $_[4];            # Option flags.
      my $icvText  = 0x004D;           # Auto Colour.
      my $grbit2   = $_[5];            # Show legend.
      my $rotation = $_[6] || 0x00;    # Show value.
  
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'C', $at;
      $data .= pack 'C', $vat;
      $data .= pack 'v', $wBkgMode;
      $data .= pack 'V', $rgbText;
      $data .= pack 'V', $x;
      $data .= pack 'V', $y;
      $data .= pack 'V', $dx;
      $data .= pack 'V', $dy;
      $data .= pack 'v', $grbit1;
      $data .= pack 'v', $icvText;
      $data .= pack 'v', $grbit2;
      $data .= pack 'v', $rotation;
  
      $self->_append( $header, $data );
  }
  
  ###############################################################################
  #
  # _store_tick()
  #
  # Write the TICK chart BIFF record.
  #
  sub _store_tick {
  
      my $self = shift;
  
      my $record    = 0x101E;        # Record identifier.
      my $length    = 0x001E;        # Number of bytes to follow.
      my $tktMajor  = 0x02;          # Type of major tick mark.
      my $tktMinor  = 0x00;          # Type of minor tick mark.
      my $tlt       = 0x03;          # Tick label position.
      my $wBkgMode  = 0x01;          # Background mode.
      my $rgb       = 0x00000000;    # Tick-label RGB colour.
      my $reserved1 = 0x00000000;    # Reserved.
      my $reserved2 = 0x00000000;    # Reserved.
      my $reserved3 = 0x00000000;    # Reserved.
      my $reserved4 = 0x00000000;    # Reserved.
      my $grbit     = 0x0023;        # Option flags.
      my $index     = 0x004D;        # Colour index.
      my $reserved5 = 0x0000;        # Reserved.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'C', $tktMajor;
      $data .= pack 'C', $tktMinor;
      $data .= pack 'C', $tlt;
      $data .= pack 'C', $wBkgMode;
      $data .= pack 'V', $rgb;
      $data .= pack 'V', $reserved1;
      $data .= pack 'V', $reserved2;
      $data .= pack 'V', $reserved3;
      $data .= pack 'V', $reserved4;
      $data .= pack 'v', $grbit;
      $data .= pack 'v', $index;
      $data .= pack 'v', $reserved5;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_valuerange()
  #
  # Write the VALUERANGE chart BIFF record.
  #
  sub _store_valuerange {
  
      my $self = shift;
  
      my $record   = 0x101F;        # Record identifier.
      my $length   = 0x002A;        # Number of bytes to follow.
      my $numMin   = 0x00000000;    # Minimum value on axis.
      my $numMax   = 0x00000000;    # Maximum value on axis.
      my $numMajor = 0x00000000;    # Value of major increment.
      my $numMinor = 0x00000000;    # Value of minor increment.
      my $numCross = 0x00000000;    # Value where category axis crosses.
      my $grbit    = 0x011F;        # Format flags.
  
      # TODO. Reverse doubles when they are handled.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'd', $numMin;
      $data .= pack 'd', $numMax;
      $data .= pack 'd', $numMajor;
      $data .= pack 'd', $numMinor;
      $data .= pack 'd', $numCross;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # Config data.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _set_default_properties()
  #
  # Setup the default properties for a chart.
  #
  sub _set_default_properties {
  
      my $self = shift;
  
      $self->{_legend} = {
          _visible  => 1,
          _position => 0,
          _vertical => 0,
      };
  
      $self->{_chartarea} = {
          _visible          => 0,
          _fg_color_index   => 0x4E,
          _fg_color_rgb     => 0xFFFFFF,
          _bg_color_index   => 0x4D,
          _bg_color_rgb     => 0x000000,
          _area_pattern     => 0x0000,
          _area_options     => 0x0000,
          _line_pattern     => 0x0005,
          _line_weight      => 0xFFFF,
          _line_color_index => 0x4D,
          _line_color_rgb   => 0x000000,
          _line_options     => 0x0008,
      };
  
      $self->{_plotarea} = {
          _visible          => 1,
          _fg_color_index   => 0x16,
          _fg_color_rgb     => 0xC0C0C0,
          _bg_color_index   => 0x4F,
          _bg_color_rgb     => 0x000000,
          _area_pattern     => 0x0001,
          _area_options     => 0x0000,
          _line_pattern     => 0x0000,
          _line_weight      => 0x0000,
          _line_color_index => 0x17,
          _line_color_rgb   => 0x808080,
          _line_options     => 0x0000,
      };
  }
  
  
  ###############################################################################
  #
  # _set_default_config_data()
  #
  # Setup the default configuration data for a chart.
  #
  sub _set_default_config_data {
  
      my $self = shift;
  
      #<<< Perltidy ignore this.
      $self->{_config} = {
          _axisparent      => [ 0, 0x00F8, 0x01F5, 0x0E7F, 0x0B36              ],
          _axisparent_pos  => [ 2, 2, 0x008C, 0x01AA, 0x0EEA, 0x0C52           ],
          _chart           => [ 0x0000, 0x0000, 0x02DD51E0, 0x01C2B838         ],
          _font_numbers    => [ 5, 10, 0x38B8, 0x22A1, 0x0000                  ],
          _font_series     => [ 6, 10, 0x38B8, 0x22A1, 0x0001                  ],
          _font_title      => [ 7, 12, 0x38B8, 0x22A1, 0x0000                  ],
          _font_axes       => [ 8, 10, 0x38B8, 0x22A1, 0x0001                  ],
          _legend          => [ 0x05F9, 0x0EE9, 0x047D, 0x9C, 0x00, 0x01, 0x0F ],
          _legend_pos      => [ 5, 2, 0x05F9, 0x0EE9, 0, 0                     ],
          _legend_text     => [ 0xFFFFFF46, 0xFFFFFF06, 0, 0, 0x00B1, 0x0000   ],
          _legend_text_pos => [ 2, 2, 0, 0, 0, 0                               ],
          _series_text     => [ 0xFFFFFF46, 0xFFFFFF06, 0, 0, 0x00B1, 0x1020   ],
          _series_text_pos => [ 2, 2, 0, 0, 0, 0                               ],
          _title_text      => [ 0x06E4, 0x0051, 0x01DB, 0x00C4, 0x0081, 0x1030 ],
          _title_text_pos  => [ 2, 2, 0, 0, 0x73, 0x1D                         ],
          _x_axis_text     => [ 0x07E1, 0x0DFC, 0xB2, 0x9C, 0x0081, 0x0000     ],
          _x_axis_text_pos => [ 2, 2, 0, 0,  0x2B,  0x17                       ],
          _y_axis_text     => [ 0x002D, 0x06AA, 0x5F, 0x1CC, 0x0281, 0x00, 90  ],
          _y_axis_text_pos => [ 2, 2, 0, 0, 0x17,  0x44                        ],
      }; #>>>
  
  
  }
  
  
  ###############################################################################
  #
  # _set_embedded_config_data()
  #
  # Setup the default configuration data for an embedded chart.
  #
  sub _set_embedded_config_data {
  
      my $self = shift;
  
      $self->{_embedded} = 1;
  
      $self->{_chartarea} = {
          _visible          => 1,
          _fg_color_index   => 0x4E,
          _fg_color_rgb     => 0xFFFFFF,
          _bg_color_index   => 0x4D,
          _bg_color_rgb     => 0x000000,
          _area_pattern     => 0x0001,
          _area_options     => 0x0001,
          _line_pattern     => 0x0000,
          _line_weight      => 0x0000,
          _line_color_index => 0x4D,
          _line_color_rgb   => 0x000000,
          _line_options     => 0x0009,
      };
  
  
      #<<< Perltidy ignore this.
      $self->{_config} = {
          _axisparent      => [ 0, 0x01D8, 0x031D, 0x0D79, 0x07E9              ],
          _axisparent_pos  => [ 2, 2, 0x010C, 0x0292, 0x0E46, 0x09FD           ],
          _chart           => [ 0x0000, 0x0000, 0x01847FE8, 0x00F47FE8         ],
          _font_numbers    => [ 5, 10, 0x1DC4, 0x1284, 0x0000                  ],
          _font_series     => [ 6, 10, 0x1DC4, 0x1284, 0x0001                  ],
          _font_title      => [ 7, 12, 0x1DC4, 0x1284, 0x0000                  ],
          _font_axes       => [ 8, 10, 0x1DC4, 0x1284, 0x0001                  ],
          _legend          => [ 0x044E, 0x0E4A, 0x088D, 0x0123, 0x0, 0x1, 0xF  ],
          _legend_pos      => [ 5, 2, 0x044E, 0x0E4A, 0, 0                     ],
          _legend_text     => [ 0xFFFFFFD9, 0xFFFFFFC1, 0, 0, 0x00B1, 0x0000   ],
          _legend_text_pos => [ 2, 2, 0, 0, 0, 0                               ],
          _series_text     => [ 0xFFFFFFD9, 0xFFFFFFC1, 0, 0, 0x00B1, 0x1020   ],
          _series_text_pos => [ 2, 2, 0, 0, 0, 0                               ],
          _title_text      => [ 0x060F, 0x004C, 0x038A, 0x016F, 0x0081, 0x1030 ],
          _title_text_pos  => [ 2, 2, 0, 0, 0x73, 0x1D                         ],
          _x_axis_text     => [ 0x07EF, 0x0C8F, 0x153, 0x123, 0x81, 0x00       ],
          _x_axis_text_pos => [ 2, 2, 0, 0, 0x2B, 0x17                         ],
          _y_axis_text     => [ 0x0057, 0x0564, 0xB5, 0x035D, 0x0281, 0x00, 90 ],
          _y_axis_text_pos => [ 2, 2, 0, 0, 0x17, 0x44                         ],
      }; #>>>
  }
  
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Chart - A writer class for Excel Charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'column' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  
  =head1 DESCRIPTION
  
  The C<Chart> module is an abstract base class for modules that implement charts in L<Spreadsheet::WriteExcel>. The information below is applicable to all of the available subclasses.
  
  The C<Chart> module isn't used directly, a chart object is created via the Workbook C<add_chart()> method where the chart type is specified:
  
      my $chart = $workbook->add_chart( type => 'column' );
  
  Currently the supported chart types are:
  
  =over
  
  =item * C<area>: Creates an Area (filled line) style chart. See L<Spreadsheet::WriteExcel::Chart::Area>.
  
  =item * C<bar>: Creates a Bar style (transposed histogram) chart. See L<Spreadsheet::WriteExcel::Chart::Bar>.
  
  =item * C<column>: Creates a column style (histogram) chart. See L<Spreadsheet::WriteExcel::Chart::Column>.
  
  =item * C<line>: Creates a Line style chart. See L<Spreadsheet::WriteExcel::Chart::Line>.
  
  =item * C<pie>: Creates an Pie style chart. See L<Spreadsheet::WriteExcel::Chart::Pie>.
  
  =item * C<scatter>: Creates an Scatter style chart. See L<Spreadsheet::WriteExcel::Chart::Scatter>.
  
  =item * C<stock>: Creates an Stock style chart. See L<Spreadsheet::WriteExcel::Chart::Stock>.
  
  =back
  
  More charts and sub-types will be supported in time. See the L</TODO> section.
  
  Methods that are common to all chart types are documented below.
  
  =head1 CHART METHODS
  
  =head2 add_series()
  
  In an Excel chart a "series" is a collection of information such as values, x-axis labels and the name that define which data is plotted. These settings are displayed when you select the C<< Chart -> Source Data... >> menu option.
  
  With a Spreadsheet::WriteExcel chart object the C<add_series()> method is used to set the properties for a series:
  
      $chart->add_series(
          categories    => '=Sheet1!$A$2:$A$10',
          values        => '=Sheet1!$B$2:$B$10',
          name          => 'Series name',
          name_formula  => '=Sheet1!$B$1',
      );
  
  The properties that can be set are:
  
  =over
  
  =item * C<values>
  
  This is the most important property of a series and must be set for every chart object. It links the chart with the worksheet data that it displays. Note the format that should be used for the formula. See L</Working with Cell Ranges>.
  
  =item * C<categories>
  
  This sets the chart category labels. The category is more or less the same as the X-axis. In most chart types the C<categories> property is optional and the chart will just assume a sequential series from C<1 .. n>.
  
  =item * C<name>
  
  Set the name for the series. The name is displayed in the chart legend and in the formula bar. The name property is optional and if it isn't supplied will default to C<Series 1 .. n>.
  
  =item * C<name_formula>
  
  Optional, can be used to link the name to a worksheet cell. See L</Chart names and links>.
  
  =back
  
  You can add more than one series to a chart, in fact some chart types such as C<stock> require it. The series numbering and order in the final chart is the same as the order in which that are added.
  
      # Add the first series.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
  
      # Add another series. Category is the same but values are different.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          name       => 'Test data series 2',
      );
  
  
  
  =head2 set_x_axis()
  
  The C<set_x_axis()> method is used to set properties of the X axis.
  
      $chart->set_x_axis( name => 'Sample length (m)' );
  
  The properties that can be set are:
  
  =over
  
  =item * C<name>
  
  Set the name (title or caption) for the axis. The name is displayed below the X axis. This property is optional. The default is to have no axis name.
  
  =item * C<name_formula>
  
  Optional, can be used to link the name to a worksheet cell. See L</Chart names and links>.
  
  =back
  
  Additional axis properties such as range, divisions and ticks will be made available in later releases. See the L</TODO> section.
  
  
  =head2 set_y_axis()
  
  The C<set_y_axis()> method is used to set properties of the Y axis.
  
      $chart->set_y_axis( name => 'Sample weight (kg)' );
  
  The properties that can be set are:
  
  =over
  
  =item * C<name>
  
  Set the name (title or caption) for the axis. The name is displayed to the left of the Y axis. This property is optional. The default is to have no axis name.
  
  =item * C<name_formula>
  
  Optional, can be used to link the name to a worksheet cell. See L</Chart names and links>.
  
  =back
  
  Additional axis properties such as range, divisions and ticks will be made available in later releases. See the L</TODO> section.
  
  =head2 set_title()
  
  The C<set_title()> method is used to set properties of the chart title.
  
      $chart->set_title( name => 'Year End Results' );
  
  The properties that can be set are:
  
  =over
  
  =item * C<name>
  
  Set the name (title) for the chart. The name is displayed above the chart. This property is optional. The default is to have no chart title.
  
  =item * C<name_formula>
  
  Optional, can be used to link the name to a worksheet cell. See L</Chart names and links>.
  
  =back
  
  
  =head2 set_legend()
  
  The C<set_legend()> method is used to set properties of the chart legend.
  
      $chart->set_legend( position => 'none' );
  
  The properties that can be set are:
  
  =over
  
  =item * C<position>
  
  Set the position of the chart legend.
  
      $chart->set_legend( position => 'none' );
  
  The default legend position is C<bottom>. The currently supported chart positions are:
  
      none
      bottom
  
  The other legend positions will be added soon.
  
  =back
  
  
  =head2 set_chartarea()
  
  The C<set_chartarea()> method is used to set the properties of the chart area. In Excel the chart area is the background area behind the chart.
  
  The properties that can be set are:
  
  =over
  
  =item * C<color>
  
  Set the colour of the chart area. The Excel default chart area color is 'white', index 9. See L</Chart object colours>.
  
  =item * C<line_color>
  
  Set the colour of the chart area border line. The Excel default border line colour is 'black', index 9.  See L</Chart object colours>.
  
  =item * C<line_pattern>
  
  Set the pattern of the of the chart area border line. The Excel default pattern is 'none', index 0 for a chart sheet and 'solid', index 1, for an embedded chart. See L</Chart line patterns>.
  
  =item * C<line_weight>
  
  Set the weight of the of the chart area border line. The Excel default weight is 'narrow', index 2. See L</Chart line weights>.
  
  =back
  
  Here is an example of setting several properties:
  
      $chart->set_chartarea(
          color        => 'red',
          line_color   => 'black',
          line_pattern => 2,
          line_weight  => 3,
      );
  
  Note, for chart sheets the chart area border is off by default. For embedded charts is is on by default.
  
  =head2 set_plotarea()
  
  The C<set_plotarea()> method is used to set properties of the plot area of a chart. In Excel the plot area is the area between the axes on which the chart series are plotted.
  
  The properties that can be set are:
  
  =over
  
  =item * C<visible>
  
  Set the visibility of the plot area. The default is 1 for visible. Set to 0 to hide the plot area and have the same colour as the background chart area.
  
  =item * C<color>
  
  Set the colour of the plot area. The Excel default plot area color is 'silver', index 23. See L</Chart object colours>.
  
  =item * C<line_color>
  
  Set the colour of the plot area border line. The Excel default border line colour is 'gray', index 22. See L</Chart object colours>.
  
  =item * C<line_pattern>
  
  Set the pattern of the of the plot area border line. The Excel default pattern is 'solid', index 1. See L</Chart line patterns>.
  
  =item * C<line_weight>
  
  Set the weight of the of the plot area border line. The Excel default weight is 'narrow', index 2. See L</Chart line weights>.
  
  =back
  
  Here is an example of setting several properties:
  
      $chart->set_plotarea(
          color        => 'red',
          line_color   => 'black',
          line_pattern => 2,
          line_weight  => 3,
      );
  
  
  
  =head1 WORKSHEET METHODS
  
  In Excel a chart sheet (i.e, a chart that isn't embedded) shares properties with data worksheets such as tab selection, headers, footers, margins and print properties.
  
  In Spreadsheet::WriteExcel you can set chart sheet properties using the same methods that are used for Worksheet objects.
  
  The following Worksheet methods are also available through a non-embedded Chart object:
  
      get_name()
      activate()
      select()
      hide()
      set_first_sheet()
      protect()
      set_zoom()
      set_tab_color()
  
      set_landscape()
      set_portrait()
      set_paper()
      set_margins()
      set_header()
      set_footer()
  
  See L<Spreadsheet::WriteExcel> for a detailed explanation of these methods.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates some of the available features when creating a chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_area.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Sample 1', 'Sample 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'area', embedded => 1 );
  
      # Configure the first series. (Sample 1)
      $chart->add_series(
          name       => 'Sample 1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure the second series. (Sample 2)
      $chart->add_series(
          name       => 'Sample 2',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (cm)' );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/area1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 Chart object colours
  
  Many of the chart objects supported by Spreadsheet::WriteExcl allow the default colours to be changed. Excel provides a palette of 56 colours and in Spreadsheet::WriteExcel these colours are accessed via their palette index in the range 8..63.
  
  The most commonly used colours can be accessed by name or index.
  
      black   =>   8,    green    =>  17,    navy     =>  18,
      white   =>   9,    orange   =>  53,    pink     =>  33,
      red     =>  10,    gray     =>  23,    purple   =>  20,
      blue    =>  12,    lime     =>  11,    silver   =>  22,
      yellow  =>  13,    cyan     =>  15,
      brown   =>  16,    magenta  =>  14,
  
  For example the following are equivalent.
  
      $chart->set_plotarea( color => 10    );
      $chart->set_plotarea( color => 'red' );
  
  The colour palette is shown in C<palette.html> in the C<docs> directory  of the distro. An Excel version of the palette can be generated using C<colors.pl> in the C<examples> directory.
  
  User defined colours can be set using the C<set_custom_color()> workbook method. This and other aspects of using colours are discussed in the "Colours in Excel" section of the main Spreadsheet::WriteExcel documentation: L<http://search.cpan.org/dist/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm#COLOURS_IN_EXCEL>.
  
  =head1 Chart line patterns
  
  Chart lines patterns can be set using either an index or a name:
  
      $chart->set_plotarea( weight => 2      );
      $chart->set_plotarea( weight => 'dash' );
  
  Chart lines have 9 possible patterns are follows:
  
      'none'         => 0,
      'solid'        => 1,
      'dash'         => 2,
      'dot'          => 3,
      'dash-dot'     => 4,
      'dash-dot-dot' => 5,
      'medium-gray'  => 6,
      'dark-gray'    => 7,
      'light-gray'   => 8,
  
  The patterns 1-8 are shown in order in the drop down dialog boxes in Excel. The default pattern is 'solid', index 1.
  
  
  =head1 Chart line weights
  
  Chart lines weights can be set using either an index or a name:
  
      $chart->set_plotarea( weight => 1          );
      $chart->set_plotarea( weight => 'hairline' );
  
  Chart lines have 4 possible weights are follows:
  
      'hairline' => 1,
      'narrow'   => 2,
      'medium'   => 3,
      'wide'     => 4,
  
  The weights 1-4 are shown in order in the drop down dialog boxes in Excel. The default weight is 'narrow', index 2.
  
  
  =head1 Chart names and links
  
  The C<add_series())>, C<set_x_axis()>, C<set_y_axis()> and C<set_title()> methods all support a C<name> property. In general these names can be either a static string or a link to a worksheet cell. If you choose to use the C<name_formula> property to specify a link then you should also the C<name> property. This isn't strictly required by Excel but some third party applications expect it to be present.
  
      $chart->set_title(
          name          => 'Year End Results',
          name_formula  => '=Sheet1!$C$1',
      );
  
  These links should be used sparingly since they aren't commonly used in Excel charts.
  
  
  =head1 Chart names and Unicode
  
  The C<add_series())>, C<set_x_axis()>, C<set_y_axis()> and C<set_title()> methods all support a C<name> property. These names can be UTF8 strings if you are using perl 5.8+.
  
  
      # perl 5.8+ example:
      my $smiley = "\x{263A}";
  
      $chart->set_title( name => "Best. Results. Ever! $smiley" );
  
  For older perls you write Unicode strings as UTF-16BE by adding a C<name_encoding> property:
  
      # perl 5.005 example:
      my $utf16be_name = pack 'n', 0x263A;
  
      $chart->set_title(
          name          => $utf16be_name,
          name_encoding => 1,
      );
  
  This methodology is explained in the "UNICODE IN EXCEL" section of L<Spreadsheet::WriteExcel> but is semi-deprecated. If you are using Unicode the easiest option is to just use UTF8 in perl 5.8+.
  
  
  =head1 Working with Cell Ranges
  
  
  In the section on C<add_series()> it was noted that the series must be defined using a range formula:
  
      $chart->add_series( values => '=Sheet1!$B$2:$B$10' );
  
  The worksheet name must be specified (even for embedded charts) and the cell references must be "absolute" references, i.e., they must contain C<$> signs. This is the format that is required by Excel for chart references.
  
  Since it isn't very convenient to work with this type of string programmatically the L<Spreadsheet::WriteExcel::Utility> module, which is included with Spreadsheet::WriteExcel, provides a function called C<xl_range_formula()> to convert from zero based row and column cell references to an A1 style formula string.
  
  The syntax is:
  
      xl_range_formula($sheetname, $row_1, $row_2, $col_1, $col_2)
  
  If you include it in your program, using the standard import syntax, you can use the function as follows:
  
  
      # Include the Utility module or just the function you need.
      use Spreadsheet::WriteExcel::Utility qw( xl_range_formula );
      ...
  
      # Then use it as required.
      $chart->add_series(
          categories    => xl_range_formula( 'Sheet1', 1, 9, 0, 0 ),
          values        => xl_range_formula( 'Sheet1', 1, 9, 1, 1 ),
      );
  
      # Which is the same as:
      $chart->add_series(
          categories    => '=Sheet1!$A$2:$A$10',
          values        => '=Sheet1!$B$2:$B$10',
      );
  
  See L<Spreadsheet::WriteExcel::Utility> for more details.
  
  
  =head1 TODO
  
  Charts in Spreadsheet::WriteExcel are a work in progress. More chart types and features will be added in time. Please be patient. Even a small feature can take a week or more to implement, test and document.
  
  Features that are on the TODO list and will be added are:
  
  =over
  
  =item *  Chart sub-types.
  
  =item * Colours and formatting options. For now you will have to make do with the default Excel colours and formats.
  
  =item * Axis controls, gridlines.
  
  =item * 3D charts.
  
  =item * Embedded data in charts for third party application support. See Known Issues.
  
  =item * Additional chart types such as Bubble and Radar. Send an email if you are interested in other types and they will be added to the queue.
  
  =back
  
  If you are interested in sponsoring a feature let me know.
  
  =head1 KNOWN ISSUES
  
  =over
  
  =item * Currently charts don't contain embedded data from which the charts can be rendered. Excel and most other third party applications ignore this and read the data via the links that have been specified. However, some applications may complain or not render charts correctly. The preview option in Mac OS X is an known example. This will be fixed in a later release.
  
  =item * When there are several charts with titles set in a workbook some of the titles may display at a font size of 10 instead of the default 12 until another chart with the title set is viewed.
  
  =item * Stock (and other) charts should have the X-axis dates aligned at an angle for clarity. This will be fixed at a later stage.
  
  =back
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART

$fatpacked{"Spreadsheet/WriteExcel/Chart/Area.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_AREA';
  package Spreadsheet::WriteExcel::Chart::Area;
  
  ###############################################################################
  #
  # Area - A writer class for Excel Area charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel::Chart.
  #
  # See formatting note in Spreadsheet::WriteExcel::Chart.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # Implementation of the abstract method from the specific chart class.
  #
  # Write the AREA chart BIFF record. Defines a area chart type.
  #
  sub _store_chart_type {
  
      my $self = shift;
  
      my $record = 0x101A;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $grbit  = 0x0001;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Area - A writer class for Excel Area charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Area chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'area' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Area charts for L<Spreadsheet::WriteExcel>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'area' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Spreadsheet::WriteExcel::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Area Chart Methods
  
  There aren't currently any area chart specific methods. See the TODO section of L<Spreadsheet::WriteExcel::Chart>.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_area.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Sample 1', 'Sample 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'area', embedded => 1 );
  
      # Configure the first series. (Sample 1)
      $chart->add_series(
          name       => 'Sample 1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure the second series. (Sample 2)
      $chart->add_series(
          name       => 'Sample 2',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (cm)' );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/area1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_AREA

$fatpacked{"Spreadsheet/WriteExcel/Chart/Bar.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_BAR';
  package Spreadsheet::WriteExcel::Chart::Bar;
  
  ###############################################################################
  #
  # Bar - A writer class for Excel Bar charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel::Chart.
  #
  # See formatting note in Spreadsheet::WriteExcel::Chart.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      bless $self, $class;
  
      # The axis positions are reversed for a bar chart so we change the config.
      my $c = $self->{_config};
      $c->{_x_axis_text}     = [ 0x2D,   0x6D9,  0x5F,   0x1CC, 0x281,  0x0, 90 ];
      $c->{_x_axis_text_pos} = [ 2,      2,      0,      0,     0x17,   0x2A ];
      $c->{_y_axis_text}     = [ 0x078A, 0x0DFC, 0x011D, 0x9C,  0x0081, 0x0000 ];
      $c->{_y_axis_text_pos} = [ 2,      2,      0,      0,     0x45,   0x17 ];
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # Implementation of the abstract method from the specific chart class.
  #
  # Write the BAR chart BIFF record. Defines a bar or column chart type.
  #
  sub _store_chart_type {
  
      my $self = shift;
  
      my $record    = 0x1017;    # Record identifier.
      my $length    = 0x0006;    # Number of bytes to follow.
      my $pcOverlap = 0x0000;    # Space between bars.
      my $pcGap     = 0x0096;    # Space between cats.
      my $grbit     = 0x0001;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $pcOverlap;
      $data .= pack 'v', $pcGap;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  ###############################################################################
  #
  # _set_embedded_config_data()
  #
  # Override some of the default configuration data for an embedded chart.
  #
  sub _set_embedded_config_data {
  
      my $self = shift;
  
      # Set the parent configuration first.
      $self->SUPER::_set_embedded_config_data();
  
      # The axis positions are reversed for a bar chart so we change the config.
      my $c = $self->{_config};
      $c->{_x_axis_text}     = [ 0x57,   0x5BC,  0xB5,   0x214, 0x281, 0x0, 90 ];
      $c->{_x_axis_text_pos} = [ 2,      2,      0,      0,     0x17,  0x2A ];
      $c->{_y_axis_text}     = [ 0x074A, 0x0C8F, 0x021F, 0x123, 0x81,  0x0000 ];
      $c->{_y_axis_text_pos} = [ 2,      2,      0,      0,     0x45,  0x17 ];
  
  }
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Bar - A writer class for Excel Bar charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Bar chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'bar' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Bar charts for L<Spreadsheet::WriteExcel>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'bar' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Spreadsheet::WriteExcel::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Bar Chart Methods
  
  There aren't currently any bar chart specific methods. See the TODO section of L<Spreadsheet::WriteExcel::Chart>.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_bar.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Sample 1', 'Sample 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'bar', embedded => 1 );
  
      # Configure the first series. (Sample 1)
      $chart->add_series(
          name       => 'Sample 1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure the second series. (Sample 2)
      $chart->add_series(
          name       => 'Sample 2',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (cm)' );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/bar1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_BAR

$fatpacked{"Spreadsheet/WriteExcel/Chart/Column.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_COLUMN';
  package Spreadsheet::WriteExcel::Chart::Column;
  
  ###############################################################################
  #
  # Column - A writer class for Excel Column charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel::Chart.
  #
  # See formatting note in Spreadsheet::WriteExcel::Chart.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # Implementation of the abstract method from the specific chart class.
  #
  # Write the BAR chart BIFF record. Defines a bar or column chart type.
  #
  sub _store_chart_type {
  
      my $self = shift;
  
      my $record    = 0x1017;    # Record identifier.
      my $length    = 0x0006;    # Number of bytes to follow.
      my $pcOverlap = 0x0000;    # Space between bars.
      my $pcGap     = 0x0096;    # Space between cats.
      my $grbit     = 0x0000;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $pcOverlap;
      $data .= pack 'v', $pcGap;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Column - A writer class for Excel Column charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Column chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'column' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Column charts for L<Spreadsheet::WriteExcel>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'column' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Spreadsheet::WriteExcel::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Column Chart Methods
  
  There aren't currently any column chart specific methods. See the TODO section of L<Spreadsheet::WriteExcel::Chart>.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_column.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Sample 1', 'Sample 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'column', embedded => 1 );
  
      # Configure the first series. (Sample 1)
      $chart->add_series(
          name       => 'Sample 1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure the second series. (Sample 2)
      $chart->add_series(
          name       => 'Sample 2',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (cm)' );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/column1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_COLUMN

$fatpacked{"Spreadsheet/WriteExcel/Chart/External.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_EXTERNAL';
  package Spreadsheet::WriteExcel::Chart::External;
  
  ###############################################################################
  #
  # External - A writer class for Excel external charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # perltidy with options: -mbl=2 -pt=0 -nola
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class             = shift;
      my $external_filename = shift;
      my $self              = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      $self->{_filename}     = $external_filename;
      $self->{_external_bin} = 1;
  
      bless $self, $class;
      $self->_initialize();    # Requires overridden initialize().
      return $self;
  }
  
  ###############################################################################
  #
  # _initialize()
  #
  # Read all the data into memory for the external binary style chart.
  #
  #
  sub _initialize {
  
      my $self = shift;
  
      my $filename   = $self->{_filename};
      my $filehandle = FileHandle->new( $filename )
        or die "Couldn't open $filename in add_chart_ext(): $!.\n";
  
      binmode( $filehandle );
  
      $self->{_filehandle}    = $filehandle;
      $self->{_datasize}      = -s $filehandle;
      $self->{_using_tmpfile} = 0;
  
      # Read the entire external chart binary into the the data buffer.
      # This will be retrieved by _get_data() when the chart is closed().
      read( $self->{_filehandle}, $self->{_data}, $self->{_datasize} );
  }
  
  
  ###############################################################################
  #
  # _close()
  #
  # We don't need to create or store Chart data structures when using an
  # external binary, so we have a default close method.
  #
  sub _close {
  
      my $self = shift;
  
      return undef;
  }
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  External - A writer class for Excel external charts.
  
  =head1 SYNOPSIS
  
  This module is used to include external charts in Spreadsheet::WriteExcel.
  
  =head1 DESCRIPTION
  
  This module is used to include external charts in L<Spreadsheet::WriteExcel>. It is an internal module and isn't used directly by the end user.
  
  It is semi-deprecated in favour of using "native" charts. See L<Spreadsheet::WriteExcel::Chart>.
  
  For information on how to used external charts see the C<external_charts.txt>  (or C<.pod>) in the C<external_charts> directory of the distro.
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_EXTERNAL

$fatpacked{"Spreadsheet/WriteExcel/Chart/Line.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_LINE';
  package Spreadsheet::WriteExcel::Chart::Line;
  
  ###############################################################################
  #
  # Line - A writer class for Excel Line charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel::Chart.
  #
  # See formatting note in Spreadsheet::WriteExcel::Chart.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # Implementation of the abstract method from the specific chart class.
  #
  # Write the LINE chart BIFF record. Defines a line chart type.
  #
  sub _store_chart_type {
  
      my $self = shift;
  
      my $record = 0x1018;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $grbit  = 0x0000;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Line - A writer class for Excel Line charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Line chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'line' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Line charts for L<Spreadsheet::WriteExcel>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'line' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Spreadsheet::WriteExcel::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Line Chart Methods
  
  There aren't currently any line chart specific methods. See the TODO section of L<Spreadsheet::WriteExcel::Chart>.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_line.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Sample 1', 'Sample 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the first series. (Sample 1)
      $chart->add_series(
          name       => 'Sample 1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure the second series. (Sample 2)
      $chart->add_series(
          name       => 'Sample 2',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (cm)' );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/line1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_LINE

$fatpacked{"Spreadsheet/WriteExcel/Chart/Pie.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_PIE';
  package Spreadsheet::WriteExcel::Chart::Pie;
  
  ###############################################################################
  #
  # Pie - A writer class for Excel Pie charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel::Chart.
  #
  # See formatting note in Spreadsheet::WriteExcel::Chart.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      $self->{_vary_data_color} = 1;
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # Implementation of the abstract method from the specific chart class.
  #
  # Write the Pie chart BIFF record.
  #
  sub _store_chart_type {
  
      my $self = shift;
  
      my $record = 0x1019;    # Record identifier.
      my $length = 0x0006;    # Number of bytes to follow.
      my $angle  = 0x0000;    # Angle.
      my $donut  = 0x0000;    # Donut hole size.
      my $grbit  = 0x0002;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $angle;
      $data .= pack 'v', $donut;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_axisparent_stream(). Overridden.
  #
  # Write the AXISPARENT chart substream.
  #
  # A Pie chart has no X or Y axis so we override this method to remove them.
  #
  sub _store_axisparent_stream {
  
      my $self = shift;
  
      $self->_store_axisparent( @{ $self->{_config}->{_axisparent} } );
  
      $self->_store_begin();
      $self->_store_pos( @{ $self->{_config}->{_axisparent_pos} } );
  
      $self->_store_chartformat_stream();
      $self->_store_end();
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Pie - A writer class for Excel Pie charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Pie chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'pie' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Pie charts for L<Spreadsheet::WriteExcel>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'pie' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_title();
  
  These methods are explained in detail in L<Spreadsheet::WriteExcel::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Pie Chart Methods
  
  There aren't currently any pie chart specific methods. See the TODO section of L<Spreadsheet::WriteExcel::Chart>.
  
  A Pie chart doesn't have an X or Y axis so the following common chart methods are ignored.
  
      $chart->set_x_axis();
      $chart->set_y_axis();
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_pie.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values' ];
      my $data = [
          [ 'Apple', 'Cherry', 'Pecan' ],
          [ 60,       30,       10     ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'pie', embedded => 1 );
  
      # Configure the series.
      $chart->add_series(
          name       => 'Pie sales data',
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
      );
  
      # Add a title.
      $chart->set_title( name => 'Popular Pie Types' );
  
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/pie1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_PIE

$fatpacked{"Spreadsheet/WriteExcel/Chart/Scatter.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_SCATTER';
  package Spreadsheet::WriteExcel::Chart::Scatter;
  
  ###############################################################################
  #
  # Scatter - A writer class for Excel Scatter charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel::Chart.
  #
  # See formatting note in Spreadsheet::WriteExcel::Chart.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # Implementation of the abstract method from the specific chart class.
  #
  # Write the SCATTER chart BIFF record. Defines a scatter chart type.
  #
  sub _store_chart_type {
  
      my $self = shift;
  
      my $record       = 0x101B;    # Record identifier.
      my $length       = 0x0006;    # Number of bytes to follow.
      my $bubble_ratio = 0x0064;    # Bubble ratio.
      my $bubble_type  = 0x0001;    # Bubble type.
      my $grbit        = 0x0000;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = '';
      $data .= pack 'v', $bubble_ratio;
      $data .= pack 'v', $bubble_type;
      $data .= pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  
  ###############################################################################
  #
  # _store_axis_category_stream(). Overridden.
  #
  # Write the AXIS chart substream for the chart category.
  #
  # For a Scatter chart the category stream is replace with a values stream. We
  # override this method and turn it into a values stream.
  #
  sub _store_axis_category_stream {
  
      my $self = shift;
  
      $self->_store_axis( 0 );
  
      $self->_store_begin();
      $self->_store_valuerange();
      $self->_store_tick();
      $self->_store_end();
  }
  
  
  ###############################################################################
  #
  # _store_marker_dataformat_stream(). Overridden.
  #
  # This is an implementation of the parent abstract method  to define
  # properties of markers, linetypes, pie formats and other.
  #
  sub _store_marker_dataformat_stream {
  
      my $self = shift;
  
      $self->_store_dataformat( 0x0000, 0xFFFD, 0x0000 );
  
      $self->_store_begin();
      $self->_store_3dbarshape();
      $self->_store_lineformat( 0x00000000, 0x0005, 0xFFFF, 0x0008, 0x004D );
      $self->_store_areaformat( 0x00FFFFFF, 0x0000, 0x01, 0x01, 0x4E, 0x4D );
      $self->_store_pieformat();
      $self->_store_markerformat( 0x00, 0x00, 0x02, 0x01, 0x4D, 0x4D, 0x3C );
      $self->_store_end();
  
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Scatter - A writer class for Excel Scatter charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Scatter chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'scatter' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Scatter charts for L<Spreadsheet::WriteExcel>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'scatter' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Spreadsheet::WriteExcel::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Scatter Chart Methods
  
  There aren't currently any scatter chart specific methods. See the TODO section of L<Spreadsheet::WriteExcel::Chart>.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_scatter.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Sample 1', 'Sample 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'scatter', embedded => 1 );
  
      # Configure the first series. (Sample 1)
      $chart->add_series(
          name       => 'Sample 1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure the second series. (Sample 2)
      $chart->add_series(
          name       => 'Sample 2',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (cm)' );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/scatter1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_SCATTER

$fatpacked{"Spreadsheet/WriteExcel/Chart/Stock.pm"} = <<'SPREADSHEET_WRITEEXCEL_CHART_STOCK';
  package Spreadsheet::WriteExcel::Chart::Stock;
  
  ###############################################################################
  #
  # Stock - A writer class for Excel Stock charts.
  #
  # Used in conjunction with Spreadsheet::WriteExcel::Chart.
  #
  # See formatting note in Spreadsheet::WriteExcel::Chart.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  require Exporter;
  
  use strict;
  use Spreadsheet::WriteExcel::Chart;
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::Chart Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Spreadsheet::WriteExcel::Chart->new( @_ );
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # _store_chart_type()
  #
  # Implementation of the abstract method from the specific chart class.
  #
  # Write the LINE chart BIFF record. A stock chart uses the same LINE record
  # as a line chart but with additional DROPBAR and CHARTLINE records to define
  # the stock style.
  #
  sub _store_chart_type {
  
      my $self = shift;
  
      my $record = 0x1018;    # Record identifier.
      my $length = 0x0002;    # Number of bytes to follow.
      my $grbit  = 0x0000;    # Option flags.
  
      my $header = pack 'vv', $record, $length;
      my $data = pack 'v', $grbit;
  
      $self->_append( $header, $data );
  }
  
  ###############################################################################
  #
  # _store_marker_dataformat_stream(). Overridden.
  #
  # This is an implementation of the parent abstract method to define
  # properties of markers, linetypes, pie formats and other.
  #
  sub _store_marker_dataformat_stream {
  
      my $self = shift;
  
      $self->_store_dropbar();
      $self->_store_begin();
      $self->_store_lineformat( 0x00000000, 0x0000, 0xFFFF, 0x0001, 0x004F );
      $self->_store_areaformat( 0x00FFFFFF, 0x0000, 0x01, 0x01, 0x09, 0x08 );
      $self->_store_end();
  
      $self->_store_dropbar();
      $self->_store_begin();
      $self->_store_lineformat( 0x00000000, 0x0000, 0xFFFF, 0x0001, 0x004F );
      $self->_store_areaformat( 0x0000, 0x00FFFFFF, 0x01, 0x01, 0x08, 0x09 );
      $self->_store_end();
  
      $self->_store_chartline();
      $self->_store_lineformat( 0x00000000, 0x0000, 0xFFFF, 0x0000, 0x004F );
  
  
      $self->_store_dataformat( 0x0000, 0xFFFD, 0x0000 );
      $self->_store_begin();
      $self->_store_3dbarshape();
      $self->_store_lineformat( 0x00000000, 0x0005, 0xFFFF, 0x0000, 0x004F );
      $self->_store_areaformat( 0x00000000, 0x0000, 0x00, 0x01, 0x4D, 0x4D );
      $self->_store_pieformat();
      $self->_store_markerformat( 0x00, 0x00, 0x00, 0x00, 0x4D, 0x4D, 0x3C );
      $self->_store_end();
  
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Stock - A writer class for Excel Stock charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Stock chart using Spreadsheet::WriteExcel:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart.xls' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'stock' );
  
      # Add a series for each Open-High-Low-Close.
      $chart->add_series( categories => '=Sheet1!$A$2:$A$6', values => '=Sheet1!$B$2:$B$6' );
      $chart->add_series( categories => '=Sheet1!$A$2:$A$6', values => '=Sheet1!$C$2:$C$6' );
      $chart->add_series( categories => '=Sheet1!$A$2:$A$6', values => '=Sheet1!$D$2:$D$6' );
      $chart->add_series( categories => '=Sheet1!$A$2:$A$6', values => '=Sheet1!$E$2:$E$6' );
  
      # Add the worksheet data the chart refers to.
      # ... See the full example below.
  
      __END__
  
  
  =head1 DESCRIPTION
  
  This module implements Stock charts for L<Spreadsheet::WriteExcel>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'stock' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Spreadsheet::WriteExcel::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Stock Chart Methods
  
  There aren't currently any stock chart specific methods. See the TODO section of L<Spreadsheet::WriteExcel::Chart>.
  
  The default Stock chart is an Open-High-Low-Close chart. A series must be added for each of these data sources.
  
  The default Stock chart is in black and white. User defined colours will be added at a later stage.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a Stock chart.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::WriteExcel;
  
      my $workbook    = Spreadsheet::WriteExcel->new( 'chart_stock_ex.xls' );
      my $worksheet   = $workbook->add_worksheet();
      my $bold        = $workbook->add_format( bold => 1 );
      my $date_format = $workbook->add_format( num_format => 'dd/mm/yyyy' );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Date', 'Open', 'High', 'Low', 'Close' ];
      my @data = (
          [ '2009-08-23', 110.75, 113.48, 109.05, 109.40 ],
          [ '2009-08-24', 111.24, 111.60, 103.57, 104.87 ],
          [ '2009-08-25', 104.96, 108.00, 103.88, 106.00 ],
          [ '2009-08-26', 104.95, 107.95, 104.66, 107.91 ],
          [ '2009-08-27', 108.10, 108.62, 105.69, 106.15 ],
      );
  
      $worksheet->write( 'A1', $headings, $bold );
  
      my $row = 1;
      for my $data ( @data ) {
          $worksheet->write( $row, 0, $data->[0], $date_format );
          $worksheet->write( $row, 1, $data->[1] );
          $worksheet->write( $row, 2, $data->[2] );
          $worksheet->write( $row, 3, $data->[3] );
          $worksheet->write( $row, 4, $data->[4] );
          $row++;
      }
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'stock', embedded => 1 );
  
      # Add a series for each of the Open-High-Low-Close columns.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$B$2:$B$6',
          name       => 'Open',
      );
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$C$2:$C$6',
          name       => 'High',
      );
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$D$2:$D$6',
          name       => 'Low',
      );
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$E$2:$E$6',
          name       => 'Close',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title( name => 'Open-High-Low-Close', );
      $chart->set_x_axis( name => 'Date', );
      $chart->set_y_axis( name => 'Share price', );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'F2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/stock1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_CHART_STOCK

$fatpacked{"Spreadsheet/WriteExcel/Examples.pm"} = <<'SPREADSHEET_WRITEEXCEL_EXAMPLES';
  package Spreadsheet::WriteExcel::Examples;
  
  ###############################################################################
  #
  # Examples - Spreadsheet::WriteExcel examples.
  #
  # A documentation only module showing the examples that are
  # included in the Spreadsheet::WriteExcel distribution. This
  # file was generated automatically via the gen_examples_pod.pl
  # program that is also included in the examples directory.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use strict;
  use vars qw($VERSION);
  $VERSION = '2.38';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Examples - Spreadsheet::WriteExcel example programs.
  
  =head1 DESCRIPTION
  
  This is a documentation only module showing the examples that are
  included in the L<Spreadsheet::WriteExcel> distribution.
  
  This file was auto-generated via the gen_examples_pod.pl
  program that is also included in the examples directory.
  
  =head1 Example programs
  
  The following is a list of the 85 example programs that are included in the Spreadsheet::WriteExcel distribution.
  
  =over
  
  =item * L<Example: a_simple.pl> A get started example with some basic features.
  
  =item * L<Example: demo.pl> A demo of some of the available features.
  
  =item * L<Example: regions.pl> A simple example of multiple worksheets.
  
  =item * L<Example: stats.pl> Basic formulas and functions.
  
  =item * L<Example: formats.pl> All the available formatting on several worksheets.
  
  =item * L<Example: bug_report.pl> A template for submitting bug reports.
  
  =item * L<Example: autofilter.pl> Examples of worksheet autofilters.
  
  =item * L<Example: autofit.pl> Simulate Excel's autofit for column widths.
  
  =item * L<Example: bigfile.pl> Write past the 7MB limit with OLE::Storage_Lite.
  
  =item * L<Example: cgi.pl> A simple CGI program.
  
  =item * L<Example: chart_area.pl> A demo of area style charts.
  
  =item * L<Example: chart_bar.pl> A demo of bar (vertical histogram) style charts.
  
  =item * L<Example: chart_column.pl> A demo of column (histogram) style charts.
  
  =item * L<Example: chart_line.pl> A demo of line style charts.
  
  =item * L<Example: chart_pie.pl> A demo of pie style charts.
  
  =item * L<Example: chart_scatter.pl> A demo of scatter style charts.
  
  =item * L<Example: chart_stock.pl> A demo of stock style charts.
  
  =item * L<Example: chess.pl> An example of reusing formatting via properties.
  
  =item * L<Example: colors.pl> A demo of the colour palette and named colours.
  
  =item * L<Example: comments1.pl> Add comments to worksheet cells.
  
  =item * L<Example: comments2.pl> Add comments with advanced options.
  
  =item * L<Example: copyformat.pl> Example of copying a cell format.
  
  =item * L<Example: data_validate.pl> An example of data validation and dropdown lists.
  
  =item * L<Example: date_time.pl> Write dates and times with write_date_time().
  
  =item * L<Example: defined_name.pl> Example of how to create defined names.
  
  =item * L<Example: diag_border.pl> A simple example of diagonal cell borders.
  
  =item * L<Example: easter_egg.pl> Expose the Excel97 flight simulator.
  
  =item * L<Example: filehandle.pl> Examples of working with filehandles.
  
  =item * L<Example: formula_result.pl> Formulas with user specified results.
  
  =item * L<Example: headers.pl> Examples of worksheet headers and footers.
  
  =item * L<Example: hide_sheet.pl> Simple example of hiding a worksheet.
  
  =item * L<Example: hyperlink1.pl> Shows how to create web hyperlinks.
  
  =item * L<Example: hyperlink2.pl> Examples of internal and external hyperlinks.
  
  =item * L<Example: images.pl> Adding images to worksheets.
  
  =item * L<Example: indent.pl> An example of cell indentation.
  
  =item * L<Example: merge1.pl> A simple example of cell merging.
  
  =item * L<Example: merge2.pl> A simple example of cell merging with formatting.
  
  =item * L<Example: merge3.pl> Add hyperlinks to merged cells.
  
  =item * L<Example: merge4.pl> An advanced example of merging with formatting.
  
  =item * L<Example: merge5.pl> An advanced example of merging with formatting.
  
  =item * L<Example: merge6.pl> An example of merging with Unicode strings.
  
  =item * L<Example: mod_perl1.pl> A simple mod_perl 1 program.
  
  =item * L<Example: mod_perl2.pl> A simple mod_perl 2 program.
  
  =item * L<Example: outline.pl> An example of outlines and grouping.
  
  =item * L<Example: outline_collapsed.pl> An example of collapsed outlines.
  
  =item * L<Example: panes.pl> An examples of how to create panes.
  
  =item * L<Example: properties.pl> Add document properties to a workbook.
  
  =item * L<Example: protection.pl> Example of cell locking and formula hiding.
  
  =item * L<Example: repeat.pl> Example of writing repeated formulas.
  
  =item * L<Example: right_to_left.pl> Change default sheet direction to right to left.
  
  =item * L<Example: row_wrap.pl> How to wrap data from one worksheet onto another.
  
  =item * L<Example: sales.pl> An example of a simple sales spreadsheet.
  
  =item * L<Example: sendmail.pl> Send an Excel email attachment using Mail::Sender.
  
  =item * L<Example: stats_ext.pl> Same as stats.pl with external references.
  
  =item * L<Example: stocks.pl> Demonstrates conditional formatting.
  
  =item * L<Example: tab_colors.pl> Example of how to set worksheet tab colours.
  
  =item * L<Example: textwrap.pl> Demonstrates text wrapping options.
  
  =item * L<Example: win32ole.pl> A sample Win32::OLE example for comparison.
  
  =item * L<Example: write_arrays.pl> Example of writing 1D or 2D arrays of data.
  
  =item * L<Example: write_handler1.pl> Example of extending the write() method. Step 1.
  
  =item * L<Example: write_handler2.pl> Example of extending the write() method. Step 2.
  
  =item * L<Example: write_handler3.pl> Example of extending the write() method. Step 3.
  
  =item * L<Example: write_handler4.pl> Example of extending the write() method. Step 4.
  
  =item * L<Example: write_to_scalar.pl> Example of writing an Excel file to a Perl scalar.
  
  =item * L<Example: unicode_utf16.pl> Simple example of using Unicode UTF16 strings.
  
  =item * L<Example: unicode_utf16_japan.pl> Write Japanese Unicode strings using UTF-16.
  
  =item * L<Example: unicode_cyrillic.pl> Write Russian Cyrillic strings using UTF-8.
  
  =item * L<Example: unicode_list.pl> List the chars in a Unicode font.
  
  =item * L<Example: unicode_2022_jp.pl> Japanese: ISO-2022-JP to utf8 in perl 5.8.
  
  =item * L<Example: unicode_8859_11.pl> Thai:     ISO-8859_11 to utf8 in perl 5.8.
  
  =item * L<Example: unicode_8859_7.pl> Greek:    ISO-8859_7  to utf8 in perl 5.8.
  
  =item * L<Example: unicode_big5.pl> Chinese:  BIG5        to utf8 in perl 5.8.
  
  =item * L<Example: unicode_cp1251.pl> Russian:  CP1251      to utf8 in perl 5.8.
  
  =item * L<Example: unicode_cp1256.pl> Arabic:   CP1256      to utf8 in perl 5.8.
  
  =item * L<Example: unicode_koi8r.pl> Russian:  KOI8-R      to utf8 in perl 5.8.
  
  =item * L<Example: unicode_polish_utf8.pl> Polish :  UTF8        to utf8 in perl 5.8.
  
  =item * L<Example: unicode_shift_jis.pl> Japanese: Shift JIS   to utf8 in perl 5.8.
  
  =item * L<Example: csv2xls.pl> Program to convert a CSV file to an Excel file.
  
  =item * L<Example: tab2xls.pl> Program to convert a tab separated file to xls.
  
  =item * L<Example: datecalc1.pl> Convert Unix/Perl time to Excel time.
  
  =item * L<Example: datecalc2.pl> Calculate an Excel date using Date::Calc.
  
  =item * L<Example: lecxe.pl> Convert Excel to WriteExcel using Win32::OLE.
  
  =item * L<Example: convertA1.pl> Helper functions for dealing with A1 notation.
  
  =item * L<Example: function_locale.pl> Add non-English function names to Formula.pm.
  
  =item * L<Example: writeA1.pl> Example of how to extend the module.
  
  =back
  
  =head2 Example: a_simple.pl
  
  
  
  A simple example of how to use the Spreadsheet::WriteExcel module to write
  some  text and numbers to an Excel binary file.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/a_simple.jpg" width="640" height="420" alt="Output from a_simple.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple example of how to use the Spreadsheet::WriteExcel module to write
      # some  text and numbers to an Excel binary file.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook called simple.xls and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('a_simple.xls');
      my $worksheet = $workbook->add_worksheet();
      
      # The general syntax is write($row, $column, $token). Note that row and
      # column are zero indexed
      #
      
      # Write some text
      $worksheet->write(0, 0,  "Hi Excel!");
      
      
      # Write some numbers
      $worksheet->write(2, 0,  3);          # Writes 3
      $worksheet->write(3, 0,  3.00000);    # Writes 3
      $worksheet->write(4, 0,  3.00001);    # Writes 3.00001
      $worksheet->write(5, 0,  3.14159);    # TeX revision no.?
      
      
      # Write some formulas
      $worksheet->write(7, 0,  '=A3 + A6');
      $worksheet->write(8, 0,  '=IF(A5>3,"Yes", "No")');
      
      
      # Write a hyperlink
      $worksheet->write(10, 0, 'http://www.perl.com/');
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/a_simple.pl>
  
  =head2 Example: demo.pl
  
  
  
  A simple demo of some of the features of Spreadsheet::WriteExcel.
  
  This program is used to create the project screenshot for Freshmeat:
  L<http://freshmeat.net/projects/writeexcel/>
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/demo.jpg" width="640" height="420" alt="Output from demo.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # A simple demo of some of the features of Spreadsheet::WriteExcel.
      #
      # This program is used to create the project screenshot for Freshmeat:
      # L<http://freshmeat.net/projects/writeexcel/>
      #
      # reverse(''), October 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook   = Spreadsheet::WriteExcel->new("demo.xls");
      my $worksheet  = $workbook->add_worksheet('Demo');
      my $worksheet2 = $workbook->add_worksheet('Another sheet');
      my $worksheet3 = $workbook->add_worksheet('And another');
      
      my $bold       = $workbook->add_format(bold => 1);
      
      
      #######################################################################
      #
      # Write a general heading
      #
      $worksheet->set_column('A:A', 36, $bold);
      $worksheet->set_column('B:B', 20       );
      $worksheet->set_row   (0,     40       );
      
      my $heading  = $workbook->add_format(
                                              bold    => 1,
                                              color   => 'blue',
                                              size    => 16,
                                              merge   => 1,
                                              align  => 'vcenter',
                                              );
      
      my @headings = ('Features of Spreadsheet::WriteExcel', '');
      $worksheet->write_row('A1', \@headings, $heading);
      
      
      #######################################################################
      #
      # Some text examples
      #
      my $text_format  = $workbook->add_format(
                                                  bold    => 1,
                                                  italic  => 1,
                                                  color   => 'red',
                                                  size    => 18,
                                                  font    =>'Lucida Calligraphy'
                                              );
      
      # A phrase in Cyrillic
      my $unicode = pack "H*", "042d0442043e002004440440043004370430002004".
                               "3d043000200440044304410441043a043e043c0021";
      
      
      $worksheet->write('A2', "Text");
      $worksheet->write('B2', "Hello Excel");
      $worksheet->write('A3', "Formatted text");
      $worksheet->write('B3', "Hello Excel", $text_format);
      $worksheet->write('A4', "Unicode text");
      $worksheet->write_utf16be_string('B4', $unicode);
      
      #######################################################################
      #
      # Some numeric examples
      #
      my $num1_format  = $workbook->add_format(num_format => '$#,##0.00');
      my $num2_format  = $workbook->add_format(num_format => ' d mmmm yyy');
      
      
      $worksheet->write('A5', "Numbers");
      $worksheet->write('B5', 1234.56);
      $worksheet->write('A6', "Formatted numbers");
      $worksheet->write('B6', 1234.56, $num1_format);
      $worksheet->write('A7', "Formatted numbers");
      $worksheet->write('B7', 37257, $num2_format);
      
      
      #######################################################################
      #
      # Formulae
      #
      $worksheet->set_selection('B8');
      $worksheet->write('A8', 'Formulas and functions, "=SIN(PI()/4)"');
      $worksheet->write('B8', '=SIN(PI()/4)');
      
      
      #######################################################################
      #
      # Hyperlinks
      #
      $worksheet->write('A9', "Hyperlinks");
      $worksheet->write('B9',  'http://www.perl.com/' );
      
      
      #######################################################################
      #
      # Images
      #
      $worksheet->write('A10', "Images");
      $worksheet->insert_image('B10', 'republic.png', 16, 8);
      
      
      #######################################################################
      #
      # Misc
      #
      $worksheet->write('A18', "Page/printer setup");
      $worksheet->write('A19', "Multiple worksheets");
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/demo.pl>
  
  =head2 Example: regions.pl
  
  
  
  An example of how to use the Spreadsheet:WriteExcel module to write a basic
  Excel workbook with multiple worksheets.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/regions.jpg" width="640" height="420" alt="Output from regions.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # An example of how to use the Spreadsheet:WriteExcel module to write a basic
      # Excel workbook with multiple worksheets.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new Excel workbook
      my $workbook = Spreadsheet::WriteExcel->new("regions.xls");
      
      # Add some worksheets
      my $north = $workbook->add_worksheet("North");
      my $south = $workbook->add_worksheet("South");
      my $east  = $workbook->add_worksheet("East");
      my $west  = $workbook->add_worksheet("West");
      
      # Add a Format
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color('blue');
      
      # Add a caption to each worksheet
      foreach my $worksheet ($workbook->sheets()) {
          $worksheet->write(0, 0, "Sales", $format);
      }
      
      # Write some data
      $north->write(0, 1, 200000);
      $south->write(0, 1, 100000);
      $east->write (0, 1, 150000);
      $west->write (0, 1, 100000);
      
      # Set the active worksheet
      $south->activate();
      
      # Set the width of the first column
      $south->set_column(0, 0, 20);
      
      # Set the active cell
      $south->set_selection(0, 1);
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/regions.pl>
  
  =head2 Example: stats.pl
  
  
  
  A simple example of how to use functions with the Spreadsheet::WriteExcel
  module.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/stats.jpg" width="640" height="420" alt="Output from stats.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple example of how to use functions with the Spreadsheet::WriteExcel
      # module.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("stats.xls");
      my $worksheet = $workbook->add_worksheet('Test data');
      
      # Set the column width for columns 1
      $worksheet->set_column(0, 0, 20);
      
      
      # Create a format for the headings
      my $format = $workbook->add_format();
      $format->set_bold();
      
      
      # Write the sample data
      $worksheet->write(0, 0, 'Sample', $format);
      $worksheet->write(0, 1, 1);
      $worksheet->write(0, 2, 2);
      $worksheet->write(0, 3, 3);
      $worksheet->write(0, 4, 4);
      $worksheet->write(0, 5, 5);
      $worksheet->write(0, 6, 6);
      $worksheet->write(0, 7, 7);
      $worksheet->write(0, 8, 8);
      
      $worksheet->write(1, 0, 'Length', $format);
      $worksheet->write(1, 1, 25.4);
      $worksheet->write(1, 2, 25.4);
      $worksheet->write(1, 3, 24.8);
      $worksheet->write(1, 4, 25.0);
      $worksheet->write(1, 5, 25.3);
      $worksheet->write(1, 6, 24.9);
      $worksheet->write(1, 7, 25.2);
      $worksheet->write(1, 8, 24.8);
      
      # Write some statistical functions
      $worksheet->write(4,  0, 'Count', $format);
      $worksheet->write(4,  1, '=COUNT(B1:I1)');
      
      $worksheet->write(5,  0, 'Sum', $format);
      $worksheet->write(5,  1, '=SUM(B2:I2)');
      
      $worksheet->write(6,  0, 'Average', $format);
      $worksheet->write(6,  1, '=AVERAGE(B2:I2)');
      
      $worksheet->write(7,  0, 'Min', $format);
      $worksheet->write(7,  1, '=MIN(B2:I2)');
      
      $worksheet->write(8,  0, 'Max', $format);
      $worksheet->write(8,  1, '=MAX(B2:I2)');
      
      $worksheet->write(9,  0, 'Standard Deviation', $format);
      $worksheet->write(9,  1, '=STDEV(B2:I2)');
      
      $worksheet->write(10, 0, 'Kurtosis', $format);
      $worksheet->write(10, 1, '=KURT(B2:I2)');
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/stats.pl>
  
  =head2 Example: formats.pl
  
  
  
  Examples of formatting using the Spreadsheet::WriteExcel module.
  
  This program demonstrates almost all possible formatting options. It is worth
  running this program and viewing the output Excel file if you are interested
  in the various formatting possibilities.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/formats.jpg" width="640" height="420" alt="Output from formats.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Examples of formatting using the Spreadsheet::WriteExcel module.
      #
      # This program demonstrates almost all possible formatting options. It is worth
      # running this program and viewing the output Excel file if you are interested
      # in the various formatting possibilities.
      #
      # reverse(''), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook = Spreadsheet::WriteExcel->new('formats.xls');
      
      # Some common formats
      my $center  = $workbook->add_format(align => 'center');
      my $heading = $workbook->add_format(align => 'center', bold => 1);
      
      # The named colors
      my %colors = (
                      0x08, 'black',
                      0x0C, 'blue',
                      0x10, 'brown',
                      0x0F, 'cyan',
                      0x17, 'gray',
                      0x11, 'green',
                      0x0B, 'lime',
                      0x0E, 'magenta',
                      0x12, 'navy',
                      0x35, 'orange',
                      0x21, 'pink',
                      0x14, 'purple',
                      0x0A, 'red',
                      0x16, 'silver',
                      0x09, 'white',
                      0x0D, 'yellow',
                   );
      
      # Call these subroutines to demonstrate different formatting options
      intro();
      fonts();
      named_colors();
      standard_colors();
      numeric_formats();
      borders();
      patterns();
      alignment();
      misc();
      
      # Note: this is required
      $workbook->close();
      
      
      ######################################################################
      #
      # Intro.
      #
      sub intro {
      
          my $worksheet = $workbook->add_worksheet('Introduction');
      
          $worksheet->set_column(0, 0, 60);
      
          my $format = $workbook->add_format();
          $format->set_bold();
          $format->set_size(14);
          $format->set_color('blue');
          $format->set_align('center');
      
          my $format2 = $workbook->add_format();
          $format2->set_bold();
          $format2->set_color('blue');
      
          $worksheet->write(2, 0, 'This workbook demonstrates some of',  $format);
          $worksheet->write(3, 0, 'the formatting options provided by',  $format);
          $worksheet->write(4, 0, 'the Spreadsheet::WriteExcel module.', $format);
      
          $worksheet->write('A7',  'Sections:', $format2);
          $worksheet->write('A8',  "internal:Fonts!A1",             'Fonts'          );
          $worksheet->write('A9',  "internal:'Named colors'!A1",    'Named colors'   );
          $worksheet->write('A10', "internal:'Standard colors'!A1", 'Standard colors');
          $worksheet->write('A11', "internal:'Numeric formats'!A1", 'Numeric formats');
          $worksheet->write('A12', "internal:Borders!A1",           'Borders'        );
          $worksheet->write('A13', "internal:Patterns!A1",          'Patterns'       );
          $worksheet->write('A14', "internal:Alignment!A1",         'Alignment'      );
          $worksheet->write('A15', "internal:Miscellaneous!A1",     'Miscellaneous'  );
      
      }
      
      
      ######################################################################
      #
      # Demonstrate the named colors.
      #
      sub named_colors {
      
          my $worksheet = $workbook->add_worksheet('Named colors');
      
          $worksheet->set_column(0, 3, 15);
      
          $worksheet->write(0, 0, "Index", $heading);
          $worksheet->write(0, 1, "Index", $heading);
          $worksheet->write(0, 2, "Name",  $heading);
          $worksheet->write(0, 3, "Color", $heading);
      
          my $i = 1;
      
          while (my($index, $color) = each %colors) {
              my $format = $workbook->add_format(
                                                  bg_color => $color,
                                                  pattern  => 1,
                                                  border   => 1
                                               );
      
              $worksheet->write($i+1, 0, $index,                    $center);
              $worksheet->write($i+1, 1, sprintf("0x%02X", $index), $center);
              $worksheet->write($i+1, 2, $color,                    $center);
              $worksheet->write($i+1, 3, '',                        $format);
              $i++;
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel colors in the range 8..63.
      #
      sub standard_colors {
      
          my $worksheet = $workbook->add_worksheet('Standard colors');
      
          $worksheet->set_column(0, 3, 15);
      
          $worksheet->write(0, 0, "Index", $heading);
          $worksheet->write(0, 1, "Index", $heading);
          $worksheet->write(0, 2, "Color", $heading);
          $worksheet->write(0, 3, "Name",  $heading);
      
          for my $i (8..63) {
              my $format = $workbook->add_format(
                                                  bg_color => $i,
                                                  pattern  => 1,
                                                  border   => 1
                                               );
      
              $worksheet->write(($i -7), 0, $i,                    $center);
              $worksheet->write(($i -7), 1, sprintf("0x%02X", $i), $center);
              $worksheet->write(($i -7), 2, '',                    $format);
      
              # Add the  color names
              if (exists $colors{$i}) {
                  $worksheet->write(($i -7), 3, $colors{$i}, $center);
      
              }
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard numeric formats.
      #
      sub numeric_formats {
      
          my $worksheet = $workbook->add_worksheet('Numeric formats');
      
          $worksheet->set_column(0, 4, 15);
          $worksheet->set_column(5, 5, 45);
      
          $worksheet->write(0, 0, "Index",       $heading);
          $worksheet->write(0, 1, "Index",       $heading);
          $worksheet->write(0, 2, "Unformatted", $heading);
          $worksheet->write(0, 3, "Formatted",   $heading);
          $worksheet->write(0, 4, "Negative",    $heading);
          $worksheet->write(0, 5, "Format",      $heading);
      
          my @formats;
          push @formats, [ 0x00, 1234.567,   0,         'General' ];
          push @formats, [ 0x01, 1234.567,   0,         '0' ];
          push @formats, [ 0x02, 1234.567,   0,         '0.00' ];
          push @formats, [ 0x03, 1234.567,   0,         '#,##0' ];
          push @formats, [ 0x04, 1234.567,   0,         '#,##0.00' ];
          push @formats, [ 0x05, 1234.567,   -1234.567, '($#,##0_);($#,##0)' ];
          push @formats, [ 0x06, 1234.567,   -1234.567, '($#,##0_);[Red]($#,##0)' ];
          push @formats, [ 0x07, 1234.567,   -1234.567, '($#,##0.00_);($#,##0.00)' ];
          push @formats, [ 0x08, 1234.567,   -1234.567, '($#,##0.00_);[Red]($#,##0.00)' ];
          push @formats, [ 0x09, 0.567,      0,         '0%' ];
          push @formats, [ 0x0a, 0.567,      0,         '0.00%' ];
          push @formats, [ 0x0b, 1234.567,   0,         '0.00E+00' ];
          push @formats, [ 0x0c, 0.75,       0,         '# ?/?' ];
          push @formats, [ 0x0d, 0.3125,     0,         '# ??/??' ];
          push @formats, [ 0x0e, 36892.521,  0,         'm/d/yy' ];
          push @formats, [ 0x0f, 36892.521,  0,         'd-mmm-yy' ];
          push @formats, [ 0x10, 36892.521,  0,         'd-mmm' ];
          push @formats, [ 0x11, 36892.521,  0,         'mmm-yy' ];
          push @formats, [ 0x12, 36892.521,  0,         'h:mm AM/PM' ];
          push @formats, [ 0x13, 36892.521,  0,         'h:mm:ss AM/PM' ];
          push @formats, [ 0x14, 36892.521,  0,         'h:mm' ];
          push @formats, [ 0x15, 36892.521,  0,         'h:mm:ss' ];
          push @formats, [ 0x16, 36892.521,  0,         'm/d/yy h:mm' ];
          push @formats, [ 0x25, 1234.567,   -1234.567, '(#,##0_);(#,##0)' ];
          push @formats, [ 0x26, 1234.567,   -1234.567, '(#,##0_);[Red](#,##0)' ];
          push @formats, [ 0x27, 1234.567,   -1234.567, '(#,##0.00_);(#,##0.00)' ];
          push @formats, [ 0x28, 1234.567,   -1234.567, '(#,##0.00_);[Red](#,##0.00)' ];
          push @formats, [ 0x29, 1234.567,   -1234.567, '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)' ];
          push @formats, [ 0x2a, 1234.567,   -1234.567, '_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)' ];
          push @formats, [ 0x2b, 1234.567,   -1234.567, '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)' ];
          push @formats, [ 0x2c, 1234.567,   -1234.567, '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)' ];
          push @formats, [ 0x2d, 36892.521,  0,         'mm:ss' ];
          push @formats, [ 0x2e, 3.0153,     0,         '[h]:mm:ss' ];
          push @formats, [ 0x2f, 36892.521,  0,         'mm:ss.0' ];
          push @formats, [ 0x30, 1234.567,   0,         '##0.0E+0' ];
          push @formats, [ 0x31, 1234.567,   0,         '@' ];
      
          my $i;
          foreach my $format (@formats){
              my $style = $workbook->add_format();
              $style->set_num_format($format->[0]);
      
              $i++;
              $worksheet->write($i, 0, $format->[0],                    $center);
              $worksheet->write($i, 1, sprintf("0x%02X", $format->[0]), $center);
              $worksheet->write($i, 2, $format->[1],                    $center);
              $worksheet->write($i, 3, $format->[1],                    $style);
      
              if ($format->[2]) {
                  $worksheet->write($i, 4, $format->[2], $style);
              }
      
              $worksheet->write_string($i, 5, $format->[3]);
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the font options.
      #
      sub fonts {
      
          my $worksheet = $workbook->add_worksheet('Fonts');
      
          $worksheet->set_column(0, 0, 30);
          $worksheet->set_column(1, 1, 10);
      
          $worksheet->write(0, 0, "Font name",   $heading);
          $worksheet->write(0, 1, "Font size",   $heading);
      
          my @fonts;
          push @fonts, [ 10, 'Arial' ];
          push @fonts, [ 12, 'Arial' ];
          push @fonts, [ 14, 'Arial' ];
          push @fonts, [ 12, 'Arial Black' ];
          push @fonts, [ 12, 'Arial Narrow' ];
          push @fonts, [ 12, 'Century Schoolbook' ];
          push @fonts, [ 12, 'Courier' ];
          push @fonts, [ 12, 'Courier New' ];
          push @fonts, [ 12, 'Garamond' ];
          push @fonts, [ 12, 'Impact' ];
          push @fonts, [ 12, 'Lucida Handwriting'] ;
          push @fonts, [ 12, 'Times New Roman' ];
          push @fonts, [ 12, 'Symbol' ];
          push @fonts, [ 12, 'Wingdings' ];
          push @fonts, [ 12, 'A font that doesn\'t exist' ];
      
          my $i;
          foreach my $font (@fonts){
              my $format = $workbook->add_format();
      
              $format->set_size($font->[0]);
              $format->set_font($font->[1]);
      
              $i++;
              $worksheet->write($i, 0, $font->[1], $format);
              $worksheet->write($i, 1, $font->[0], $format);
          }
      
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel border styles.
      #
      sub borders {
      
          my $worksheet = $workbook->add_worksheet('Borders');
      
          $worksheet->set_column(0, 4, 10);
          $worksheet->set_column(5, 5, 40);
      
          $worksheet->write(0, 0, "Index", $heading);
          $worksheet->write(0, 1, "Index", $heading);
          $worksheet->write(0, 3, "Style", $heading);
          $worksheet->write(0, 5, "The style is highlighted in red for ", $heading);
          $worksheet->write(1, 5, "emphasis, the default color is black.", $heading);
      
          for my $i (0..13){
              my $format = $workbook->add_format();
              $format->set_border($i);
              $format->set_border_color('red');
              $format->set_align('center');
      
              $worksheet->write((2*($i+1)), 0, $i,                    $center);
              $worksheet->write((2*($i+1)), 1, sprintf("0x%02X", $i), $center);
      
              $worksheet->write((2*($i+1)), 3, "Border", $format);
          }
      
          $worksheet->write(30, 0, "Diag type", $heading);
          $worksheet->write(30, 1, "Index", $heading);
          $worksheet->write(30, 3, "Style", $heading);
          $worksheet->write(30, 5, "Diagonal Boder styles", $heading);
      
          for my $i (1..3){
              my $format = $workbook->add_format();
              $format->set_diag_type($i);
              $format->set_diag_border(1);
              $format->set_diag_color('red');
              $format->set_align('center');
      
              $worksheet->write((2*($i+15)), 0, $i,                     $center);
              $worksheet->write((2*($i+15)), 1, sprintf("0x%02X", $i),  $center);
      
              $worksheet->write((2*($i+15)), 3, "Border", $format);
          }
      }
      
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel cell patterns.
      #
      sub patterns {
      
          my $worksheet = $workbook->add_worksheet('Patterns');
      
          $worksheet->set_column(0, 4, 10);
          $worksheet->set_column(5, 5, 50);
      
          $worksheet->write(0, 0, "Index", $heading);
          $worksheet->write(0, 1, "Index", $heading);
          $worksheet->write(0, 3, "Pattern", $heading);
      
          $worksheet->write(0, 5, "The background colour has been set to silver.", $heading);
          $worksheet->write(1, 5, "The foreground colour has been set to green.",  $heading);
      
          for my $i (0..18){
              my $format = $workbook->add_format();
      
              $format->set_pattern($i);
              $format->set_bg_color('silver');
              $format->set_fg_color('green');
              $format->set_align('center');
      
              $worksheet->write((2*($i+1)), 0, $i,                    $center);
              $worksheet->write((2*($i+1)), 1, sprintf("0x%02X", $i), $center);
      
              $worksheet->write((2*($i+1)), 3, "Pattern", $format);
      
              if ($i == 1) {
                  $worksheet->write((2*($i+1)), 5, "This is solid colour, the most useful pattern.", $heading);
              }
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel cell alignments.
      #
      sub alignment {
      
          my $worksheet = $workbook->add_worksheet('Alignment');
      
          $worksheet->set_column(0, 7, 12);
          $worksheet->set_row(0, 40);
          $worksheet->set_selection(7, 0);
      
          my $format01 = $workbook->add_format();
          my $format02 = $workbook->add_format();
          my $format03 = $workbook->add_format();
          my $format04 = $workbook->add_format();
          my $format05 = $workbook->add_format();
          my $format06 = $workbook->add_format();
          my $format07 = $workbook->add_format();
          my $format08 = $workbook->add_format();
          my $format09 = $workbook->add_format();
          my $format10 = $workbook->add_format();
          my $format11 = $workbook->add_format();
          my $format12 = $workbook->add_format();
          my $format13 = $workbook->add_format();
          my $format14 = $workbook->add_format();
          my $format15 = $workbook->add_format();
          my $format16 = $workbook->add_format();
          my $format17 = $workbook->add_format();
      
          $format02->set_align('top');
          $format03->set_align('bottom');
          $format04->set_align('vcenter');
          $format05->set_align('vjustify');
          $format06->set_text_wrap();
      
          $format07->set_align('left');
          $format08->set_align('right');
          $format09->set_align('center');
          $format10->set_align('fill');
          $format11->set_align('justify');
          $format12->set_merge();
      
          $format13->set_rotation(45);
          $format14->set_rotation(-45);
          $format15->set_rotation(270);
      
          $format16->set_shrink();
          $format17->set_indent(1);
      
          $worksheet->write(0, 0, 'Vertical',     $heading);
          $worksheet->write(0, 1, 'top',          $format02);
          $worksheet->write(0, 2, 'bottom',       $format03);
          $worksheet->write(0, 3, 'vcenter',      $format04);
          $worksheet->write(0, 4, 'vjustify',     $format05);
          $worksheet->write(0, 5, "text\nwrap",   $format06);
      
          $worksheet->write(2, 0, 'Horizontal',   $heading);
          $worksheet->write(2, 1, 'left',         $format07);
          $worksheet->write(2, 2, 'right',        $format08);
          $worksheet->write(2, 3, 'center',       $format09);
          $worksheet->write(2, 4, 'fill',         $format10);
          $worksheet->write(2, 5, 'justify',      $format11);
      
          $worksheet->write(3, 1, 'merge',        $format12);
          $worksheet->write(3, 2, '',             $format12);
      
          $worksheet->write(3, 3, 'Shrink ' x 3,  $format16);
          $worksheet->write(3, 4, 'Indent',       $format17);
      
      
          $worksheet->write(5, 0, 'Rotation',     $heading);
          $worksheet->write(5, 1, 'Rotate 45',    $format13);
          $worksheet->write(6, 1, 'Rotate -45',   $format14);
          $worksheet->write(7, 1, 'Rotate 270',   $format15);
      }
      
      
      ######################################################################
      #
      # Demonstrate other miscellaneous features.
      #
      sub misc {
      
          my $worksheet = $workbook->add_worksheet('Miscellaneous');
      
          $worksheet->set_column(2, 2, 25);
      
          my $format01 = $workbook->add_format();
          my $format02 = $workbook->add_format();
          my $format03 = $workbook->add_format();
          my $format04 = $workbook->add_format();
          my $format05 = $workbook->add_format();
          my $format06 = $workbook->add_format();
          my $format07 = $workbook->add_format();
      
          $format01->set_underline(0x01);
          $format02->set_underline(0x02);
          $format03->set_underline(0x21);
          $format04->set_underline(0x22);
          $format05->set_font_strikeout();
          $format06->set_font_outline();
          $format07->set_font_shadow();
      
          $worksheet->write(1,  2, 'Underline  0x01',          $format01);
          $worksheet->write(3,  2, 'Underline  0x02',          $format02);
          $worksheet->write(5,  2, 'Underline  0x21',          $format03);
          $worksheet->write(7,  2, 'Underline  0x22',          $format04);
          $worksheet->write(9,  2, 'Strikeout',                $format05);
          $worksheet->write(11, 2, 'Outline (Macintosh only)', $format06);
          $worksheet->write(13, 2, 'Shadow (Macintosh only)',  $format07);
      }
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/formats.pl>
  
  =head2 Example: bug_report.pl
  
  
  
  A template for submitting a bug report.
  
  Run this program and read the output from the command line.
  
  
  
      #!/usr/bin/perl -w
      
      
      ###############################################################################
      #
      # A template for submitting a bug report.
      #
      # Run this program and read the output from the command line.
      #
      # reverse(''), March 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      
      print << 'HINTS_1';
      
      REPORTING A BUG OR ASKING A QUESTION
      
          Feel free to report bugs or ask questions. However, to save time
          consider the following steps first:
      
          Read the documentation:
      
              The Spreadsheet::WriteExcel documentation has been refined in
              response to user questions. Therefore, if you have a question it is
              possible that someone else has asked it before you and that it is
              already addressed in the documentation. Since there is a lot of
              documentation to get through you should at least read the table of
              contents and search for keywords that you are interested in.
      
          Look at the example programs:
      
              There are over 70 example programs shipped with the standard
              Spreadsheet::WriteExcel distribution. Many of these were created in
              response to user questions. Try to identify an example program that
              corresponds to your query and adapt it to your needs.
      
      HINTS_1
      print "Press enter ..."; <STDIN>;
      
      print << 'HINTS_2';
      
          If you submit a bug report here are some pointers.
      
          1.  Put "WriteExcel:" at the beginning of the subject line. This helps
              to filter genuine messages from spam.
      
          2.  Describe the problems as clearly and as concisely as possible.
      
          3.  Send a sample program. It is often easier to describe a problem in
              code than in written prose.
      
          4.  The sample program should be as small as possible to demonstrate the
              problem. Don't copy and past large sections of your program. The
              program should also be self contained and working.
      
          A sample bug report is generated below. If you use this format then it
          will help to analyse your question and respond to it more quickly.
      
          Please don't send patches without contacting the author first.
      
      
      HINTS_2
      print "Press enter ..."; <STDIN>;
      
      
      print << 'EMAIL';
      
      =======================================================================
      
      To:      John McNamara <jmcnamara@cpan.org>
      Subject: WriteExcel: Problem with something.
      
      Hi John,
      
      I am using Spreadsheet::WriteExcel and I have encountered a problem. I
      want it to do SOMETHING but the module appears to do SOMETHING_ELSE.
      
      Here is some code that demonstrates the problem.
      
          #!/usr/bin/perl -w
      
          use strict;
          use Spreadsheet::WriteExcel;
      
          my $workbook  = Spreadsheet::WriteExcel->new("reload.xls");
          my $worksheet = $workbook->add_worksheet();
      
          $worksheet->write(0, 0, "Hi Excel!");
      
          __END__
      
      
      I tested using Excel XX (or Gnumeric or OpenOffice.org).
      
      My automatically generated system details are as follows:
      EMAIL
      
      
      print "\n    Perl version   : $]";
      print "\n    OS name        : $^O";
      print "\n    Module versions: (not all are required)\n";
      
      
      my @modules = qw(
                        Spreadsheet::WriteExcel
                        Spreadsheet::ParseExcel
                        OLE::Storage_Lite
                        Parse::RecDescent
                        File::Temp
                        Digest::MD4
                        Digest::Perl::MD4
                        Digest::MD5
                      );
      
      
      for my $module (@modules) {
          my $version;
          eval "require $module";
      
          if (not $@) {
              $version = $module->VERSION;
              $version = '(unknown)' if not defined $version;
          }
          else {
              $version = '(not installed)';
          }
      
          printf "%21s%-24s\t%s\n", "", $module, $version;
      }
      
      
      print << "BYE";
      Yours etc.,
      
      A. Person
      --
      
      BYE
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/bug_report.pl>
  
  =head2 Example: autofilter.pl
  
  
  
  An example of how to create autofilters with Spreadsheet::WriteExcel.
  
  An autofilter is a way of adding drop down lists to the headers of a 2D range
  of worksheet data. This is turn allow users to filter the data based on
  simple criteria so that some data is shown and some is hidden.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/autofilter.jpg" width="640" height="420" alt="Output from autofilter.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # An example of how to create autofilters with Spreadsheet::WriteExcel.
      #
      # An autofilter is a way of adding drop down lists to the headers of a 2D range
      # of worksheet data. This is turn allow users to filter the data based on
      # simple criteria so that some data is shown and some is hidden.
      #
      # reverse(''), September 2007, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook   = Spreadsheet::WriteExcel->new('autofilter.xls');
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      my $worksheet4 = $workbook->add_worksheet();
      my $worksheet5 = $workbook->add_worksheet();
      my $worksheet6 = $workbook->add_worksheet();
      
      my $bold       = $workbook->add_format(bold => 1);
      
      
      # Extract the data embedded at the end of this file.
      my @headings = split ' ', <DATA>;
      my @data;
      push @data, [split] while <DATA>;
      
      
      # Set up several sheets with the same data.
      for my $worksheet ($workbook->sheets()) {
          $worksheet->set_column('A:D', 12);
          $worksheet->set_row(0, 20, $bold);
          $worksheet->write('A1', \@headings);
      }
      
      
      ###############################################################################
      #
      # Example 1. Autofilter without conditions.
      #
      
      $worksheet1->autofilter('A1:D51');
      $worksheet1->write('A2', [[@data]]);
      
      
      ###############################################################################
      #
      #
      # Example 2. Autofilter with a filter condition in the first column.
      #
      
      # The range in this example is the same as above but in row-column notation.
      $worksheet2->autofilter(0, 0, 50, 3);
      
      # The placeholder "Region" in the filter is ignored and can be any string
      # that adds clarity to the expression.
      #
      $worksheet2->filter_column(0, 'Region eq East');
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      my $row = 1;
      
      for my $row_data (@data) {
          my $region = $row_data->[0];
      
          if ($region eq 'East') {
              # Row is visible.
          }
          else {
              # Hide row.
              $worksheet2->set_row($row, undef, undef, 1);
          }
      
          $worksheet2->write($row++, 0, $row_data);
      }
      
      
      ###############################################################################
      #
      #
      # Example 3. Autofilter with a dual filter condition in one of the columns.
      #
      
      $worksheet3->autofilter('A1:D51');
      
      $worksheet3->filter_column('A', 'x eq East or x eq South');
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data (@data) {
          my $region = $row_data->[0];
      
          if ($region eq 'East' or $region eq 'South') {
              # Row is visible.
          }
          else {
              # Hide row.
              $worksheet3->set_row($row, undef, undef, 1);
          }
      
          $worksheet3->write($row++, 0, $row_data);
      }
      
      
      ###############################################################################
      #
      #
      # Example 4. Autofilter with filter conditions in two columns.
      #
      
      $worksheet4->autofilter('A1:D51');
      
      $worksheet4->filter_column('A', 'x eq East');
      $worksheet4->filter_column('C', 'x > 3000 and x < 8000' );
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data (@data) {
          my $region = $row_data->[0];
          my $volume = $row_data->[2];
      
          if ($region eq 'East' and
              $volume >  3000   and $volume < 8000
          )
          {
              # Row is visible.
          }
          else {
              # Hide row.
              $worksheet4->set_row($row, undef, undef, 1);
          }
      
          $worksheet4->write($row++, 0, $row_data);
      }
      
      
      ###############################################################################
      #
      #
      # Example 5. Autofilter with filter for blanks.
      #
      
      # Create a blank cell in our test data.
      $data[5]->[0] = '';
      
      
      $worksheet5->autofilter('A1:D51');
      $worksheet5->filter_column('A', 'x == Blanks');
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data (@data) {
          my $region = $row_data->[0];
      
          if ($region eq '')
          {
              # Row is visible.
          }
          else {
              # Hide row.
              $worksheet5->set_row($row, undef, undef, 1);
          }
      
          $worksheet5->write($row++, 0, $row_data);
      }
      
      
      ###############################################################################
      #
      #
      # Example 6. Autofilter with filter for non-blanks.
      #
      
      
      $worksheet6->autofilter('A1:D51');
      $worksheet6->filter_column('A', 'x == NonBlanks');
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data (@data) {
          my $region = $row_data->[0];
      
          if ($region ne '')
          {
              # Row is visible.
          }
          else {
              # Hide row.
              $worksheet6->set_row($row, undef, undef, 1);
          }
      
          $worksheet6->write($row++, 0, $row_data);
      }
      
      
      
      __DATA__
      Region    Item      Volume    Month
      East      Apple     9000      July
      East      Apple     5000      July
      South     Orange    9000      September
      North     Apple     2000      November
      West      Apple     9000      November
      South     Pear      7000      October
      North     Pear      9000      August
      West      Orange    1000      December
      West      Grape     1000      November
      South     Pear      10000     April
      West      Grape     6000      January
      South     Orange    3000      May
      North     Apple     3000      December
      South     Apple     7000      February
      West      Grape     1000      December
      East      Grape     8000      February
      South     Grape     10000     June
      West      Pear      7000      December
      South     Apple     2000      October
      East      Grape     7000      December
      North     Grape     6000      April
      East      Pear      8000      February
      North     Apple     7000      August
      North     Orange    7000      July
      North     Apple     6000      June
      South     Grape     8000      September
      West      Apple     3000      October
      South     Orange    10000     November
      West      Grape     4000      July
      North     Orange    5000      August
      East      Orange    1000      November
      East      Orange    4000      October
      North     Grape     5000      August
      East      Apple     1000      December
      South     Apple     10000     March
      East      Grape     7000      October
      West      Grape     1000      September
      East      Grape     10000     October
      South     Orange    8000      March
      North     Apple     4000      July
      South     Orange    5000      July
      West      Apple     4000      June
      East      Apple     5000      April
      North     Pear      3000      August
      East      Grape     9000      November
      North     Orange    8000      October
      East      Apple     10000     June
      South     Pear      1000      December
      North     Grape     10000     July
      East      Grape     6000      February
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/autofilter.pl>
  
  =head2 Example: autofit.pl
  
  
  
  Simulate Excel's autofit for column widths.
  
  Excel provides a function called Autofit (Format->Columns->Autofit) that
  adjusts column widths to match the length of the longest string in a column.
  Excel calculates these widths at run time when it has access to information
  about string lengths and font information. This function is *not* a feature
  of the file format and thus cannot be implemented by Spreadsheet::WriteExcel.
  
  However, we can make an attempt to simulate it by keeping track of the
  longest string written to each column and then adjusting the column widths
  prior to closing the file.
  
  We keep track of the longest strings by adding a handler to the write()
  function. See add_handler() in the S::WE docs for more information.
  
  The main problem with trying to simulate Autofit lies in defining a
  relationship between a string length and its width in a arbitrary font and
  size. We use two approaches below. The first is a simple direct relationship
  obtained by trial and error. The second is a slightly more sophisticated
  method using an external module. For more complicated applications you will
  probably have to work out your own methods.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/autofit.jpg" width="640" height="420" alt="Output from autofit.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # Simulate Excel's autofit for column widths.
      #
      # Excel provides a function called Autofit (Format->Columns->Autofit) that
      # adjusts column widths to match the length of the longest string in a column.
      # Excel calculates these widths at run time when it has access to information
      # about string lengths and font information. This function is *not* a feature
      # of the file format and thus cannot be implemented by Spreadsheet::WriteExcel.
      #
      # However, we can make an attempt to simulate it by keeping track of the
      # longest string written to each column and then adjusting the column widths
      # prior to closing the file.
      #
      # We keep track of the longest strings by adding a handler to the write()
      # function. See add_handler() in the S::WE docs for more information.
      #
      # The main problem with trying to simulate Autofit lies in defining a
      # relationship between a string length and its width in a arbitrary font and
      # size. We use two approaches below. The first is a simple direct relationship
      # obtained by trial and error. The second is a slightly more sophisticated
      # method using an external module. For more complicated applications you will
      # probably have to work out your own methods.
      #
      # reverse(''), May 2006, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook    = Spreadsheet::WriteExcel->new('autofit.xls');
      my $worksheet   = $workbook->add_worksheet();
      
      
      ###############################################################################
      #
      # Add a handler to store the width of the longest string written to a column.
      # We use the stored width to simulate an autofit of the column widths.
      #
      # You should do this for every worksheet you want to autofit.
      #
      $worksheet->add_write_handler(qr[\w], \&store_string_widths);
      
      
      
      $worksheet->write('A1', 'Hello');
      $worksheet->write('B1', 'Hello World');
      $worksheet->write('D1', 'Hello');
      $worksheet->write('F1', 'This is a long string as an example.');
      
      # Run the autofit after you have finished writing strings to the workbook.
      autofit_columns($worksheet);
      
      
      
      ###############################################################################
      #
      # Functions used for Autofit.
      #
      ###############################################################################
      
      ###############################################################################
      #
      # Adjust the column widths to fit the longest string in the column.
      #
      sub autofit_columns {
      
          my $worksheet = shift;
          my $col       = 0;
      
          for my $width (@{$worksheet->{__col_widths}}) {
      
              $worksheet->set_column($col, $col, $width) if $width;
              $col++;
          }
      }
      
      
      ###############################################################################
      #
      # The following function is a callback that was added via add_write_handler()
      # above. It modifies the write() function so that it stores the maximum
      # unwrapped width of a string in a column.
      #
      sub store_string_widths {
      
          my $worksheet = shift;
          my $col       = $_[1];
          my $token     = $_[2];
      
          # Ignore some tokens that we aren't interested in.
          return if not defined $token;       # Ignore undefs.
          return if $token eq '';             # Ignore blank cells.
          return if ref $token eq 'ARRAY';    # Ignore array refs.
          return if $token =~ /^=/;           # Ignore formula
      
          # Ignore numbers
          return if $token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
      
          # Ignore various internal and external hyperlinks. In a real scenario
          # you may wish to track the length of the optional strings used with
          # urls.
          return if $token =~ m{^[fh]tt?ps?://};
          return if $token =~ m{^mailto:};
          return if $token =~ m{^(?:in|ex)ternal:};
      
      
          # We store the string width as data in the Worksheet object. We use
          # a double underscore key name to avoid conflicts with future names.
          #
          my $old_width    = $worksheet->{__col_widths}->[$col];
          my $string_width = string_width($token);
      
          if (not defined $old_width or $string_width > $old_width) {
              # You may wish to set a minimum column width as follows.
              #return undef if $string_width < 10;
      
              $worksheet->{__col_widths}->[$col] = $string_width;
          }
      
      
          # Return control to write();
          return undef;
      }
      
      
      ###############################################################################
      #
      # Very simple conversion between string length and string width for Arial 10.
      # See below for a more sophisticated method.
      #
      sub string_width {
      
          return 0.9 * length $_[0];
      }
      
      __END__
      
      
      
      ###############################################################################
      #
      # This function uses an external module to get a more accurate width for a
      # string. Note that in a real program you could "use" the module instead of
      # "require"-ing it and you could make the Font object global to avoid repeated
      # initialisation.
      #
      # Note also that the $pixel_width to $cell_width is specific to Arial. For
      # other fonts you should calculate appropriate relationships. A future version
      # of S::WE will provide a way of specifying column widths in pixels instead of
      # cell units in order to simplify this conversion.
      #
      sub string_width {
      
          require Font::TTFMetrics;
      
          my $arial        = Font::TTFMetrics->new('c:\windows\fonts\arial.ttf');
      
          my $font_size    = 10;
          my $dpi          = 96;
          my $units_per_em = $arial->get_units_per_em();
          my $font_width   = $arial->string_width($_[0]);
      
          # Convert to pixels as per TTFMetrics docs.
          my $pixel_width  = 6 + $font_width *$font_size *$dpi /(72 *$units_per_em);
      
          # Add extra pixels for border around text.
          $pixel_width  += 6;
      
          # Convert to cell width (for Arial) and for cell widths > 1.
          my $cell_width   = ($pixel_width -5) /7;
      
          return $cell_width;
      
      }
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/autofit.pl>
  
  =head2 Example: bigfile.pl
  
  
  
  Example of creating a Spreadsheet::WriteExcel that is larger than the
  default 7MB limit.
  
  This is exactly that same as any other Spreadsheet::WriteExcel program except
  that is requires that the OLE::Storage module is installed.
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/bigfile.jpg" width="640" height="420" alt="Output from bigfile.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of creating a Spreadsheet::WriteExcel that is larger than the
      # default 7MB limit.
      #
      # This is exactly that same as any other Spreadsheet::WriteExcel program except
      # that is requires that the OLE::Storage module is installed.
      #
      # reverse(''), Jan 2007, John McNamara, jmcnamara@cpan.org
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new('bigfile.xls');
      my $worksheet = $workbook->add_worksheet();
      
      $worksheet->set_column(0, 50, 18);
      
      for my $col (0 .. 50) {
          for my $row (0 .. 6000) {
              $worksheet->write($row, $col, "Row: $row Col: $col");
          }
      }
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/bigfile.pl>
  
  =head2 Example: cgi.pl
  
  
  
  Example of how to use the Spreadsheet::WriteExcel module to send an Excel
  file to a browser in a CGI program.
  
  On Windows the hash-bang line should be something like:
  
      #!C:\Perl\bin\perl.exe
  
  The "Content-Disposition" line will cause a prompt to be generated to save
  the file. If you want to stream the file to the browser instead, comment out
  that line as shown below.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the Spreadsheet::WriteExcel module to send an Excel
      # file to a browser in a CGI program.
      #
      # On Windows the hash-bang line should be something like:
      #
      #     #!C:\Perl\bin\perl.exe
      #
      # The "Content-Disposition" line will cause a prompt to be generated to save
      # the file. If you want to stream the file to the browser instead, comment out
      # that line as shown below.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Set the filename and send the content type
      my $filename ="cgitest.xls";
      
      print "Content-type: application/vnd.ms-excel\n";
      # The Content-Disposition will generate a prompt to save the file. If you want
      # to stream the file to the browser, comment out the following line.
      print "Content-Disposition: attachment; filename=$filename\n";
      print "\n";
      
      # Create a new workbook and add a worksheet. The special Perl filehandle - will
      # redirect the output to STDOUT
      #
      my $workbook  = Spreadsheet::WriteExcel->new(\*STDOUT);
      my $worksheet = $workbook->add_worksheet();
      
      
      # Set the column width for column 1
      $worksheet->set_column(0, 0, 20);
      
      
      # Create a format
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_size(15);
      $format->set_color('blue');
      
      
      # Write to the workbook
      $worksheet->write(0, 0, "Hi Excel!", $format);
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/cgi.pl>
  
  =head2 Example: chart_area.pl
  
  
  
  A simple demo of Area charts in Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chart_area.jpg" width="640" height="420" alt="Output from chart_area.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple demo of Area charts in Spreadsheet::WriteExcel.
      #
      # reverse(''), December 2009, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_area.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values 1', 'Values 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      
      ###############################################################################
      #
      # Example 1. A minimal chart.
      #
      my $chart1 = $workbook->add_chart( type => 'area' );
      
      # Add values only. Use the default categories.
      $chart1->add_series( values => '=Sheet1!$B$2:$B$7' );
      
      
      ###############################################################################
      #
      # Example 2. A minimal chart with user specified categories (X axis)
      #            and a series name.
      #
      my $chart2 = $workbook->add_chart( type => 'area' );
      
      # Configure the series.
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      
      ###############################################################################
      #
      # Example 3. Same as previous chart but with added title and axes labels.
      #
      my $chart3 = $workbook->add_chart( type => 'area' );
      
      # Configure the series.
      $chart3->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart3->set_title( name => 'Results of sample analysis' );
      $chart3->set_x_axis( name => 'Sample number' );
      $chart3->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 4. Same as previous chart but with an added series and with a
      #            user specified chart sheet name.
      #
      my $chart4 = $workbook->add_chart( name => 'Results Chart', type => 'area' );
      
      # Configure the series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add another series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          name       => 'Test data series 2',
      );
      
      # Add some labels.
      $chart4->set_title( name => 'Results of sample analysis' );
      $chart4->set_x_axis( name => 'Sample number' );
      $chart4->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 5. Same as Example 3 but as an embedded chart.
      #
      my $chart5 = $workbook->add_chart( type => 'area', embedded => 1 );
      
      # Configure the series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart5->set_title( name => 'Results of sample analysis' );
      $chart5->set_x_axis( name => 'Sample number' );
      $chart5->set_y_axis( name => 'Sample length (cm)' );
      
      # Insert the chart into the main worksheet.
      $worksheet->insert_chart( 'E2', $chart5 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chart_area.pl>
  
  =head2 Example: chart_bar.pl
  
  
  
  A simple demo of Bar charts in Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chart_bar.jpg" width="640" height="420" alt="Output from chart_bar.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple demo of Bar charts in Spreadsheet::WriteExcel.
      #
      # reverse(''), December 2009, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_bar.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values 1', 'Values 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      
      ###############################################################################
      #
      # Example 1. A minimal chart.
      #
      my $chart1 = $workbook->add_chart( type => 'bar' );
      
      # Add values only. Use the default categories.
      $chart1->add_series( values => '=Sheet1!$B$2:$B$7' );
      
      
      ###############################################################################
      #
      # Example 2. A minimal chart with user specified categories (X axis)
      #            and a series name.
      #
      my $chart2 = $workbook->add_chart( type => 'bar' );
      
      # Configure the series.
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      
      ###############################################################################
      #
      # Example 3. Same as previous chart but with added title and axes labels.
      #
      my $chart3 = $workbook->add_chart( type => 'bar' );
      
      # Configure the series.
      $chart3->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart3->set_title( name => 'Results of sample analysis' );
      $chart3->set_x_axis( name => 'Sample number' );
      $chart3->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 4. Same as previous chart but with an added series and with a
      #            user specified chart sheet name.
      #
      my $chart4 = $workbook->add_chart( name => 'Results Chart', type => 'bar' );
      
      # Configure the series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add another series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          name       => 'Test data series 2',
      );
      
      # Add some labels.
      $chart4->set_title( name => 'Results of sample analysis' );
      $chart4->set_x_axis( name => 'Sample number' );
      $chart4->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 5. Same as Example 3 but as an embedded chart.
      #
      my $chart5 = $workbook->add_chart( type => 'bar', embedded => 1 );
      
      # Configure the series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart5->set_title( name => 'Results of sample analysis' );
      $chart5->set_x_axis( name => 'Sample number' );
      $chart5->set_y_axis( name => 'Sample length (cm)' );
      
      # Insert the chart into the main worksheet.
      $worksheet->insert_chart( 'E2', $chart5 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chart_bar.pl>
  
  =head2 Example: chart_column.pl
  
  
  
  A simple demo of Column charts in Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chart_column.jpg" width="640" height="420" alt="Output from chart_column.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple demo of Column charts in Spreadsheet::WriteExcel.
      #
      # reverse(''), December 2009, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_column.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values 1', 'Values 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      
      ###############################################################################
      #
      # Example 1. A minimal chart.
      #
      my $chart1 = $workbook->add_chart( type => 'column' );
      
      # Add values only. Use the default categories.
      $chart1->add_series( values => '=Sheet1!$B$2:$B$7' );
      
      
      ###############################################################################
      #
      # Example 2. A minimal chart with user specified categories (X axis)
      #            and a series name.
      #
      my $chart2 = $workbook->add_chart( type => 'column' );
      
      # Configure the series.
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      
      ###############################################################################
      #
      # Example 3. Same as previous chart but with added title and axes labels.
      #
      my $chart3 = $workbook->add_chart( type => 'column' );
      
      # Configure the series.
      $chart3->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart3->set_title( name => 'Results of sample analysis' );
      $chart3->set_x_axis( name => 'Sample number' );
      $chart3->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 4. Same as previous chart but with an added series and with a
      #            user specified chart sheet name.
      #
      my $chart4 = $workbook->add_chart( name => 'Results Chart', type => 'column' );
      
      # Configure the series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add another series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          name       => 'Test data series 2',
      );
      
      # Add some labels.
      $chart4->set_title( name => 'Results of sample analysis' );
      $chart4->set_x_axis( name => 'Sample number' );
      $chart4->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 5. Same as Example 3 but as an embedded chart.
      #
      my $chart5 = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Configure the series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart5->set_title( name => 'Results of sample analysis' );
      $chart5->set_x_axis( name => 'Sample number' );
      $chart5->set_y_axis( name => 'Sample length (cm)' );
      
      # Insert the chart into the main worksheet.
      $worksheet->insert_chart( 'E2', $chart5 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chart_column.pl>
  
  =head2 Example: chart_line.pl
  
  
  
  A simple demo of Line charts in Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chart_line.jpg" width="640" height="420" alt="Output from chart_line.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple demo of Line charts in Spreadsheet::WriteExcel.
      #
      # reverse(''), December 2009, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_line.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values 1', 'Values 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      
      ###############################################################################
      #
      # Example 1. A minimal chart.
      #
      my $chart1 = $workbook->add_chart( type => 'line' );
      
      # Add values only. Use the default categories.
      $chart1->add_series( values => '=Sheet1!$B$2:$B$7' );
      
      
      ###############################################################################
      #
      # Example 2. A minimal chart with user specified categories (X axis)
      #            and a series name.
      #
      my $chart2 = $workbook->add_chart( type => 'line' );
      
      # Configure the series.
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      
      ###############################################################################
      #
      # Example 3. Same as previous chart but with added title and axes labels.
      #
      my $chart3 = $workbook->add_chart( type => 'line' );
      
      # Configure the series.
      $chart3->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart3->set_title( name => 'Results of sample analysis' );
      $chart3->set_x_axis( name => 'Sample number' );
      $chart3->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 4. Same as previous chart but with an added series and with a
      #            user specified chart sheet name.
      #
      my $chart4 = $workbook->add_chart( name => 'Results Chart', type => 'line' );
      
      # Configure the series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add another series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          name       => 'Test data series 2',
      );
      
      # Add some labels.
      $chart4->set_title( name => 'Results of sample analysis' );
      $chart4->set_x_axis( name => 'Sample number' );
      $chart4->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 5. Same as Example 3 but as an embedded chart.
      #
      my $chart5 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure the series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart5->set_title( name => 'Results of sample analysis' );
      $chart5->set_x_axis( name => 'Sample number' );
      $chart5->set_y_axis( name => 'Sample length (cm)' );
      
      # Insert the chart into the main worksheet.
      $worksheet->insert_chart( 'E2', $chart5 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chart_line.pl>
  
  =head2 Example: chart_pie.pl
  
  
  
  A simple demo of Pie charts in Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chart_pie.jpg" width="640" height="420" alt="Output from chart_pie.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple demo of Pie charts in Spreadsheet::WriteExcel.
      #
      # reverse(''), December 2009, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_pie.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values' ];
      my $data = [
          [ 'Apple', 'Cherry', 'Pecan' ],
          [ 60,       30,       10     ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      
      ###############################################################################
      #
      # Example 1. A minimal chart.
      #
      my $chart1 = $workbook->add_chart( type => 'pie' );
      
      # Add values only. Use the default categories.
      $chart1->add_series( values => '=Sheet1!$B$2:$B$4' );
      
      
      ###############################################################################
      #
      # Example 2. A minimal chart with user specified categories and a series name.
      #
      my $chart2 = $workbook->add_chart( type => 'pie' );
      
      # Configure the series.
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
          name       => 'Pie sales data',
      );
      
      
      ###############################################################################
      #
      # Example 3. Same as previous chart but with an added title.
      #
      my $chart3 = $workbook->add_chart( type => 'pie' );
      
      # Configure the series.
      $chart3->add_series(
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
          name       => 'Pie sales data',
      );
      
      # Add a title.
      $chart3->set_title( name => 'Popular Pie Types' );
      
      
      ###############################################################################
      #
      # Example 4. Same as previous chart with a user specified chart sheet name.
      #
      my $chart4 = $workbook->add_chart( name => 'Results Chart', type => 'pie' );
      
      # Configure the series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
          name       => 'Pie sales data',
      );
      
      # The other chart_*.pl examples add a second series in example 4 but additional
      # series aren't plotted in a pie chart.
      
      # Add a title.
      $chart4->set_title( name => 'Popular Pie Types' );
      
      
      ###############################################################################
      #
      # Example 5. Same as Example 3 but as an embedded chart.
      #
      my $chart5 = $workbook->add_chart( type => 'pie', embedded => 1 );
      
      # Configure the series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
          name       => 'Pie sales data',
      );
      
      # Add a title.
      $chart5->set_title( name => 'Popular Pie Types' );
      
      # Insert the chart into the main worksheet.
      $worksheet->insert_chart( 'D2', $chart5 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chart_pie.pl>
  
  =head2 Example: chart_scatter.pl
  
  
  
  A simple demo of Scatter charts in Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chart_scatter.jpg" width="640" height="420" alt="Output from chart_scatter.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple demo of Scatter charts in Spreadsheet::WriteExcel.
      #
      # reverse(''), December 2009, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_scatter.xls' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values 1', 'Values 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 1, 4, 5, 2, 1, 5 ],
          [ 3, 6, 7, 5, 4, 3 ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      
      ###############################################################################
      #
      # Example 1. A minimal chart.
      #
      my $chart1 = $workbook->add_chart( type => 'scatter' );
      
      # Add values only. Use the default categories.
      $chart1->add_series( values => '=Sheet1!$B$2:$B$7' );
      
      
      ###############################################################################
      #
      # Example 2. A minimal chart with user specified categories (X axis)
      #            and a series name.
      #
      my $chart2 = $workbook->add_chart( type => 'scatter' );
      
      # Configure the series.
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      
      ###############################################################################
      #
      # Example 3. Same as previous chart but with added title and axes labels.
      #
      my $chart3 = $workbook->add_chart( type => 'scatter' );
      
      # Configure the series.
      $chart3->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart3->set_title( name => 'Results of sample analysis' );
      $chart3->set_x_axis( name => 'Sample number' );
      $chart3->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 4. Same as previous chart but with an added series and with a
      #            user specified chart sheet name.
      #
      my $chart4 = $workbook->add_chart( name => 'Results Chart', type => 'scatter' );
      
      # Configure the series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add another series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          name       => 'Test data series 2',
      );
      
      # Add some labels.
      $chart4->set_title( name => 'Results of sample analysis' );
      $chart4->set_x_axis( name => 'Sample number' );
      $chart4->set_y_axis( name => 'Sample length (cm)' );
      
      
      ###############################################################################
      #
      # Example 5. Same as Example 3 but as an embedded chart.
      #
      my $chart5 = $workbook->add_chart( type => 'scatter', embedded => 1 );
      
      # Configure the series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
      
      # Add some labels.
      $chart5->set_title( name => 'Results of sample analysis' );
      $chart5->set_x_axis( name => 'Sample number' );
      $chart5->set_y_axis( name => 'Sample length (cm)' );
      
      # Insert the chart into the main worksheet.
      $worksheet->insert_chart( 'E2', $chart5 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chart_scatter.pl>
  
  =head2 Example: chart_stock.pl
  
  
  
  A simple demo of Stock charts in Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chart_stock.jpg" width="640" height="420" alt="Output from chart_stock.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple demo of Stock charts in Spreadsheet::WriteExcel.
      #
      # reverse('©'), January 2010, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new( 'chart_stock.xls' );
      my $worksheet = $workbook->add_worksheet();
      
      
      ###############################################################################
      #
      # Set up the data worksheet that the charts will refer to. We read the example
      # data from the __DATA__ section at the end of the file. This simulates
      # reading the data from a database or other source.
      #
      # The default Excel Stock chart is an Open-High-Low-Close chart. Therefore
      # we will need data for each of those series.
      #
      # The layout of the __DATA__ section is similar to the layout of the worksheet.
      #
      
      # Add some formats.
      my $bold        = $workbook->add_format( bold       => 1 );
      my $date_format = $workbook->add_format( num_format => 'dd/mm/yyyy' );
      
      # Increase the width of the column used for date to make it clearer.
      $worksheet->set_column( 'A:A', 12 );
      
      # Read the data from the __DATA__ section at the end. In a real example this
      # would probably be a database query.
      my @stock_data;
      
      while ( <DATA> ) {
          next unless /\S/;    # Skip blank lines.
          next if /^#/;        # Skip comments.
      
          push @stock_data, [split];
      }
      
      # Write the data to the worksheet.
      my $row = 0;
      my $col = 0;
      
      my $headers = shift @stock_data;
      $worksheet->write( $row++, $col, $headers, $bold );
      
      for my $stock_data ( @stock_data ) {
      
          my @data = @$stock_data;
          my $date = shift @data;
      
          $worksheet->write( $row, $col, $date, $date_format );
          $worksheet->write( $row, $col + 1, \@data );
      
          $row++;
      }
      
      
      ###############################################################################
      #
      # Example 1. A default Open-High-Low-Close chart with series names, axes labels
      #            and a title.
      #
      
      my $chart1 = $workbook->add_chart( type => 'stock' );
      
      # Add a series for each of the Open-High-Low-Close columns. The categories are
      # the dates in the first column.
      
      $chart1->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$B$2:$B$10',
          name       => 'Open',
      );
      
      $chart1->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$C$2:$C$10',
          name       => 'High',
      );
      
      $chart1->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$D$2:$D$10',
          name       => 'Low',
      );
      
      $chart1->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$E$2:$E$10',
          name       => 'Close',
      );
      
      # Add a chart title and axes labels.
      $chart1->set_title( name => 'Open-High-Low-Close', );
      $chart1->set_x_axis( name => 'Date', );
      $chart1->set_y_axis( name => 'Share price', );
      
      ###############################################################################
      #
      # Example 2. Same as the previous as an embedded chart.
      #
      
      my $chart2 = $workbook->add_chart( type => 'stock', embedded => 1 );
      
      # Add a series for each of the Open-High-Low-Close columns. The categories are
      # the dates in the first column.
      
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$B$2:$B$10',
          name       => 'Open',
      );
      
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$C$2:$C$10',
          name       => 'High',
      );
      
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$D$2:$D$10',
          name       => 'Low',
      );
      
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$E$2:$E$10',
          name       => 'Close',
      );
      
      # Add a chart title and axes labels.
      $chart2->set_title( name => 'Open-High-Low-Close', );
      $chart2->set_x_axis( name => 'Date', );
      $chart2->set_y_axis( name => 'Share price', );
      
      # Insert the chart into the main worksheet.
      $worksheet->insert_chart( 'G2', $chart2 );
      
      
      __DATA__
      # Some sample stock data used for charting.
      Date        Open    High    Low     Close
      2009-08-19  100.00  104.06  95.96   100.34
      2009-08-20  101.01  109.08  100.50  108.31
      2009-08-23  110.75  113.48  109.05  109.40
      2009-08-24  111.24  111.60  103.57  104.87
      2009-08-25  104.96  108.00  103.88  106.00
      2009-08-26  104.95  107.95  104.66  107.91
      2009-08-27  108.10  108.62  105.69  106.15
      2009-08-30  105.28  105.49  102.01  102.01
      2009-08-31  102.30  103.71  102.16  102.37
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chart_stock.pl>
  
  =head2 Example: chess.pl
  
  
  
  Example of formatting using the Spreadsheet::WriteExcel module via
  property hashes.
  
  Setting format properties via hashes of values is useful when you have
  to deal with a large number of similar formats. Consider for example a
  chess board pattern with black squares, white unformatted squares and
  a border.
  
  This relatively simple example requires 14 separate Format
  objects although there are only 5 different properties: black
  background, top border, bottom border, left border and right border.
  
  Using property hashes it is possible to define these 5 sets of
  properties and then add them together to create the 14 Format
  configurations.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/chess.jpg" width="640" height="420" alt="Output from chess.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ########################################################################
      #
      # Example of formatting using the Spreadsheet::WriteExcel module via
      # property hashes.
      #
      # Setting format properties via hashes of values is useful when you have
      # to deal with a large number of similar formats. Consider for example a
      # chess board pattern with black squares, white unformatted squares and
      # a border.
      #
      # This relatively simple example requires 14 separate Format
      # objects although there are only 5 different properties: black
      # background, top border, bottom border, left border and right border.
      #
      # Using property hashes it is possible to define these 5 sets of
      # properties and then add them together to create the 14 Format
      # configurations.
      #
      # reverse(''), July 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new("chess.xls");
      my $worksheet = $workbook->add_worksheet();
      
      
      # Some row and column formatting
      $worksheet->set_column('B:I', 10);
      
      for my $i (1..8) {
          $worksheet->set_row($i, 50);
      }
      
      
      # Define the property hashes
      #
      my %black = (
                      'fg_color'  => 'black',
                      'pattern'   => 1,
                  );
      
      my %top     = ( 'top'    => 6 );
      my %bottom  = ( 'bottom' => 6 );
      my %left    = ( 'left'   => 6 );
      my %right   = ( 'right'  => 6 );
      
      
      # Define the formats
      #
      my $format01 = $workbook->add_format(%top,    %left          );
      my $format02 = $workbook->add_format(%top,    %black         );
      my $format03 = $workbook->add_format(%top,                   );
      my $format04 = $workbook->add_format(%top,    %right, %black );
      
      my $format05 = $workbook->add_format(%left                   );
      my $format06 = $workbook->add_format(%black                  );
      my $format07 = $workbook->add_format(                        );
      my $format08 = $workbook->add_format(%right,  %black         );
      my $format09 = $workbook->add_format(%right                  );
      my $format10 = $workbook->add_format(%left,   %black         );
      
      my $format11 = $workbook->add_format(%bottom, %left,  %black );
      my $format12 = $workbook->add_format(%bottom                 );
      my $format13 = $workbook->add_format(%bottom, %black         );
      my $format14 = $workbook->add_format(%bottom, %right         );
      
      
      # Draw the pattern
      $worksheet->write('B2', '', $format01);
      $worksheet->write('C2', '', $format02);
      $worksheet->write('D2', '', $format03);
      $worksheet->write('E2', '', $format02);
      $worksheet->write('F2', '', $format03);
      $worksheet->write('G2', '', $format02);
      $worksheet->write('H2', '', $format03);
      $worksheet->write('I2', '', $format04);
      
      $worksheet->write('B3', '', $format10);
      $worksheet->write('C3', '', $format07);
      $worksheet->write('D3', '', $format06);
      $worksheet->write('E3', '', $format07);
      $worksheet->write('F3', '', $format06);
      $worksheet->write('G3', '', $format07);
      $worksheet->write('H3', '', $format06);
      $worksheet->write('I3', '', $format09);
      
      $worksheet->write('B4', '', $format05);
      $worksheet->write('C4', '', $format06);
      $worksheet->write('D4', '', $format07);
      $worksheet->write('E4', '', $format06);
      $worksheet->write('F4', '', $format07);
      $worksheet->write('G4', '', $format06);
      $worksheet->write('H4', '', $format07);
      $worksheet->write('I4', '', $format08);
      
      $worksheet->write('B5', '', $format10);
      $worksheet->write('C5', '', $format07);
      $worksheet->write('D5', '', $format06);
      $worksheet->write('E5', '', $format07);
      $worksheet->write('F5', '', $format06);
      $worksheet->write('G5', '', $format07);
      $worksheet->write('H5', '', $format06);
      $worksheet->write('I5', '', $format09);
      
      $worksheet->write('B6', '', $format05);
      $worksheet->write('C6', '', $format06);
      $worksheet->write('D6', '', $format07);
      $worksheet->write('E6', '', $format06);
      $worksheet->write('F6', '', $format07);
      $worksheet->write('G6', '', $format06);
      $worksheet->write('H6', '', $format07);
      $worksheet->write('I6', '', $format08);
      
      $worksheet->write('B7', '', $format10);
      $worksheet->write('C7', '', $format07);
      $worksheet->write('D7', '', $format06);
      $worksheet->write('E7', '', $format07);
      $worksheet->write('F7', '', $format06);
      $worksheet->write('G7', '', $format07);
      $worksheet->write('H7', '', $format06);
      $worksheet->write('I7', '', $format09);
      
      $worksheet->write('B8', '', $format05);
      $worksheet->write('C8', '', $format06);
      $worksheet->write('D8', '', $format07);
      $worksheet->write('E8', '', $format06);
      $worksheet->write('F8', '', $format07);
      $worksheet->write('G8', '', $format06);
      $worksheet->write('H8', '', $format07);
      $worksheet->write('I8', '', $format08);
      
      $worksheet->write('B9', '', $format11);
      $worksheet->write('C9', '', $format12);
      $worksheet->write('D9', '', $format13);
      $worksheet->write('E9', '', $format12);
      $worksheet->write('F9', '', $format13);
      $worksheet->write('G9', '', $format12);
      $worksheet->write('H9', '', $format13);
      $worksheet->write('I9', '', $format14);
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/chess.pl>
  
  =head2 Example: colors.pl
  
  
  
  Demonstrates Spreadsheet::WriteExcel's named colors and the Excel color
  palette.
  
  The set_custom_color() Worksheet method can be used to override one of the
  built-in palette values with a more suitable colour. See the main docs.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/colors.jpg" width="640" height="420" alt="Output from colors.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ################################################################################
      #
      # Demonstrates Spreadsheet::WriteExcel's named colors and the Excel color
      # palette.
      #
      # The set_custom_color() Worksheet method can be used to override one of the
      # built-in palette values with a more suitable colour. See the main docs.
      #
      # reverse(''), March 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook = Spreadsheet::WriteExcel->new("colors.xls");
      
      # Some common formats
      my $center  = $workbook->add_format(align => 'center');
      my $heading = $workbook->add_format(align => 'center', bold => 1);
      
      
      ######################################################################
      #
      # Demonstrate the named colors.
      #
      
      my %colors = (
                      0x08, 'black',
                      0x0C, 'blue',
                      0x10, 'brown',
                      0x0F, 'cyan',
                      0x17, 'gray',
                      0x11, 'green',
                      0x0B, 'lime',
                      0x0E, 'magenta',
                      0x12, 'navy',
                      0x35, 'orange',
                      0x21, 'pink',
                      0x14, 'purple',
                      0x0A, 'red',
                      0x16, 'silver',
                      0x09, 'white',
                      0x0D, 'yellow',
                   );
      
      my $worksheet1 = $workbook->add_worksheet('Named colors');
      
      $worksheet1->set_column(0, 3, 15);
      
      $worksheet1->write(0, 0, "Index", $heading);
      $worksheet1->write(0, 1, "Index", $heading);
      $worksheet1->write(0, 2, "Name",  $heading);
      $worksheet1->write(0, 3, "Color", $heading);
      
      my $i = 1;
      
      while (my($index, $color) = each %colors) {
          my $format = $workbook->add_format(
                                              fg_color => $color,
                                              pattern  => 1,
                                              border   => 1
                                           );
      
          $worksheet1->write($i+1, 0, $index,                    $center);
          $worksheet1->write($i+1, 1, sprintf("0x%02X", $index), $center);
          $worksheet1->write($i+1, 2, $color,                    $center);
          $worksheet1->write($i+1, 3, '',                        $format);
          $i++;
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel colors in the range 8..63.
      #
      
      my $worksheet2 = $workbook->add_worksheet('Standard colors');
      
      $worksheet2->set_column(0, 3, 15);
      
      $worksheet2->write(0, 0, "Index", $heading);
      $worksheet2->write(0, 1, "Index", $heading);
      $worksheet2->write(0, 2, "Color", $heading);
      $worksheet2->write(0, 3, "Name",  $heading);
      
      for my $i (8..63) {
          my $format = $workbook->add_format(
                                              fg_color => $i,
                                              pattern  => 1,
                                              border   => 1
                                           );
      
          $worksheet2->write(($i -7), 0, $i,                    $center);
          $worksheet2->write(($i -7), 1, sprintf("0x%02X", $i), $center);
          $worksheet2->write(($i -7), 2, '',                    $format);
      
          # Add the  color names
          if (exists $colors{$i}) {
              $worksheet2->write(($i -7), 3, $colors{$i}, $center);
      
          }
      }
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/colors.pl>
  
  =head2 Example: comments1.pl
  
  
  
  This example demonstrates writing cell comments.
  
  A cell comment is indicated in Excel by a small red triangle in the upper
  right-hand corner of the cell.
  
  For more advanced comment options see comments2.pl.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/comments1.jpg" width="640" height="420" alt="Output from comments1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # This example demonstrates writing cell comments.
      #
      # A cell comment is indicated in Excel by a small red triangle in the upper
      # right-hand corner of the cell.
      #
      # For more advanced comment options see comments2.pl.
      #
      # reverse(''), November 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new("comments1.xls");
      my $worksheet = $workbook->add_worksheet();
      
      
      
      $worksheet->write        ('A1', 'Hello'            );
      $worksheet->write_comment('A1', 'This is a comment');
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/comments1.pl>
  
  =head2 Example: comments2.pl
  
  
  
  This example demonstrates writing cell comments.
  
  A cell comment is indicated in Excel by a small red triangle in the upper
  right-hand corner of the cell.
  
  Each of the worksheets demonstrates different features of cell comments.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/comments2.jpg" width="640" height="420" alt="Output from comments2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # This example demonstrates writing cell comments.
      #
      # A cell comment is indicated in Excel by a small red triangle in the upper
      # right-hand corner of the cell.
      #
      # Each of the worksheets demonstrates different features of cell comments.
      #
      # reverse(''), November 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook   = Spreadsheet::WriteExcel->new("comments2.xls");
      my $text_wrap  = $workbook->add_format(text_wrap => 1, valign => 'top');
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      my $worksheet4 = $workbook->add_worksheet();
      my $worksheet5 = $workbook->add_worksheet();
      my $worksheet6 = $workbook->add_worksheet();
      my $worksheet7 = $workbook->add_worksheet();
      my $worksheet8 = $workbook->add_worksheet();
      
      
      # Variables that we will use in each example.
      my $cell_text = '';
      my $comment   = '';
      
      
      
      
      ###############################################################################
      #
      # Example 1. Demonstrates a simple cell comment without formatting and Unicode
      #            comments encoded as UTF-16 and as UTF-8.
      #
      
      # Set up some formatting.
      $worksheet1->set_column('C:C', 25);
      $worksheet1->set_row(2, 50);
      $worksheet1->set_row(5, 50);
      
      
      # Simple ascii string.
      $cell_text = 'Hold the mouse over this cell to see the comment.';
      
      $comment   = 'This is a comment.';
      
      $worksheet1->write        ('C3', $cell_text, $text_wrap);
      $worksheet1->write_comment('C3', $comment);
      
      
      # UTF-16 string.
      $cell_text = 'This is a UTF-16 comment.';
      
      $comment   = pack "n", 0x263a;
      
      $worksheet1->write        ('C6', $cell_text, $text_wrap);
      $worksheet1->write_comment('C6', $comment, encoding => 1);
      
      
      # UTF-8 string in perl 5.8.
      if ($] >= 5.008) {
      
          $worksheet1->set_row(8, 50);
          $cell_text = 'This is a UTF-8 string.';
          $comment   = chr 0x263a;
      
          $worksheet1->write        ('C9', $cell_text, $text_wrap);
          $worksheet1->write_comment('C9', $comment);
      }
      
      
      
      ###############################################################################
      #
      # Example 2. Demonstrates visible and hidden comments.
      #
      
      # Set up some formatting.
      $worksheet2->set_column('C:C', 25);
      $worksheet2->set_row(2, 50);
      $worksheet2->set_row(5, 50);
      
      
      $cell_text = 'This cell comment is visible.';
      
      $comment   = 'Hello.';
      
      $worksheet2->write        ('C3', $cell_text, $text_wrap);
      $worksheet2->write_comment('C3', $comment, visible => 1);
      
      
      $cell_text = "This cell comment isn't visible (the default).";
      
      $comment   = 'Hello.';
      
      $worksheet2->write        ('C6', $cell_text, $text_wrap);
      $worksheet2->write_comment('C6', $comment);
      
      
      
      
      ###############################################################################
      #
      # Example 3. Demonstrates visible and hidden comments set at the worksheet
      #            level.
      #
      
      # Set up some formatting.
      $worksheet3->set_column('C:C', 25);
      $worksheet3->set_row(2, 50);
      $worksheet3->set_row(5, 50);
      $worksheet3->set_row(8, 50);
      
      # Make all comments on the worksheet visible.
      $worksheet3->show_comments();
      
      $cell_text = 'This cell comment is visible, explicitly.';
      
      $comment   = 'Hello.';
      
      $worksheet3->write        ('C3', $cell_text, $text_wrap);
      $worksheet3->write_comment('C3', $comment, visible => 1);
      
      
      $cell_text = 'This cell comment is also visible because '.
                   'we used show_comments().';
      
      $comment   = 'Hello.';
      
      $worksheet3->write        ('C6', $cell_text, $text_wrap);
      $worksheet3->write_comment('C6', $comment);
      
      
      $cell_text = 'However, we can still override it locally.';
      
      $comment   = 'Hello.';
      
      $worksheet3->write        ('C9', $cell_text, $text_wrap);
      $worksheet3->write_comment('C9', $comment, visible => 0);
      
      
      
      
      ###############################################################################
      #
      # Example 4. Demonstrates changes to the comment box dimensions.
      #
      
      # Set up some formatting.
      $worksheet4->set_column('C:C', 25);
      $worksheet4->set_row(2,  50);
      $worksheet4->set_row(5,  50);
      $worksheet4->set_row(8,  50);
      $worksheet4->set_row(15, 50);
      
      $worksheet4->show_comments();
      
      $cell_text = 'This cell comment is default size.';
      
      $comment   = 'Hello.';
      
      $worksheet4->write        ('C3', $cell_text, $text_wrap);
      $worksheet4->write_comment('C3', $comment);
      
      
      $cell_text = 'This cell comment is twice as wide.';
      
      $comment   = 'Hello.';
      
      $worksheet4->write        ('C6', $cell_text, $text_wrap);
      $worksheet4->write_comment('C6', $comment, x_scale => 2);
      
      
      $cell_text = 'This cell comment is twice as high.';
      
      $comment   = 'Hello.';
      
      $worksheet4->write        ('C9', $cell_text, $text_wrap);
      $worksheet4->write_comment('C9', $comment, y_scale => 2);
      
      
      $cell_text = 'This cell comment is scaled in both directions.';
      
      $comment   = 'Hello.';
      
      $worksheet4->write        ('C16', $cell_text, $text_wrap);
      $worksheet4->write_comment('C16', $comment, x_scale => 1.2, y_scale => 0.8);
      
      
      $cell_text = 'This cell comment has width and height specified in pixels.';
      
      $comment   = 'Hello.';
      
      $worksheet4->write        ('C19', $cell_text, $text_wrap);
      $worksheet4->write_comment('C19', $comment, width => 200, height => 20);
      
      
      
      ###############################################################################
      #
      # Example 5. Demonstrates changes to the cell comment position.
      #
      
      $worksheet5->set_column('C:C', 25);
      $worksheet5->set_row(2, 50);
      $worksheet5->set_row(5, 50);
      $worksheet5->set_row(8, 50);
      $worksheet5->set_row(11, 50);
      
      $worksheet5->show_comments();
      
      $cell_text = 'This cell comment is in the default position.';
      
      $comment   = 'Hello.';
      
      $worksheet5->write        ('C3', $cell_text, $text_wrap);
      $worksheet5->write_comment('C3', $comment);
      
      
      $cell_text = 'This cell comment has been moved to another cell.';
      
      $comment   = 'Hello.';
      
      $worksheet5->write        ('C6', $cell_text, $text_wrap);
      $worksheet5->write_comment('C6', $comment, start_cell => 'E4');
      
      
      $cell_text = 'This cell comment has been moved to another cell.';
      
      $comment   = 'Hello.';
      
      $worksheet5->write        ('C9', $cell_text, $text_wrap);
      $worksheet5->write_comment('C9', $comment, start_row => 8, start_col => 4);
      
      
      $cell_text = 'This cell comment has been shifted within its default cell.';
      
      $comment   = 'Hello.';
      
      $worksheet5->write        ('C12', $cell_text, $text_wrap);
      $worksheet5->write_comment('C12', $comment, x_offset => 30, y_offset => 12);
      
      
      
      ###############################################################################
      #
      # Example 6. Demonstrates changes to the comment background colour.
      #
      
      $worksheet6->set_column('C:C', 25);
      $worksheet6->set_row(2, 50);
      $worksheet6->set_row(5, 50);
      $worksheet6->set_row(8, 50);
      
      $worksheet6->show_comments();
      
      $cell_text = 'This cell comment has a different colour.';
      
      $comment   = 'Hello.';
      
      $worksheet6->write        ('C3', $cell_text, $text_wrap);
      $worksheet6->write_comment('C3', $comment, color => 'green');
      
      
      $cell_text = 'This cell comment has the default colour.';
      
      $comment   = 'Hello.';
      
      $worksheet6->write        ('C6', $cell_text, $text_wrap);
      $worksheet6->write_comment('C6', $comment);
      
      
      $cell_text = 'This cell comment has a different colour.';
      
      $comment   = 'Hello.';
      
      $worksheet6->write        ('C9', $cell_text, $text_wrap);
      $worksheet6->write_comment('C9', $comment, color => 0x35);
      
      
      
      
      ###############################################################################
      #
      # Example 7. Demonstrates how to set the cell comment author.
      #
      
      $worksheet7->set_column('C:C', 30);
      $worksheet7->set_row(2,  50);
      $worksheet7->set_row(5,  50);
      $worksheet7->set_row(8,  50);
      $worksheet7->set_row(11, 50);
      
      my $author = '';
      my $cell   = 'C3';
      
      $cell_text = "Move the mouse over this cell and you will see 'Cell commented ".
                   "by $author' (blank) in the status bar at the bottom";
      
      $comment   = 'Hello.';
      
      $worksheet7->write        ($cell, $cell_text, $text_wrap);
      $worksheet7->write_comment($cell, $comment);
      
      
      $author    = 'Perl';
      $cell      = 'C6';
      $cell_text = "Move the mouse over this cell and you will see 'Cell commented ".
                   "by $author' in the status bar at the bottom";
      
      $comment   = 'Hello.';
      
      $worksheet7->write        ($cell, $cell_text, $text_wrap);
      $worksheet7->write_comment($cell, $comment, author => $author);
      
      
      $author    = pack "n", 0x20AC; # UTF-16 Euro
      $cell      = 'C9';
      $cell_text = "Move the mouse over this cell and you will see 'Cell commented ".
                   "by Euro' in the status bar at the bottom";
      
      $comment   = 'Hello.';
      
      $worksheet7->write        ($cell, $cell_text, $text_wrap);
      $worksheet7->write_comment($cell, $comment, author          => $author,
                                                  author_encoding => 1      );
      
      # UTF-8 string in perl 5.8.
      if ($] >= 5.008) {
          $author    = chr 0x20AC;
          $cell      = 'C12';
          $cell_text = "Move the mouse over this cell and you will see 'Cell commented ".
                       "by $author' in the status bar at the bottom";
          $comment   = 'Hello.';
      
          $worksheet7->write        ($cell, $cell_text, $text_wrap);
          $worksheet7->write_comment($cell, $comment, author => $author);
      
      }
      
      
      ###############################################################################
      #
      # Example 8. Demonstrates the need to explicitly set the row height.
      #
      
      # Set up some formatting.
      $worksheet8->set_column('C:C', 25);
      $worksheet8->set_row(2, 80);
      
      $worksheet8->show_comments();
      
      
      $cell_text = 'The height of this row has been adjusted explicitly using ' .
                   'set_row(). The size of the comment box is adjusted '         .
                   'accordingly by WriteExcel.';
      
      $comment   = 'Hello.';
      
      $worksheet8->write        ('C3', $cell_text, $text_wrap);
      $worksheet8->write_comment('C3', $comment);
      
      
      $cell_text = 'The height of this row has been adjusted by Excel due to the '  .
                   'text wrap property being set. Unfortunately this means that '   .
                   'the height of the row is unknown to WriteExcel at run time '    .
                   "and thus the comment box is stretched as well.\n\n"             .
                   'Use set_row() to specify the row height explicitly to avoid '   .
                   'this problem.';
      
      $comment   = 'Hello.';
      
      $worksheet8->write        ('C6', $cell_text, $text_wrap);
      $worksheet8->write_comment('C6', $comment);
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/comments2.pl>
  
  =head2 Example: copyformat.pl
  
  
  
  Example of how to use the format copying method with Spreadsheet::WriteExcel.
  
  This feature isn't required very often.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/copyformat.jpg" width="640" height="420" alt="Output from copyformat.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the format copying method with Spreadsheet::WriteExcel.
      #
      # This feature isn't required very often.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create workbook1
      my $workbook1       = Spreadsheet::WriteExcel->new("workbook1.xls");
      my $worksheet1      = $workbook1->add_worksheet();
      my $format1a        = $workbook1->add_format();
      my $format1b        = $workbook1->add_format();
      
      # Create workbook2
      my $workbook2       = Spreadsheet::WriteExcel->new("workbook2.xls");
      my $worksheet2      = $workbook2->add_worksheet();
      my $format2a        = $workbook2->add_format();
      my $format2b        = $workbook2->add_format();
      
      
      # Create a global format object that isn't tied to a workbook
      my $global_format   = Spreadsheet::WriteExcel::Format->new();
      
      # Set the formatting
      $global_format->set_color('blue');
      $global_format->set_bold();
      $global_format->set_italic();
      
      # Create another example format
      $format1b->set_color('red');
      
      # Copy the global format properties to the worksheet formats
      $format1a->copy($global_format);
      $format2a->copy($global_format);
      
      # Copy a format from worksheet1 to worksheet2
      $format2b->copy($format1b);
      
      # Write some output
      $worksheet1->write(0, 0, "Ciao", $format1a);
      $worksheet1->write(1, 0, "Ciao", $format1b);
      
      $worksheet2->write(0, 0, "Hello", $format2a);
      $worksheet2->write(1, 0, "Hello", $format2b);
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/copyformat.pl>
  
  =head2 Example: data_validate.pl
  
  
  
  Example of how to add data validation and dropdown lists to a
  Spreadsheet::WriteExcel file.
  
  Data validation is a feature of Excel which allows you to restrict the data
  that a users enters in a cell and to display help and warning messages. It
  also allows you to restrict input to values in a drop down list.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/data_validate.jpg" width="640" height="420" alt="Output from data_validate.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add data validation and dropdown lists to a
      # Spreadsheet::WriteExcel file.
      #
      # Data validation is a feature of Excel which allows you to restrict the data
      # that a users enters in a cell and to display help and warning messages. It
      # also allows you to restrict input to values in a drop down list.
      #
      # reverse(''), August 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new('data_validate.xls');
      my $worksheet = $workbook->add_worksheet();
      
      # Add a format for the header cells.
      my $header_format = $workbook->add_format(
                                                  border      => 1,
                                                  bg_color    => 43,
                                                  bold        => 1,
                                                  text_wrap   => 1,
                                                  valign      => 'vcenter',
                                                  indent      => 1,
                                               );
      
      # Set up layout of the worksheet.
      $worksheet->set_column('A:A', 64);
      $worksheet->set_column('B:B', 15);
      $worksheet->set_column('D:D', 15);
      $worksheet->set_row(0, 36);
      $worksheet->set_selection('B3');
      
      
      # Write the header cells and some data that will be used in the examples.
      my $row = 0;
      my $txt;
      my $heading1 = 'Some examples of data validation in Spreadsheet::WriteExcel';
      my $heading2 = 'Enter values in this column';
      my $heading3 = 'Sample Data';
      
      $worksheet->write('A1', $heading1, $header_format);
      $worksheet->write('B1', $heading2, $header_format);
      $worksheet->write('D1', $heading3, $header_format);
      
      $worksheet->write('D3', ['Integers',   1, 10]);
      $worksheet->write('D4', ['List data', 'open', 'high', 'close']);
      $worksheet->write('D5', ['Formula',   '=AND(F5=50,G5=60)', 50, 60]);
      
      
      #
      # Example 1. Limiting input to an integer in a fixed range.
      #
      $txt = 'Enter an integer between 1 and 10';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'integer',
              criteria        => 'between',
              minimum         => 1,
              maximum         => 10,
          });
      
      
      #
      # Example 2. Limiting input to an integer outside a fixed range.
      #
      $txt = 'Enter an integer that is not between 1 and 10 (using cell references)';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'integer',
              criteria        => 'not between',
              minimum         => '=E3',
              maximum         => '=F3',
          });
      
      
      #
      # Example 3. Limiting input to an integer greater than a fixed value.
      #
      $txt = 'Enter an integer greater than 0';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'integer',
              criteria        => '>',
              value           => 0,
          });
      
      
      #
      # Example 4. Limiting input to an integer less than a fixed value.
      #
      $txt = 'Enter an integer less than 10';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'integer',
              criteria        => '<',
              value           => 10,
          });
      
      
      #
      # Example 5. Limiting input to a decimal in a fixed range.
      #
      $txt = 'Enter a decimal between 0.1 and 0.5';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'decimal',
              criteria        => 'between',
              minimum         => 0.1,
              maximum         => 0.5,
          });
      
      
      #
      # Example 6. Limiting input to a value in a dropdown list.
      #
      $txt = 'Select a value from a drop down list';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'list',
              source          => ['open', 'high', 'close'],
          });
      
      
      #
      # Example 6. Limiting input to a value in a dropdown list.
      #
      $txt = 'Select a value from a drop down list (using a cell range)';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'list',
              source          => '=E4:G4',
          });
      
      
      #
      # Example 7. Limiting input to a date in a fixed range.
      #
      $txt = 'Enter a date between 1/1/2008 and 12/12/2008';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'date',
              criteria        => 'between',
              minimum         => '2008-01-01T',
              maximum         => '2008-12-12T',
          });
      
      
      #
      # Example 8. Limiting input to a time in a fixed range.
      #
      $txt = 'Enter a time between 6:00 and 12:00';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'time',
              criteria        => 'between',
              minimum         => 'T06:00',
              maximum         => 'T12:00',
          });
      
      
      #
      # Example 9. Limiting input to a string greater than a fixed length.
      #
      $txt = 'Enter a string longer than 3 characters';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'length',
              criteria        => '>',
              value           => 3,
          });
      
      
      #
      # Example 10. Limiting input based on a formula.
      #
      $txt = 'Enter a value if the following is true "=AND(F5=50,G5=60)"';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate        => 'custom',
              value           => '=AND(F5=50,G5=60)',
          });
      
      
      #
      # Example 11. Displaying and modify data validation messages.
      #
      $txt = 'Displays a message when you select the cell';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
          });
      
      
      #
      # Example 12. Displaying and modify data validation messages.
      #
      $txt = 'Display a custom error message when integer isn\'t between 1 and 100';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
              error_title   => 'Input value is not valid!',
              error_message => 'It should be an integer between 1 and 100',
          });
      
      
      #
      # Example 13. Displaying and modify data validation messages.
      #
      $txt = 'Display a custom information message when integer isn\'t between 1 and 100';
      $row += 2;
      
      $worksheet->write($row, 0, $txt);
      $worksheet->data_validation($row, 1,
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
              error_title   => 'Input value is not valid!',
              error_message => 'It should be an integer between 1 and 100',
              error_type    => 'information',
          });
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/data_validate.pl>
  
  =head2 Example: date_time.pl
  
  
  
  Spreadsheet::WriteExcel example of writing dates and times using the
  write_date_time() Worksheet method.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/date_time.jpg" width="640" height="420" alt="Output from date_time.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Spreadsheet::WriteExcel example of writing dates and times using the
      # write_date_time() Worksheet method.
      #
      # reverse(''), August 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("date_time.xls");
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format(bold => 1);
      my $row       = 0;
      
      
      # Expand the first column so that the date is visible.
      $worksheet->set_column("A:B", 30);
      
      
      # Write the column headers
      $worksheet->write('A1', 'Formatted date', $bold);
      $worksheet->write('B1', 'Format',         $bold);
      
      
      # Examples date and time formats. In the output file compare how changing
      # the format codes change the appearance of the date.
      #
      my @date_formats = (
          'dd/mm/yy',
          'mm/dd/yy',
          '',
          'd mm yy',
          'dd mm yy',
          '',
          'dd m yy',
          'dd mm yy',
          'dd mmm yy',
          'dd mmmm yy',
          '',
          'dd mm y',
          'dd mm yyy',
          'dd mm yyyy',
          '',
          'd mmmm yyyy',
          '',
          'dd/mm/yy',
          'dd/mm/yy hh:mm',
          'dd/mm/yy hh:mm:ss',
          'dd/mm/yy hh:mm:ss.000',
          '',
          'hh:mm',
          'hh:mm:ss',
          'hh:mm:ss.000',
      );
      
      
      # Write the same date and time using each of the above formats. The empty
      # string formats create a blank line to make the example clearer.
      #
      for my $date_format (@date_formats) {
          $row++;
          next if $date_format eq '';
      
          # Create a format for the date or time.
          my $format =  $workbook->add_format(
                                              num_format => $date_format,
                                              align      => 'left'
                                             );
      
          # Write the same date using different formats.
          $worksheet->write_date_time($row, 0, '2004-08-01T12:30:45.123', $format);
          $worksheet->write          ($row, 1, $date_format);
      }
      
      
      # The following is an example of an invalid date. It is written as a string
      # instead of a number. This is also Excel's default behaviour.
      #
      $row += 2;
      $worksheet->write_date_time($row, 0, '2004-13-01T12:30:45.123');
      $worksheet->write          ($row, 1, 'Invalid date. Written as string.', $bold);
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/date_time.pl>
  
  =head2 Example: defined_name.pl
  
  
  
  Example of how to create defined names in a Spreadsheet::WriteExcel file.
  
  This method is used to defined a name that can be used to represent a value,
  a single cell or a range of cells in a workbook.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/defined_name.jpg" width="640" height="420" alt="Output from defined_name.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to create defined names in a Spreadsheet::WriteExcel file.
      #
      # This method is used to defined a name that can be used to represent a value,
      # a single cell or a range of cells in a workbook.
      #
      # reverse(''), September 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook   = Spreadsheet::WriteExcel->new('defined_name.xls');
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      
      
      $workbook->define_name('Exchange_rate', '=0.96');
      $workbook->define_name('Sales',         '=Sheet1!$G$1:$H$10');
      $workbook->define_name('Sheet2!Sales',  '=Sheet2!$G$1:$G$10');
      
      
      for my $worksheet ($workbook->sheets()) {
          $worksheet->set_column('A:A', 45);
          $worksheet->write('A2', 'This worksheet contains some defined names,');
          $worksheet->write('A3', 'See the Insert -> Name -> Define dialog.');
      
      }
      
      
      $worksheet1->write('A4', '=Exchange_rate');
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/defined_name.pl>
  
  =head2 Example: diag_border.pl
  
  
  
  A simple formatting example that demonstrates how to add a diagonal cell
  border with Spreadsheet::WriteExcel
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/diag_border.jpg" width="640" height="420" alt="Output from diag_border.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple formatting example that demonstrates how to add a diagonal cell
      # border with Spreadsheet::WriteExcel
      #
      # reverse(''), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new('diag_border.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      my $format1   = $workbook->add_format(diag_type       => '1');
      
      my $format2   = $workbook->add_format(diag_type       => '2');
      
      my $format3   = $workbook->add_format(diag_type       => '3');
      
      my $format4   = $workbook->add_format(
                                            diag_type       => '3',
                                            diag_border     => '7',
                                            diag_color      => 'red',
                                           );
      
      
      $worksheet->write('B3',  'Text', $format1);
      $worksheet->write('B6',  'Text', $format2);
      $worksheet->write('B9',  'Text', $format3);
      $worksheet->write('B12', 'Text', $format4);
      
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/diag_border.pl>
  
  =head2 Example: easter_egg.pl
  
  
  
  This uses the Win32::OLE module to expose the Flight Simulator easter egg
  in Excel 97 SR2.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # This uses the Win32::OLE module to expose the Flight Simulator easter egg
      # in Excel 97 SR2.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Win32::OLE;
      
      my $application = Win32::OLE->new("Excel.Application");
      my $workbook    = $application->Workbooks->Add;
      my $worksheet   = $workbook->Worksheets(1);
      
      $application->{Visible} = 1;
      
      $worksheet->Range("L97:X97")->Select;
      $worksheet->Range("M97")->Activate;
      
      my $message =  "Hold down Shift and Ctrl and click the ".
                     "Chart Wizard icon on the toolbar.\n\n".
                     "Use the mouse motion and buttons to control ".
                     "movement. Try to find the monolith. ".
                     "Close this dialog first.";
      
      $application->InputBox($message);
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/easter_egg.pl>
  
  =head2 Example: filehandle.pl
  
  
  
  Example of using Spreadsheet::WriteExcel to write Excel files to
  different filehandles.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/filehandle.jpg" width="640" height="420" alt="Output from filehandle.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of using Spreadsheet::WriteExcel to write Excel files to
      # different filehandles.
      #
      # reverse(''), April 2003, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      use IO::Scalar;
      
      
      
      
      ###############################################################################
      #
      # Example 1. This demonstrates the standard way of creating an Excel file by
      # specifying a file name.
      #
      
      my $workbook1  = Spreadsheet::WriteExcel->new('fh_01.xls');
      my $worksheet1 = $workbook1->add_worksheet();
      
      $worksheet1->write(0, 0,  "Hi Excel!");
      
      
      
      
      ###############################################################################
      #
      # Example 2. Write an Excel file to an existing filehandle.
      #
      
      open    TEST, "> fh_02.xls" or die "Couldn't open file: $!";
      binmode TEST; # Always do this regardless of whether the platform requires it.
      
      my $workbook2  = Spreadsheet::WriteExcel->new(\*TEST);
      my $worksheet2 = $workbook2->add_worksheet();
      
      $worksheet2->write(0, 0,  "Hi Excel!");
      
      
      
      
      ###############################################################################
      #
      # Example 3. Write an Excel file to an existing OO style filehandle.
      #
      
      my $fh = FileHandle->new("> fh_03.xls")
               or die "Couldn't open file: $!";
      
      binmode($fh);
      
      my $workbook3  = Spreadsheet::WriteExcel->new($fh);
      my $worksheet3 = $workbook3->add_worksheet();
      
      $worksheet3->write(0, 0,  "Hi Excel!");
      
      
      
      
      ###############################################################################
      #
      # Example 4. Write an Excel file to a string via IO::Scalar. Please refer to
      # the IO::Scalar documentation for further details.
      #
      
      my $xls_str;
      
      tie *XLS, 'IO::Scalar', \$xls_str;
      
      my $workbook4  = Spreadsheet::WriteExcel->new(\*XLS);
      my $worksheet4 = $workbook4->add_worksheet();
      
      $worksheet4->write(0, 0, "Hi Excel 4");
      $workbook4->close(); # This is required before we use the scalar
      
      
      # The Excel file is now in $xls_str. As a demonstration, print it to a file.
      open    TMP, "> fh_04.xls" or die "Couldn't open file: $!";
      binmode TMP;
      print   TMP  $xls_str;
      close   TMP;
      
      
      
      
      ###############################################################################
      #
      # Example 5. Write an Excel file to a string via IO::Scalar's newer interface.
      # Please refer to the IO::Scalar documentation for further details.
      #
      my $xls_str2;
      
      my $fh5 = IO::Scalar->new(\$xls_str2);
      
      
      my $workbook5  = Spreadsheet::WriteExcel->new($fh5);
      my $worksheet5 = $workbook5->add_worksheet();
      
      $worksheet5->write(0, 0, "Hi Excel 5");
      $workbook5->close(); # This is required before we use the scalar
      
      # The Excel file is now in $xls_str. As a demonstration, print it to a file.
      open    TMP, "> fh_05.xls" or die "Couldn't open file: $!";
      binmode TMP;
      print   TMP  $xls_str2;
      close   TMP;
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/filehandle.pl>
  
  =head2 Example: formula_result.pl
  
  
  
  Example of how to write Spreadsheet::WriteExcel formulas with a user
  specified result.
  
  This is generally only required when writing a spreadsheet for an
  application other than Excel where the formula isn't evaluated.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/formula_result.jpg" width="640" height="420" alt="Output from formula_result.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # Example of how to write Spreadsheet::WriteExcel formulas with a user
      # specified result.
      #
      # This is generally only required when writing a spreadsheet for an
      # application other than Excel where the formula isn't evaluated.
      #
      # reverse(''), August 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new('formula_result.xls');
      my $worksheet = $workbook->add_worksheet();
      my $format    = $workbook->add_format(color => 'blue');
      
      
      $worksheet->write('A1', '=1+2');
      $worksheet->write('A2', '=1+2',                     $format, 4);
      $worksheet->write('A3', '="ABC"',                   undef,   'DEF');
      $worksheet->write('A4', '=IF(A1 > 1, TRUE, FALSE)', undef,   'TRUE');
      $worksheet->write('A5', '=1/0',                     undef,   '#DIV/0!');
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/formula_result.pl>
  
  =head2 Example: headers.pl
  
  
  
  This program shows several examples of how to set up headers and
  footers with Spreadsheet::WriteExcel.
  
  The control characters used in the header/footer strings are:
  
      Control             Category            Description
      =======             ========            ===========
      &L                  Justification       Left
      &C                                      Center
      &R                                      Right
  
      &P                  Information         Page number
      &N                                      Total number of pages
      &D                                      Date
      &T                                      Time
      &F                                      File name
      &A                                      Worksheet name
  
      &fontsize           Font                Font size
      &"font,style"                           Font name and style
      &U                                      Single underline
      &E                                      Double underline
      &S                                      Strikethrough
      &X                                      Superscript
      &Y                                      Subscript
  
      &&                  Miscellaneous       Literal ampersand &
  
  See the main Spreadsheet::WriteExcel documentation for more information.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/headers.jpg" width="640" height="420" alt="Output from headers.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ######################################################################
      #
      # This program shows several examples of how to set up headers and
      # footers with Spreadsheet::WriteExcel.
      #
      # The control characters used in the header/footer strings are:
      #
      #     Control             Category            Description
      #     =======             ========            ===========
      #     &L                  Justification       Left
      #     &C                                      Center
      #     &R                                      Right
      #
      #     &P                  Information         Page number
      #     &N                                      Total number of pages
      #     &D                                      Date
      #     &T                                      Time
      #     &F                                      File name
      #     &A                                      Worksheet name
      #
      #     &fontsize           Font                Font size
      #     &"font,style"                           Font name and style
      #     &U                                      Single underline
      #     &E                                      Double underline
      #     &S                                      Strikethrough
      #     &X                                      Superscript
      #     &Y                                      Subscript
      #
      #     &&                  Miscellaneous       Literal ampersand &
      #
      # See the main Spreadsheet::WriteExcel documentation for more information.
      #
      # reverse(''), March 2002, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new("headers.xls");
      my $preview   = "Select Print Preview to see the header and footer";
      
      
      ######################################################################
      #
      # A simple example to start
      #
      my $worksheet1  = $workbook->add_worksheet('Simple');
      
      my $header1     = '&CHere is some centred text.';
      
      my $footer1     = '&LHere is some left aligned text.';
      
      
      $worksheet1->set_header($header1);
      $worksheet1->set_footer($footer1);
      
      $worksheet1->set_column('A:A', 50);
      $worksheet1->write('A1', $preview);
      
      
      
      
      ######################################################################
      #
      # This is an example of some of the header/footer variables.
      #
      my $worksheet2  = $workbook->add_worksheet('Variables');
      
      my $header2     = '&LPage &P of &N'.
                        '&CFilename: &F' .
                        '&RSheetname: &A';
      
      my $footer2     = '&LCurrent date: &D'.
                        '&RCurrent time: &T';
      
      
      
      $worksheet2->set_header($header2);
      $worksheet2->set_footer($footer2);
      
      
      $worksheet2->set_column('A:A', 50);
      $worksheet2->write('A1', $preview);
      $worksheet2->write('A21', "Next sheet");
      $worksheet2->set_h_pagebreaks(20);
      
      
      
      ######################################################################
      #
      # This example shows how to use more than one font
      #
      my $worksheet3 = $workbook->add_worksheet('Mixed fonts');
      
      my $header3    = '&C' .
                       '&"Courier New,Bold"Hello ' .
                       '&"Arial,Italic"World';
      
      my $footer3    = '&C' .
                       '&"Symbol"e' .
                       '&"Arial" = mc&X2';
      
      $worksheet3->set_header($header3);
      $worksheet3->set_footer($footer3);
      
      $worksheet3->set_column('A:A', 50);
      $worksheet3->write('A1', $preview);
      
      
      
      
      ######################################################################
      #
      # Example of line wrapping
      #
      my $worksheet4 = $workbook->add_worksheet('Word wrap');
      
      my $header4    = "&CHeading 1\nHeading 2\nHeading 3";
      
      $worksheet4->set_header($header4);
      
      $worksheet4->set_column('A:A', 50);
      $worksheet4->write('A1', $preview);
      
      
      
      
      ######################################################################
      #
      # Example of inserting a literal ampersand &
      #
      my $worksheet5 = $workbook->add_worksheet('Ampersand');
      
      my $header5    = "&CCuriouser && Curiouser - Attorneys at Law";
      
      $worksheet5->set_header($header5);
      
      $worksheet5->set_column('A:A', 50);
      $worksheet5->write('A1', $preview);
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/headers.pl>
  
  =head2 Example: hide_sheet.pl
  
  
  
  Example of how to hide a worksheet with Spreadsheet::WriteExcel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/hide_sheet.jpg" width="640" height="420" alt="Output from hide_sheet.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # Example of how to hide a worksheet with Spreadsheet::WriteExcel.
      #
      # reverse(''), April 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook   = Spreadsheet::WriteExcel->new('hidden.xls');
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      
      # Sheet2 won't be visible until it is unhidden in Excel.
      $worksheet2->hide();
      
      $worksheet1->write(0, 0, 'Sheet2 is hidden');
      $worksheet2->write(0, 0, 'How did you find me?');
      $worksheet3->write(0, 0, 'Sheet2 is hidden');
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/hide_sheet.pl>
  
  =head2 Example: hyperlink1.pl
  
  
  
  Example of how to use the WriteExcel module to write hyperlinks.
  
  See also hyperlink2.pl for worksheet URL examples.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/hyperlink1.jpg" width="640" height="420" alt="Output from hyperlink1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the WriteExcel module to write hyperlinks.
      #
      # See also hyperlink2.pl for worksheet URL examples.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("hyperlink.xls");
      my $worksheet = $workbook->add_worksheet('Hyperlinks');
      
      # Format the first column
      $worksheet->set_column('A:A', 30);
      $worksheet->set_selection('B1');
      
      
      # Add a sample format
      my $format = $workbook->add_format();
      $format->set_size(12);
      $format->set_bold();
      $format->set_color('red');
      $format->set_underline();
      
      
      # Write some hyperlinks
      $worksheet->write('A1', 'http://www.perl.com/'                );
      $worksheet->write('A3', 'http://www.perl.com/', 'Perl home'   );
      $worksheet->write('A5', 'http://www.perl.com/', undef, $format);
      $worksheet->write('A7', 'mailto:jmcnamara@cpan.org', 'Mail me');
      
      # Write a URL that isn't a hyperlink
      $worksheet->write_string('A9', 'http://www.perl.com/');
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/hyperlink1.pl>
  
  =head2 Example: hyperlink2.pl
  
  
  
  Example of how to use the WriteExcel module to write internal and internal
  hyperlinks.
  
  If you wish to run this program and follow the hyperlinks you should create
  the following directory structure:
  
      C:\ -- Temp --+-- Europe
                    |
                    \-- Asia
  
  
  See also hyperlink1.pl for web URL examples.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the WriteExcel module to write internal and internal
      # hyperlinks.
      #
      # If you wish to run this program and follow the hyperlinks you should create
      # the following directory structure:
      #
      #     C:\ -- Temp --+-- Europe
      #                   |
      #                   \-- Asia
      #
      #
      # See also hyperlink1.pl for web URL examples.
      #
      # reverse(''), February 2002, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create three workbooks:
      #   C:\Temp\Europe\Ireland.xls
      #   C:\Temp\Europe\Italy.xls
      #   C:\Temp\Asia\China.xls
      #
      my $ireland   = Spreadsheet::WriteExcel->new('C:\Temp\Europe\Ireland.xls');
      my $ire_links = $ireland->add_worksheet('Links');
      my $ire_sales = $ireland->add_worksheet('Sales');
      my $ire_data  = $ireland->add_worksheet('Product Data');
      
      my $italy     = Spreadsheet::WriteExcel->new('C:\Temp\Europe\Italy.xls');
      my $ita_links = $italy->add_worksheet('Links');
      my $ita_sales = $italy->add_worksheet('Sales');
      my $ita_data  = $italy->add_worksheet('Product Data');
      
      my $china     = Spreadsheet::WriteExcel->new('C:\Temp\Asia\China.xls');
      my $cha_links = $china->add_worksheet('Links');
      my $cha_sales = $china->add_worksheet('Sales');
      my $cha_data  = $china->add_worksheet('Product Data');
      
      # Add a format
      my $format = $ireland->add_format(color => 'green', bold => 1);
      $ire_links->set_column('A:B', 25);
      
      
      ###############################################################################
      #
      # Examples of internal links
      #
      $ire_links->write('A1', 'Internal links', $format);
      
      # Internal link
      $ire_links->write('A2', 'internal:Sales!A2');
      
      # Internal link to a range
      $ire_links->write('A3', 'internal:Sales!A3:D3');
      
      # Internal link with an alternative string
      $ire_links->write('A4', 'internal:Sales!A4', 'Link');
      
      # Internal link with a format
      $ire_links->write('A5', 'internal:Sales!A5', $format);
      
      # Internal link with an alternative string and format
      $ire_links->write('A6', 'internal:Sales!A6', 'Link', $format);
      
      # Internal link (spaces in worksheet name)
      $ire_links->write('A7', q{internal:'Product Data'!A7});
      
      
      ###############################################################################
      #
      # Examples of external links
      #
      $ire_links->write('B1', 'External links', $format);
      
      # External link to a local file
      $ire_links->write('B2', 'external:Italy.xls');
      
      # External link to a local file with worksheet
      $ire_links->write('B3', 'external:Italy.xls#Sales!B3');
      
      # External link to a local file with worksheet and alternative string
      $ire_links->write('B4', 'external:Italy.xls#Sales!B4', 'Link');
      
      # External link to a local file with worksheet and format
      $ire_links->write('B5', 'external:Italy.xls#Sales!B5', $format);
      
      # External link to a remote file, absolute path
      $ire_links->write('B6', 'external:c:/Temp/Asia/China.xls');
      
      # External link to a remote file, relative path
      $ire_links->write('B7', 'external:../Asia/China.xls');
      
      # External link to a remote file with worksheet
      $ire_links->write('B8', 'external:c:/Temp/Asia/China.xls#Sales!B8');
      
      # External link to a remote file with worksheet (with spaces in the name)
      $ire_links->write('B9', q{external:c:/Temp/Asia/China.xls#'Product Data'!B9});
      
      
      ###############################################################################
      #
      # Some utility links to return to the main sheet
      #
      $ire_sales->write('A2', 'internal:Links!A2', 'Back');
      $ire_sales->write('A3', 'internal:Links!A3', 'Back');
      $ire_sales->write('A4', 'internal:Links!A4', 'Back');
      $ire_sales->write('A5', 'internal:Links!A5', 'Back');
      $ire_sales->write('A6', 'internal:Links!A6', 'Back');
      $ire_data-> write('A7', 'internal:Links!A7', 'Back');
      
      $ita_links->write('A1', 'external:Ireland.xls#Links!B2', 'Back');
      $ita_sales->write('B3', 'external:Ireland.xls#Links!B3', 'Back');
      $ita_sales->write('B4', 'external:Ireland.xls#Links!B4', 'Back');
      $ita_sales->write('B5', 'external:Ireland.xls#Links!B5', 'Back');
      $cha_links->write('A1', 'external:../Europe/Ireland.xls#Links!B6', 'Back');
      $cha_sales->write('B8', 'external:../Europe/Ireland.xls#Links!B8', 'Back');
      $cha_data-> write('B9', 'external:../Europe/Ireland.xls#Links!B9', 'Back');
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/hyperlink2.pl>
  
  =head2 Example: images.pl
  
  
  
  Example of how to insert images into an Excel worksheet using the
  Spreadsheet::WriteExcel insert_image() method.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/images.jpg" width="640" height="420" alt="Output from images.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # Example of how to insert images into an Excel worksheet using the
      # Spreadsheet::WriteExcel insert_image() method.
      #
      # reverse(''), October 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook called simple.xls and add a worksheet
      my $workbook   = Spreadsheet::WriteExcel->new("images.xls");
      my $worksheet1 = $workbook->add_worksheet('Image 1');
      my $worksheet2 = $workbook->add_worksheet('Image 2');
      my $worksheet3 = $workbook->add_worksheet('Image 3');
      my $worksheet4 = $workbook->add_worksheet('Image 4');
      
      # Insert a basic image
      $worksheet1->write('A10', "Image inserted into worksheet.");
      $worksheet1->insert_image('A1', 'republic.png');
      
      
      # Insert an image with an offset
      $worksheet2->write('A10', "Image inserted with an offset.");
      $worksheet2->insert_image('A1', 'republic.png', 32, 10);
      
      # Insert a scaled image
      $worksheet3->write('A10', "Image scaled: width x 2, height x 0.8.");
      $worksheet3->insert_image('A1', 'republic.png', 0, 0, 2, 0.8);
      
      # Insert an image over varied column and row sizes.
      $worksheet4->set_column('A:A', 5);
      $worksheet4->set_column('B:B', undef, undef, 1); # Hidden
      $worksheet4->set_column('C:D', 10);
      $worksheet4->set_row(0, 30);
      $worksheet4->set_row(3, 5);
      
      $worksheet4->write('A10', "Image inserted over scaled rows and columns.");
      $worksheet4->insert_image('A1', 'republic.png');
      
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/images.pl>
  
  =head2 Example: indent.pl
  
  
  
  A simple formatting example using Spreadsheet::WriteExcel.
  
  This program demonstrates the indentation cell format.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/indent.jpg" width="640" height="420" alt="Output from indent.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple formatting example using Spreadsheet::WriteExcel.
      #
      # This program demonstrates the indentation cell format.
      #
      # reverse(''), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new('indent.xls');
      
      my $worksheet = $workbook->add_worksheet();
      my $indent1   = $workbook->add_format(indent => 1);
      my $indent2   = $workbook->add_format(indent => 2);
      
      $worksheet->set_column('A:A', 40);
      
      
      $worksheet->write('A1', "This text is indented 1 level",  $indent1);
      $worksheet->write('A2', "This text is indented 2 levels", $indent2);
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/indent.pl>
  
  =head2 Example: merge1.pl
  
  
  
  Simple example of merging cells using the Spreadsheet::WriteExcel module.
  
  This example merges three cells using the "Centre Across Selection"
  alignment which was the Excel 5 method of achieving a merge. For a more
  modern approach use the merge_range() worksheet method instead.
  See the merge3.pl - merge6.pl programs.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/merge1.jpg" width="640" height="420" alt="Output from merge1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Simple example of merging cells using the Spreadsheet::WriteExcel module.
      #
      # This example merges three cells using the "Centre Across Selection"
      # alignment which was the Excel 5 method of achieving a merge. For a more
      # modern approach use the merge_range() worksheet method instead.
      # See the merge3.pl - merge6.pl programs.
      #
      # reverse(''), August 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("merge1.xls");
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_column('B:D', 20);
      $worksheet->set_row(2, 30);
      
      
      # Create a merge format
      my $format = $workbook->add_format(center_across => 1);
      
      
      # Only one cell should contain text, the others should be blank.
      $worksheet->write      (2, 1, "Center across selection", $format);
      $worksheet->write_blank(2, 2,                 $format);
      $worksheet->write_blank(2, 3,                 $format);
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/merge1.pl>
  
  =head2 Example: merge2.pl
  
  
  
  Simple example of merging cells using the Spreadsheet::WriteExcel module
  
  This example merges three cells using the "Centre Across Selection"
  alignment which was the Excel 5 method of achieving a merge. For a more
  modern approach use the merge_range() worksheet method instead.
  See the merge3.pl - merge6.pl programs.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/merge2.jpg" width="640" height="420" alt="Output from merge2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Simple example of merging cells using the Spreadsheet::WriteExcel module
      #
      # This example merges three cells using the "Centre Across Selection"
      # alignment which was the Excel 5 method of achieving a merge. For a more
      # modern approach use the merge_range() worksheet method instead.
      # See the merge3.pl - merge6.pl programs.
      #
      # reverse(''), August 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("merge2.xls");
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_column(1, 2, 30);
      $worksheet->set_row(2, 40);
      
      
      # Create a merged format
      my $format = $workbook->add_format(
                                              center_across   => 1,
                                              bold            => 1,
                                              size            => 15,
                                              pattern         => 1,
                                              border          => 6,
                                              color           => 'white',
                                              fg_color        => 'green',
                                              border_color    => 'yellow',
                                              align           => 'vcenter',
                                        );
      
      
      # Only one cell should contain text, the others should be blank.
      $worksheet->write      (2, 1, "Center across selection", $format);
      $worksheet->write_blank(2, 2,                            $format);
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/merge2.pl>
  
  =head2 Example: merge3.pl
  
  
  
  Example of how to use Spreadsheet::WriteExcel to write a hyperlink in a
  merged cell. There are two options write_url_range() with a standard merge
  format or merge_range().
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/merge3.jpg" width="640" height="420" alt="Output from merge3.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use Spreadsheet::WriteExcel to write a hyperlink in a
      # merged cell. There are two options write_url_range() with a standard merge
      # format or merge_range().
      #
      # reverse(''), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('merge3.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row($_, 30) for (1, 3, 6, 7);
      $worksheet->set_column('B:D', 20);
      
      
      ###############################################################################
      #
      # Example 1: Merge cells containing a hyperlink using write_url_range()
      # and the standard Excel 5+ merge property.
      #
      my $format1 = $workbook->add_format(
                                          center_across   => 1,
                                          border          => 1,
                                          underline       => 1,
                                          color           => 'blue',
                                       );
      
      # Write the cells to be merged
      $worksheet->write_url_range('B2:D2', 'http://www.perl.com', $format1);
      $worksheet->write_blank('C2', $format1);
      $worksheet->write_blank('D2', $format1);
      
      
      
      ###############################################################################
      #
      # Example 2: Merge cells containing a hyperlink using merge_range().
      #
      my $format2 = $workbook->add_format(
                                          border      => 1,
                                          underline   => 1,
                                          color       => 'blue',
                                          align       => 'center',
                                          valign      => 'vcenter',
                                        );
      
      # Merge 3 cells
      $worksheet->merge_range('B4:D4', 'http://www.perl.com', $format2);
      
      
      # Merge 3 cells over two rows
      $worksheet->merge_range('B7:D8', 'http://www.perl.com', $format2);
      
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/merge3.pl>
  
  =head2 Example: merge4.pl
  
  
  
  Example of how to use the Spreadsheet::WriteExcel merge_range() workbook
  method with complex formatting.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/merge4.jpg" width="640" height="420" alt="Output from merge4.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the Spreadsheet::WriteExcel merge_range() workbook
      # method with complex formatting.
      #
      # reverse(''), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('merge4.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row($_, 30) for (1..11);
      $worksheet->set_column('B:D', 20);
      
      
      ###############################################################################
      #
      # Example 1: Text centered vertically and horizontally
      #
      my $format1 = $workbook->add_format(
                                          border  => 6,
                                          bold    => 1,
                                          color   => 'red',
                                          valign  => 'vcenter',
                                          align   => 'center',
                                         );
      
      
      
      $worksheet->merge_range('B2:D3', 'Vertical and horizontal', $format1);
      
      
      ###############################################################################
      #
      # Example 2: Text aligned to the top and left
      #
      my $format2 = $workbook->add_format(
                                          border  => 6,
                                          bold    => 1,
                                          color   => 'red',
                                          valign  => 'top',
                                          align   => 'left',
                                        );
      
      
      
      $worksheet->merge_range('B5:D6', 'Aligned to the top and left', $format2);
      
      
      ###############################################################################
      #
      # Example 3:  Text aligned to the bottom and right
      #
      my $format3 = $workbook->add_format(
                                          border  => 6,
                                          bold    => 1,
                                          color   => 'red',
                                          valign  => 'bottom',
                                          align   => 'right',
                                        );
      
      
      
      $worksheet->merge_range('B8:D9', 'Aligned to the bottom and right', $format3);
      
      
      ###############################################################################
      #
      # Example 4:  Text justified (i.e. wrapped) in the cell
      #
      my $format4 = $workbook->add_format(
                                          border  => 6,
                                          bold    => 1,
                                          color   => 'red',
                                          valign  => 'top',
                                          align   => 'justify',
                                        );
      
      
      
      $worksheet->merge_range('B11:D12', 'Justified: '.'so on and ' x18, $format4);
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/merge4.pl>
  
  =head2 Example: merge5.pl
  
  
  
  Example of how to use the Spreadsheet::WriteExcel merge_cells() workbook
  method with complex formatting and rotation.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/merge5.jpg" width="640" height="420" alt="Output from merge5.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the Spreadsheet::WriteExcel merge_cells() workbook
      # method with complex formatting and rotation.
      #
      #
      # reverse(''), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('merge5.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row($_, 36)         for (3..8);
      $worksheet->set_column($_, $_ , 15) for (1,3,5);
      
      
      ###############################################################################
      #
      # Rotation 1, letters run from top to bottom
      #
      my $format1 = $workbook->add_format(
                                          border      => 6,
                                          bold        => 1,
                                          color       => 'red',
                                          valign      => 'vcentre',
                                          align       => 'centre',
                                          rotation    => 270,
                                        );
      
      
      $worksheet->merge_range('B4:B9', 'Rotation 270', $format1);
      
      
      ###############################################################################
      #
      # Rotation 2, 90 anticlockwise
      #
      my $format2 = $workbook->add_format(
                                          border      => 6,
                                          bold        => 1,
                                          color       => 'red',
                                          valign      => 'vcentre',
                                          align       => 'centre',
                                          rotation    => 90,
                                        );
      
      
      $worksheet->merge_range('D4:D9', 'Rotation 90', $format2);
      
      
      
      ###############################################################################
      #
      # Rotation 3, 90 clockwise
      #
      my $format3 = $workbook->add_format(
                                          border      => 6,
                                          bold        => 1,
                                          color       => 'red',
                                          valign      => 'vcentre',
                                          align       => 'centre',
                                          rotation    => -90,
                                        );
      
      
      $worksheet->merge_range('F4:F9', 'Rotation -90', $format3);
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/merge5.pl>
  
  =head2 Example: merge6.pl
  
  
  
  Example of how to use the Spreadsheet::WriteExcel merge_cells() workbook
  method with Unicode strings.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/merge6.jpg" width="640" height="420" alt="Output from merge6.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the Spreadsheet::WriteExcel merge_cells() workbook
      # method with Unicode strings.
      #
      #
      # reverse(''), December 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new('merge6.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row($_, 36) for 2..9;
      $worksheet->set_column('B:D', 25);
      
      
      # Format for the merged cells.
      my $format = $workbook->add_format(
                                          border      => 6,
                                          bold        => 1,
                                          color       => 'red',
                                          size        => 20,
                                          valign      => 'vcentre',
                                          align       => 'left',
                                          indent      => 1,
                                        );
      
      
      
      
      ###############################################################################
      #
      # Write an Ascii string.
      #
      
      $worksheet->merge_range('B3:D4', 'ASCII: A simple string', $format);
      
      
      
      
      ###############################################################################
      #
      # Write a UTF-16 Unicode string.
      #
      
      # A phrase in Cyrillic encoded as UTF-16BE.
      my $utf16_str = pack "H*", '005500540046002d00310036003a0020'.
                                 '042d0442043e002004440440043004370430002004'.
                                 '3d043000200440044304410441043a043e043c0021';
      
      # Note the extra parameter at the end to indicate UTF-16 encoding.
      $worksheet->merge_range('B6:D7', $utf16_str, $format, 1);
      
      
      
      
      ###############################################################################
      #
      # Write a UTF-8 Unicode string.
      #
      
      if ($] >= 5.008) {
          my $smiley = chr 0x263a;
          $worksheet->merge_range('B9:D10', "UTF-8: A Unicode smiley $smiley",
                                             $format);
      }
      else {
          $worksheet->merge_range('B9:D10', "UTF-8: Requires Perl 5.8", $format);
      }
      
      
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/merge6.pl>
  
  =head2 Example: mod_perl1.pl
  
  
  
  Example of how to use the Spreadsheet::WriteExcel module to send an Excel
  file to a browser using mod_perl 1 and Apache
  
  This module ties *XLS directly to Apache, and with the correct
  content-disposition/types it will prompt the user to save
  the file, or open it at this location.
  
  This script is a modification of the Spreadsheet::WriteExcel cgi.pl example.
  
  Change the name of this file to Cgi.pm.
  Change the package location to where ever you locate this package.
  In the example below it is located in the WriteExcel directory.
  
  Your httpd.conf entry for this module, should you choose to use it
  as a stand alone app, should look similar to the following:
  
      <Location /spreadsheet-test>
        SetHandler perl-script
        PerlHandler Spreadsheet::WriteExcel::Cgi
        PerlSendHeader On
      </Location>
  
  The PerlHandler name above and the package name below *have* to match.
  
      ###############################################################################
      #
      # Example of how to use the Spreadsheet::WriteExcel module to send an Excel
      # file to a browser using mod_perl 1 and Apache
      #
      # This module ties *XLS directly to Apache, and with the correct
      # content-disposition/types it will prompt the user to save
      # the file, or open it at this location.
      #
      # This script is a modification of the Spreadsheet::WriteExcel cgi.pl example.
      #
      # Change the name of this file to Cgi.pm.
      # Change the package location to where ever you locate this package.
      # In the example below it is located in the WriteExcel directory.
      #
      # Your httpd.conf entry for this module, should you choose to use it
      # as a stand alone app, should look similar to the following:
      #
      #     <Location /spreadsheet-test>
      #       SetHandler perl-script
      #       PerlHandler Spreadsheet::WriteExcel::Cgi
      #       PerlSendHeader On
      #     </Location>
      #
      # The PerlHandler name above and the package name below *have* to match.
      
      # Apr 2001, Thomas Sullivan, webmaster@860.org
      # Feb 2001, John McNamara, jmcnamara@cpan.org
      
      package Spreadsheet::WriteExcel::Cgi;
      
      ##########################################
      # Pragma Definitions
      ##########################################
      use strict;
      
      ##########################################
      # Required Modules
      ##########################################
      use Apache::Constants qw(:common);
      use Apache::Request;
      use Apache::URI; # This may not be needed
      use Spreadsheet::WriteExcel;
      
      ##########################################
      # Main App Body
      ##########################################
      sub handler {
          # New apache object
          # Should you decide to use it.
          my $r = Apache::Request->new(shift);
      
          # Set the filename and send the content type
          # This will appear when they save the spreadsheet
          my $filename ="cgitest.xls";
      
          ####################################################
          ## Send the content type headers
          ####################################################
          print "Content-disposition: attachment;filename=$filename\n";
          print "Content-type: application/vnd.ms-excel\n\n";
      
          ####################################################
          # Tie a filehandle to Apache's STDOUT.
          # Create a new workbook and add a worksheet.
          ####################################################
          tie *XLS => 'Apache';
          binmode(*XLS);
      
          my $workbook  = Spreadsheet::WriteExcel->new(\*XLS);
          my $worksheet = $workbook->add_worksheet();
      
      
          # Set the column width for column 1
          $worksheet->set_column(0, 0, 20);
      
      
          # Create a format
          my $format = $workbook->add_format();
          $format->set_bold();
          $format->set_size(15);
          $format->set_color('blue');
      
      
          # Write to the workbook
          $worksheet->write(0, 0, "Hi Excel!", $format);
      
          # You must close the workbook for Content-disposition
          $workbook->close();
      }
      
      1;
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/mod_perl1.pl>
  
  =head2 Example: mod_perl2.pl
  
  
  
  Example of how to use the Spreadsheet::WriteExcel module to send an Excel
  file to a browser using mod_perl 2 and Apache.
  
  This module ties *XLS directly to Apache, and with the correct
  content-disposition/types it will prompt the user to save
  the file, or open it at this location.
  
  This script is a modification of the Spreadsheet::WriteExcel cgi.pl example.
  
  Change the name of this file to MP2Test.pm.
  Change the package location to where ever you locate this package.
  In the example below it is located in the WriteExcel directory.
  
  Your httpd.conf entry for this module, should you choose to use it
  as a stand alone app, should look similar to the following:
  
      PerlModule Apache2::RequestRec
      PerlModule APR::Table
      PerlModule Apache2::RequestIO
  
      <Location /spreadsheet-test>
         SetHandler perl-script
         PerlResponseHandler Spreadsheet::WriteExcel::MP2Test
      </Location>
  
  The PerlResponseHandler must match the package name below.
  
      ###############################################################################
      #
      # Example of how to use the Spreadsheet::WriteExcel module to send an Excel
      # file to a browser using mod_perl 2 and Apache.
      #
      # This module ties *XLS directly to Apache, and with the correct
      # content-disposition/types it will prompt the user to save
      # the file, or open it at this location.
      #
      # This script is a modification of the Spreadsheet::WriteExcel cgi.pl example.
      #
      # Change the name of this file to MP2Test.pm.
      # Change the package location to where ever you locate this package.
      # In the example below it is located in the WriteExcel directory.
      #
      # Your httpd.conf entry for this module, should you choose to use it
      # as a stand alone app, should look similar to the following:
      #
      #     PerlModule Apache2::RequestRec
      #     PerlModule APR::Table
      #     PerlModule Apache2::RequestIO
      #
      #     <Location /spreadsheet-test>
      #        SetHandler perl-script
      #        PerlResponseHandler Spreadsheet::WriteExcel::MP2Test
      #     </Location>
      #
      # The PerlResponseHandler must match the package name below.
      
      # Jun 2004, Matisse Enzer, matisse@matisse.net  (mod_perl 2 version)
      # Apr 2001, Thomas Sullivan, webmaster@860.org
      # Feb 2001, John McNamara, jmcnamara@cpan.org
      
      package Spreadsheet::WriteExcel::MP2Test;
      
      ##########################################
      # Pragma Definitions
      ##########################################
      use strict;
      
      ##########################################
      # Required Modules
      ##########################################
      use Apache2::Const -compile => qw( :common );
      use Spreadsheet::WriteExcel;
      
      ##########################################
      # Main App Body
      ##########################################
      sub handler {
          my($r) = @_;  # Apache request object is passed to handler in mod_perl 2
      
          # Set the filename and send the content type
          # This will appear when they save the spreadsheet
          my $filename ="mod_perl2_test.xls";
      
          ####################################################
          ## Send the content type headers the mod_perl 2 way
          ####################################################
          $r->headers_out->{'Content-Disposition'} = "attachment;filename=$filename";
          $r->content_type('application/vnd.ms-excel');
      
          ####################################################
          # Tie a filehandle to Apache's STDOUT.
          # Create a new workbook and add a worksheet.
          ####################################################
          tie *XLS => $r;  # The mod_perl 2 way. Tie to the Apache::RequestRec object
          binmode(*XLS);
      
          my $workbook  = Spreadsheet::WriteExcel->new(\*XLS);
          my $worksheet = $workbook->add_worksheet();
      
      
          # Set the column width for column 1
          $worksheet->set_column(0, 0, 20);
      
      
          # Create a format
          my $format = $workbook->add_format();
          $format->set_bold();
          $format->set_size(15);
          $format->set_color('blue');
      
      
          # Write to the workbook
          $worksheet->write(0, 0, 'Hi Excel! from ' . $r->hostname , $format);
      
          # You must close the workbook for Content-disposition
          $workbook->close();
          return Apache2::Const::OK;
      }
      
      1;
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/mod_perl2.pl>
  
  =head2 Example: outline.pl
  
  
  
  Example of how use Spreadsheet::WriteExcel to generate Excel outlines and
  grouping.
  
  
  Excel allows you to group rows or columns so that they can be hidden or
  displayed with a single mouse click. This feature is referred to as outlines.
  
  Outlines can reduce complex data down to a few salient sub-totals or 
  summaries.
  
  This feature is best viewed in Excel but the following is an ASCII
  representation of what a worksheet with three outlines might look like.
  Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9 are grouped at
  level 1. The lines at the left hand side are called outline level bars.
  
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |  _  | 2 |   B   |       |       |       |  ...
       | |   | 3 |  (C)  |       |       |       |  ...
       | |   | 4 |  (D)  |       |       |       |  ...
       | -   | 5 |   E   |       |       |       |  ...
       |  _  | 6 |   F   |       |       |       |  ...
       | |   | 7 |  (G)  |       |       |       |  ...
       | |   | 8 |  (H)  |       |       |       |  ...
       | -   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking the minus sign on each of the level 2 outlines will collapse and
  hide the data as shown in the next figure. The minus sign changes to a plus
  sign to indicate that the data in the outline is hidden.
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |     | 2 |   B   |       |       |       |  ...
       | +   | 5 |   E   |       |       |       |  ...
       |     | 6 |   F   |       |       |       |  ...
       | +   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking on the minus sign on the level 1 outline will collapse the remaining
  rows as follows:
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
             | 1 |   A   |       |       |       |  ...
       +     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  See the main Spreadsheet::WriteExcel documentation for more information.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/outline.jpg" width="640" height="420" alt="Output from outline.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how use Spreadsheet::WriteExcel to generate Excel outlines and
      # grouping.
      #
      #
      # Excel allows you to group rows or columns so that they can be hidden or
      # displayed with a single mouse click. This feature is referred to as outlines.
      #
      # Outlines can reduce complex data down to a few salient sub-totals or 
      # summaries.
      #
      # This feature is best viewed in Excel but the following is an ASCII
      # representation of what a worksheet with three outlines might look like.
      # Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9 are grouped at
      # level 1. The lines at the left hand side are called outline level bars.
      #
      #
      #             ------------------------------------------
      #      1 2 3 |   |   A   |   B   |   C   |   D   |  ...
      #             ------------------------------------------
      #       _    | 1 |   A   |       |       |       |  ...
      #      |  _  | 2 |   B   |       |       |       |  ...
      #      | |   | 3 |  (C)  |       |       |       |  ...
      #      | |   | 4 |  (D)  |       |       |       |  ...
      #      | -   | 5 |   E   |       |       |       |  ...
      #      |  _  | 6 |   F   |       |       |       |  ...
      #      | |   | 7 |  (G)  |       |       |       |  ...
      #      | |   | 8 |  (H)  |       |       |       |  ...
      #      | -   | 9 |   I   |       |       |       |  ...
      #      -     | . |  ...  |  ...  |  ...  |  ...  |  ...
      #
      #
      # Clicking the minus sign on each of the level 2 outlines will collapse and
      # hide the data as shown in the next figure. The minus sign changes to a plus
      # sign to indicate that the data in the outline is hidden.
      #
      #             ------------------------------------------
      #      1 2 3 |   |   A   |   B   |   C   |   D   |  ...
      #             ------------------------------------------
      #       _    | 1 |   A   |       |       |       |  ...
      #      |     | 2 |   B   |       |       |       |  ...
      #      | +   | 5 |   E   |       |       |       |  ...
      #      |     | 6 |   F   |       |       |       |  ...
      #      | +   | 9 |   I   |       |       |       |  ...
      #      -     | . |  ...  |  ...  |  ...  |  ...  |  ...
      #
      #
      # Clicking on the minus sign on the level 1 outline will collapse the remaining
      # rows as follows:
      #
      #             ------------------------------------------
      #      1 2 3 |   |   A   |   B   |   C   |   D   |  ...
      #             ------------------------------------------
      #            | 1 |   A   |       |       |       |  ...
      #      +     | . |  ...  |  ...  |  ...  |  ...  |  ...
      #
      # See the main Spreadsheet::WriteExcel documentation for more information.
      #
      # reverse(''), April 2003, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add some worksheets
      my $workbook   = Spreadsheet::WriteExcel->new('outline.xls');
      my $worksheet1 = $workbook->add_worksheet('Outlined Rows');
      my $worksheet2 = $workbook->add_worksheet('Collapsed Rows');
      my $worksheet3 = $workbook->add_worksheet('Outline Columns');
      my $worksheet4 = $workbook->add_worksheet('Outline levels');
      
      # Add a general format
      my $bold = $workbook->add_format(bold => 1);
      
      
      
      ###############################################################################
      #
      # Example 1: Create a worksheet with outlined rows. It also includes SUBTOTAL()
      # functions so that it looks like the type of automatic outlines that are
      # generated when you use the Excel Data->SubTotals menu item.
      #
      
      
      # For outlines the important parameters are $hidden and $level. Rows with the
      # same $level are grouped together. The group will be collapsed if $hidden is
      # non-zero. $height and $XF are assigned default values if they are undef.
      #
      # The syntax is: set_row($row, $height, $XF, $hidden, $level, $collapsed)
      #
      $worksheet1->set_row(1,  undef, undef, 0, 2);
      $worksheet1->set_row(2,  undef, undef, 0, 2);
      $worksheet1->set_row(3,  undef, undef, 0, 2);
      $worksheet1->set_row(4,  undef, undef, 0, 2);
      $worksheet1->set_row(5,  undef, undef, 0, 1);
      
      $worksheet1->set_row(6,  undef, undef, 0, 2);
      $worksheet1->set_row(7,  undef, undef, 0, 2);
      $worksheet1->set_row(8,  undef, undef, 0, 2);
      $worksheet1->set_row(9,  undef, undef, 0, 2);
      $worksheet1->set_row(10, undef, undef, 0, 1);
      
      
      # Add a column format for clarity
      $worksheet1->set_column('A:A', 20);
      
      # Add the data, labels and formulas
      $worksheet1->write('A1',  'Region', $bold);
      $worksheet1->write('A2',  'North');
      $worksheet1->write('A3',  'North');
      $worksheet1->write('A4',  'North');
      $worksheet1->write('A5',  'North');
      $worksheet1->write('A6',  'North Total', $bold);
      
      $worksheet1->write('B1',  'Sales',  $bold);
      $worksheet1->write('B2',  1000);
      $worksheet1->write('B3',  1200);
      $worksheet1->write('B4',  900);
      $worksheet1->write('B5',  1200);
      $worksheet1->write('B6',  '=SUBTOTAL(9,B2:B5)', $bold);
      
      $worksheet1->write('A7',  'South');
      $worksheet1->write('A8',  'South');
      $worksheet1->write('A9',  'South');
      $worksheet1->write('A10', 'South');
      $worksheet1->write('A11', 'South Total', $bold);
      
      $worksheet1->write('B7',  400);
      $worksheet1->write('B8',  600);
      $worksheet1->write('B9',  500);
      $worksheet1->write('B10', 600);
      $worksheet1->write('B11', '=SUBTOTAL(9,B7:B10)', $bold);
      
      $worksheet1->write('A12', 'Grand Total', $bold);
      $worksheet1->write('B12', '=SUBTOTAL(9,B2:B10)', $bold);
      
      
      ###############################################################################
      #
      # Example 2: Create a worksheet with outlined rows. This is the same as the
      # previous example except that the rows are collapsed.
      # Note: We need to indicate the row that contains the collapsed symbol '+'
      # with the optional parameter, $collapsed.
      
      # The group will be collapsed if $hidden is non-zero.
      # The syntax is: set_row($row, $height, $XF, $hidden, $level, $collapsed)
      #
      $worksheet2->set_row(1,  undef, undef, 1, 2);
      $worksheet2->set_row(2,  undef, undef, 1, 2);
      $worksheet2->set_row(3,  undef, undef, 1, 2);
      $worksheet2->set_row(4,  undef, undef, 1, 2);
      $worksheet2->set_row(5,  undef, undef, 1, 1);
      
      $worksheet2->set_row(6,  undef, undef, 1, 2);
      $worksheet2->set_row(7,  undef, undef, 1, 2);
      $worksheet2->set_row(8,  undef, undef, 1, 2);
      $worksheet2->set_row(9,  undef, undef, 1, 2);
      $worksheet2->set_row(10, undef, undef, 1, 1);
      $worksheet2->set_row(11, undef, undef, 0, 0, 1);
      
      
      # Add a column format for clarity
      $worksheet2->set_column('A:A', 20);
      
      # Add the data, labels and formulas
      $worksheet2->write('A1',  'Region', $bold);
      $worksheet2->write('A2',  'North');
      $worksheet2->write('A3',  'North');
      $worksheet2->write('A4',  'North');
      $worksheet2->write('A5',  'North');
      $worksheet2->write('A6',  'North Total', $bold);
      
      $worksheet2->write('B1',  'Sales',  $bold);
      $worksheet2->write('B2',  1000);
      $worksheet2->write('B3',  1200);
      $worksheet2->write('B4',  900);
      $worksheet2->write('B5',  1200);
      $worksheet2->write('B6',  '=SUBTOTAL(9,B2:B5)', $bold);
      
      $worksheet2->write('A7',  'South');
      $worksheet2->write('A8',  'South');
      $worksheet2->write('A9',  'South');
      $worksheet2->write('A10', 'South');
      $worksheet2->write('A11', 'South Total', $bold);
      
      $worksheet2->write('B7',  400);
      $worksheet2->write('B8',  600);
      $worksheet2->write('B9',  500);
      $worksheet2->write('B10', 600);
      $worksheet2->write('B11', '=SUBTOTAL(9,B7:B10)', $bold);
      
      $worksheet2->write('A12', 'Grand Total', $bold);
      $worksheet2->write('B12', '=SUBTOTAL(9,B2:B10)', $bold);
      
      
      
      ###############################################################################
      #
      # Example 3: Create a worksheet with outlined columns.
      #
      my $data = [
                  ['Month', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',' Total'],
                  ['North', 50,    20,    15,    25,    65,    80,    ,'=SUM(B2:G2)'],
                  ['South', 10,    20,    30,    50,    50,    50,    ,'=SUM(B3:G3)'],
                  ['East',  45,    75,    50,    15,    75,    100,   ,'=SUM(B4:G4)'],
                  ['West',  15,    15,    55,    35,    20,    50,    ,'=SUM(B5:G6)'],
                 ];
      
      # Add bold format to the first row
      $worksheet3->set_row(0, undef, $bold);
      
      # Syntax: set_column($col1, $col2, $width, $XF, $hidden, $level, $collapsed)
      $worksheet3->set_column('A:A', 10, $bold      );
      $worksheet3->set_column('B:G', 5,  undef, 0, 1);
      $worksheet3->set_column('H:H', 10);
      
      # Write the data and a formula
      $worksheet3->write_col('A1', $data);
      $worksheet3->write('H6', '=SUM(H2:H5)', $bold);
      
      
      
      ###############################################################################
      #
      # Example 4: Show all possible outline levels.
      #
      my $levels = ["Level 1", "Level 2", "Level 3", "Level 4",
                    "Level 5", "Level 6", "Level 7", "Level 6",
                    "Level 5", "Level 4", "Level 3", "Level 2", "Level 1"];
      
      
      $worksheet4->write_col('A1', $levels);
      
      $worksheet4->set_row(0,  undef, undef, undef, 1);
      $worksheet4->set_row(1,  undef, undef, undef, 2);
      $worksheet4->set_row(2,  undef, undef, undef, 3);
      $worksheet4->set_row(3,  undef, undef, undef, 4);
      $worksheet4->set_row(4,  undef, undef, undef, 5);
      $worksheet4->set_row(5,  undef, undef, undef, 6);
      $worksheet4->set_row(6,  undef, undef, undef, 7);
      $worksheet4->set_row(7,  undef, undef, undef, 6);
      $worksheet4->set_row(8,  undef, undef, undef, 5);
      $worksheet4->set_row(9,  undef, undef, undef, 4);
      $worksheet4->set_row(10, undef, undef, undef, 3);
      $worksheet4->set_row(11, undef, undef, undef, 2);
      $worksheet4->set_row(12, undef, undef, undef, 1);
      
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/outline.pl>
  
  =head2 Example: outline_collapsed.pl
  
  
  
  Example of how use Spreadsheet::WriteExcel to generate Excel outlines and
  grouping.
  
  These example focus mainly on collapsed outlines. See also the
  outlines.pl example program for more general examples.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/outline_collapsed.jpg" width="640" height="420" alt="Output from outline_collapsed.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how use Spreadsheet::WriteExcel to generate Excel outlines and
      # grouping.
      #
      # These example focus mainly on collapsed outlines. See also the
      # outlines.pl example program for more general examples.
      #
      # reverse(''), March 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add some worksheets
      my $workbook   = Spreadsheet::WriteExcel->new('outline_collapsed.xls');
      my $worksheet1 = $workbook->add_worksheet('Outlined Rows');
      my $worksheet2 = $workbook->add_worksheet('Collapsed Rows 1');
      my $worksheet3 = $workbook->add_worksheet('Collapsed Rows 2');
      my $worksheet4 = $workbook->add_worksheet('Collapsed Rows 3');
      my $worksheet5 = $workbook->add_worksheet('Outline Columns');
      my $worksheet6 = $workbook->add_worksheet('Collapsed Columns');
      
      
      # Add a general format
      my $bold = $workbook->add_format(bold => 1);
      
      
      #
      # This function will generate the same data and sub-totals on each worksheet.
      #
      sub create_sub_totals {
      
          my $worksheet = $_[0];
      
          # Add a column format for clarity
          $worksheet->set_column('A:A', 20);
      
          # Add the data, labels and formulas
          $worksheet->write('A1',  'Region', $bold);
          $worksheet->write('A2',  'North');
          $worksheet->write('A3',  'North');
          $worksheet->write('A4',  'North');
          $worksheet->write('A5',  'North');
          $worksheet->write('A6',  'North Total', $bold);
      
          $worksheet->write('B1',  'Sales',  $bold);
          $worksheet->write('B2',  1000);
          $worksheet->write('B3',  1200);
          $worksheet->write('B4',  900);
          $worksheet->write('B5',  1200);
          $worksheet->write('B6',  '=SUBTOTAL(9,B2:B5)', $bold);
      
          $worksheet->write('A7',  'South');
          $worksheet->write('A8',  'South');
          $worksheet->write('A9',  'South');
          $worksheet->write('A10', 'South');
          $worksheet->write('A11', 'South Total', $bold);
      
          $worksheet->write('B7',  400);
          $worksheet->write('B8',  600);
          $worksheet->write('B9',  500);
          $worksheet->write('B10', 600);
          $worksheet->write('B11', '=SUBTOTAL(9,B7:B10)', $bold);
      
          $worksheet->write('A12', 'Grand Total', $bold);
          $worksheet->write('B12', '=SUBTOTAL(9,B2:B10)', $bold);
      
      }
      
      
      ###############################################################################
      #
      # Example 1: Create a worksheet with outlined rows. It also includes SUBTOTAL()
      # functions so that it looks like the type of automatic outlines that are
      # generated when you use the Excel Data->SubTotals menu item.
      #
      
      # The syntax is: set_row($row, $height, $XF, $hidden, $level, $collapsed)
      $worksheet1->set_row(1,  undef, undef, 0, 2);
      $worksheet1->set_row(2,  undef, undef, 0, 2);
      $worksheet1->set_row(3,  undef, undef, 0, 2);
      $worksheet1->set_row(4,  undef, undef, 0, 2);
      $worksheet1->set_row(5,  undef, undef, 0, 1);
      
      $worksheet1->set_row(6,  undef, undef, 0, 2);
      $worksheet1->set_row(7,  undef, undef, 0, 2);
      $worksheet1->set_row(8,  undef, undef, 0, 2);
      $worksheet1->set_row(9,  undef, undef, 0, 2);
      $worksheet1->set_row(10, undef, undef, 0, 1);
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals($worksheet1);
      
      
      ###############################################################################
      #
      # Example 2: Create a worksheet with collapsed outlined rows.
      # This is the same as the example 1  except that the all rows are collapsed.
      # Note: We need to indicate the row that contains the collapsed symbol '+' with
      # the optional parameter, $collapsed.
      
      $worksheet2->set_row(1,  undef, undef, 1, 2);
      $worksheet2->set_row(2,  undef, undef, 1, 2);
      $worksheet2->set_row(3,  undef, undef, 1, 2);
      $worksheet2->set_row(4,  undef, undef, 1, 2);
      $worksheet2->set_row(5,  undef, undef, 1, 1);
      
      $worksheet2->set_row(6,  undef, undef, 1, 2);
      $worksheet2->set_row(7,  undef, undef, 1, 2);
      $worksheet2->set_row(8,  undef, undef, 1, 2);
      $worksheet2->set_row(9,  undef, undef, 1, 2);
      $worksheet2->set_row(10, undef, undef, 1, 1);
      
      $worksheet2->set_row(11, undef, undef, 0, 0, 1);
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals($worksheet2);
      
      
      ###############################################################################
      #
      # Example 3: Create a worksheet with collapsed outlined rows.
      # Same as the example 1  except that the two sub-totals are collapsed.
      
      $worksheet3->set_row(1,  undef, undef, 1, 2);
      $worksheet3->set_row(2,  undef, undef, 1, 2);
      $worksheet3->set_row(3,  undef, undef, 1, 2);
      $worksheet3->set_row(4,  undef, undef, 1, 2);
      $worksheet3->set_row(5,  undef, undef, 0, 1, 1);
      
      $worksheet3->set_row(6,  undef, undef, 1, 2);
      $worksheet3->set_row(7,  undef, undef, 1, 2);
      $worksheet3->set_row(8,  undef, undef, 1, 2);
      $worksheet3->set_row(9,  undef, undef, 1, 2);
      $worksheet3->set_row(10, undef, undef, 0, 1, 1);
      
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals($worksheet3);
      
      
      ###############################################################################
      #
      # Example 4: Create a worksheet with outlined rows.
      # Same as the example 1  except that the two sub-totals are collapsed.
      
      $worksheet4->set_row(1,  undef, undef, 1, 2);
      $worksheet4->set_row(2,  undef, undef, 1, 2);
      $worksheet4->set_row(3,  undef, undef, 1, 2);
      $worksheet4->set_row(4,  undef, undef, 1, 2);
      $worksheet4->set_row(5,  undef, undef, 1, 1, 1);
      
      $worksheet4->set_row(6,  undef, undef, 1, 2);
      $worksheet4->set_row(7,  undef, undef, 1, 2);
      $worksheet4->set_row(8,  undef, undef, 1, 2);
      $worksheet4->set_row(9,  undef, undef, 1, 2);
      $worksheet4->set_row(10, undef, undef, 1, 1, 1);
      
      $worksheet4->set_row(11, undef, undef, 0, 0, 1);
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals($worksheet4);
      
      
      
      ###############################################################################
      #
      # Example 5: Create a worksheet with outlined columns.
      #
      my $data = [
                  ['Month', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',' Total'],
                  ['North', 50,    20,    15,    25,    65,    80,    ,'=SUM(B2:G2)'],
                  ['South', 10,    20,    30,    50,    50,    50,    ,'=SUM(B3:G3)'],
                  ['East',  45,    75,    50,    15,    75,    100,   ,'=SUM(B4:G4)'],
                  ['West',  15,    15,    55,    35,    20,    50,    ,'=SUM(B5:G6)'],
                 ];
      
      # Add bold format to the first row
      $worksheet5->set_row(0, undef, $bold);
      
      # Syntax: set_column($col1, $col2, $width, $XF, $hidden, $level, $collapsed)
      $worksheet5->set_column('A:A', 10, $bold      );
      $worksheet5->set_column('B:G', 5,  undef, 0, 1);
      $worksheet5->set_column('H:H', 10             );
      
      # Write the data and a formula
      $worksheet5->write_col('A1', $data);
      $worksheet5->write('H6', '=SUM(H2:H5)', $bold);
      
      
      ###############################################################################
      #
      # Example 6: Create a worksheet with collapsed outlined columns.
      # This is the same as the previous example except collapsed columns.
      
      # Add bold format to the first row
      $worksheet6->set_row(0, undef, $bold);
      
      # Syntax: set_column($col1, $col2, $width, $XF, $hidden, $level, $collapsed)
      $worksheet6->set_column('A:A', 10, $bold         );
      $worksheet6->set_column('B:G', 5,  undef, 1, 1   );
      $worksheet6->set_column('H:H', 10, undef, 0, 0, 1);
      
      # Write the data and a formula
      $worksheet6->write_col('A1', $data);
      $worksheet6->write('H6', '=SUM(H2:H5)', $bold);
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/outline_collapsed.pl>
  
  =head2 Example: panes.pl
  
  
  
  Example of using the WriteExcel module to create worksheet panes.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/panes.jpg" width="640" height="420" alt="Output from panes.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # Example of using the WriteExcel module to create worksheet panes.
      #
      # reverse(''), May 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new("panes.xls");
      
      my $worksheet1 = $workbook->add_worksheet('Panes 1');
      my $worksheet2 = $workbook->add_worksheet('Panes 2');
      my $worksheet3 = $workbook->add_worksheet('Panes 3');
      my $worksheet4 = $workbook->add_worksheet('Panes 4');
      
      # Freeze panes
      $worksheet1->freeze_panes(1, 0); # 1 row
      
      $worksheet2->freeze_panes(0, 1); # 1 column
      $worksheet3->freeze_panes(1, 1); # 1 row and column
      
      # Split panes.
      # The divisions must be specified in terms of row and column dimensions.
      # The default row height is 12.75 and the default column width is 8.43
      #
      $worksheet4->split_panes(12.75, 8.43, 1, 1); # 1 row and column
      
      
      #######################################################################
      #
      # Set up some formatting and text to highlight the panes
      #
      
      my $header = $workbook->add_format();
      $header->set_color('white');
      $header->set_align('center');
      $header->set_align('vcenter');
      $header->set_pattern();
      $header->set_fg_color('green');
      
      my $center = $workbook->add_format();
      $center->set_align('center');
      
      
      #######################################################################
      #
      # Sheet 1
      #
      
      $worksheet1->set_column('A:I', 16);
      $worksheet1->set_row(0, 20);
      $worksheet1->set_selection('C3');
      
      for my $i (0..8){
          $worksheet1->write(0, $i, 'Scroll down', $header);
      }
      
      for my $i (1..100){
          for my $j (0..8){
              $worksheet1->write($i, $j, $i+1, $center);
          }
      }
      
      
      #######################################################################
      #
      # Sheet 2
      #
      
      $worksheet2->set_column('A:A', 16);
      $worksheet2->set_selection('C3');
      
      for my $i (0..49){
          $worksheet2->set_row($i, 15);
          $worksheet2->write($i, 0, 'Scroll right', $header);
      }
      
      for my $i (0..49){
          for my $j (1..25){
              $worksheet2->write($i, $j, $j, $center);
          }
      }
      
      
      #######################################################################
      #
      # Sheet 3
      #
      
      $worksheet3->set_column('A:Z', 16);
      $worksheet3->set_selection('C3');
      
      for my $i (1..25){
          $worksheet3->write(0, $i, 'Scroll down',  $header);
      }
      
      for my $i (1..49){
          $worksheet3->write($i, 0, 'Scroll right', $header);
      }
      
      for my $i (1..49){
          for my $j (1..25){
              $worksheet3->write($i, $j, $j, $center);
          }
      }
      
      
      #######################################################################
      #
      # Sheet 4
      #
      
      $worksheet4->set_selection('C3');
      
      for my $i (1..25){
          $worksheet4->write(0, $i, 'Scroll', $center);
      }
      
      for my $i (1..49){
          $worksheet4->write($i, 0, 'Scroll', $center);
      }
      
      for my $i (1..49){
          for my $j (1..25){
              $worksheet4->write($i, $j, $j, $center);
          }
      }
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/panes.pl>
  
  =head2 Example: properties.pl
  
  
  
  An example of adding document properties to a Spreadsheet::WriteExcel file.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/properties.jpg" width="640" height="420" alt="Output from properties.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # An example of adding document properties to a Spreadsheet::WriteExcel file.
      #
      # reverse(''), August 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new('properties.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      $workbook->set_properties(
          title    => 'This is an example spreadsheet',
          subject  => 'With document properties',
          author   => 'John McNamara',
          manager  => 'Dr. Heinz Doofenshmirtz ',
          company  => 'of Wolves',
          category => 'Example spreadsheets',
          keywords => 'Sample, Example, Properties',
          comments => 'Created with Perl and Spreadsheet::WriteExcel',
      );
      
      
      $worksheet->set_column('A:A', 50);
      $worksheet->write('A1', 'Select File->Properties to see the file properties');
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/properties.pl>
  
  =head2 Example: protection.pl
  
  
  
  Example of cell locking and formula hiding in an Excel worksheet via
  the Spreadsheet::WriteExcel module.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/protection.jpg" width="640" height="420" alt="Output from protection.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ########################################################################
      #
      # Example of cell locking and formula hiding in an Excel worksheet via
      # the Spreadsheet::WriteExcel module.
      #
      # reverse(''), August 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new("protection.xls");
      my $worksheet = $workbook->add_worksheet();
      
      # Create some format objects
      my $locked    = $workbook->add_format(locked => 1);
      my $unlocked  = $workbook->add_format(locked => 0);
      my $hidden    = $workbook->add_format(hidden => 1);
      
      # Format the columns
      $worksheet->set_column('A:A', 42);
      $worksheet->set_selection('B3:B3');
      
      # Protect the worksheet
      $worksheet->protect();
      
      # Examples of cell locking and hiding
      $worksheet->write('A1', 'Cell B1 is locked. It cannot be edited.');
      $worksheet->write('B1', '=1+2', $locked);
      
      $worksheet->write('A2', 'Cell B2 is unlocked. It can be edited.');
      $worksheet->write('B2', '=1+2', $unlocked);
      
      $worksheet->write('A3', "Cell B3 is hidden. The formula isn't visible.");
      $worksheet->write('B3', '=1+2', $hidden);
      
      $worksheet->write('A5', 'Use Menu->Tools->Protection->Unprotect Sheet');
      $worksheet->write('A6', 'to remove the worksheet protection.   ');
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/protection.pl>
  
  =head2 Example: repeat.pl
  
  
  
  Example of writing repeated formulas.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/repeat.jpg" width="640" height="420" alt="Output from repeat.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ######################################################################
      #
      # Example of writing repeated formulas.
      #
      # reverse(''), August 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new("repeat.xls");
      my $worksheet = $workbook->add_worksheet();
      
      
      my $limit = 1000;
      
      # Write a column of numbers
      for my $row (0..$limit) {
          $worksheet->write($row, 0,  $row);
      }
      
      
      # Store a formula
      my $formula = $worksheet->store_formula('=A1*5+4');
      
      
      # Write a column of formulas based on the stored formula
      for my $row (0..$limit) {
          $worksheet->repeat_formula($row, 1, $formula, undef,
                                              qr/^A1$/, 'A'.($row+1));
      }
      
      
      # Direct formula writing. As a speed comparison uncomment the
      # following and run the program again
      
      #for my $row (0..$limit) {
      #    $worksheet->write_formula($row, 2, '=A'.($row+1).'*5+4');
      #}
      
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/repeat.pl>
  
  =head2 Example: right_to_left.pl
  
  
  
  Example of how to change the default worksheet direction from
  left-to-right to right-to-left as required by some eastern verions
  of Excel.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/right_to_left.jpg" width="640" height="420" alt="Output from right_to_left.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # Example of how to change the default worksheet direction from
      # left-to-right to right-to-left as required by some eastern verions
      # of Excel.
      #
      # reverse(''), January 2006, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook   = Spreadsheet::WriteExcel->new("right_to_left.xls");
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      
      $worksheet2->right_to_left();
      
      $worksheet1->write(0, 0, 'Hello'); #  A1, B1, C1, ...
      $worksheet2->write(0, 0, 'Hello'); # ..., C1, B1, A1
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/right_to_left.pl>
  
  =head2 Example: row_wrap.pl
  
  
  
  Demonstrates how to wrap data from one worksheet onto another.
  
  Excel has a row limit of 65536 rows. Sometimes the amount of row data to be
  written to a file is greater than this limit. In this case it is a useful
  technique to wrap the data from one worksheet onto the next so that we get
  something like the following:
  
    Sheet1  Row     1  -  65536
    Sheet2  Row 65537  - 131072
    Sheet3  Row 131073 - ...
  
  In order to achieve this we use a single worksheet reference and
  reinitialise it to point to a new worksheet when required.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/row_wrap.jpg" width="640" height="420" alt="Output from row_wrap.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # Demonstrates how to wrap data from one worksheet onto another.
      #
      # Excel has a row limit of 65536 rows. Sometimes the amount of row data to be
      # written to a file is greater than this limit. In this case it is a useful
      # technique to wrap the data from one worksheet onto the next so that we get
      # something like the following:
      #
      #   Sheet1  Row     1  -  65536
      #   Sheet2  Row 65537  - 131072
      #   Sheet3  Row 131073 - ...
      #
      # In order to achieve this we use a single worksheet reference and
      # reinitialise it to point to a new worksheet when required.
      #
      # reverse(''), May 2006, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      my $workbook  = Spreadsheet::WriteExcel->new('row_wrap.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Worksheet formatting.
      $worksheet->set_column('A:A', 20);
      
      
      # For the sake of this example we will use a small row limit. In order to use
      # the entire row range set the $row_limit to 65536.
      my $row_limit = 10;
      my $row       = 0;
      
      for my $count (1 .. 2 * $row_limit +10) {
      
          # When we hit the row limit we redirect the output
          # to a new worksheet and reset the row number.
          if ($row == $row_limit) {
              $worksheet = $workbook->add_worksheet();
              $row = 0;
      
              # Repeat any worksheet formatting.
              $worksheet->set_column('A:A', 20);
          }
      
          $worksheet->write($row, 0,  "This is row $count");
          $row++;
      }
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/row_wrap.pl>
  
  =head2 Example: sales.pl
  
  
  
  Example of a sales worksheet to demonstrate several different features.
  Also uses functions from the L<Spreadsheet::WriteExcel::Utility> module.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/sales.jpg" width="640" height="420" alt="Output from sales.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of a sales worksheet to demonstrate several different features.
      # Also uses functions from the L<Spreadsheet::WriteExcel::Utility> module.
      #
      # reverse(''), October 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      use Spreadsheet::WriteExcel::Utility;
      
      # Create a new workbook and add a worksheet
      my $workbook        = Spreadsheet::WriteExcel->new("sales.xls");
      my $worksheet       = $workbook->add_worksheet('May Sales');
      
      
      # Set up some formats
      my %heading         =   (
                                  bold        => 1,
                                  pattern     => 1,
                                  fg_color    => 19,
                                  border      => 1,
                                  align       => 'center',
                              );
      
      my %total           =   (
                              bold        => 1,
                              top         => 1,
                              num_format  => '$#,##0.00'
                              );
      
      my $heading         = $workbook->add_format(%heading);
      my $total_format    = $workbook->add_format(%total);
      my $price_format    = $workbook->add_format(num_format => '$#,##0.00');
      my $date_format     = $workbook->add_format(num_format => 'mmm d yyy');
      
      
      # Write the main headings
      $worksheet->freeze_panes(1); # Freeze the first row
      $worksheet->write('A1', 'Item',     $heading);
      $worksheet->write('B1', 'Quantity', $heading);
      $worksheet->write('C1', 'Price',    $heading);
      $worksheet->write('D1', 'Total',    $heading);
      $worksheet->write('E1', 'Date',     $heading);
      
      # Set the column widths
      $worksheet->set_column('A:A', 25);
      $worksheet->set_column('B:B', 10);
      $worksheet->set_column('C:E', 16);
      
      
      # Extract the sales data from the __DATA__ section at the end of the file.
      # In reality this information would probably come from a database
      my @sales;
      
      foreach my $line (<DATA>) {
          chomp $line;
          next if $line eq '';
          # Simple-minded processing of CSV data. Refer to the Text::CSV_XS
          # and Text::xSV modules for a more complete CSV handling.
          my @items = split /,/, $line;
          push @sales, \@items;
      }
      
      
      # Write out the items from each row
      my $row = 1;
      foreach my $sale (@sales) {
      
          $worksheet->write($row, 0, @$sale[0]);
          $worksheet->write($row, 1, @$sale[1]);
          $worksheet->write($row, 2, @$sale[2], $price_format);
      
          # Create a formula like '=B2*C2'
          my $formula =   '='
                          . xl_rowcol_to_cell($row, 1)
                          . "*"
                          . xl_rowcol_to_cell($row, 2);
      
          $worksheet->write($row, 3, $formula, $price_format);
      
          # Parse the date
          my $date = xl_decode_date_US(@$sale[3]);
          $worksheet->write($row, 4, $date, $date_format);
          $row++;
      }
      
      # Create a formula to sum the totals, like '=SUM(D2:D6)'
      my $total = '=SUM(D2:'
                  . xl_rowcol_to_cell($row-1, 3)
                  . ")";
      
      $worksheet->write($row, 3, $total, $total_format);
      
      
      
      __DATA__
      586 card,20,125.50,5/12/01
      Flat Screen Monitor,1,1300.00,5/12/01
      64 MB dimms,45,49.99,5/13/01
      15 GB HD,12,300.00,5/13/01
      Speakers (pair),5,15.50,5/14/01
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/sales.pl>
  
  =head2 Example: sendmail.pl
  
  
  
  Example of how to use Mail::Sender to send a Spreadsheet::WriteExcel Excel
  file as an attachment.
  
  The main thing is to ensure that you close() the Worbook before you send it.
  
  See the L<Mail::Sender> module for further details.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use Mail::Sender to send a Spreadsheet::WriteExcel Excel
      # file as an attachment.
      #
      # The main thing is to ensure that you close() the Worbook before you send it.
      #
      # See the L<Mail::Sender> module for further details.
      #
      # reverse(''), August 2002, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      use Mail::Sender;
      
      # Create an Excel file
      my $workbook  = Spreadsheet::WriteExcel->new("sendmail.xls");
      my $worksheet = $workbook->add_worksheet;
      
      $worksheet->write('A1', "Hello World!");
      
      $workbook->close(); # Must close before sending
      
      
      
      # Send the file.  Change all variables to suit
      my $sender = new Mail::Sender
      {
          smtp => '123.123.123.123',
          from => 'Someone'
      };
      
      $sender->MailFile(
      {
          to      => 'another@mail.com',
          subject => 'Excel file',
          msg     => "Here is the data.\n",
          file    => 'mail.xls',
      });
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/sendmail.pl>
  
  =head2 Example: stats_ext.pl
  
  
  
  Example of formatting using the Spreadsheet::WriteExcel module
  
  This is a simple example of how to use functions that reference cells in
  other worksheets within the same workbook.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/stats_ext.jpg" width="640" height="420" alt="Output from stats_ext.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of formatting using the Spreadsheet::WriteExcel module
      #
      # This is a simple example of how to use functions that reference cells in
      # other worksheets within the same workbook.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("stats_ext.xls");
      my $worksheet1 = $workbook->add_worksheet('Test results');
      my $worksheet2 = $workbook->add_worksheet('Data');
      
      # Set the column width for columns 1
      $worksheet1->set_column('A:A', 20);
      
      
      # Create a format for the headings
      my $heading = $workbook->add_format();
      $heading->set_bold();
      
      # Create a numerical format
      my $numformat = $workbook->add_format();
      $numformat->set_num_format('0.00');
      
      
      
      
      # Write some statistical functions
      $worksheet1->write('A1', 'Count', $heading);
      $worksheet1->write('B1', '=COUNT(Data!B2:B9)');
      
      $worksheet1->write('A2', 'Sum', $heading);
      $worksheet1->write('B2', '=SUM(Data!B2:B9)');
      
      $worksheet1->write('A3', 'Average', $heading);
      $worksheet1->write('B3', '=AVERAGE(Data!B2:B9)');
      
      $worksheet1->write('A4', 'Min', $heading);
      $worksheet1->write('B4', '=MIN(Data!B2:B9)');
      
      $worksheet1->write('A5', 'Max', $heading);
      $worksheet1->write('B5', '=MAX(Data!B2:B9)');
      
      $worksheet1->write('A6', 'Standard Deviation', $heading);
      $worksheet1->write('B6', '=STDEV(Data!B2:B9)');
      
      $worksheet1->write('A7', 'Kurtosis', $heading);
      $worksheet1->write('B7', '=KURT(Data!B2:B9)');
      
      
      # Write the sample data
      $worksheet2->write('A1', 'Sample', $heading);
      $worksheet2->write('A2', 1);
      $worksheet2->write('A3', 2);
      $worksheet2->write('A4', 3);
      $worksheet2->write('A5', 4);
      $worksheet2->write('A6', 5);
      $worksheet2->write('A7', 6);
      $worksheet2->write('A8', 7);
      $worksheet2->write('A9', 8);
      
      $worksheet2->write('B1', 'Length', $heading);
      $worksheet2->write('B2', 25.4, $numformat);
      $worksheet2->write('B3', 25.4, $numformat);
      $worksheet2->write('B4', 24.8, $numformat);
      $worksheet2->write('B5', 25.0, $numformat);
      $worksheet2->write('B6', 25.3, $numformat);
      $worksheet2->write('B7', 24.9, $numformat);
      $worksheet2->write('B8', 25.2, $numformat);
      $worksheet2->write('B9', 24.8, $numformat);
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/stats_ext.pl>
  
  =head2 Example: stocks.pl
  
  
  
  Example of formatting using the Spreadsheet::WriteExcel module
  
  This example shows how to use a conditional numerical format
  with colours to indicate if a share price has gone up or down.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/stocks.jpg" width="640" height="420" alt="Output from stocks.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of formatting using the Spreadsheet::WriteExcel module
      #
      # This example shows how to use a conditional numerical format
      # with colours to indicate if a share price has gone up or down.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("stocks.xls");
      my $worksheet = $workbook->add_worksheet();
      
      # Set the column width for columns 1, 2, 3 and 4
      $worksheet->set_column(0, 3, 15);
      
      
      # Create a format for the column headings
      my $header = $workbook->add_format();
      $header->set_bold();
      $header->set_size(12);
      $header->set_color('blue');
      
      
      # Create a format for the stock price
      my $f_price = $workbook->add_format();
      $f_price->set_align('left');
      $f_price->set_num_format('$0.00');
      
      
      # Create a format for the stock volume
      my $f_volume = $workbook->add_format();
      $f_volume->set_align('left');
      $f_volume->set_num_format('#,##0');
      
      
      # Create a format for the price change. This is an example of a conditional
      # format. The number is formatted as a percentage. If it is positive it is
      # formatted in green, if it is negative it is formatted in red and if it is
      # zero it is formatted as the default font colour (in this case black).
      # Note: the [Green] format produces an unappealing lime green. Try
      # [Color 10] instead for a dark green.
      #
      my $f_change = $workbook->add_format();
      $f_change->set_align('left');
      $f_change->set_num_format('[Green]0.0%;[Red]-0.0%;0.0%');
      
      
      # Write out the data
      $worksheet->write(0, 0, 'Company', $header);
      $worksheet->write(0, 1, 'Price',   $header);
      $worksheet->write(0, 2, 'Volume',  $header);
      $worksheet->write(0, 3, 'Change',  $header);
      
      $worksheet->write(1, 0, 'Damage Inc.'     );
      $worksheet->write(1, 1, 30.25,     $f_price);  # $30.25
      $worksheet->write(1, 2, 1234567,   $f_volume); # 1,234,567
      $worksheet->write(1, 3, 0.085,     $f_change); # 8.5% in green
      
      $worksheet->write(2, 0, 'Dump Corp.'      );
      $worksheet->write(2, 1, 1.56,      $f_price);  # $1.56
      $worksheet->write(2, 2, 7564,      $f_volume); # 7,564
      $worksheet->write(2, 3, -0.015,    $f_change); # -1.5% in red
      
      $worksheet->write(3, 0, 'Rev Ltd.'        );
      $worksheet->write(3, 1, 0.13,      $f_price);  # $0.13
      $worksheet->write(3, 2, 321,       $f_volume); # 321
      $worksheet->write(3, 3, 0,         $f_change); # 0 in the font color (black)
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/stocks.pl>
  
  =head2 Example: tab_colors.pl
  
  
  
  Example of how to set Excel worksheet tab colours.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/tab_colors.jpg" width="640" height="420" alt="Output from tab_colors.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # Example of how to set Excel worksheet tab colours.
      #
      # reverse(''), May 2006, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook   = Spreadsheet::WriteExcel->new('tab_colors.xls');
      
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      my $worksheet4 = $workbook->add_worksheet();
      
      # Worksheet1 will have the default tab colour.
      $worksheet2->set_tab_color('red');
      $worksheet3->set_tab_color('green');
      $worksheet4->set_tab_color(0x35); # Orange
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/tab_colors.pl>
  
  =head2 Example: textwrap.pl
  
  
  
  Example of formatting using the Spreadsheet::WriteExcel module
  
  This example shows how to wrap text in a cell. There are two alternatives,
  vertical justification and text wrap.
  
  With vertical justification the text is wrapped automatically to fit the
  column width. With text wrap you must specify a newline with an embedded \n.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/textwrap.jpg" width="640" height="420" alt="Output from textwrap.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of formatting using the Spreadsheet::WriteExcel module
      #
      # This example shows how to wrap text in a cell. There are two alternatives,
      # vertical justification and text wrap.
      #
      # With vertical justification the text is wrapped automatically to fit the
      # column width. With text wrap you must specify a newline with an embedded \n.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("textwrap.xls");
      my $worksheet = $workbook->add_worksheet();
      
      # Set the column width for columns 1, 2 and 3
      $worksheet->set_column(1, 1, 24);
      $worksheet->set_column(2, 2, 34);
      $worksheet->set_column(3, 3, 34);
      
      # Set the row height for rows 1, 4, and 6. The height of row 2 will adjust
      # automatically to fit the text.
      #
      $worksheet->set_row(0, 30);
      $worksheet->set_row(3, 40);
      $worksheet->set_row(5, 80);
      
      
      # No newlines
      my $str1  = "For whatever we lose (like a you or a me) ";
      $str1    .= "it's always ourselves we find in the sea";
      
      # Embedded newlines
      my $str2  = "For whatever we lose\n(like a you or a me)\n";
         $str2 .= "it's always ourselves\nwe find in the sea";
      
      
      # Create a format for the column headings
      my $header = $workbook->add_format();
      $header->set_bold();
      $header->set_font("Courier New");
      $header->set_align('center');
      $header->set_align('vcenter');
      
      # Create a "vertical justification" format
      my $format1 = $workbook->add_format();
      $format1->set_align('vjustify');
      
      # Create a "text wrap" format
      my $format2 = $workbook->add_format();
      $format2->set_text_wrap();
      
      # Write the headers
      $worksheet->write(0, 1, "set_align('vjustify')", $header);
      $worksheet->write(0, 2, "set_align('vjustify')", $header);
      $worksheet->write(0, 3, "set_text_wrap()", $header);
      
      # Write some examples
      $worksheet->write(1, 1, $str1, $format1);
      $worksheet->write(1, 2, $str1, $format1);
      $worksheet->write(1, 3, $str2, $format2);
      
      $worksheet->write(3, 1, $str1, $format1);
      $worksheet->write(3, 2, $str1, $format1);
      $worksheet->write(3, 3, $str2, $format2);
      
      $worksheet->write(5, 1, $str1, $format1);
      $worksheet->write(5, 2, $str1, $format1);
      $worksheet->write(5, 3, $str2, $format2);
      
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/textwrap.pl>
  
  =head2 Example: win32ole.pl
  
  
  
  This is a simple example of how to create an Excel file using the
  Win32::OLE module for the sake of comparison.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # This is a simple example of how to create an Excel file using the
      # Win32::OLE module for the sake of comparison.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Cwd;
      use Win32::OLE;
      use Win32::OLE::Const 'Microsoft Excel';
      
      
      my $application = Win32::OLE->new("Excel.Application");
      my $workbook    = $application->Workbooks->Add;
      my $worksheet   = $workbook->Worksheets(1);
      
      $worksheet->Cells(1,1)->{Value} = "Hello World";
      $worksheet->Cells(2,1)->{Value} = "One";
      $worksheet->Cells(3,1)->{Value} = "Two";
      $worksheet->Cells(4,1)->{Value} =  3;
      $worksheet->Cells(5,1)->{Value} =  4.0000001;
      
      # Add some formatting
      $worksheet->Cells(1,1)->Font->{Bold}       = "True";
      $worksheet->Cells(1,1)->Font->{Size}       = 16;
      $worksheet->Cells(1,1)->Font->{ColorIndex} = 3;
      $worksheet->Columns("A:A")->{ColumnWidth}  = 25;
      
      # Write a hyperlink
      my $range = $worksheet->Range("A7:A7");
      $worksheet->Hyperlinks->Add({ Anchor => $range, Address => "http://www.perl.com/"});
      
      # Get current directory using Cwd.pm
      my $dir = cwd();
      
      $workbook->SaveAs({
                          FileName   => $dir . '/win32ole.xls',
                          FileFormat => xlNormal,
                        });
      $workbook->Close;
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/win32ole.pl>
  
  =head2 Example: write_arrays.pl
  
  
  
  Example of how to use the Spreadsheet::WriteExcel module to
  write 1D and 2D arrays of data.
  
  To find out more about array references refer(!!) to the perlref and
  perlreftut manpages. To find out more about 2D arrays or "list of
  lists" refer to the perllol manpage.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/write_arrays.jpg" width="640" height="420" alt="Output from write_arrays.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # Example of how to use the Spreadsheet::WriteExcel module to
      # write 1D and 2D arrays of data.
      #
      # To find out more about array references refer(!!) to the perlref and
      # perlreftut manpages. To find out more about 2D arrays or "list of
      # lists" refer to the perllol manpage.
      #
      # reverse(''), March 2002, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook   = Spreadsheet::WriteExcel->new("write_arrays.xls");
      my $worksheet1 = $workbook->add_worksheet('Example 1');
      my $worksheet2 = $workbook->add_worksheet('Example 2');
      my $worksheet3 = $workbook->add_worksheet('Example 3');
      my $worksheet4 = $workbook->add_worksheet('Example 4');
      my $worksheet5 = $workbook->add_worksheet('Example 5');
      my $worksheet6 = $workbook->add_worksheet('Example 6');
      my $worksheet7 = $workbook->add_worksheet('Example 7');
      my $worksheet8 = $workbook->add_worksheet('Example 8');
      
      my $format     = $workbook->add_format(color => 'red', bold => 1);
      
      
      # Data arrays used in the following examples.
      # undef values are written as blank cells (with format if specified).
      #
      my @array   =   ( 'one', 'two', undef, 'four' );
      
      my @array2d =   (
                          ['maggie', 'milly', 'molly', 'may'  ],
                          [13,       14,      15,      16     ],
                          ['shell',  'star',  'crab',  'stone'],
                      );
      
      
      # 1. Write a row of data using an array reference.
      $worksheet1->write('A1', \@array);
      
      # 2. Same as 1. above using an anonymous array ref.
      $worksheet2->write('A1', [ @array ]);
      
      # 3. Write a row of data using an explicit write_row() method call.
      #    This is the same as calling write() in Ex. 1 above.
      #
      $worksheet3->write_row('A1', \@array);
      
      # 4. Write a column of data using the write_col() method call.
      $worksheet4->write_col('A1', \@array);
      
      # 5. Write a column of data using a ref to an array ref, i.e. a 2D array.
      $worksheet5->write('A1', [ \@array ]);
      
      # 6. Write a 2D array in col-row order.
      $worksheet6->write('A1', \@array2d);
      
      # 7. Write a 2D array in row-col order.
      $worksheet7->write_col('A1', \@array2d);
      
      # 8. Write a row of data with formatting. The blank cell is also formatted.
      $worksheet8->write('A1', \@array, $format);
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/write_arrays.pl>
  
  =head2 Example: write_handler1.pl
  
  
  
  Example of how to add a user defined data handler to the Spreadsheet::
  WriteExcel write() method.
  
  The following example shows how to add a handler for a 7 digit ID number.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/write_handler1.jpg" width="640" height="420" alt="Output from write_handler1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the Spreadsheet::
      # WriteExcel write() method.
      #
      # The following example shows how to add a handler for a 7 digit ID number.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook    = Spreadsheet::WriteExcel->new("write_handler1.xls");
      my $worksheet   = $workbook->add_worksheet();
      
      
      ###############################################################################
      #
      # Add a handler for 7 digit id numbers. This is useful when you want a string
      # such as 0000001 written as a string instead of a number and thus preserve
      # the leading zeroes.
      #
      # Note: you can get the same effect using the keep_leading_zeros() method but
      # this serves as a simple example.
      #
      $worksheet->add_write_handler(qr[^\d{7}$], \&write_my_id);
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found.
      #
      sub write_my_id {
      
          my $worksheet = shift;
      
          return $worksheet->write_string(@_);
      }
      
      
      # This format maintains the cell as text even if it is edited.
      my $id_format   = $workbook->add_format(num_format => '@');
      
      
      # Write some numbers in the user defined format
      $worksheet->write('A1', '0000000', $id_format);
      $worksheet->write('A2', '0000001', $id_format);
      $worksheet->write('A3', '0004000', $id_format);
      $worksheet->write('A4', '1234567', $id_format);
      
      # Write some numbers that don't match the defined format
      $worksheet->write('A6', '000000',  $id_format);
      $worksheet->write('A7', '000001',  $id_format);
      $worksheet->write('A8', '004000',  $id_format);
      $worksheet->write('A9', '123456',  $id_format);
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/write_handler1.pl>
  
  =head2 Example: write_handler2.pl
  
  
  
  Example of how to add a user defined data handler to the Spreadsheet::
  WriteExcel write() method.
  
  The following example shows how to add a handler for a 7 digit ID number.
  It adds an additional constraint to the write_handler1.pl in that it only
  filters data that isn't in the third column.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/write_handler2.jpg" width="640" height="420" alt="Output from write_handler2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the Spreadsheet::
      # WriteExcel write() method.
      #
      # The following example shows how to add a handler for a 7 digit ID number.
      # It adds an additional constraint to the write_handler1.pl in that it only
      # filters data that isn't in the third column.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook    = Spreadsheet::WriteExcel->new("write_handler2.xls");
      my $worksheet   = $workbook->add_worksheet();
      
      
      ###############################################################################
      #
      # Add a handler for 7 digit id numbers. This is useful when you want a string
      # such as 0000001 written as a string instead of a number and thus preserve
      # the leading zeroes.
      #
      # Note: you can get the same effect using the keep_leading_zeros() method but
      # this serves as a simple example.
      #
      $worksheet->add_write_handler(qr[^\d{7}$], \&write_my_id);
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found. The handler
      # is set up so that it only filters data if it is in the third column.
      #
      sub write_my_id {
      
          my $worksheet = shift;
          my $col       = $_[1];
      
          # col is zero based
          if ($col != 2) {
              return $worksheet->write_string(@_);
          }
          else {
              # Reject the match and return control to write()
              return undef;
          }
      
      }
      
      
      # This format maintains the cell as text even if it is edited.
      my $id_format   = $workbook->add_format(num_format => '@');
      
      
      # Write some numbers in the user defined format
      $worksheet->write('A1', '0000000', $id_format);
      $worksheet->write('B1', '0000001', $id_format);
      $worksheet->write('C1', '0000002', $id_format);
      $worksheet->write('D1', '0000003', $id_format);
      
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/write_handler2.pl>
  
  =head2 Example: write_handler3.pl
  
  
  
  Example of how to add a user defined data handler to the Spreadsheet::
  WriteExcel write() method.
  
  The following example shows how to add a handler for dates in a specific
  format.
  
  See write_handler4.pl for a more rigorous example with error handling.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/write_handler3.jpg" width="640" height="420" alt="Output from write_handler3.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the Spreadsheet::
      # WriteExcel write() method.
      #
      # The following example shows how to add a handler for dates in a specific
      # format.
      #
      # See write_handler4.pl for a more rigorous example with error handling.
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook    = Spreadsheet::WriteExcel->new("write_handler3.xls");
      my $worksheet   = $workbook->add_worksheet();
      my $date_format = $workbook->add_format(num_format => 'dd/mm/yy');
      
      
      ###############################################################################
      #
      # Add a handler to match dates in the following format: d/m/yyyy
      #
      # The day and month can be single or double digits.
      #
      $worksheet->add_write_handler(qr[^\d{1,2}/\d{1,2}/\d{4}$], \&write_my_date);
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found.
      # See write_handler4.pl for a more rigorous example with error handling.
      #
      sub write_my_date {
      
          my $worksheet = shift;
          my @args      = @_;
      
          my $token     = $args[2];
             $token     =~ qr[^(\d{1,2})/(\d{1,2})/(\d{4})$];
      
          # Change to the date format required by write_date_time().
          my $date = sprintf "%4d-%02d-%02dT", $3, $2, $1;
      
          $args[2] = $date;
      
          return $worksheet->write_date_time(@args);
      }
      
      
      # Write some dates in the user defined format
      $worksheet->write('A1', '22/12/2004', $date_format);
      $worksheet->write('A2', '1/1/1995',   $date_format);
      $worksheet->write('A3', '01/01/1995', $date_format);
      
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/write_handler3.pl>
  
  =head2 Example: write_handler4.pl
  
  
  
  Example of how to add a user defined data handler to the Spreadsheet::
  WriteExcel write() method.
  
  The following example shows how to add a handler for dates in a specific
  format.
  
  This is a more rigorous version of write_handler3.pl.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/write_handler4.jpg" width="640" height="420" alt="Output from write_handler4.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the Spreadsheet::
      # WriteExcel write() method.
      #
      # The following example shows how to add a handler for dates in a specific
      # format.
      #
      # This is a more rigorous version of write_handler3.pl.
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook    = Spreadsheet::WriteExcel->new("write_handler4.xls");
      my $worksheet   = $workbook->add_worksheet();
      my $date_format = $workbook->add_format(num_format => 'dd/mm/yy');
      
      
      ###############################################################################
      #
      # Add a handler to match dates in the following formats: d/m/yy, d/m/yyyy
      #
      # The day and month can be single or double digits and the year can be  2 or 4
      # digits.
      #
      $worksheet->add_write_handler(qr[^\d{1,2}/\d{1,2}/\d{2,4}$], \&write_my_date);
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found.
      #
      sub write_my_date {
      
          my $worksheet = shift;
          my @args      = @_;
      
          my $token     = $args[2];
      
          if ($token =~  qr[^(\d{1,2})/(\d{1,2})/(\d{2,4})$]) {
      
              my $day  = $1;
              my $mon  = $2;
              my $year = $3;
      
              # Use a window for 2 digit dates. This will keep some ragged Perl
              # programmer employed in thirty years time. :-)
              if (length $year == 2) {
                  if ($year < 50) {
                      $year += 2000;
                  }
                  else {
                      $year += 1900;
                  }
              }
      
              my $date = sprintf "%4d-%02d-%02dT", $year, $mon, $day;
      
              # Convert the ISO ISO8601 style string to an Excel date
              $date = $worksheet->convert_date_time($date);
      
              if (defined $date) {
                  # Date was valid
                  $args[2] = $date;
                  return $worksheet->write_number(@args);
              }
              else {
                  # Not a valid date therefore write as a string
                  return $worksheet->write_string(@args);
              }
          }
          else {
              # Shouldn't happen if the same match is used in the re and sub.
              return undef;
          }
      }
      
      
      # Write some dates in the user defined format
      $worksheet->write('A1', '22/12/2004', $date_format);
      $worksheet->write('A2', '22/12/04',   $date_format);
      $worksheet->write('A3', '2/12/04',    $date_format);
      $worksheet->write('A4', '2/5/04',     $date_format);
      $worksheet->write('A5', '2/5/95',     $date_format);
      $worksheet->write('A6', '2/5/1995',   $date_format);
      
      # Some erroneous dates
      $worksheet->write('A8', '2/5/1895',   $date_format); # Date out of Excel range
      $worksheet->write('A9', '29/2/2003',  $date_format); # Invalid leap day
      $worksheet->write('A10','50/50/50',   $date_format); # Matches but isn't a date
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/write_handler4.pl>
  
  =head2 Example: write_to_scalar.pl
  
  
  
  An example of writing an Excel file to a Perl scalar using Spreadsheet::
  WriteExcel and the new features of perl 5.8.
  
  For an examples of how to write to a scalar in versions prior to perl 5.8
  see the filehandle.pl program and IO:Scalar.
  
  
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # An example of writing an Excel file to a Perl scalar using Spreadsheet::
      # WriteExcel and the new features of perl 5.8.
      #
      # For an examples of how to write to a scalar in versions prior to perl 5.8
      # see the filehandle.pl program and IO:Scalar.
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      require 5.008;
      
      
      # Use perl 5.8's feature of using a scalar as a filehandle.
      my   $fh;
      my   $str = '';
      open $fh, '>', \$str or die "Failed to open filehandle: $!";
      
      
      # Or replace the previous three lines with this:
      # open my $fh, '>', \my $str or die "Failed to open filehandle: $!";
      
      
      # Spreadsheet::WriteExce accepts filehandle as well as file names.
      my $workbook  = Spreadsheet::WriteExcel->new($fh);
      my $worksheet = $workbook->add_worksheet();
      
      $worksheet->write(0, 0,  "Hi Excel!");
      
      $workbook->close();
      
      
      # The Excel file in now in $str. Remember to binmode() the output
      # filehandle before printing it.
      binmode STDOUT;
      print $str;
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/write_to_scalar.pl>
  
  =head2 Example: unicode_utf16.pl
  
  
  
  A simple example of writing some Unicode text with Spreadsheet::WriteExcel.
  
  This example shows UTF16 encoding. With perl 5.8 it is also possible to use
  utf8 without modification.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_utf16.jpg" width="640" height="420" alt="Output from unicode_utf16.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of writing some Unicode text with Spreadsheet::WriteExcel.
      #
      # This example shows UTF16 encoding. With perl 5.8 it is also possible to use
      # utf8 without modification.
      #
      # reverse(''), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new('unicode_utf16.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Write the Unicode smiley face (with increased font for legibility)
      my $smiley    = pack "n", 0x263a;
      my $big_font  = $workbook->add_format(size => 40);
      
      $worksheet->write_utf16be_string('A3', $smiley, $big_font);
      
      
      # Write a phrase in Cyrillic
      my $uni_str = pack "H*", "042d0442043e002004440440043004370430002004".
                               "3d043000200440044304410441043a043e043c0021";
      
      $worksheet->write_utf16be_string('A5', $uni_str);
      
      
      $worksheet->write_utf16be_string('A7', pack "H*", "0074006500730074");
      
      
      
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_utf16.pl>
  
  =head2 Example: unicode_utf16_japan.pl
  
  
  
  A simple example of writing some Unicode text with Spreadsheet::WriteExcel.
  
  This creates an Excel file with the word Nippon in 3 character sets.
  
  This example shows UTF16 encoding. With perl 5.8 it is also possible to use
  utf8 without modification.
  
  See also the unicode_2022_jp.pl and unicode_shift_jis.pl examples.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_utf16_japan.jpg" width="640" height="420" alt="Output from unicode_utf16_japan.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of writing some Unicode text with Spreadsheet::WriteExcel.
      #
      # This creates an Excel file with the word Nippon in 3 character sets.
      #
      # This example shows UTF16 encoding. With perl 5.8 it is also possible to use
      # utf8 without modification.
      #
      # See also the unicode_2022_jp.pl and unicode_shift_jis.pl examples.
      #
      # reverse(''), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new('unicode_utf16_japan.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Set a Unicode font.
      my $uni_font  = $workbook->add_format(font => 'Arial Unicode MS');
      
      
      # Create some UTF-16BE Unicode text.
      my $kanji     = pack 'n*', 0x65e5, 0x672c;
      my $katakana  = pack 'n*', 0xff86, 0xff8e, 0xff9d;
      my $hiragana  = pack 'n*', 0x306b, 0x307b, 0x3093;
      
      
      
      $worksheet->write_utf16be_string('A1', $kanji,    $uni_font);
      $worksheet->write_utf16be_string('A2', $katakana, $uni_font);
      $worksheet->write_utf16be_string('A3', $hiragana, $uni_font);
      
      
      $worksheet->write('B1', 'Kanji');
      $worksheet->write('B2', 'Katakana');
      $worksheet->write('B3', 'Hiragana');
      
      
      __END__
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_utf16_japan.pl>
  
  =head2 Example: unicode_cyrillic.pl
  
  
  
  A simple example of writing some Russian cyrillic text using
  Spreadsheet::WriteExcel and perl 5.8.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_cyrillic.jpg" width="640" height="420" alt="Output from unicode_cyrillic.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of writing some Russian cyrillic text using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # reverse(''), March 2005, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      # In this example we generate utf8 strings from character data but in a
      # real application we would expect them to come from an external source.
      #
      
      
      # Create a Russian worksheet name in utf8.
      my $sheet   = pack "U*", 0x0421, 0x0442, 0x0440, 0x0430, 0x043D, 0x0438,
                               0x0446, 0x0430;
      
      
      # Create a Russian string.
      my $str     = pack "U*", 0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441,
                               0x0442, 0x0432, 0x0443, 0x0439, 0x0020, 0x041C,
                               0x0438, 0x0440, 0x0021;
      
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_cyrillic.xls");
      my $worksheet = $workbook->add_worksheet($sheet . '1');
      
         $worksheet->set_column('A:A', 18);
         $worksheet->write('A1', $str);
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_cyrillic.pl>
  
  =head2 Example: unicode_list.pl
  
  
  
  A simple example using Spreadsheet::WriteExcel to display all available
  Unicode characters in a font.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_list.jpg" width="640" height="420" alt="Output from unicode_list.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example using Spreadsheet::WriteExcel to display all available
      # Unicode characters in a font.
      #
      # reverse(''), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new('unicode_list.xls');
      my $worksheet = $workbook->add_worksheet();
      
      
      # Set a Unicode font.
      my $uni_font  = $workbook->add_format(font => 'Arial Unicode MS');
      
      # Ascii font for labels.
      my $courier   = $workbook->add_format(font => 'Courier New');
      
      
      my $char = 0;
      
      # Loop through all 32768 UTF-16BE characters.
      #
      for my $row (0 .. 2 ** 12 -1) {
          for my $col (0 .. 31) {
      
              last if $char == 0xffff;
      
              if ($col % 2 == 0){
                  $worksheet->write_string($row, $col,
                                                 sprintf('0x%04X', $char), $courier);
              }
              else {
                  $worksheet->write_utf16be_string($row, $col,
                                                  pack('n', $char++), $uni_font);
              }
          }
      }
      
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_list.pl>
  
  =head2 Example: unicode_2022_jp.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Japanese from a file with ISO-2022-JP
  encoded text.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_2022_jp.jpg" width="640" height="420" alt="Output from unicode_2022_jp.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Japanese from a file with ISO-2022-JP
      # encoded text.
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_2022_jp.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_2022_jp.txt';
      
      open FH, '<:encoding(iso-2022-jp)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_2022_jp.pl>
  
  =head2 Example: unicode_8859_11.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Thai from a file with ISO-8859-11 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_8859_11.jpg" width="640" height="420" alt="Output from unicode_8859_11.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Thai from a file with ISO-8859-11 encoded text.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_8859_11.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_8859_11.txt';
      
      open FH, '<:encoding(iso-8859-11)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_8859_11.pl>
  
  =head2 Example: unicode_8859_7.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Greek from a file with ISO-8859-7 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_8859_7.jpg" width="640" height="420" alt="Output from unicode_8859_7.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Greek from a file with ISO-8859-7 encoded text.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_8859_7.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_8859_7.txt';
      
      open FH, '<:encoding(iso-8859-7)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_8859_7.pl>
  
  =head2 Example: unicode_big5.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Chinese from a file with BIG5 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_big5.jpg" width="640" height="420" alt="Output from unicode_big5.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Chinese from a file with BIG5 encoded text.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_big5.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 80);
      
      
      my $file = 'unicode_big5.txt';
      
      open FH, '<:encoding(big5)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_big5.pl>
  
  =head2 Example: unicode_cp1251.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Russian from a file with CP1251 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_cp1251.jpg" width="640" height="420" alt="Output from unicode_cp1251.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Russian from a file with CP1251 encoded text.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_cp1251.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_cp1251.txt';
      
      open FH, '<:encoding(cp1251)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_cp1251.pl>
  
  =head2 Example: unicode_cp1256.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Arabic text from a CP-1256 encoded file.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_cp1256.jpg" width="640" height="420" alt="Output from unicode_cp1256.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Arabic text from a CP-1256 encoded file.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_cp1256.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_cp1256.txt';
      
      open FH, '<:encoding(cp1256)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_cp1256.pl>
  
  =head2 Example: unicode_koi8r.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Russian from a file with KOI8-R encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_koi8r.jpg" width="640" height="420" alt="Output from unicode_koi8r.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Russian from a file with KOI8-R encoded text.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_koi8r.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_koi8r.txt';
      
      open FH, '<:encoding(koi8-r)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_koi8r.pl>
  
  =head2 Example: unicode_polish_utf8.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Polish from a file with UTF8 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_polish_utf8.jpg" width="640" height="420" alt="Output from unicode_polish_utf8.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Polish from a file with UTF8 encoded text.
      #
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_polish_utf8.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_polish_utf8.txt';
      
      open FH, '<:encoding(utf8)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_polish_utf8.pl>
  
  =head2 Example: unicode_shift_jis.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Spreadsheet::WriteExcel and perl 5.8.
  
  This example generates some Japenese text from a file with Shift-JIS
  encoded text.
  
  
  
  =begin html
  
  <p><center><img src="http://homepage.eircom.net/~jmcnamara/perl/images/unicode_shift_jis.jpg" width="640" height="420" alt="Output from unicode_shift_jis.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Spreadsheet::WriteExcel and perl 5.8.
      #
      # This example generates some Japenese text from a file with Shift-JIS
      # encoded text.
      #
      # reverse(''), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      
      # Perl 5.8 or later is required for proper utf8 handling. For older perl
      # versions you should use UTF16 and the write_utf16be_string() method.
      # See the write_utf16be_string section of the Spreadsheet::WriteExcel docs.
      #
      require 5.008;
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      my $workbook  = Spreadsheet::WriteExcel->new("unicode_shift_jis.xls");
      my $worksheet = $workbook->add_worksheet();
         $worksheet->set_column('A:A', 50);
      
      
      my $file = 'unicode_shift_jis.txt';
      
      open FH, '<:encoding(shiftjis)', $file  or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while (<FH>) {
          next if /^#/; # Ignore the comments in the sample file.
          chomp;
          $worksheet->write($row++, 0,  $_);
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/unicode_shift_jis.pl>
  
  =head2 Example: csv2xls.pl
  
  
  
  Example of how to use the WriteExcel module
  
  Simple program to convert a CSV comma-separated value file to an Excel file.
  This is more or less an non-op since Excel can read CSV files.
  The program uses Text::CSV_XS to parse the CSV.
  
  Usage: csv2xls.pl file.csv newfile.xls
  
  
  NOTE: This is only a simple conversion utility for illustrative purposes.
  For converting a CSV or Tab separated or any other type of delimited
  text file to Excel I recommend the more rigorous csv2xls program that is
  part of H.Merijn Brand's Text::CSV_XS module distro.
  
  See the examples/csv2xls link here:
      L<http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST>
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the WriteExcel module
      #
      # Simple program to convert a CSV comma-separated value file to an Excel file.
      # This is more or less an non-op since Excel can read CSV files.
      # The program uses Text::CSV_XS to parse the CSV.
      #
      # Usage: csv2xls.pl file.csv newfile.xls
      #
      #
      # NOTE: This is only a simple conversion utility for illustrative purposes.
      # For converting a CSV or Tab separated or any other type of delimited
      # text file to Excel I recommend the more rigorous csv2xls program that is
      # part of H.Merijn Brand's Text::CSV_XS module distro.
      #
      # See the examples/csv2xls link here:
      #     L<http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST>
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      use Text::CSV_XS;
      
      # Check for valid number of arguments
      if (($#ARGV < 1) || ($#ARGV > 2)) {
         die("Usage: csv2xls csvfile.txt newfile.xls\n");
      };
      
      # Open the Comma Separated Variable file
      open (CSVFILE, $ARGV[0]) or die "$ARGV[0]: $!";
      
      # Create a new Excel workbook
      my $workbook  = Spreadsheet::WriteExcel->new($ARGV[1]);
      my $worksheet = $workbook->add_worksheet();
      
      # Create a new CSV parsing object
      my $csv = Text::CSV_XS->new;
      
      # Row and column are zero indexed
      my $row = 0;
      
      
      while (<CSVFILE>) {
          if ($csv->parse($_)) {
              my @Fld = $csv->fields;
      
              my $col = 0;
              foreach my $token (@Fld) {
                  $worksheet->write($row, $col, $token);
                  $col++;
              }
              $row++;
          }
          else {
              my $err = $csv->error_input;
              print "Text::CSV_XS parse() failed on argument: ", $err, "\n";
          }
      }
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/csv2xls.pl>
  
  =head2 Example: tab2xls.pl
  
  
  
  Example of how to use the WriteExcel module
  
  The following converts a tab separated file into an Excel file
  
  Usage: tab2xls.pl tabfile.txt newfile.xls
  
  
  NOTE: This is only a simple conversion utility for illustrative purposes.
  For converting a CSV or Tab separated or any other type of delimited
  text file to Excel I recommend the more rigorous csv2xls program that is
  part of H.Merijn Brand's Text::CSV_XS module distro.
  
  See the examples/csv2xls link here:
      L<http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST>
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to use the WriteExcel module
      #
      # The following converts a tab separated file into an Excel file
      #
      # Usage: tab2xls.pl tabfile.txt newfile.xls
      #
      #
      # NOTE: This is only a simple conversion utility for illustrative purposes.
      # For converting a CSV or Tab separated or any other type of delimited
      # text file to Excel I recommend the more rigorous csv2xls program that is
      # part of H.Merijn Brand's Text::CSV_XS module distro.
      #
      # See the examples/csv2xls link here:
      #     L<http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST>
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      # Check for valid number of arguments
      if (($#ARGV < 1) || ($#ARGV > 2)) {
          die("Usage: tab2xls tabfile.txt newfile.xls\n");
      };
      
      
      # Open the tab delimited file
      open (TABFILE, $ARGV[0]) or die "$ARGV[0]: $!";
      
      
      # Create a new Excel workbook
      my $workbook  = Spreadsheet::WriteExcel->new($ARGV[1]);
      my $worksheet = $workbook->add_worksheet();
      
      # Row and column are zero indexed
      my $row = 0;
      
      while (<TABFILE>) {
          chomp;
          # Split on single tab
          my @Fld = split('\t', $_);
      
          my $col = 0;
          foreach my $token (@Fld) {
              $worksheet->write($row, $col, $token);
              $col++;
          }
          $row++;
      }
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/tab2xls.pl>
  
  =head2 Example: datecalc1.pl
  
  
  
  NOTE: An easier way of writing dates and times is to use the newer
        write_date_time() Worksheet method. See the date_time.pl example.
  
  
  
  Demonstration of writing date/time cells to Excel spreadsheets,
  using UNIX/Perl time as source of date/time.
  
  
  
  UNIX/Perl time is the time since the Epoch (00:00:00 GMT, 1 Jan 1970)
  measured in seconds.
  
  An Excel file can use exactly one of two different date/time systems.
  In these systems, a floating point number represents the number of days
  (and fractional parts of the day) since a start point. The floating point
  number is referred to as a 'serial'.
  
  The two systems ('1900' and '1904') use different starting points:
  
   '1900'; '1.00' is 1 Jan 1900 BUT 1900 is erroneously regarded as
           a leap year - see:
             http://support.microsoft.com/support/kb/articles/Q181/3/70.asp
           for the excuse^H^H^H^H^H^Hreason.
   '1904'; '1.00' is 2 Jan 1904.
  
  The '1904' system is the default for Apple Macs. Windows versions of
  Excel have the option to use the '1904' system.
  
  Note that Visual Basic's "DateSerial" function does NOT erroneously
  regard 1900 as a leap year, and thus its serials do not agree with
  the 1900 serials of Excel for dates before 1 Mar 1900.
  
  Note that StarOffice (at least at version 5.2) does NOT erroneously
  regard 1900 as a leap year, and thus its serials do not agree with
  the 1900 serials of Excel for dates before 1 Mar 1900.
  
  
      #!/usr/bin/perl -w
      
      
      ######################################################################
      #
      # NOTE: An easier way of writing dates and times is to use the newer
      #       write_date_time() Worksheet method. See the date_time.pl example.
      #
      ######################################################################
      #
      # Demonstration of writing date/time cells to Excel spreadsheets,
      # using UNIX/Perl time as source of date/time.
      #
      ######################################################################
      #
      # UNIX/Perl time is the time since the Epoch (00:00:00 GMT, 1 Jan 1970)
      # measured in seconds.
      #
      # An Excel file can use exactly one of two different date/time systems.
      # In these systems, a floating point number represents the number of days
      # (and fractional parts of the day) since a start point. The floating point
      # number is referred to as a 'serial'.
      #
      # The two systems ('1900' and '1904') use different starting points:
      #
      #  '1900'; '1.00' is 1 Jan 1900 BUT 1900 is erroneously regarded as
      #          a leap year - see:
      #            http://support.microsoft.com/support/kb/articles/Q181/3/70.asp
      #          for the excuse^H^H^H^H^H^Hreason.
      #  '1904'; '1.00' is 2 Jan 1904.
      #
      # The '1904' system is the default for Apple Macs. Windows versions of
      # Excel have the option to use the '1904' system.
      #
      # Note that Visual Basic's "DateSerial" function does NOT erroneously
      # regard 1900 as a leap year, and thus its serials do not agree with
      # the 1900 serials of Excel for dates before 1 Mar 1900.
      #
      # Note that StarOffice (at least at version 5.2) does NOT erroneously
      # regard 1900 as a leap year, and thus its serials do not agree with
      # the 1900 serials of Excel for dates before 1 Mar 1900.
      #
      
      # Copyright 2000, Andrew Benham, adsb@bigfoot.com
      #
      
      ######################################################################
      #
      # Calculation description
      # =======================
      #
      # 1900 system
      # -----------
      # Unix time is '0' at 00:00:00 GMT 1 Jan 1970, i.e. 70 years after 1 Jan 1900.
      # Of those 70 years, 17 (1904,08,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68)
      # were leap years with an extra day.
      # Thus there were 17 + 70*365 days = 25567 days between 1 Jan 1900 and
      # 1 Jan 1970.
      # In the 1900 system, '1' is 1 Jan 1900, but as 1900 was not a leap year
      # 1 Jan 1900 should really be '2', so 1 Jan 1970 is '25569'.
      #
      # 1904 system
      # -----------
      # Unix time is '0' at 00:00:00 GMT 1 Jan 1970, i.e. 66 years after 1 Jan 1904.
      # Of those 66 years, 17 (1904,08,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68)
      # were leap years with an extra day.
      # Thus there were 17 + 66*365 days = 24107 days between 1 Jan 1904 and
      # 1 Jan 1970.
      # In the 1904 system, 2 Jan 1904 being '1', 1 Jan 1970 is '24107'.
      #
      ######################################################################
      #
      # Copyright (c) 2000, Andrew Benham.
      # This program is free software. It may be used, redistributed and/or
      # modified under the same terms as Perl itself.
      #
      # Andrew Benham, adsb@bigfoot.com
      # London, United Kingdom
      # 11 Nov 2000
      #
      ######################################################################
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      use Time::Local;
      
      use vars qw/$DATE_SYSTEM/;
      
      # Use 1900 date system on all platforms other than Apple Mac (for which
      # use 1904 date system).
      $DATE_SYSTEM = ($^O eq 'MacOS') ? 1 : 0;
      
      my $workbook = Spreadsheet::WriteExcel->new("dates.xls");
      my $worksheet = $workbook->add_worksheet();
      
      my $format_date =  $workbook->add_format();
      $format_date->set_num_format('d mmmm yyy');
      
      $worksheet->set_column(0,1,21);
      
      $worksheet->write_string (0,0,"The epoch (GMT)");
      $worksheet->write_number (0,1,&calc_serial(0,1),0x16);
      
      $worksheet->write_string (1,0,"The epoch (localtime)");
      $worksheet->write_number (1,1,&calc_serial(0,0),0x16);
      
      $worksheet->write_string (2,0,"Today");
      $worksheet->write_number (2,1,&calc_serial(),$format_date);
      
      my $christmas2000 = timelocal(0,0,0,25,11,100);
      $worksheet->write_string (3,0,"Christmas 2000");
      $worksheet->write_number (3,1,&calc_serial($christmas2000),$format_date);
      
      $workbook->close();
      
      #-----------------------------------------------------------
      # calc_serial()
      #
      # Called with (up to) 2 parameters.
      #   1.  Unix timestamp.  If omitted, uses current time.
      #   2.  GMT flag. Set to '1' to return serial in GMT.
      #       If omitted, returns serial in appropriate timezone.
      #
      # Returns date/time serial according to $DATE_SYSTEM selected
      #-----------------------------------------------------------
      sub calc_serial {
      	my $time = (defined $_[0]) ? $_[0] : time();
      	my $gmtflag = (defined $_[1]) ? $_[1] : 0;
      
      	# Divide timestamp by number of seconds in a day.
      	# This gives a date serial with '0' on 1 Jan 1970.
      	my $serial = $time / 86400;
      
      	# Adjust the date serial by the offset appropriate to the
      	# currently selected system (1900/1904).
      	if ($DATE_SYSTEM == 0) {	# use 1900 system
      		$serial += 25569;
      	} else {			# use 1904 system
      		$serial += 24107;
      	}
      
      	unless ($gmtflag) {
      		# Now have a 'raw' serial with the right offset. But this
      		# gives a serial in GMT, which is false unless the timezone
      		# is GMT. We need to adjust the serial by the appropriate
      		# timezone offset.
      		# Calculate the appropriate timezone offset by seeing what
      		# the differences between localtime and gmtime for the given
      		# time are.
      
      		my @gmtime = gmtime($time);
      		my @ltime  = localtime($time);
      
      		# For the first 7 elements of the two arrays, adjust the
      		# date serial where the elements differ.
      		for (0 .. 6) {
      			my $diff = $ltime[$_] - $gmtime[$_];
      			if ($diff) {
      				$serial += _adjustment($diff,$_);
      			}
      		}
      	}
      
      	# Perpetuate the error that 1900 was a leap year by decrementing
      	# the serial if we're using the 1900 system and the date is prior to
      	# 1 Mar 1900. This has the effect of making serial value '60'
      	# 29 Feb 1900.
      
      	# This fix only has any effect if UNIX/Perl time on the platform
      	# can represent 1900. Many can't.
      
      	unless ($DATE_SYSTEM) {
      		$serial-- if ($serial < 61);	# '61' is 1 Mar 1900
      	}
      	return $serial;
      }
      
      sub _adjustment {
      	# Based on the difference in the localtime/gmtime array elements
      	# number, return the adjustment required to the serial.
      
      	# We only look at some elements of the localtime/gmtime arrays:
      	#    seconds    unlikely to be different as all known timezones
      	#               have an offset of integral multiples of 15 minutes,
      	#		but it's easy to do.
      	#    minutes    will be different for timezone offsets which are
      	#		not an exact number of hours.
      	#    hours	very likely to be different.
      	#    weekday	will differ when localtime/gmtime difference
      	#		straddles midnight.
      	#
      	# Assume that difference between localtime and gmtime is less than
      	# 5 days, then don't have to do maths for day of month, month number,
      	# year number, etc...
      
      	my ($delta,$element) = @_;
      	my $adjust = 0;
      
      	if ($element == 0) {		# Seconds
      		$adjust = $delta/86400;		# 60 * 60 * 24
      	} elsif ($element == 1) {	# Minutes
      		$adjust = $delta/1440;		# 60 * 24
      	} elsif ($element == 2) {	# Hours
      		$adjust = $delta/24;		# 24
      	} elsif ($element == 6) {	# Day of week number
      		# Catch difference straddling Sat/Sun in either direction
      		$delta += 7 if ($delta < -4);
      		$delta -= 7 if ($delta > 4);
      
      		$adjust = $delta;
      	}
      	return $adjust;
      }
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/datecalc1.pl>
  
  =head2 Example: datecalc2.pl
  
  
  
  Example of how to using the Date::Calc module to calculate Excel dates.
  
  NOTE: An easier way of writing dates and times is to use the newer
        write_date_time() Worksheet method. See the date_time.pl example.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to using the Date::Calc module to calculate Excel dates.
      #
      # NOTE: An easier way of writing dates and times is to use the newer
      #       write_date_time() Worksheet method. See the date_time.pl example.
      #
      # reverse(''), June 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      use Date::Calc qw(Delta_DHMS); # You may need to install this module.
      
      
      # Create a new workbook and add a worksheet
      my $workbook = Spreadsheet::WriteExcel->new("excel_date2.xls");
      my $worksheet = $workbook->add_worksheet();
      
      # Expand the first column so that the date is visible.
      $worksheet->set_column("A:A", 25);
      
      
      # Add a format for the date
      my $format =  $workbook->add_format();
      $format->set_num_format('d mmmm yyy HH:MM:SS');
      
      
      my $date;
      
      # Write some dates and times
      $date =  excel_date(1900, 1, 1);
      $worksheet->write("A1", $date, $format);
      
      $date =  excel_date(2000, 1, 1);
      $worksheet->write("A2", $date, $format);
      
      $date =  excel_date(2000, 4, 17, 14, 33, 15);
      $worksheet->write("A3", $date, $format);
      
      
      ###############################################################################
      #
      # excel_date($years, $months, $days, $hours, $minutes, $seconds)
      #
      # Create an Excel date in the 1900 format. All of the arguments are optional
      # but you should at least add $years.
      #
      # Corrects for Excel's missing leap day in 1900. See excel_time1.pl for an
      # explanation.
      #
      sub excel_date {
      
          my $years   = $_[0] || 1900;
          my $months  = $_[1] || 1;
          my $days    = $_[2] || 1;
          my $hours   = $_[3] || 0;
          my $minutes = $_[4] || 0;
          my $seconds = $_[5] || 0;
      
          my @date = ($years, $months, $days, $hours, $minutes, $seconds);
          my @epoch = (1899, 12, 31, 0, 0, 0);
      
          ($days, $hours, $minutes, $seconds) = Delta_DHMS(@epoch, @date);
      
          my $date = $days + ($hours*3600 +$minutes*60 +$seconds)/(24*60*60);
      
          # Add a day for Excel's missing leap day in 1900
          $date++ if ($date > 59);
      
          return $date;
      }
      
      ###############################################################################
      #
      # excel_date($years, $months, $days, $hours, $minutes, $seconds)
      #
      # Create an Excel date in the 1904 format. All of the arguments are optional
      # but you should at least add $years.
      #
      # You will also need to call $workbook->set_1904() for this format to be valid.
      #
      sub excel_date_1904 {
      
          my $years   = $_[0] || 1900;
          my $months  = $_[1] || 1;
          my $days    = $_[2] || 1;
          my $hours   = $_[3] || 0;
          my $minutes = $_[4] || 0;
          my $seconds = $_[5] || 0;
      
          my @date = ($years, $months, $days, $hours, $minutes, $seconds);
          my @epoch = (1904, 1, 1, 0, 0, 0);
      
          ($days, $hours, $minutes, $seconds) = Delta_DHMS(@epoch, @date);
      
          my $date = $days + ($hours*3600 +$minutes*60 +$seconds)/(24*60*60);
      
          return $date;
      }
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/datecalc2.pl>
  
  =head2 Example: lecxe.pl
  
  
  Utility program to convert an Excel file into a Spreadsheet::WriteExcel
  program using Win32::OLE
  
  
      #!/usr/bin/perl -w
      
      #
      # Utility program to convert an Excel file into a Spreadsheet::WriteExcel
      # program using Win32::OLE
      #
      
      #
      # lecxe program
      # by t0mas@netlords.net
      #
      # Version  0.01a    Initial release (alpha)
      
      
      # Modules
      use strict;
      use Win32::OLE;
      use Win32::OLE::Const;
      use Getopt::Std;
      
      
      # Vars
      use vars qw(%opts);
      
      
      # Get options
      getopts('i:o:v',\%opts);
      
      
      # Not enough options
      exit &usage unless ($opts{i} && $opts{o});
      
      
      # Create Excel object
      my $Excel = new Win32::OLE("Excel.Application","Quit") or
              die "Can't start excel: $!";
      
      
      # Get constants
      my $ExcelConst=Win32::OLE::Const->Load("Microsoft Excel");
      
      
      # Show Excel
      $Excel->{Visible} = 1 if ($opts{v});
      
      
      # Open infile
      my $Workbook = $Excel->Workbooks->Open({Filename=>$opts{i}});
      
      
      # Open outfile
      open (OUTFILE,">$opts{o}") or die "Can't open outfile $opts{o}: $!";
      
      
      # Print header for outfile
      print OUTFILE <<'EOH';
      #!/usr/bin/perl -w
      
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      
      use vars qw($workbook %worksheets %formats);
      
      
      $workbook = Spreadsheet::WriteExcel->new("_change_me_.xls");
      
      
      EOH
      
      
      # Loop all sheets
      foreach my $sheetnum (1..$Excel->Workbooks(1)->Worksheets->Count) {
      
      
              # Format sheet
              my $name=$Excel->Workbooks(1)->Worksheets($sheetnum)->Name;
              print "Sheet $name\n" if ($opts{v});
              print OUTFILE "# Sheet $name\n";
              print OUTFILE "\$worksheets{'$name'} = \$workbook->add_worksheet('$name');\n";
      
      
              # Get usedrange of cells in worksheet
              my $usedrange=$Excel->Workbooks(1)->Worksheets($sheetnum)->UsedRange;
      
      
              # Loop all columns in used range
              foreach my $j (1..$usedrange->Columns->Count){
      
      
                      # Format column
                      print "Col $j\n" if ($opts{v});
                      my ($colwidth);
                      $colwidth=$usedrange->Columns($j)->ColumnWidth;
                      print OUTFILE "# Column $j\n";
                      print OUTFILE "\$worksheets{'$name'}->set_column(".($j-1).",".($j-1).
                              ", $colwidth);\n";
      
      
                      # Loop all rows in used range
                      foreach my $i (1..$usedrange->Rows->Count){
      
      
                              # Format row
                              print "Row $i\n" if ($opts{v});
                              print OUTFILE "# Row $i\n";
                              do {
                                      my ($rowheight);
                                      $rowheight=$usedrange->Rows($i)->RowHeight;
                                      print OUTFILE "\$worksheets{'$name'}->set_row(".($i-1).
                                              ", $rowheight);\n";
                              } if ($j==1);
      
      
                              # Start creating cell format
                              my $fname="\$formats{'".$name.'R'.$i.'C'.$j."'}";
                              my $format="$fname=\$workbook->add_format();\n";
                              my $print_format=0;
      
                              # Check for borders
                              my @bfnames=qw(left right top bottom);
                              foreach my $k (1..$usedrange->Cells($i,$j)->Borders->Count) {
                                      my $lstyle=$usedrange->Cells($i,$j)->Borders($k)->LineStyle;
                                      if ($lstyle > 0) {
                                              $format.=$fname."->set_".$bfnames[$k-1]."($lstyle);\n";
                                              $print_format=1;
                                      }
                              }
      
      
                              # Check for font
                              my ($fontattr,$prop,$func,%fontsets,$fontColor);
                              %fontsets=(Name=>'set_font',
                                                      Size=>'set_size');
                              while (($prop,$func) = each %fontsets) {
                                      $fontattr=$usedrange->Cells($i,$j)->Font->$prop;
                                      if ($fontattr ne "") {
                                              $format.=$fname."->$func('$fontattr');\n";
                                              $print_format=1;
                                      }
      
      
                              }
                              %fontsets=(Bold=>'set_bold(1)',
                                                      Italic=>'set_italic(1)',
                                                      Underline=>'set_underline(1)',
                                                      Strikethrough=>'set_strikeout(1)',
                                                      Superscript=>'set_script(1)',
                                                      Subscript=>'set_script(2)',
                                                      OutlineFont=>'set_outline(1)',
                                                      Shadow=>'set_shadow(1)');
                              while (($prop,$func) = each %fontsets) {
                                      $fontattr=$usedrange->Cells($i,$j)->Font->$prop;
                                      if ($fontattr==1) {
                                              $format.=$fname."->$func;\n" ;
      
                                              $print_format=1;
                                      }
                              }
                              $fontColor=$usedrange->Cells($i,$j)->Font->ColorIndex();
                              if ($fontColor>0&&$fontColor!=$ExcelConst->{xlColorIndexAutomatic}) {
                                      $format.=$fname."->set_color(".($fontColor+7).");\n" ;
                                      $print_format=1;
                              }
      
      
      
                              # Check text alignment, merging and wrapping
                              my ($halign,$valign,$merge,$wrap);
                              $halign=$usedrange->Cells($i,$j)->HorizontalAlignment;
                              my %hAligns=($ExcelConst->{xlHAlignCenter}=>"'center'",
                                      $ExcelConst->{xlHAlignJustify}=>"'justify'",
                                      $ExcelConst->{xlHAlignLeft}=>"'left'",
                                      $ExcelConst->{xlHAlignRight}=>"'right'",
                                      $ExcelConst->{xlHAlignFill}=>"'fill'",
                                      $ExcelConst->{xlHAlignCenterAcrossSelection}=>"'merge'");
                              if ($halign!=$ExcelConst->{xlHAlignGeneral}) {
                                      $format.=$fname."->set_align($hAligns{$halign});\n";
                                      $print_format=1;
                              }
                              $valign=$usedrange->Cells($i,$j)->VerticalAlignment;
                              my %vAligns=($ExcelConst->{xlVAlignBottom}=>"'bottom'",
                                      $ExcelConst->{xlVAlignCenter}=>"'vcenter'",
                                      $ExcelConst->{xlVAlignJustify}=>"'vjustify'",
                                      $ExcelConst->{xlVAlignTop}=>"'top'");
                              if ($valign) {
                                      $format.=$fname."->set_align($vAligns{$valign});\n";
                                      $print_format=1;
                              }
                              $merge=$usedrange->Cells($i,$j)->MergeCells;
                              if ($merge==1) {
                                      $format.=$fname."->set_merge();\n";
      
                                      $print_format=1;
                              }
                              $wrap=$usedrange->Cells($i,$j)->WrapText;
                              if ($wrap==1) {
                                      $format.=$fname."->set_text_wrap(1);\n";
      
                                      $print_format=1;
                              }
      
      
                              # Check patterns
                              my ($pattern,%pats);
                              %pats=(-4142=>0,-4125=>2,-4126=>3,-4124=>4,-4128=>5,-4166=>6,
                                              -4121=>7,-4162=>8);
                              $pattern=$usedrange->Cells($i,$j)->Interior->Pattern;
                              if ($pattern&&$pattern!=$ExcelConst->{xlPatternAutomatic}) {
                                      $pattern=$pats{$pattern} if ($pattern<0 && defined $pats{$pattern});
                                      $format.=$fname."->set_pattern($pattern);\n";
      
                                      # Colors fg/bg
                                      my ($cIndex);
                                      $cIndex=$usedrange->Cells($i,$j)->Interior->PatternColorIndex;
                                      if ($cIndex>0&&$cIndex!=$ExcelConst->{xlColorIndexAutomatic}) {
                                              $format.=$fname."->set_bg_color(".($cIndex+7).");\n";
                                      }
                                      $cIndex=$usedrange->Cells($i,$j)->Interior->ColorIndex;
                                      if ($cIndex>0&&$cIndex!=$ExcelConst->{xlColorIndexAutomatic}) {
                                              $format.=$fname."->set_fg_color(".($cIndex+7).");\n";
                                      }
                                      $print_format=1;
                              }
      
      
                              # Check for number format
                              my ($num_format);
                              $num_format=$usedrange->Cells($i,$j)->NumberFormat;
                              if ($num_format ne "") {
                                      $format.=$fname."->set_num_format('$num_format');\n";
                                      $print_format=1;
                              }
      
      
                              # Check for contents (text or formula)
                              my ($contents);
                              $contents=$usedrange->Cells($i,$j)->Formula;
                              $contents=$usedrange->Cells($i,$j)->Text if ($contents eq "");
      
      
                              # Print cell
                              if ($contents ne "" or $print_format) {
                                      print OUTFILE "# Cell($i,$j)\n";
                                      print OUTFILE $format if ($print_format);
                                      print OUTFILE "\$worksheets{'$name'}->write(".($i-1).",".($j-1).
                                              ",'$contents'";
                                      print OUTFILE ",$fname" if ($print_format);
                                      print OUTFILE ");\n";
                              }
                      }
              }
      }
      
      
      # Famous last words...
      print OUTFILE "\$workbook->close();\n";
      
      
      # Close outfile
      close (OUTFILE) or die "Can't close outfile $opts{o}: $!";
      
      
      ####################################################################
      sub usage {
              printf STDERR "usage: $0 [options]\n".
                      "\tOptions:\n".
                      "\t\t-v       \tverbose mode\n" .
                      "\t\t-i <name>\tname of input file\n" .
                      "\t\t-o <name>\tname of output file\n";
      }
      
      
      ####################################################################
      sub END {
              # Quit excel
              do {
                      $Excel->{DisplayAlerts} = 0;
                      $Excel->Quit;
              } if (defined $Excel);
      }
      
      
      __END__
      
      
      =head1 NAME
      
      
      lecxe - A Excel file to Spreadsheet::WriteExcel code converter
      
      
      =head1 DESCRIPTION
      
      
      This program takes an MS Excel workbook file as input and from
      that file, produces an output file with Perl code that uses the
      Spreadsheet::WriteExcel module to reproduce the original
      file.
      
      
      =head1 STUFF
      
      
      Additional hands-on editing of the output file might be neccecary
      as:
      
      
      * This program always names the file produced by output script
        _change_me_.xls
      
      
      * Users of international Excel versions will have som work to do
        on list separators and numeric punctation characters.
      
      
      =head1 SEE ALSO
      
      
      L<Win32::OLE>, L<Win32::OLE::Variant>, L<Spreadsheet::WriteExcel>
      
      
      =head1 BUGS
      
      
      * Picks wrong color on cells sometimes.
      
      
      * Probably a few other...
      
      
      =head1 DISCLAIMER
      
      
      I do not guarantee B<ANYTHING> with this program. If you use it you
      are doing so B<AT YOUR OWN RISK>! I may or may not support this
      depending on my time schedule...
      
      
      =head1 AUTHOR
      
      
      t0mas@netlords.net
      
      
      =head1 COPYRIGHT
      
      
      Copyright 2001, t0mas@netlords.net
      
      
      This package is free software; you can redistribute it and/or
      modify it under the same terms as Perl itself.
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/lecxe.pl>
  
  =head2 Example: convertA1.pl
  
  
  
  This program contains helper functions to deal with the Excel A1 cell
  reference  notation.
  
  These functions have been superseded by L<Spreadsheet::WriteExcel::Utility>.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # This program contains helper functions to deal with the Excel A1 cell
      # reference  notation.
      #
      # These functions have been superseded by L<Spreadsheet::WriteExcel::Utility>.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      
      print "\n";
      print "Cell B7   is equivalent to (";
      print join " ", cell_to_rowcol('B7');
      print ") in row column notation.\n";
      
      print "Cell \$B7  is equivalent to (";
      print join " ", cell_to_rowcol('$B7');
      print ") in row column notation.\n";
      
      print "Cell B\$7  is equivalent to (";
      print join " ", cell_to_rowcol('B$7');
      print ") in row column notation.\n";
      
      print "Cell \$B\$7 is equivalent to (";
      print join " ", cell_to_rowcol('$B$7');
      print ") in row column notation.\n\n";
      
      print "Row and column (1999, 29)       are equivalent to ";
      print rowcol_to_cell(1999, 29),   ".\n";
      
      print "Row and column (1999, 29, 0, 1) are equivalent to ";
      print rowcol_to_cell(1999, 29, 0, 1),   ".\n\n";
      
      print "The base cell is:     Z7\n";
      print "Increment the row:    ", inc_cell_row('Z7'), "\n";
      print "Decrement the row:    ", dec_cell_row('Z7'), "\n";
      print "Increment the column: ", inc_cell_col('Z7'), "\n";
      print "Decrement the column: ", dec_cell_col('Z7'), "\n\n";
      
      
      ###############################################################################
      #
      # rowcol_to_cell($row, $col, $row_absolute, $col_absolute)
      #
      # Convert a zero based row and column reference to a A1 reference. For example
      # (0, 2) to C1. $row_absolute, $col_absolute are optional. They are boolean
      # values used to indicate if the row or column value is absolute, i.e. if it is
      # prefixed by a $ sign: eg. (0, 2, 0, 1) converts to $C1.
      #
      # Returns: a cell reference string.
      #
      sub rowcol_to_cell {
      
          my $row     = $_[0];
          my $col     = $_[1];
          my $row_abs = $_[2] || 0;
          my $col_abs = $_[3] || 0;
      
      
          if ($row_abs) {
              $row_abs = '$'
          }
          else {
              $row_abs = ''
          }
      
          if ($col_abs) {
              $col_abs = '$'
          }
          else {
              $col_abs = ''
          }
      
      
          my $int  = int ($col / 26);
          my $frac = $col % 26 +1;
      
          my $chr1 ='';
          my $chr2 ='';
      
      
          if ($frac != 0) {
              $chr2 = chr (ord('A') + $frac -1);
          }
      
          if ($int > 0) {
              $chr1 = chr (ord('A') + $int  -1);
          }
      
          $row++;     # Zero index to 1-index
      
          return $col_abs . $chr1 . $chr2 . $row_abs. $row;
      }
      
      
      ###############################################################################
      #
      # cell_to_rowcol($cell_ref)
      #
      # Convert an Excel cell reference in A1 notation to a zero based row and column
      # reference; converts C1 to (0, 2, 0, 0).
      #
      # Returns: row, column, row_is_absolute, column_is_absolute
      #
      #
      sub cell_to_rowcol {
      
          my $cell = shift;
      
          $cell =~ /(\$?)([A-I]?[A-Z])(\$?)(\d+)/;
      
          my $col_abs = $1 eq "" ? 0 : 1;
          my $col     = $2;
          my $row_abs = $3 eq "" ? 0 : 1;
          my $row     = $4;
      
          # Convert base26 column string to number
          # All your Base are belong to us.
          my @chars  = split //, $col;
          my $expn   = 0;
          $col       = 0;
      
          while (@chars) {
              my $char = pop(@chars); # LS char first
              $col += (ord($char) -ord('A') +1) * (26**$expn);
              $expn++;
          }
      
          # Convert 1-index to zero-index
          $row--;
          $col--;
      
          return $row, $col, $row_abs, $col_abs;
      }
      
      
      ###############################################################################
      #
      # inc_cell_row($cell_ref)
      #
      # Increments the row number of an Excel cell reference in A1 notation.
      # For example C3 to C4
      #
      # Returns: a cell reference string.
      #
      sub inc_cell_row {
      
          my $cell = shift;
          my ($row, $col, $row_abs, $col_abs) = cell_to_rowcol($cell);
      
          $row++;
      
          return rowcol_to_cell($row, $col, $row_abs, $col_abs);
      }
      
      
      ###############################################################################
      #
      # dec_cell_row($cell_ref)
      #
      # Decrements the row number of an Excel cell reference in A1 notation.
      # For example C4 to C3
      #
      # Returns: a cell reference string.
      #
      sub dec_cell_row {
      
          my $cell = shift;
          my ($row, $col, $row_abs, $col_abs) = cell_to_rowcol($cell);
      
          $row--;
      
          return rowcol_to_cell($row, $col, $row_abs, $col_abs);
      }
      
      
      ###############################################################################
      #
      # inc_cell_col($cell_ref)
      #
      # Increments the column number of an Excel cell reference in A1 notation.
      # For example C3 to D3
      #
      # Returns: a cell reference string.
      #
      sub inc_cell_col {
      
          my $cell = shift;
          my ($row, $col, $row_abs, $col_abs) = cell_to_rowcol($cell);
      
          $col++;
      
          return rowcol_to_cell($row, $col, $row_abs, $col_abs);
      }
      
      
      ###############################################################################
      #
      # dec_cell_col($cell_ref)
      #
      # Decrements the column number of an Excel cell reference in A1 notation.
      # For example D3 to C3
      #
      # Returns: a cell reference string.
      #
      sub dec_cell_col {
      
          my $cell = shift;
          my ($row, $col, $row_abs, $col_abs) = cell_to_rowcol($cell);
      
          $col--;
      
          return rowcol_to_cell($row, $col, $row_abs, $col_abs);
      }
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/convertA1.pl>
  
  =head2 Example: function_locale.pl
  
  
  
  Generate function names for different locales.
  
  This program can be used to generate the hash of known functions for use in
  the Formula.pm module. By default the function names are in English but you
  can also choose to support the following languages: German, French, Spanish,
  Portuguese, Dutch, Finnish, Italian and Swedish.
  
  This would allow you to do something like the following:
  
        $worksheet->write(0, 0, '=SUM(C1:C3)'  );
        $worksheet->write(1, 0, '=SUMME(C1:C3)');
        $worksheet->write(2, 0, '=SOMME(C1:C3)');
        $worksheet->write(3, 0, '=SUMA(C1:C3)' );
        $worksheet->write(4, 0, '=SOMA(C1:C3)' );
        $worksheet->write(5, 0, '=SOM(C1:C3)'  );
        $worksheet->write(6, 0, '=SUMMA(C1:C3)');
        $worksheet->write(7, 0, '=SOMMA(C1:C3)');
  
  Unfortunately, if you wish to support more than one language there are some
  conflicts between function names:
  
        Function        Language 1              Language 2
        ========        ==========              ==========
        NB              French                  Dutch
        NA              English/French          Finnish
        TRIM            French                  English
        DIA             Spanish/Portuguese      German
  
  Therefore, if you try to generate a hash of function names to support both
  French and English then the function TRIM will be assigned the meaning of the
  first language that defines it, which in this case is French. You can get
  around this by renaming the function for one of the languages and documenting
  the change, for example: TRIM.EN or TRIM.FR.
  
  Please note that this only partially solves the problem of localisation.
  There are also number formats to consider (1.5 == 1,5) and the fact that the
  list separator "," and the array separator ";" are interchanged in different
  locales.
  
  The longest function name is LOI.NORMALE.STANDARD.INVERSE (29 chars) followed
  by NORM.JAKAUMA.NORMIT.KNT (25 chars).
  The shortest function name in all languages is T.
  
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Generate function names for different locales.
      #
      # This program can be used to generate the hash of known functions for use in
      # the Formula.pm module. By default the function names are in English but you
      # can also choose to support the following languages: German, French, Spanish,
      # Portuguese, Dutch, Finnish, Italian and Swedish.
      #
      # This would allow you to do something like the following:
      #
      #       $worksheet->write(0, 0, '=SUM(C1:C3)'  );
      #       $worksheet->write(1, 0, '=SUMME(C1:C3)');
      #       $worksheet->write(2, 0, '=SOMME(C1:C3)');
      #       $worksheet->write(3, 0, '=SUMA(C1:C3)' );
      #       $worksheet->write(4, 0, '=SOMA(C1:C3)' );
      #       $worksheet->write(5, 0, '=SOM(C1:C3)'  );
      #       $worksheet->write(6, 0, '=SUMMA(C1:C3)');
      #       $worksheet->write(7, 0, '=SOMMA(C1:C3)');
      #
      # Unfortunately, if you wish to support more than one language there are some
      # conflicts between function names:
      #
      #       Function        Language 1              Language 2
      #       ========        ==========              ==========
      #       NB              French                  Dutch
      #       NA              English/French          Finnish
      #       TRIM            French                  English
      #       DIA             Spanish/Portuguese      German
      #
      # Therefore, if you try to generate a hash of function names to support both
      # French and English then the function TRIM will be assigned the meaning of the
      # first language that defines it, which in this case is French. You can get
      # around this by renaming the function for one of the languages and documenting
      # the change, for example: TRIM.EN or TRIM.FR.
      #
      # Please note that this only partially solves the problem of localisation.
      # There are also number formats to consider (1.5 == 1,5) and the fact that the
      # list separator "," and the array separator ";" are interchanged in different
      # locales.
      #
      # The longest function name is LOI.NORMALE.STANDARD.INVERSE (29 chars) followed
      # by NORM.JAKAUMA.NORMIT.KNT (25 chars).
      # The shortest function name in all languages is T.
      #
      #
      # reverse(''); John McNamara, March 2001, jmcnamara@cpan.org
      #
      
      
      
      use strict;
      
      
      #
      # Modify the following variables to add the language to the function name hash
      #
      my $english    = 1;
      my $german     = 0;
      my $french     = 0;
      my $spanish    = 0;
      my $portuguese = 0;
      my $dutch      = 0;
      my $finnish    = 0;
      my $italian    = 0;
      my $swedish    = 0;
      
      my %funcs;
      
      # Ignore the headings
      <DATA>;
      
      # Print the beginning of the hash definition
      print "    %functions  = (\n";
      print "        #" . " " x 37 ;
      print "ptg  args  class  vol\n";
      
      while (<DATA>){
          my @F = split " ";
          my $value = $F[0];
          my $args  = $F[1];
          my $ref   = $F[2];
          my $vol   = $F[3];
      
          print_function($F[4],  $value, $args, $ref, $vol) if $english;
          print_function($F[5],  $value, $args, $ref, $vol) if $german;
          print_function($F[6],  $value, $args, $ref, $vol) if $french;
          print_function($F[7],  $value, $args, $ref, $vol) if $spanish;
          print_function($F[8],  $value, $args, $ref, $vol) if $portuguese;
          print_function($F[9],  $value, $args, $ref, $vol) if $dutch;
          print_function($F[10], $value, $args, $ref, $vol) if $finnish;
          print_function($F[11], $value, $args, $ref, $vol) if $italian;
          print_function($F[12], $value, $args, $ref, $vol) if $swedish;
      }
      # Print the end of the hash definition
      print "    );\n";
      
      
      ###############################################################################
      #
      # Function to print the function names. It prints a warning if there is a
      # clash.
      #
      sub print_function {
      
          my $func  = shift;
          my $value = shift;
          my $args  = shift;
          my $ref   = shift;
          my $vol   = shift;
      
          $func = "'$func'";
      
          if (not exists $funcs{$func}) {
              printf("        %-31s => [%4d, %4d, %4d, %4d ],\n",
                                         $func, $value, $args, $ref, $vol);
              $funcs{$func} = $value;
          }
          else {
              if ($funcs{$func} != $value) {
                  print "        # Warning ";
                  print $func, " is already defined in another language\n";
                  printf("        #%-31s => [%4d, %4d, %4d, %4d ],\n",
                                              $func, $value, $args, $ref, $vol);
              }
          }
      }
      
      
      # Note: The following data contains the function names in the various
      # languages. These lines are LONG.
      
      __DATA__
      Value   Args    Refclass   Volatile   English                            German                             French                             Spanish                            Portuguese                         Dutch                        Finnish                            Italian                            Swedish
      0       -1      0          0          COUNT                              ANZAHL                             NB                                 CONTAR                             CONT.NM                           AANTAL                       LASKE                              CONTA.NUMERI                       ANTAL
      1       -1      1          0          IF                                 WENN                               SI                                 SI                                 SE                                 ALS                          JOS                                SE                                 OM
      2        1      1          0          ISNA                               ISTNV                              ESTNA                              ESNOD                              .NO.DISP                         ISNB                         ONPUUTTUU                          VAL.NON.DISP                       RSAKNAD
      3        1      1          0          ISERROR                            ISTFEHLER                          ESTERREUR                          ESERROR                            ERROS                             ISFOUT                       ONVIRHE                            VAL.ERRORE                         RFEL
      4       -1      0          0          SUM                                SUMME                              SOMME                              SUMA                               SOMA                               SOM                          SUMMA                              SOMMA                              SUMMA
      5       -1      0          0          AVERAGE                            MITTELWERT                         MOYENNE                            PROMEDIO                           MDIA                              GEMIDDELDE                   KESKIARVO                          MEDIA                              MEDEL
      6       -1      0          0          MIN                                MIN                                MIN                                MIN                                MNIMO                             MIN                          MIN                                MIN                                MIN
      7       -1      0          0          MAX                                MAX                                MAX                                MAX                                MXIMO                             MAX                          MAKS                               MAX                                MAX
      8       -1      0          0          ROW                                ZEILE                              LIGNE                              FILA                               LIN                                RIJ                          RIVI                               RIF.RIGA                           RAD
      9       -1      0          0          COLUMN                             SPALTE                             COLONNE                            COLUMNA                            COL                                KOLOM                        SARAKE                             RIF.COLONNA                        KOLUMN
      10       0      0          0          NA                                 NV                                 NA                                 NOD                                NO.DISP                           NB                           PUUTTUU                            NON.DISP                           SAKNAS
      11      -1      1          0          NPV                                NBW                                VAN                                VNA                                VPL                                NHW                          NNA                                VAN                                NETNUVRDE
      12      -1      0          0          STDEV                              STABW                              ECARTYPE                           DESVEST                            DESVPAD                            STDEV                        KESKIHAJONTA                       DEV.ST                             STDAV
      13      -1      1          0          DOLLAR                             DM                                 FRANC                              MONEDA                             MOEDA                              GULDEN                       VALUUTTA                           VALUTA                             VALUTA
      14      -1      1          0          FIXED                              FEST                               CTXT                               DECIMAL                            DEF.NM.DEC                        VAST                         KIINTE                            FISSO                              FASTTAL
      15       1      1          0          SIN                                SIN                                SIN                                SENO                               SEN                                SIN                          SIN                                SEN                                SIN
      16       1      1          0          COS                                COS                                COS                                COS                                COS                                COS                          COS                                COS                                COS
      17       1      1          0          TAN                                TAN                                TAN                                TAN                                TAN                                TAN                          TAN                                TAN                                TAN
      18       1      1          0          ATAN                               ARCTAN                             ATAN                               ATAN                               ATAN                               BOOGTAN                      ATAN                               ARCTAN                             ARCTAN
      19       0      1          0          PI                                 PI                                 PI                                 PI                                 PI                                 PI                           PII                                PI.GRECO                           PI
      20       1      1          0          SQRT                               WURZEL                             RACINE                             RAIZ                               RAIZ                               WORTEL                       NELIJUURI                         RADQ                               ROT
      21       1      1          0          EXP                                EXP                                EXP                                EXP                                EXP                                EXP                          EKSPONENTTI                        EXP                                EXP
      22       1      1          0          LN                                 LN                                 LN                                 LN                                 LN                                 LN                           LUONNLOG                           LN                                 LN
      23       1      1          0          LOG10                              LOG10                              LOG10                              LOG10                              LOG10                              LOG10                        LOG10                              LOG10                              LOG10
      24       1      1          0          ABS                                ABS                                ABS                                ABS                                ABS                                ABS                          ITSEISARVO                         ASS                                ABS
      25       1      1          0          INT                                GANZZAHL                           ENT                                ENTERO                             INT                                INTEGER                      KOKONAISLUKU                       INT                                HELTAL
      26       1      1          0          SIGN                               VORZEICHEN                         SIGNE                              SIGNO                              SINAL                              POS.NEG                      ETUMERKKI                          SEGNO                              TECKEN
      27       2      1          0          ROUND                              RUNDEN                             ARRONDI                            REDONDEAR                          ARRED                              AFRONDEN                     PYRIST                           ARROTONDA                          AVRUNDA
      28      -1      0          0          LOOKUP                             VERWEIS                            RECHERCHE                          BUSCAR                             PROC                               ZOEKEN                       HAKU                               CERCA                              LETAUPP
      29      -1      0          1          INDEX                              INDEX                              INDEX                              INDICE                             NDICE                             INDEX                        INDEKSI                            INDICE                             INDEX
      30       2      1          0          REPT                               WIEDERHOLEN                        REPT                               REPETIR                            REPETIR                            HERHALING                    TOISTA                             RIPETI                             REP
      31       3      1          0          MID                                TEIL                               STXT                               EXTRAE                             EXT.TEXTO                          DEEL                         POIMI.TEKSTI                       STRINGA.ESTRAI                     EXTEXT
      32       1      1          0          LEN                                LNGE                              NBCAR                              LARGO                              NM.CARACT                         LENGTE                       PITUUS                             LUNGHEZZA                          LNGD
      33       1      1          0          VALUE                              WERT                               CNUM                               VALOR                              VALOR                              WAARDE                       ARVO                               VALORE                             TEXTNUM
      34       0      1          0          TRUE                               WAHR                               VRAI                               VERDADERO                          VERDADEIRO                         WAAR                         TOSI                               VERO                               SANT
      35       0      1          0          FALSE                              FALSCH                             FAUX                               FALSO                              FALSO                              ONWAAR                       EPTOSI                            FALSO                              FALSKT
      36      -1      0          0          AND                                UND                                ET                                 Y                                  E                                  EN                           JA                                 E                                  OCH
      37      -1      0          0          OR                                 ODER                               OU                                 O                                  OU                                 OF                           TAI                                O                                  ELLER
      38       1      1          0          NOT                                NICHT                              NON                                NO                                 NO                                NIET                         EI                                 NON                                ICKE
      39       2      1          0          MOD                                REST                               MOD                                RESIDUO                            MOD                                REST                         JAKOJ                              RESTO                              REST
      40       3      0          0          DCOUNT                             DBANZAHL                           BDNB                               BDCONTAR                           BDCONTAR                           DBAANTAL                     TLASKE                             DB.CONTA.NUMERI                    DANTAL
      41       3      0          0          DSUM                               DBSUMME                            BDSOMME                            BDSUMA                             BDSOMA                             DBSOM                        TSUMMA                             DB.SOMMA                           DSUMMA
      42       3      0          0          DAVERAGE                           DBMITTELWERT                       BDMOYENNE                          BDPROMEDIO                         BDMDIA                            DBGEMIDDELDE                 TKESKIARVO                         DB.MEDIA                           DMEDEL
      43       3      0          0          DMIN                               DBMIN                              BDMIN                              BDMIN                              BDMN                              DBMIN                        TMIN                               DB.MIN                             DMIN
      44       3      0          0          DMAX                               DBMAX                              BDMAX                              BDMAX                              BDMX                              DBMAX                        TMAKS                              DB.MAX                             DMAX
      45       3      0          0          DSTDEV                             DBSTDABW                           BDECARTYPE                         BDDESVEST                          BDEST                              DBSTDEV                      TKESKIHAJONTA                      DB.DEV.ST                          DSTDAV
      46      -1      0          0          VAR                                VARIANZ                            VAR                                VAR                                VAR                                VAR                          VAR                                VAR                                VARIANS
      47       3      0          0          DVAR                               DBVARIANZ                          BDVAR                              BDVAR                              BDVAREST                           DBVAR                        TVARIANSSI                         DB.VAR                             DVARIANS
      48       2      1          0          TEXT                               TEXT                               TEXTE                              TEXTO                              TEXTO                              TEKST                        TEKSTI                             TESTO                              TEXT
      49      -1      0          0          LINEST                             RGP                                DROITEREG                          ESTIMACION.LINEAL                  PROJ.LIN                           LIJNSCH                      LINREGR                            REGR.LIN                           REGR
      50      -1      0          0          TREND                              TREND                              TENDANCE                           TENDENCIA                          TENDNCIA                          TREND                        SUUNTAUS                           TENDENZA                           TREND
      51      -1      0          0          LOGEST                             RKP                                LOGREG                             ESTIMACION.LOGARITMICA             PROJ.LOG                           LOGSCH                       LOGREGR                            REGR.LOG                           EXPREGR
      52      -1      0          0          GROWTH                             VARIATION                          CROISSANCE                         CRECIMIENTO                        CRESCIMENTO                        GROEI                        KASVU                              CRESCITA                           EXPTREND
      56      -1      1          0          PV                                 BW                                 VA                                 VA                                 VP                                 HW                           NA                                 VA                                 NUVRDE
      57      -1      1          0          FV                                 ZW                                 VC                                 VF                                 VF                                 TW                           TULEVA.ARVO                        VAL.FUT                            SLUTVRDE
      58      -1      1          0          NPER                               ZZR                                NPM                                NPER                               NPER                               NPER                         NJAKSO                             NUM.RATE                           PERIODER
      59      -1      1          0          PMT                                RMZ                                VPM                                PAGO                               PGTO                               BET                          MAKSU                              RATA                               BETALNING
      60      -1      1          0          RATE                               ZINS                               TAUX                               TASA                               TAXA                               RENTE                        KORKO                              TASSO                              RNTA
      61       3      0          0          MIRR                               QIKV                               TRIM                               TIRM                               MTIR                               GIR                          MSISINEN                          TIR.VAR                            MODIR
      62      -1      0          0          IRR                                IKV                                TRI                                TIR                                TIR                                IR                           SISINEN.KORKO                     TIR.COST                           IR
      63       0      1          1          RAND                               ZUFALLSZAHL                        ALEA                               ALEATORIO                          ALEATRIO                          ASELECT                      SATUNNAISLUKU                      CASUALE                            SLUMP
      64      -1      0          0          MATCH                              VERGLEICH                          EQUIV                              COINCIDIR                          CORRESP                            VERGELIJKEN                  VASTINE                            CONFRONTA                          PASSA
      65       3      1          0          DATE                               DATUM                              DATE                               FECHA                              DATA                               DATUM                        PIVYS                            DATA                               DATUM
      66       3      1          0          TIME                               ZEIT                               TEMPS                              NSHORA                             TEMPO                              TIJD                         AIKA                               ORARIO                             KLOCKSLAG
      67       1      1          0          DAY                                TAG                                JOUR                               DIA                                DIA                                DAG                          PIV                              GIORNO                             DAG
      68       1      1          0          MONTH                              MONAT                              MOIS                               MES                                MS                                MAAND                        KUUKAUSI                           MESE                               MNAD
      69       1      1          0          YEAR                               JAHR                               ANNEE                              AO                                ANO                                JAAR                         VUOSI                              ANNO                               R
      70      -1      1          0          WEEKDAY                            WOCHENTAG                          JOURSEM                            DIASEM                             DIA.DA.SEMANA                      WEEKDAG                      VIIKONPIV                        GIORNO.SETTIMANA                   VECKODAG
      71       1      1          0          HOUR                               STUNDE                             HEURE                              HORA                               HORA                               UUR                          TUNNIT                             ORA                                TIMME
      72       1      1          0          MINUTE                             MINUTE                             MINUTE                             MINUTO                             MINUTO                             MINUUT                       MINUUTIT                           MINUTO                             MINUT
      73       1      1          0          SECOND                             SEKUNDE                            SECONDE                            SEGUNDO                            SEGUNDO                            SECONDE                      SEKUNNIT                           SECONDO                            SEKUND
      74       0      1          1          NOW                                JETZT                              MAINTENANT                         AHORA                              AGORA                              NU                           NYT                                ADESSO                             NU
      75       1      0          1          AREAS                              BEREICHE                           ZONES                              AREAS                              REAS                              BEREIKEN                     ALUEET                             AREE                               OMRDEN
      76       1      0          1          ROWS                               ZEILEN                             LIGNES                             FILAS                              LINS                               RIJEN                        RIVIT                              RIGHE                              RADER
      77       1      0          1          COLUMNS                            SPALTEN                            COLONNES                           COLUMNAS                           COLS                               KOLOMMEN                     SARAKKEET                          COLONNE                            KOLUMNER
      78      -1      0          1          OFFSET                             BEREICH.VERSCHIEBEN                DECALER                            DESREF                             DESLOC                             VERSCHUIVING                 SIIRTYM                           SCARTO                             FRSKJUTNING
      82      -1      1          0          SEARCH                             SUCHEN                             CHERCHE                            HALLAR                             LOCALIZAR                          VIND.SPEC                    KY.LPI                           RICERCA                            SK
      83       1      1          0          TRANSPOSE                          MTRANS                             TRANSPOSE                          TRANSPONER                         TRANSPOR                           TRANSPONEREN                 TRANSPONOI                         MATR.TRASPOSTA                     TRANSPONERA
      86       1      1          0          TYPE                               TYP                                TYPE                               TIPO                               TIPO                               TYPE                         TYYPPI                             TIPO                               VRDETYP
      97       2      1          0          ATAN2                              ARCTAN2                            ATAN2                              ATAN2                              ATAN2                              BOOGTAN2                     ATAN2                              ARCTAN.2                           ARCTAN2
      98       1      1          0          ASIN                               ARCSIN                             ASIN                               ASENO                              ASEN                               BOOGSIN                      ASIN                               ARCSEN                             ARCSIN
      99       1      1          0          ACOS                               ARCCOS                             ACOS                               ACOS                               ACOS                               BOOGCOS                      ACOS                               ARCCOS                             ARCCOS
      100     -1      1          0          CHOOSE                             WAHL                               CHOISIR                            ELEGIR                             ESCOLHER                           KIEZEN                       VALITSE.INDEKSI                    SCEGLI                             VLJ
      101     -1      0          0          HLOOKUP                            WVERWEIS                           RECHERCHEH                         BUSCARH                            PROCH                              HORIZ.ZOEKEN                 VHAKU                              CERCA.ORIZZ                        LETAKOLUMN
      102     -1      0          0          VLOOKUP                            SVERWEIS                           RECHERCHEV                         BUSCARV                            PROCV                              VERT.ZOEKEN                  PHAKU                              CERCA.VERT                         LETARAD
      105      1      0          0          ISREF                              ISTBEZUG                           ESTREF                             ESREF                              REF                               ISVERWIJZING                 ONVIITT                            VAL.RIF                            RREF
      109     -1      1          0          LOG                                LOG                                LOG                                LOG                                LOG                                LOG                          LOG                                LOG                                LOG
      111      1      1          0          CHAR                               ZEICHEN                            CAR                                CARACTER                           CARACT                             TEKEN                        MERKKI                             CODICE.CARATT                      TECKENKOD
      112      1      1          0          LOWER                              KLEIN                              MINUSCULE                          MINUSC                             MINSCULA                          KLEINE.LETTERS               PIENET                             MINUSC                             GEMENER
      113      1      1          0          UPPER                              GROSS                              MAJUSCULE                          MAYUSC                             MAISCULA                          HOOFDLETTERS                 ISOT                               MAIUSC                             VERSALER
      114      1      1          0          PROPER                             GROSS2                             NOMPROPRE                          NOMPROPIO                          PRI.MAISCULA                      BEGINLETTERS                 ERISNIMI                           MAIUSC.INIZ                        INITIAL
      115     -1      1          0          LEFT                               LINKS                              GAUCHE                             IZQUIERDA                          ESQUERDA                           LINKS                        VASEN                              SINISTRA                           VNSTER
      116     -1      1          0          RIGHT                              RECHTS                             DROITE                             DERECHA                            DIREITA                            RECHTS                       OIKEA                              DESTRA                             HGER
      117      2      1          0          EXACT                              IDENTISCH                          EXACT                              IGUAL                              EXATO                              GELIJK                       VERTAA                             IDENTICO                           EXAKT
      118      1      1          0          TRIM                               GLTTEN                            SUPPRESPACE                        ESPACIOS                           ARRUMAR                            SPATIES.WISSEN               POISTA.VLIT                       ANNULLA.SPAZI                      RENSA
      119      4      1          0          REPLACE                            ERSETZEN                           REMPLACER                          REEMPLAZAR                         MUDAR                              VERVANGEN                    KORVAA                             RIMPIAZZA                          ERSTT
      120     -1      1          0          SUBSTITUTE                         WECHSELN                           SUBSTITUE                          SUSTITUIR                          SUBSTITUIR                         SUBSTITUEREN                 VAIHDA                             SOSTITUISCI                        BYT.UT
      121      1      1          0          CODE                               CODE                               CODE                               CODIGO                             CDIGO                             CODE                         KOODI                              CODICE                             KOD
      124     -1      1          0          FIND                               FINDEN                             TROUVE                             ENCONTRAR                          PROCURAR                           VIND.ALLES                   ETSI                               TROVA                              HITTA
      125     -1      0          1          CELL                               ZELLE                              CELLULE                            CELDA                              CL                                CEL                          SOLU                               CELLA                              CELL
      126      1      1          0          ISERR                              ISTFEHL                            ESTERR                             ESERR                              ERRO                              ISFOUT2                      ONVIRH                             VAL.ERR                            RF
      127      1      1          0          ISTEXT                             ISTTEXT                            ESTTEXTE                           ESTEXTO                            TEXTO                             ISTEKST                      ONTEKSTI                           VAL.TESTO                          RTEXT
      128      1      1          0          ISNUMBER                           ISTZAHL                            ESTNUM                             ESNUMERO                           NM                               ISGETAL                      ONLUKU                             VAL.NUMERO                         RTAL
      129      1      1          0          ISBLANK                            ISTLEER                            ESTVIDE                            ESBLANCO                           CL.VAZIA                         ISLEEG                       ONTYHJ                            VAL.VUOTO                          RTOM
      130      1      0          0          T                                  T                                  T                                  T                                  T                                  T                            T                                  T                                  T
      131      1      0          0          N                                  N                                  N                                  N                                  N                                  N                            N                                  NUM                                N
      140      1      1          0          DATEVALUE                          DATWERT                            DATEVAL                            FECHANUMERO                        DATA.VALOR                         DATUMWAARDE                  PIVYSARVO                        DATA.VALORE                        DATUMVRDE
      141      1      1          0          TIMEVALUE                          ZEITWERT                           TEMPSVAL                           HORANUMERO                         VALOR.TEMPO                        TIJDWAARDE                   AIKA_ARVO                          ORARIO.VALORE                      TIDVRDE
      142      3      1          0          SLN                                LIA                                AMORLIN                            SLN                                DPD                                LIN.AFSCHR                   STP                                AMMORT.COST                        LINAVSKR
      143      4      1          0          SYD                                DIA                                SYD                                SYD                                SDA                                SYD                          VUOSIPOISTO                        AMMORT.ANNUO                       RSAVSKR
      144     -1      1          0          DDB                                GDA                                DDB                                DDB                                BDD                                DDB                          DDB                                AMMORT                             DEGAVSKR
      148     -1      1          1          INDIRECT                           INDIREKT                           INDIRECT                           INDIRECTO                          INDIRETO                           INDIRECT                     EPSUORA                           INDIRETTO                          INDIREKT
      150     -1      1          0          CALL                               AUFRUFEN                           FONCTION.APPELANTE                 LLAMAR                             CHAMAR                             ROEPEN                       KUTSU                              RICHIAMA                           ANROPA
      162      1      1          0          CLEAN                              SUBERN                            EPURAGE                            LIMPIAR                            TIRAR                              WISSEN.CONTROL               SIIVOA                             LIBERA                             STDA
      163      1      2          0          MDETERM                            MDET                               DETERMAT                           MDETERM                            MATRIZ.DETERM                      DETERMINANTMAT               MDETERM                            MATR.DETERM                        MDETERM
      164      1      2          0          MINVERSE                           MINV                               INVERSEMAT                         MINVERSA                           MATRIZ.INVERSO                     INVERSEMAT                   MKNTEINEN                        MATR.INVERSA                       MINVERT
      165      2      2          0          MMULT                              MMULT                              PRODUITMAT                         MMULT                              MATRIZ.MULT                        PRODUKTMAT                   MKERRO                             MATR.PRODOTTO                      MMULT
      167     -1      1          0          IPMT                               ZINSZ                              INTPER                             PAGOINT                            IPGTO                              IBET                         IPMT                               INTERESSI                          RBETALNING
      168     -1      1          0          PPMT                               KAPZ                               PRINCPER                           PAGOPRIN                           PPGTO                              PBET                         PPMT                               P.RATA                             AMORT
      169     -1      0          0          COUNTA                             ANZAHL2                            NBVAL                              CONTARA                            CONT.VALORES                       AANTALARG                    LASKE.A                            CONTA.VALORI                       ANTALV
      183     -1      0          0          PRODUCT                            PRODUKT                            PRODUIT                            PRODUCTO                           MULT                               PRODUKT                      TULO                               PRODOTTO                           PRODUKT
      184      1      1          0          FACT                               FAKULTT                           FACT                               FACT                               FATORIAL                           FACULTEIT                    KERTOMA                            FATTORIALE                         FAKULTET
      189      3      0          0          DPRODUCT                           DBPRODUKT                          BDPRODUIT                          BDPRODUCTO                         BDMULTIPL                          DBPRODUKT                    TTULO                              DB.PRODOTTO                        DPRODUKT
      190      1      1          0          ISNONTEXT                          ISTKTEXT                           ESTNONTEXTE                        ESNOTEXTO                          .NO.TEXTO                        ISGEENTEKST                  ONEI_TEKSTI                        VAL.NON.TESTO                      REJTEXT
      193     -1      0          0          STDEVP                             STABWN                             ECARTYPEP                          DESVESTP                           DESVPADP                           STDEVP                       KESKIHAJONTAP                      DEV.ST.POP                         STDAVP
      194     -1      0          0          VARP                               VARIANZEN                          VAR.P                              VARP                               VARP                               VARP                         VARP                               VAR.POP                            VARIANSP
      195      3      0          0          DSTDEVP                            DBSTDABWN                          BDECARTYPEP                        BDDESVESTP                         BDDESVPA                           DBSTDEVP                     TKESKIHAJONTAP                     DB.DEV.ST.POP                      DSTDAVP
      196      3      0          0          DVARP                              DBVARIANZEN                        BDVARP                             BDVARP                             BDVARP                             DBVARP                       TVARIANSSIP                        DB.VAR.POP                         DVARIANSP
      197     -1      1          0          TRUNC                              KRZEN                             TRONQUE                            TRUNCAR                            TRUNCAR                            GEHEEL                       KATKAISE                           TRONCA                             AVKORTA
      198      1      1          0          ISLOGICAL                          ISTLOG                             ESTLOGIQUE                         ESLOGICO                           LGICO                            ISLOGISCH                    ONTOTUUS                           VAL.LOGICO                         RLOGISK
      199      3      0          0          DCOUNTA                            DBANZAHL2                          BDNBVAL                            BDCONTARA                          BDCONTARA                          DBAANTALC                    TLASKEA                            DB.CONTA.VALORI                    DANTALV
      212      2      1          0          ROUNDUP                            AUFRUNDEN                          ARRONDI.SUP                        REDONDEAR.MAS                      ARREDONDAR.PARA.CIMA               AFRONDEN.NAAR.BOVEN          PYRIST.DES.YLS                  ARROTONDA.PER.ECC                  AVRUNDA.UPPT
      213      2      1          0          ROUNDDOWN                          ABRUNDEN                           ARRONDI.INF                        REDONDEAR.MENOS                    ARREDONDAR.PARA.BAIXO              AFRONDEN.NAAR.BENEDEN        PYRIST.DES.ALAS                  ARROTONDA.PER.DIF                  AVRUNDA.NEDT
      216     -1      0          0          RANK                               RANG                               RANG                               JERARQUIA                          ORDEM                              RANG                         ARVON.MUKAAN                       RANGO                              RANG
      219     -1      1          0          ADDRESS                            ADRESSE                            ADRESSE                            DIRECCION                          ENDEREO                           ADRES                        OSOITE                             INDIRIZZO                          ADRESS
      220     -1      1          0          DAYS360                            TAGE360                            JOURS360                           DIAS360                            DIAS360                            DAGEN360                     PIVT360                          GIORNO360                          DAGAR360
      221      0      1          1          TODAY                              HEUTE                              AUJOURDHUI                         HOY                                HOJE                               VANDAAG                      TM.PIV                         OGGI                               IDAG
      222     -1      1          0          VDB                                VDB                                VDB                                DVS                                BDV                                VDB                          VDB                                AMMORT.VAR                         VDEGRAVSKR
      227     -1      0          0          MEDIAN                             MEDIAN                             MEDIANE                            MEDIANA                            MED                                MEDIAAN                      MEDIAANI                           MEDIANA                            MEDIAN
      228     -1      2          0          SUMPRODUCT                         SUMMENPRODUKT                      SOMMEPROD                          SUMAPRODUCTO                       SOMARPRODUTO                       SOMPRODUKT                   TULOJEN.SUMMA                      MATR.SOMMA.PRODOTTO                PRODUKTSUMMA
      229      1      1          0          SINH                               SINHYP                             SINH                               SENOH                              SENH                               SINH                         SINH                               SENH                               SINH
      230      1      1          0          COSH                               COSHYP                             COSH                               COSH                               COSH                               COSH                         COSH                               COSH                               COSH
      231      1      1          0          TANH                               TANHYP                             TANH                               TANH                               TANH                               TANH                         TANH                               TANH                               TANH
      232      1      1          0          ASINH                              ARCSINHYP                          ASINH                              ASENOH                             ASENH                              BOOGSINH                     ASINH                              ARCSENH                            ARCSINH
      233      1      1          0          ACOSH                              ARCCOSHYP                          ACOSH                              ACOSH                              ACOSH                              BOOGCOSH                     ACOSH                              ARCCOSH                            ARCCOSH
      234      1      1          0          ATANH                              ARCTANHYP                          ATANH                              ATANH                              ATANH                              BOOGTANH                     ATANH                              ARCTANH                            ARCTANH
      235      3      0          0          DGET                               DBAUSZUG                           BDLIRE                             BDEXTRAER                          BDEXTRAIR                          DBLEZEN                      TNOUDA                             DB.VALORI                          DHMTA
      244      1      1          1          INFO                               INFO                               INFO                               INFO                               INFORMAO                         INFO                         KUVAUS                             AMBIENTE.INFO                      INFO
      247     -1      1          0          DB                                 GDA2                               DB                                 DB                                 BD                                 DB                           DB                                 AMMORT.FISSO                       DB
      252      2      0          0          FREQUENCY                          HUFIGKEIT                         FREQUENCE                          FRECUENCIA                         FREQNCIA                         INTERVAL                     TAAJUUS                            FREQUENZA                          FREKVENS
      261      1      1          0          ERROR.TYPE                         FEHLER.TYP                         TYPE.ERREUR                        TIPO.DE.ERROR                      TIPO.ERRO                          TYPE.FOUT                    VIRHEEN.LAJI                       ERRORE.TIPO                        FEL.TYP
      267     -1      1          0          REGISTER.ID                        REGISTER.KENNUMMER                 REGISTRE.NUMERO                    ID.REGISTRO                        IDENT.REGISTRO                     REGISTRATIE.ID               REKISTERI.TUNNUS                   IDENTIFICATORE.REGISTRO            REGISTRERA.ID
      269     -1      0          0          AVEDEV                             MITTELABW                          ECART.MOYEN                        DESVPROM                           DESV.MDIO                         GEM.DEVIATIE                 KESKIPOIKKEAMA                     MEDIA.DEV                          MEDELAVV
      270     -1      1          0          BETADIST                           BETAVERT                           LOI.BETA                           DISTR.BETA                         DISTBETA                           BETA.VERD                    BEETAJAKAUMA                       DISTRIB.BETA                       BETAFRD
      271      1      1          0          GAMMALN                            GAMMALN                            LNGAMMA                            GAMMA.LN                           LNGAMA                             GAMMA.LN                     GAMMALN                            LN.GAMMA                           GAMMALN
      272     -1      1          0          BETAINV                            BETAINV                            BETA.INVERSE                       DISTR.BETA.INV                     BETA.ACUM.INV                      BETA.INV                     BEETAJAKAUMA.KNT                 INV.BETA                           BETAINV
      273      4      1          0          BINOMDIST                          BINOMVERT                          LOI.BINOMIALE                      DISTR.BINOM                        DISTRBINOM                         BINOMIALE.VERD               BINOMIJAKAUMA                      DISTRIB.BINOM                      BINOMFRD
      274      2      1          0          CHIDIST                            CHIVERT                            LOI.KHIDEUX                        DISTR.CHI                          DIST.QUI                           CHI.KWADRAAT                 CHIJAKAUMA                         DISTRIB.CHI                        CHI2FRD
      275      2      1          0          CHIINV                             CHIINV                             KHIDEUX.INVERSE                    PRUEBA.CHI.INV                     INV.QUI                            CHI.KWADRAAT.INV             CHIJAKAUMA.KNT                   INV.CHI                            CHI2INV
      276      2      1          0          COMBIN                             KOMBINATIONEN                      COMBIN                             COMBINAT                           COMBIN                             COMBINATIES                  KOMBINAATIO                        COMBINAZIONE                       KOMBIN
      277      3      1          0          CONFIDENCE                         KONFIDENZ                          INTERVALLE.CONFIANCE               INTERVALO.CONFIANZA                INT.CONFIANA                      BETROUWBAARHEID              LUOTTAMUSVLI                      CONFIDENZA                         KONFIDENS
      278      3      1          0          CRITBINOM                          KRITBINOM                          CRITERE.LOI.BINOMIALE              BINOM.CRIT                         CRIT.BINOM                         CRIT.BINOM                   BINOMIJAKAUMA.KRIT                 CRIT.BINOM                         KRITBINOM
      279      1      1          0          EVEN                               GERADE                             PAIR                               REDONDEA.PAR                       PAR                                EVEN                         PARILLINEN                         PARI                               JMN
      280      3      1          0          EXPONDIST                          EXPONVERT                          LOI.EXPONENTIELLE                  DISTR.EXP                          DISTEXPON                          EXPON.VERD                   EKSPONENTIAALIJAKAUMA              DISTRIB.EXP                        EXPONFRD
      281      3      1          0          FDIST                              FVERT                              LOI.F                              DISTR.F                            DISTF                              F.VERDELING                  FJAKAUMA                           DISTRIB.F                          FFRD
      282      3      1          0          FINV                               FINV                               INVERSE.LOI.F                      DISTR.F.INV                        INVF                               F.INVERSE                    FJAKAUMA.KNT                     INV.F                              FINV
      283      1      1          0          FISHER                             FISHER                             FISHER                             FISHER                             FISHER                             FISHER                       FISHER                             FISHER                             FISHER
      284      1      1          0          FISHERINV                          FISHERINV                          FISHER.INVERSE                     PRUEBA.FISHER.INV                  FISHERINV                          FISHER.INV                   FISHER.KNT                       INV.FISHER                         FISHERINV
      285      2      1          0          FLOOR                              UNTERGRENZE                        PLANCHER                           MULTIPLO.INFERIOR                  ARREDMULTB                         AFRONDEN.BENEDEN             PYRIST.KERR.ALAS                 ARROTONDA.DIFETTO                  RUNDA.NER
      286      4      1          0          GAMMADIST                          GAMMAVERT                          LOI.GAMMA                          DISTR.GAMMA                        DISTGAMA                           GAMMA.VERD                   GAMMAJAKAUMA                       DISTRIB.GAMMA                      GAMMAFRD
      287      3      1          0          GAMMAINV                           GAMMAINV                           LOI.GAMMA.INVERSE                  DISTR.GAMMA.INV                    INVGAMA                            GAMMA.INV                    GAMMAJAKAUMA.KNT                 INV.GAMMA                          GAMMAINV
      288      2      1          0          CEILING                            OBERGRENZE                         PLAFOND                            MULTIPLO.SUPERIOR                  TETO                               AFRONDEN.BOVEN               PYRIST.KERR.YLS                 ARROTONDA.ECCESSO                  RUNDA.UPP
      289      4      1          0          HYPGEOMDIST                        HYPGEOMVERT                        LOI.HYPERGEOMETRIQUE               DISTR.HIPERGEOM                    DIST.HIPERGEOM                     HYPERGEO.VERD                HYPERGEOM.JAKAUMA                  DISTRIB.IPERGEOM                   HYPGEOMFRD
      290      3      1          0          LOGNORMDIST                        LOGNORMVERT                        LOI.LOGNORMALE                     DISTR.LOG.NORM                     DIST.LOGNORMAL                     LOG.NORM.VERD                LOGNORM.JAKAUMA                    DISTRIB.LOGNORM                    LOGNORMFRD
      291      3      1          0          LOGINV                             LOGINV                             LOI.LOGNORMALE.INVERSE             DISTR.LOG.INV                      INVLOG                             LOG.NORM.INV                 LOGNORM.JAKAUMA.KNT              INV.LOGNORM                        LOGINV
      292      3      1          0          NEGBINOMDIST                       NEGBINOMVERT                       LOI.BINOMIALE.NEG                  NEGBINOMDIST                       DIST.BIN.NEG                       NEG.BINOM.VERD               BINOMIJAKAUMA.NEG                  DISTRIB.BINOM.NEG                  NEGBINOMFRD
      293      4      1          0          NORMDIST                           NORMVERT                           LOI.NORMALE                        DISTR.NORM                         DIST.NORM                          NORM.VERD                    NORM.JAKAUMA                       DISTRIB.NORM                       NORMFRD
      294      1      1          0          NORMSDIST                          STANDNORMVERT                      LOI.NORMALE.STANDARD               DISTR.NORM.ESTAND                  DIST.NORMP                         STAND.NORM.VERD              NORM.JAKAUMA.NORMIT                DISTRIB.NORM.ST                    NORMSFRD
      295      3      1          0          NORMINV                            NORMINV                            LOI.NORMALE.INVERSE                DISTR.NORM.INV                     INV.NORM                           NORM.INV                     NORM.JAKAUMA.KNT                 INV.NORM                           NORMINV
      296      1      1          0          NORMSINV                           STANDNORMINV                       LOI.NORMALE.STANDARD.INVERSE       DISTR.NORM.ESTAND.INV              INV.NORMP                          STAND.NORM.INV               NORM.JAKAUMA.NORMIT.KNT          INV.NORM.ST                        NORMSINV
      297      3      1          0          STANDARDIZE                        STANDARDISIERUNG                   CENTREE.REDUITE                    NORMALIZACION                      PADRONIZAR                         NORMALISEREN                 NORMITA                            NORMALIZZA                         STANDARDISERA
      298      1      1          0          ODD                                UNGERADE                           IMPAIR                             REDONDEA.IMPAR                     MPAR                              ONEVEN                       PARITON                            DISPARI                            UDDA
      299      2      1          0          PERMUT                             VARIATIONEN                        PERMUTATION                        PERMUTACIONES                      PERMUT                             PERMUTATIES                  PERMUTAATIO                        PERMUTAZIONE                       PERMUT
      300      3      1          0          POISSON                            POISSON                            LOI.POISSON                        POISSON                            POISSON                            POISSON                      POISSON                            POISSON                            POISSON
      301      3      1          0          TDIST                              TVERT                              LOI.STUDENT                        DISTR.T                            DISTT                              T.VERD                       TJAKAUMA                           DISTRIB.T                          TFRD
      302      4      1          0          WEIBULL                            WEIBULL                            LOI.WEIBULL                        DIST.WEIBULL                       WEIBULL                            WEIBULL                      WEIBULL                            WEIBULL                            WEIBULL
      303      2      2          0          SUMXMY2                            SUMMEXMY2                          SOMME.XMY2                         SUMAXMENOSY2                       SOMAXMY2                           SOM.XMINY.2                  EROTUSTEN.NELISUMMA               SOMMA.Q.DIFF                       SUMMAXMY2
      304      2      2          0          SUMX2MY2                           SUMMEX2MY2                         SOMME.X2MY2                        SUMAX2MENOSY2                      SOMAX2DY2                          SOM.X2MINY2                  NELISUMMIEN.EROTUS                SOMMA.DIFF.Q                       SUMMAX2MY2
      305      2      2          0          SUMX2PY2                           SUMMEX2PY2                         SOMME.X2PY2                        SUMAX2MASY2                        SOMAX2SY2                          SOM.X2PLUSY2                 NELISUMMIEN.SUMMA                 SOMMA.SOMMA.Q                      SUMMAX2PY2
      306      2      2          0          CHITEST                            CHITEST                            TEST.KHIDEUX                       PRUEBA.CHI                         TESTE.QUI                          CHI.TOETS                    CHITESTI                           TEST.CHI                           CHI2TEST
      307      2      2          0          CORREL                             KORREL                             COEFFICIENT.CORRELATION            COEF.DE.CORREL                     CORREL                             CORRELATIE                   KORRELAATIO                        CORRELAZIONE                       KORREL
      308      2      2          0          COVAR                              KOVAR                              COVARIANCE                         COVAR                              COVAR                              COVARIANTIE                  KOVARIANSSI                        COVARIANZA                         KOVAR
      309      3      2          0          FORECAST                           SCHTZER                           PREVISION                          PRONOSTICO                         PREVISO                           VOORSPELLEN                  ENNUSTE                            PREVISIONE                         PREDIKTION
      310      2      2          0          FTEST                              FTEST                              TEST.F                             PRUEBA.F                           TESTEF                             F.TOETS                      FTESTI                             TEST.F                             FTEST
      311      2      2          0          INTERCEPT                          ACHSENABSCHNITT                    ORDONNEE.ORIGINE                   INTERSECCION                       INTERCEPO                        SNIJPUNT                     LEIKKAUSPISTE                      INTERCETTA                         SKRNINGSPUNKT
      312      2      2          0          PEARSON                            PEARSON                            PEARSON                            PEARSON                            PEARSON                            PEARSON                      PEARSON                            PEARSON                            PEARSON
      313      2      2          0          RSQ                                BESTIMMTHEITSMASS                  COEFFICIENT.DETERMINATION          COEFICIENTE.R2                     RQUAD                              R.KWADRAAT                   PEARSON.NELI                      RQ                                 RKV
      314      2      2          0          STEYX                              STFEHLERYX                         ERREUR.TYPE.XY                     ERROR.TIPICO.XY                    EPADYX                             STAND.FOUT.YX                KESKIVIRHE                         ERR.STD.YX                         STDFELYX
      315      2      2          0          SLOPE                              STEIGUNG                           PENTE                              PENDIENTE                          INCLINAO                         RICHTING                     KULMAKERROIN                       PENDENZA                           LUTNING
      316      4      2          0          TTEST                              TTEST                              TEST.STUDENT                       PRUEBA.T                           TESTET                             T.TOETS                      TTESTI                             TEST.T                             TTEST
      317     -1      2          0          PROB                               WAHRSCHBEREICH                     PROBABILITE                        PROBABILIDAD                       PROB                               KANS                         TODENNKISYYS                     PROBABILIT                        SANNOLIKHET
      318     -1      0          0          DEVSQ                              SUMQUADABW                         SOMME.CARRES.ECARTS                DESVIA2                            DESVQ                              DEV.KWAD                     OIKAISTU.NELISUMMA                DEV.Q                              KVADAVV
      319     -1      0          0          GEOMEAN                            GEOMITTEL                          MOYENNE.GEOMETRIQUE                MEDIA.GEOM                         MDIA.GEOMTRICA                   MEETK.GEM                    KESKIARVO.GEOM                     MEDIA.GEOMETRICA                   GEOMEDEL
      320     -1      0          0          HARMEAN                            HARMITTEL                          MOYENNE.HARMONIQUE                 MEDIA.ARMO                         MDIA.HARMNICA                    HARM.GEM                     KESKIARVO.HARM                     MEDIA.ARMONICA                     HARMMEDEL
      321     -1      0          0          SUMSQ                              QUADRATESUMME                      SOMME.CARRES                       SUMA.CUADRADOS                     SOMAQUAD                           KWADRATENSOM                 NELISUMMA                         SOMMA.Q                            KVADRATSUMMA
      322     -1      0          0          KURT                               KURT                               KURTOSIS                           CURTOSIS                           CURT                               KURTOSIS                     KURT                               CURTOSI                            TOPPIGHET
      323     -1      0          0          SKEW                               SCHIEFE                            COEFFICIENT.ASYMETRIE              COEFICIENTE.ASIMETRIA              DISTORO                          SCHEEFHEID                   JAKAUMAN.VINOUS                    ASIMMETRIA                         SNEDHET
      324     -1      0          0          ZTEST                              GTEST                              TEST.Z                             PRUEBA.Z                           TESTEZ                             Z.TOETS                      ZTESTI                             TEST.Z                             ZTEST
      325      2      0          0          LARGE                              KGRSSTE                           GRANDE.VALEUR                      K.ESIMO.MAYOR                      MAIOR                              GROOTSTE                     SUURI                              GRANDE                             STRSTA
      326      2      0          0          SMALL                              KKLEINSTE                          PETITE.VALEUR                      K.ESIMO.MENOR                      MENOR                              KLEINSTE                     PIENI                              PICCOLO                            MINSTA
      327      2      0          0          QUARTILE                           QUARTILE                           QUARTILE                           CUARTIL                            QUARTIL                            KWARTIEL                     NELJNNES                          QUARTILE                           KVARTIL
      328      2      0          0          PERCENTILE                         QUANTIL                            CENTILE                            PERCENTIL                          PERCENTIL                          PERCENTIEL                   PROSENTTIPISTE                     PERCENTILE                         PERCENTIL
      329     -1      0          0          PERCENTRANK                        QUANTILSRANG                       RANG.POURCENTAGE                   RANGO.PERCENTIL                    ORDEM.PORCENTUAL                   PERCENT.RANG                 PROSENTTIJRJESTYS                 PERCENT.RANGO                      PROCENTRANG
      330     -1      2          0          MODE                               MODALWERT                          MODE                               MODA                               MODO                               MODUS                        MOODI                              MODA                               TYPVRDE
      331      2      0          0          TRIMMEAN                           GESTUTZTMITTEL                     MOYENNE.REDUITE                    MEDIA.ACOTADA                      MDIA.INTERNA                      GETRIMD.GEM                  KESKIARVO.TASATTU                  MEDIA.TRONCATA                     TRIMMEDEL
      332      2      1          0          TINV                               TINV                               LOI.STUDENT.INVERSE                DISTR.T.INV                        INVT                               T.INV                        TJAKAUMA.KNT                     INV.T                              TINV
      336     -1      1          0          CONCATENATE                        VERKETTEN                          CONCATENER                         CONCATENAR                         CONCATENAR                         TEKST.SAMENVOEGEN            KETJUTA                            CONCATENA                          SAMMANFOGA
      337      2      1          0          POWER                              POTENZ                             PUISSANCE                          POTENCIA                           POTNCIA                           MACHT                        POTENSSI                           POTENZA                            UPPHJT.TILL
      342      1      1          0          RADIANS                            RADIANT                            RADIANS                            RADIANES                           RADIANOS                           RADIALEN                     RADIAANIT                          RADIANTI                           RADIANER
      343      1      1          0          DEGREES                            GRAD                               DEGRES                             GRADOS                             GRAUS                              GRADEN                       ASTEET                             GRADI                              GRADER
      344     -1      0          0          SUBTOTAL                           TEILERGEBNIS                       SOUS.TOTAL                         SUBTOTALES                         SUBTOTAL                           SUBTOTAAL                    VLISUMMA                          SUBTOTALE                          DELSUMMA
      345     -1      0          0          SUMIF                              SUMMEWENN                          SOMME.SI                           SUMAR.SI                           SOMASE                             SOM.ALS                      SUMMA.JOS                          SOMMA.SE                           SUMMA.OM
      346      2      0          0          COUNTIF                            ZHLENWENN                         NB.SI                              CONTAR.SI                          CONT.SE                            AANTAL.ALS                   LASKE.JOS                          CONTA.SE                           ANTAL.OM
      347      1      0          0          COUNTBLANK                         ANZAHLLEEREZELLEN                  NB.VIDE                            CONTAR.BLANCO                      CONTAR.VAZIO                       AANTAL.LEGE.CELLEN           LASKE.TYHJT                       CONTA.VUOTE                        ANTAL.TOMMA
      354     -1      1          0          ROMAN                              RMISCH                            ROMAIN                             NUMERO.ROMANO                      ROMANO                             ROMEINS                      ROMAN                              ROMANO                             ROMERSK
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/function_locale.pl>
  
  =head2 Example: writeA1.pl
  
  
  
  This is an example of how to extend the Spreadsheet::WriteExcel module.
  
  Code is appended to the Spreadsheet::WriteExcel::Worksheet module by reusing
  the package name. The new code provides a write() method that allows you to
  use Excels A1 style cell references.  This is not particularly useful but it
  serves as an example of how the module can be extended without modifying the
  code directly.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # This is an example of how to extend the Spreadsheet::WriteExcel module.
      #
      # Code is appended to the Spreadsheet::WriteExcel::Worksheet module by reusing
      # the package name. The new code provides a write() method that allows you to
      # use Excels A1 style cell references.  This is not particularly useful but it
      # serves as an example of how the module can be extended without modifying the
      # code directly.
      #
      # reverse(''), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Spreadsheet::WriteExcel;
      
      # Create a new workbook called simple.xls and add a worksheet
      my $workbook  = Spreadsheet::WriteExcel->new("writeA1.xls");
      my $worksheet = $workbook->add_worksheet();
      
      # Write numbers or text
      $worksheet->write  (0, 0, "Hello");
      $worksheet->writeA1("A3", "A3"   );
      $worksheet->writeA1("A5", 1.2345 );
      
      
      ###############################################################################
      #
      # The following will be appended to the Spreadsheet::WriteExcel::Worksheet
      # package.
      #
      
      package Spreadsheet::WriteExcel::Worksheet;
      
      ###############################################################################
      #
      # writeA1($cell, $token, $format)
      #
      # Convert $cell from Excel A1 notation to $row, $col notation and
      # call write() on $token.
      #
      # Returns: return value of called subroutine or -4 for invalid cell
      # reference.
      #
      sub writeA1 {
          my $self = shift;
          my $cell = shift;
          my $col;
          my $row;
      
          if ($cell =~ /([A-z]+)(\d+)/) {
             ($row, $col) = _convertA1($2, $1);
             $self->write($row, $col, @_);
          } else {
              return -4;
          }
      }
      
      ###############################################################################
      #
      # _convertA1($row, $col)
      #
      # Convert Excel A1 notation to $row, $col notation. Convert base26 column
      # string to a number.
      #
      sub _convertA1 {
          my $row    = $_[0];
          my $col    = $_[1]; # String in AA notation
      
          my @chars  = split //, $col;
          my $expn   = 0;
          $col       = 0;
      
          while (@chars) {
              my $char = uc(pop(@chars)); # LS char first
              $col += (ord($char) -ord('A') +1) * (26**$expn);
              $expn++;
          }
      
          # Convert 1 index to 0 index
          $row--;
          $col--;
      
          return($row, $col);
      }
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.38/examples/writeA1.pl>
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  Contributed examples contain the original author's name.
  
  =head1 COPYRIGHT
  
  Copyright MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =cut
SPREADSHEET_WRITEEXCEL_EXAMPLES

$fatpacked{"Spreadsheet/WriteExcel/Format.pm"} = <<'SPREADSHEET_WRITEEXCEL_FORMAT';
  package Spreadsheet::WriteExcel::Format;
  
  ###############################################################################
  #
  # Format - A class for defining Excel formatting.
  #
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use Exporter;
  use strict;
  use Carp;
  
  
  
  
  
  
  use vars qw($AUTOLOAD $VERSION @ISA);
  @ISA = qw(Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor
  #
  sub new {
  
      my $class  = shift;
  
      my $self   = {
                      _xf_index       => shift || 0,
  
                      _type           => 0,
                      _font_index     => 0,
                      _font           => 'Arial',
                      _size           => 10,
                      _bold           => 0x0190,
                      _italic         => 0,
                      _color          => 0x7FFF,
                      _underline      => 0,
                      _font_strikeout => 0,
                      _font_outline   => 0,
                      _font_shadow    => 0,
                      _font_script    => 0,
                      _font_family    => 0,
                      _font_charset   => 0,
                      _font_encoding  => 0,
  
                      _num_format     => 0,
                      _num_format_enc => 0,
  
                      _hidden         => 0,
                      _locked         => 1,
  
                      _text_h_align   => 0,
                      _text_wrap      => 0,
                      _text_v_align   => 2,
                      _text_justlast  => 0,
                      _rotation       => 0,
  
                      _fg_color       => 0x40,
                      _bg_color       => 0x41,
  
                      _pattern        => 0,
  
                      _bottom         => 0,
                      _top            => 0,
                      _left           => 0,
                      _right          => 0,
  
                      _bottom_color   => 0x40,
                      _top_color      => 0x40,
                      _left_color     => 0x40,
                      _right_color    => 0x40,
  
                      _indent         => 0,
                      _shrink         => 0,
                      _merge_range    => 0,
                      _reading_order  => 0,
  
                      _diag_type      => 0,
                      _diag_color     => 0x40,
                      _diag_border    => 0,
  
                      _font_only      => 0,
  
                      # Temp code to prevent merged formats in non-merged cells.
                      _used_merge     => 0,
  
                   };
  
      bless  $self, $class;
  
      # Set properties passed to Workbook::add_format()
      $self->set_format_properties(@_) if @_;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # copy($format)
  #
  # Copy the attributes of another Spreadsheet::WriteExcel::Format object.
  #
  sub copy {
      my $self  = shift;
      my $other = $_[0];
  
      return unless defined $other;
      return unless (ref($self) eq ref($other));
  
      # Store the properties that we don't want overwritten.
      my $xf                  = $self->{_xf_index};
      my $merge_range         = $self->{_merge_range};
      my $used_merge          = $self->{_used_merge};
  
      %$self                  = %$other; # Copy properties
  
      # Restore saved properties.
      $self->{_xf_index}      = $xf;
      $self->{_merge_range}   = $merge_range;
      $self->{_used_merge}    = $used_merge;
  }
  
  
  ###############################################################################
  #
  # get_xf($style)
  #
  # Generate an Excel BIFF XF record.
  #
  sub get_xf {
  
      use integer;    # Avoid << shift bug in Perl 5.6.0 on HP-UX
  
      my $self = shift;
  
      my $record;     # Record identifier
      my $length;     # Number of bytes to follow
  
      my $ifnt;       # Index to FONT record
      my $ifmt;       # Index to FORMAT record
      my $style;      # Style and other options
      my $align;      # Alignment
      my $indent;     #
      my $icv;        # fg and bg pattern colors
      my $border1;    # Border line options
      my $border2;    # Border line options
      my $border3;    # Border line options
  
  
      # Set the type of the XF record and some of the attributes.
      if ($self->{_type} == 0xFFF5) {
          $style = 0xFFF5;
      }
      else {
          $style   = $self->{_locked};
          $style  |= $self->{_hidden} << 1;
      }
  
  
      # Flags to indicate if attributes have been set.
      my $atr_num     = ($self->{_num_format}     != 0);
  
      my $atr_fnt     = ($self->{_font_index}     != 0);
  
      my $atr_alc     = ($self->{_text_h_align}   != 0  ||
                         $self->{_text_v_align}   != 2  ||
                         $self->{_shrink}         != 0  ||
                         $self->{_merge_range}    != 0  ||
                         $self->{_text_wrap}      != 0  ||
                         $self->{_indent}         != 0) ? 1 : 0;
  
      my $atr_bdr     = ($self->{_bottom}         != 0  ||
                         $self->{_top}            != 0  ||
                         $self->{_left}           != 0  ||
                         $self->{_right}          != 0  ||
                         $self->{_diag_type}      != 0) ? 1: 0;
  
      my $atr_pat     = ($self->{_fg_color}       != 0x40  ||
                         $self->{_bg_color}       != 0x41  ||
                         $self->{_pattern}        != 0x00) ? 1 : 0;
  
      my $atr_prot    = ($self->{_hidden}         != 0  ||
                         $self->{_locked}         != 1) ? 1 : 0;
  
  
      # Set attribute changed flags for the style formats.
      if ($self->{_xf_index} != 0 and $self->{_type} == 0xFFF5) {
  
          if ($self->{_xf_index} >= 16) {
              $atr_num    = 0;
              $atr_fnt    = 1;
          }
          else {
              $atr_num    = 1;
              $atr_fnt    = 0;
          }
  
          $atr_alc    = 1;
          $atr_bdr    = 1;
          $atr_pat    = 1;
          $atr_prot   = 1;
      }
  
  
      # Set a default diagonal border style if none was specified.
      $self->{_diag_border} = 1 if !$self->{_diag_border} and $self->{_diag_type};
  
  
      # Reset the default colours for the non-font properties
      $self->{_fg_color}     = 0x40 if $self->{_fg_color}     == 0x7FFF;
      $self->{_bg_color}     = 0x41 if $self->{_bg_color}     == 0x7FFF;
      $self->{_bottom_color} = 0x40 if $self->{_bottom_color} == 0x7FFF;
      $self->{_top_color}    = 0x40 if $self->{_top_color}    == 0x7FFF;
      $self->{_left_color}   = 0x40 if $self->{_left_color}   == 0x7FFF;
      $self->{_right_color}  = 0x40 if $self->{_right_color}  == 0x7FFF;
      $self->{_diag_color}   = 0x40 if $self->{_diag_color}   == 0x7FFF;
  
  
      # Zero the default border colour if the border has not been set.
      $self->{_bottom_color} = 0 if $self->{_bottom}    == 0;
      $self->{_top_color}    = 0 if $self->{_top}       == 0;
      $self->{_right_color}  = 0 if $self->{_right}     == 0;
      $self->{_left_color}   = 0 if $self->{_left}      == 0;
      $self->{_diag_color}   = 0 if $self->{_diag_type} == 0;
  
  
      # The following 2 logical statements take care of special cases in relation
      # to cell colours and patterns:
      # 1. For a solid fill (_pattern == 1) Excel reverses the role of foreground
      #    and background colours.
      # 2. If the user specifies a foreground or background colour without a
      #    pattern they probably wanted a solid fill, so we fill in the defaults.
      #
      if ($self->{_pattern}  <= 0x01 and
          $self->{_bg_color} != 0x41 and
          $self->{_fg_color} == 0x40    )
      {
          $self->{_fg_color} = $self->{_bg_color};
          $self->{_bg_color} = 0x40;
          $self->{_pattern}  = 1;
      }
  
      if ($self->{_pattern}  <= 0x01 and
          $self->{_bg_color} == 0x41 and
          $self->{_fg_color} != 0x40    )
      {
          $self->{_bg_color} = 0x40;
          $self->{_pattern}  = 1;
      }
  
  
      # Set default alignment if indent is set.
      $self->{_text_h_align} = 1 if $self->{_indent} and
                                    $self->{_text_h_align} == 0;
  
  
      $record         = 0x00E0;
      $length         = 0x0014;
  
      $ifnt           = $self->{_font_index};
      $ifmt           = $self->{_num_format};
  
  
      $align          = $self->{_text_h_align};
      $align         |= $self->{_text_wrap}     << 3;
      $align         |= $self->{_text_v_align}  << 4;
      $align         |= $self->{_text_justlast} << 7;
      $align         |= $self->{_rotation}      << 8;
  
  
  
      $indent         = $self->{_indent};
      $indent        |= $self->{_shrink}        << 4;
      $indent        |= $self->{_merge_range}   << 5;
      $indent        |= $self->{_reading_order} << 6;
      $indent        |= $atr_num                << 10;
      $indent        |= $atr_fnt                << 11;
      $indent        |= $atr_alc                << 12;
      $indent        |= $atr_bdr                << 13;
      $indent        |= $atr_pat                << 14;
      $indent        |= $atr_prot               << 15;
  
  
      $border1        = $self->{_left};
      $border1       |= $self->{_right}         << 4;
      $border1       |= $self->{_top}           << 8;
      $border1       |= $self->{_bottom}        << 12;
  
      $border2        = $self->{_left_color};
      $border2       |= $self->{_right_color}   << 7;
      $border2       |= $self->{_diag_type}     << 14;
  
  
      $border3        = $self->{_top_color};
      $border3       |= $self->{_bottom_color}  << 7;
      $border3       |= $self->{_diag_color}    << 14;
      $border3       |= $self->{_diag_border}   << 21;
      $border3       |= $self->{_pattern}       << 26;
  
      $icv            = $self->{_fg_color};
      $icv           |= $self->{_bg_color}      << 7;
  
  
  
      my $header      = pack("vv",        $record, $length);
      my $data        = pack("vvvvvvvVv", $ifnt, $ifmt, $style,
                                          $align, $indent,
                                          $border1, $border2, $border3,
                                          $icv);
  
      return($header . $data);
  }
  
  
  ###############################################################################
  #
  # Note to porters. The majority of the set_property() methods are created
  # dynamically via Perl' AUTOLOAD sub, see below. You may prefer/have to specify
  # them explicitly in other implementation languages.
  #
  
  
  ###############################################################################
  #
  # get_font()
  #
  # Generate an Excel BIFF FONT record.
  #
  sub get_font {
  
      my $self      = shift;
  
      my $record;     # Record identifier
      my $length;     # Record length
  
      my $dyHeight;   # Height of font (1/20 of a point)
      my $grbit;      # Font attributes
      my $icv;        # Index to color palette
      my $bls;        # Bold style
      my $sss;        # Superscript/subscript
      my $uls;        # Underline
      my $bFamily;    # Font family
      my $bCharSet;   # Character set
      my $reserved;   # Reserved
      my $cch;        # Length of font name
      my $rgch;       # Font name
      my $encoding;   # Font name character encoding
  
  
      $dyHeight   = $self->{_size} * 20;
      $icv        = $self->{_color};
      $bls        = $self->{_bold};
      $sss        = $self->{_font_script};
      $uls        = $self->{_underline};
      $bFamily    = $self->{_font_family};
      $bCharSet   = $self->{_font_charset};
      $rgch       = $self->{_font};
      $encoding   = $self->{_font_encoding};
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($rgch)) {
              $rgch = Encode::encode("UTF-16BE", $rgch);
              $encoding = 1;
          }
      }
  
      $cch = length $rgch;
  
      # Handle Unicode font names.
      if ($encoding == 1) {
          croak "Uneven number of bytes in Unicode font name" if $cch % 2;
          $cch  /= 2 if $encoding;
          $rgch  = pack 'v*', unpack 'n*', $rgch;
      }
  
      $record     = 0x31;
      $length     = 0x10 + length $rgch;
      $reserved   = 0x00;
  
      $grbit      = 0x00;
      $grbit     |= 0x02 if $self->{_italic};
      $grbit     |= 0x08 if $self->{_font_strikeout};
      $grbit     |= 0x10 if $self->{_font_outline};
      $grbit     |= 0x20 if $self->{_font_shadow};
  
  
      my $header  = pack("vv",          $record, $length);
      my $data    = pack("vvvvvCCCCCC", $dyHeight, $grbit, $icv, $bls,
                                        $sss, $uls, $bFamily,
                                        $bCharSet, $reserved, $cch, $encoding);
  
      return($header . $data . $rgch);
  }
  
  ###############################################################################
  #
  # get_font_key()
  #
  # Returns a unique hash key for a font. Used by Workbook->_store_all_fonts()
  #
  sub get_font_key {
  
      my $self    = shift;
  
      # The following elements are arranged to increase the probability of
      # generating a unique key. Elements that hold a large range of numbers
      # e.g. _color are placed between two binary elements such as _italic
      #
      my $key = "$self->{_font}$self->{_size}";
      $key   .= "$self->{_font_script}$self->{_underline}";
      $key   .= "$self->{_font_strikeout}$self->{_bold}$self->{_font_outline}";
      $key   .= "$self->{_font_family}$self->{_font_charset}";
      $key   .= "$self->{_font_shadow}$self->{_color}$self->{_italic}";
      $key   .= "$self->{_font_encoding}";
      $key    =~ s/ /_/g; # Convert the key to a single word
  
      return $key;
  }
  
  
  ###############################################################################
  #
  # get_xf_index()
  #
  # Returns the index used by Worksheet->_XF()
  #
  sub get_xf_index {
      my $self   = shift;
  
      return $self->{_xf_index};
  }
  
  
  ###############################################################################
  #
  # _get_color()
  #
  # Used in conjunction with the set_xxx_color methods to convert a color
  # string into a number. Color range is 0..63 but we will restrict it
  # to 8..63 to comply with Gnumeric. Colors 0..7 are repeated in 8..15.
  #
  sub _get_color {
  
      my %colors = (
                      aqua    => 0x0F,
                      cyan    => 0x0F,
                      black   => 0x08,
                      blue    => 0x0C,
                      brown   => 0x10,
                      magenta => 0x0E,
                      fuchsia => 0x0E,
                      gray    => 0x17,
                      grey    => 0x17,
                      green   => 0x11,
                      lime    => 0x0B,
                      navy    => 0x12,
                      orange  => 0x35,
                      pink    => 0x21,
                      purple  => 0x14,
                      red     => 0x0A,
                      silver  => 0x16,
                      white   => 0x09,
                      yellow  => 0x0D,
                   );
  
      # Return the default color, 0x7FFF, if undef,
      return 0x7FFF unless defined $_[0];
  
      # or the color string converted to an integer,
      return $colors{lc($_[0])} if exists $colors{lc($_[0])};
  
      # or the default color if string is unrecognised,
      return 0x7FFF if ($_[0] =~ m/\D/);
  
      # or an index < 8 mapped into the correct range,
      return $_[0] + 8 if $_[0] < 8;
  
      # or the default color if arg is outside range,
      return 0x7FFF if $_[0] > 63;
  
      # or an integer in the valid range
      return $_[0];
  }
  
  
  ###############################################################################
  #
  # set_type()
  #
  # Set the XF object type as 0 = cell XF or 0xFFF5 = style XF.
  #
  sub set_type {
  
      my $self = shift;
      my $type = $_[0];
  
      if (defined $_[0] and $_[0] eq 0) {
          $self->{_type} = 0x0000;
      }
      else {
          $self->{_type} = 0xFFF5;
      }
  }
  
  
  ###############################################################################
  #
  # set_align()
  #
  # Set cell alignment.
  #
  sub set_align {
  
      my $self     = shift;
      my $location = $_[0];
  
      return if not defined $location;  # No default
      return if $location =~ m/\d/;     # Ignore numbers
  
      $location = lc($location);
  
      $self->set_text_h_align(1) if ($location eq 'left');
      $self->set_text_h_align(2) if ($location eq 'centre');
      $self->set_text_h_align(2) if ($location eq 'center');
      $self->set_text_h_align(3) if ($location eq 'right');
      $self->set_text_h_align(4) if ($location eq 'fill');
      $self->set_text_h_align(5) if ($location eq 'justify');
      $self->set_text_h_align(6) if ($location eq 'center_across');
      $self->set_text_h_align(6) if ($location eq 'centre_across');
      $self->set_text_h_align(6) if ($location eq 'merge');        # S:WE name
      $self->set_text_h_align(7) if ($location eq 'distributed');
      $self->set_text_h_align(7) if ($location eq 'equal_space');  # ParseExcel
  
  
      $self->set_text_v_align(0) if ($location eq 'top');
      $self->set_text_v_align(1) if ($location eq 'vcentre');
      $self->set_text_v_align(1) if ($location eq 'vcenter');
      $self->set_text_v_align(2) if ($location eq 'bottom');
      $self->set_text_v_align(3) if ($location eq 'vjustify');
      $self->set_text_v_align(4) if ($location eq 'vdistributed');
      $self->set_text_v_align(4) if ($location eq 'vequal_space'); # ParseExcel
  }
  
  
  ###############################################################################
  #
  # set_valign()
  #
  # Set vertical cell alignment. This is required by the set_format_properties()
  # method to differentiate between the vertical and horizontal properties.
  #
  sub set_valign {
  
      my $self = shift;
      $self->set_align(@_);
  }
  
  
  ###############################################################################
  #
  # set_center_across()
  #
  # Implements the Excel5 style "merge".
  #
  sub set_center_across {
  
      my $self     = shift;
  
      $self->set_text_h_align(6);
  }
  
  
  ###############################################################################
  #
  # set_merge()
  #
  # This was the way to implement a merge in Excel5. However it should have been
  # called "center_across" and not "merge".
  # This is now deprecated. Use set_center_across() or better merge_range().
  #
  #
  sub set_merge {
  
      my $self     = shift;
  
      $self->set_text_h_align(6);
  }
  
  
  ###############################################################################
  #
  # set_bold()
  #
  # Bold has a range 0x64..0x3E8.
  # 0x190 is normal. 0x2BC is bold. So is an excessive use of AUTOLOAD.
  #
  sub set_bold {
  
      my $self   = shift;
      my $weight = $_[0];
  
      $weight = 0x2BC if not defined $weight; # Bold text
      $weight = 0x2BC if $weight == 1;        # Bold text
      $weight = 0x190 if $weight == 0;        # Normal text
      $weight = 0x190 if $weight <  0x064;    # Lower bound
      $weight = 0x190 if $weight >  0x3E8;    # Upper bound
  
      $self->{_bold} = $weight;
  }
  
  
  ###############################################################################
  #
  # set_border($style)
  #
  # Set cells borders to the same style
  #
  sub set_border {
  
      my $self  = shift;
      my $style = $_[0];
  
      $self->set_bottom($style);
      $self->set_top($style);
      $self->set_left($style);
      $self->set_right($style);
  }
  
  
  ###############################################################################
  #
  # set_border_color($color)
  #
  # Set cells border to the same color
  #
  sub set_border_color {
  
      my $self  = shift;
      my $color = $_[0];
  
      $self->set_bottom_color($color);
      $self->set_top_color($color);
      $self->set_left_color($color);
      $self->set_right_color($color);
  }
  
  
  ###############################################################################
  #
  # set_rotation($angle)
  #
  # Set the rotation angle of the text. An alignment property.
  #
  sub set_rotation {
  
      my $self     = shift;
      my $rotation = $_[0];
  
      # Argument should be a number
      return if $rotation !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  
      # The arg type can be a double but the Excel dialog only allows integers.
      $rotation = int $rotation;
  
      if ($rotation == 270) {
          $rotation = 255;
      }
      elsif ($rotation >= -90 or $rotation <= 90) {
          $rotation = -$rotation +90 if $rotation < 0;
      }
      else {
          carp "Rotation $rotation outside range: -90 <= angle <= 90";
          $rotation = 0;
      }
  
      $self->{_rotation} = $rotation;
  }
  
  
  ###############################################################################
  #
  # set_format_properties()
  #
  # Convert hashes of properties to method calls.
  #
  sub set_format_properties {
  
      my $self = shift;
  
      my %properties = @_; # Merge multiple hashes into one
  
      while (my($key, $value) = each(%properties)) {
  
          # Strip leading "-" from Tk style properties e.g. -color => 'red'.
          $key =~ s/^-//;
  
          # Create a sub to set the property.
          my $sub = \&{"set_$key"};
          $sub->($self, $value);
     }
  }
  
  # Renamed rarely used set_properties() to set_format_properties() to avoid
  # confusion with Workbook method of the same name. The following acts as an
  # alias for any code that uses the old name.
  *set_properties = *set_format_properties;
  
  
  ###############################################################################
  #
  # AUTOLOAD. Deus ex machina.
  #
  # Dynamically create set methods that aren't already defined.
  #
  sub AUTOLOAD {
  
      my $self = shift;
  
      # Ignore calls to DESTROY
      return if $AUTOLOAD =~ /::DESTROY$/;
  
      # Check for a valid method names, i.e. "set_xxx_yyy".
      $AUTOLOAD =~ /.*::set(\w+)/ or die "Unknown method: $AUTOLOAD\n";
  
      # Match the attribute, i.e. "_xxx_yyy".
      my $attribute = $1;
  
      # Check that the attribute exists
      exists $self->{$attribute}  or die "Unknown method: $AUTOLOAD\n";
  
      # The attribute value
      my $value;
  
  
      # There are two types of set methods: set_property() and
      # set_property_color(). When a method is AUTOLOADED we store a new anonymous
      # sub in the appropriate slot in the symbol table. The speeds up subsequent
      # calls to the same method.
      #
      no strict 'refs'; # To allow symbol table hackery
  
      if ($AUTOLOAD =~ /.*::set\w+color$/) {
          # For "set_property_color" methods
          $value =  _get_color($_[0]);
  
          *{$AUTOLOAD} = sub {
                                  my $self  = shift;
  
                                  $self->{$attribute} = _get_color($_[0]);
                             };
      }
      else {
  
          $value = $_[0];
          $value = 1 if not defined $value; # The default value is always 1
  
          *{$AUTOLOAD} = sub {
                                  my $self  = shift;
                                  my $value = shift;
  
                                  $value = 1 if not defined $value;
                                  $self->{$attribute} = $value;
                              };
      }
  
  
      $self->{$attribute} = $value;
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Format - A class for defining Excel formatting.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::WriteExcel
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::WriteExcel.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  � MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL_FORMAT

$fatpacked{"Spreadsheet/WriteExcel/Formula.pm"} = <<'SPREADSHEET_WRITEEXCEL_FORMULA';
  package Spreadsheet::WriteExcel::Formula;
  
  ###############################################################################
  #
  # Formula - A class for generating Excel formulas.
  #
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use Exporter;
  use strict;
  use Carp;
  
  
  
  
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # Class data.
  #
  my $parser;
  my %ptg;
  my %functions;
  
  
  ###############################################################################
  #
  # For debugging.
  #
  my $_debug = 0;
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor
  #
  sub new {
  
      my $class  = $_[0];
  
      my $self   = {
                      _byte_order     => $_[1],
                      _workbook       => "",
                      _ext_sheets     => {},
                      _ext_refs       => {},
                      _ext_ref_count  => 0,
                      _ext_names      => {},
                   };
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # _init_parser()
  #
  # There is a small overhead involved in generating the parser. Therefore, the
  # initialisation is delayed until a formula is required.
  # TODO: use a pre-compiled grammar.
  #
  # Porters take note, a recursive descent parser isn't mandatory. A future
  # version of this module may use a YACC based parser instead.
  #
  sub _init_parser {
  
      my $self = shift;
  
      # Delay loading Parse::RecDescent to reduce the module dependencies.
      eval { require Parse::RecDescent };
      die  "The Parse::RecDescent module must be installed in order ".
           "to write an Excel formula\n" if $@;
  
      $self->_initialize_hashes();
  
      # The parsing grammar.
      #
      # TODO: Add support for international versions of Excel
      #
      $parser = Parse::RecDescent->new(<<'EndGrammar');
  
          expr:           list
  
          # Match arg lists such as SUM(1,2, 3)
          list:           <leftop: addition ',' addition>
                          { [ $item[1], '_arg', scalar @{$item[1]} ] }
  
          addition:       <leftop: multiplication add_op multiplication>
  
          # TODO: The add_op operators don't have equal precedence.
          add_op:         add |  sub | concat
                          | eq | ne | le | ge | lt | gt   # Order is important
  
          add:            '+'  { 'ptgAdd'    }
          sub:            '-'  { 'ptgSub'    }
          concat:         '&'  { 'ptgConcat' }
          eq:             '='  { 'ptgEQ'     }
          ne:             '<>' { 'ptgNE'     }
          le:             '<=' { 'ptgLE'     }
          ge:             '>=' { 'ptgGE'     }
          lt:             '<'  { 'ptgLT'     }
          gt:             '>'  { 'ptgGT'     }
  
  
          multiplication: <leftop: exponention mult_op exponention>
  
          mult_op:        mult  | div
          mult:           '*' { 'ptgMul' }
          div:            '/' { 'ptgDiv' }
  
          # Left associative (apparently)
          exponention:    <leftop: factor exp_op factor>
  
          exp_op:         '^' { 'ptgPower' }
  
          factor:         number       # Order is important
                          | string
                          | range2d
                          | range3d
                          | true
                          | false
                          | ref2d
                          | ref3d
                          | function
                          | name
                          | '(' expr ')'  { [$item[2], 'ptgParen'] }
  
          # Match a string.
          # Regex by merlyn. See http://www.perlmonks.org/index.pl?node_id=330280
          #
          string:           /"([^"]|"")*"/     #" For editors
                          { [ '_str', $item[1]] }
  
          # Match float or integer
          number:           /([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?/
                          { ['_num', $item[1]] }
  
          # Note: The highest column values is IV. The following regexes match
          # up to IZ. Out of range values are caught in the code.
          #
          # Note: sheetnames with whitespace, commas, or parentheses must be in
          # single quotes. Applies to ref3d and range3d
          #
  
          # Match A1, $A1, A$1 or $A$1.
          ref2d:            /\$?[A-I]?[A-Z]\$?\d+/
                          { ['_ref2d', $item[1]] }
  
          # Match an external sheet reference: Sheet1!A1 or 'Sheet (1)'!A1
          ref3d:            /[^!(,]+!\$?[A-I]?[A-Z]\$?\d+/
                          { ['_ref3d', $item[1]] }
                          | /'[^']+'!\$?[A-I]?[A-Z]\$?\d+/
                          { ['_ref3d', $item[1]] }
  
          # Match A1:C5, $A1:$C5 or A:C etc.
          range2d:          /\$?[A-I]?[A-Z]\$?(\d+)?:\$?[A-I]?[A-Z]\$?(\d+)?/
                          { ['_range2d', $item[1]] }
  
          # Match an external sheet range. 'Sheet 1:Sheet 2'!B2:C5
          range3d:          /[^!(,]+!\$?[A-I]?[A-Z]\$?(\d+)?:\$?[A-I]?[A-Z]\$?(\d+)?/
                          { ['_range3d', $item[1]] }
                          | /'[^']+'!\$?[A-I]?[A-Z]\$?(\d+)?:\$?[A-I]?[A-Z]\$?(\d+)?/
                          { ['_range3d', $item[1]] }
  
          # Match a function name.
          function:         /[A-Z0-9-_.]+/ '()'
                          { ['_funcV', $item[1]] }
                          | /[A-Z0-9-_.]+/ '(' expr ')'
                          { ['_class', $item[1], $item[3], '_funcV', $item[1]] }
                          | /[A-Z0-9-_.]+/ '(' list ')'
                          { ['_class', $item[1], $item[3], '_funcV', $item[1]] }
  
          # Match a defined name.
          name:           /[A-Za-z_]\w+/
                          { ['_name', $item[1]] }
  
          # Boolean values.
          true:           'TRUE'  { [ 'ptgBool', 1 ] }
  
          false:          'FALSE' { [ 'ptgBool', 0 ] }
  
  EndGrammar
  
  print "Init_parser.\n\n" if $_debug;
  }
  
  
  
  ###############################################################################
  #
  # parse_formula()
  #
  # Takes a textual description of a formula and returns a RPN encoded byte
  # string.
  #
  sub parse_formula {
  
      my $self= shift;
  
      # Initialise the parser if this is the first call
      $self->_init_parser() if not defined $parser;
  
      my $formula = shift @_;
      my $tokens;
  
      print $formula, "\n" if $_debug;
  
      # Build the parse tree for the formula
      my $parsetree =$parser->expr($formula);
  
      # Check if parsing worked.
      if (defined $parsetree) {
          my @tokens = $self->_reverse_tree(@$parsetree);
  
          # Add a volatile token if the formula contains a volatile function.
          # This must be the first token in the list
          #
          unshift @tokens, '_vol' if $self->_check_volatile(@tokens);
  
          # The return value depends on which Worksheet.pm method is the caller
          if (wantarray) {
              # Parse formula to see if it throws any errors and then
              # return raw tokens to Worksheet::store_formula()
              #
              $self->parse_tokens(@tokens);
              return @tokens;
          }
          else{
              # Return byte stream to Worksheet::write_formula()
              return $self->parse_tokens(@tokens);
          }
      }
      else {
          die "Couldn't parse formula: =$formula\n";
      }
  }
  
  
  ###############################################################################
  #
  # parse_tokens()
  #
  # Convert each token or token pair to its Excel 'ptg' equivalent.
  #
  sub parse_tokens {
  
      my $self        = shift;
      my $parse_str   = '';
      my $last_type   = '';
      my $modifier    = '';
      my $num_args    = 0;
      my $class       = 0;
      my @class       = 1;
      my @tokens      = @_;
  
  
      # A note about the class modifiers used below. In general the class,
      # "reference" or "value", of a function is applied to all of its operands.
      # However, in certain circumstances the operands can have mixed classes,
      # e.g. =VLOOKUP with external references. These will eventually be dealt
      # with by the parser. However, as a workaround the class type of a token
      # can be changed via the repeat_formula interface. Thus, a _ref2d token can
      # be changed by the user to _ref2dA or _ref2dR to change its token class.
      #
      while (@_) {
          my $token = shift @_;
  
          if ($token eq '_arg') {
              $num_args = shift @_;
          }
          elsif ($token eq '_class') {
              $token = shift @_;
              $class = $functions{$token}[2];
              # If $class is undef then it means that the function isn't valid.
              die "Unknown function $token() in formula\n" unless defined $class;
              push @class, $class;
          }
          elsif ($token eq '_vol') {
              $parse_str  .= $self->_convert_volatile();
          }
          elsif ($token eq 'ptgBool') {
              $token = shift @_;
              $parse_str .= $self->_convert_bool($token);
          }
          elsif ($token eq '_num') {
              $token = shift @_;
              $parse_str .= $self->_convert_number($token);
          }
          elsif ($token eq '_str') {
              $token = shift @_;
              $parse_str .= $self->_convert_string($token);
          }
          elsif ($token =~ /^_ref2d/) {
              ($modifier  = $token) =~ s/_ref2d//;
              $class      = $class[-1];
              $class      = 0 if $modifier eq 'R';
              $class      = 1 if $modifier eq 'V';
              $token      = shift @_;
              $parse_str .= $self->_convert_ref2d($token, $class);
          }
          elsif ($token =~ /^_ref3d/) {
              ($modifier  = $token) =~ s/_ref3d//;
              $class      = $class[-1];
              $class      = 0 if $modifier eq 'R';
              $class      = 1 if $modifier eq 'V';
              $token      = shift @_;
              $parse_str .= $self->_convert_ref3d($token, $class);
          }
          elsif ($token =~ /^_range2d/) {
              ($modifier  = $token) =~ s/_range2d//;
              $class      = $class[-1];
              $class      = 0 if $modifier eq 'R';
              $class      = 1 if $modifier eq 'V';
              $token      = shift @_;
              $parse_str .= $self->_convert_range2d($token, $class);
          }
          elsif ($token =~ /^_range3d/) {
              ($modifier  = $token) =~ s/_range3d//;
              $class      = $class[-1];
              $class      = 0 if $modifier eq 'R';
              $class      = 1 if $modifier eq 'V';
              $token      = shift @_;
              $parse_str .= $self->_convert_range3d($token, $class);
          }
          elsif ($token =~ /^_name/) {
              ($modifier  = $token) =~ s/_name//;
              $class      = $class[-1];
              $class      = 0 if $modifier eq 'R';
              $class      = 1 if $modifier eq 'V';
              $token = shift @_;
              $parse_str .= $self->_convert_name($token, $class);
          }
          elsif ($token eq '_funcV') {
              $token = shift @_;
              $parse_str .= $self->_convert_function($token, $num_args);
              pop @class;
              $num_args = 0; # Reset after use
          }
          elsif ($token eq '_func') {
              $token = shift @_;
              $parse_str .= $self->_convert_function($token, $num_args, 1);
              pop @class;
              $num_args = 0; # Reset after use
          }
          elsif (exists $ptg{$token}) {
              $parse_str .= pack("C", $ptg{$token});
          }
          else {
              # Unrecognised token
              return undef;
          }
      }
  
  
      if ($_debug) {
          print join(" ", map { sprintf "%02X", $_ } unpack("C*",$parse_str));
          print "\n\n";
          print join(" ", @tokens), "\n\n";
      }
  
      return $parse_str;
  }
  
  
  ###############################################################################
  #
  #  _reverse_tree()
  #
  # This function descends recursively through the parse tree. At each level it
  # swaps the order of an operator followed by an operand.
  # For example, 1+2*3 would be converted in the following sequence:
  #               1 + 2 * 3
  #               1 + (2 * 3)
  #               1 + (2 3 *)
  #               1 (2 3 *) +
  #               1 2 3 * +
  #
  sub _reverse_tree
  {
      my $self = shift;
  
      my @tokens;
      my @expression = @_;
      my @stack;
  
      while (@expression) {
          my $token = shift @expression;
  
          # If the token is an operator swap it with the following operand
          if (    $token eq 'ptgAdd'      ||
                  $token eq 'ptgSub'      ||
                  $token eq 'ptgConcat'   ||
                  $token eq 'ptgMul'      ||
                  $token eq 'ptgDiv'      ||
                  $token eq 'ptgPower'    ||
                  $token eq 'ptgEQ'       ||
                  $token eq 'ptgNE'       ||
                  $token eq 'ptgLE'       ||
                  $token eq 'ptgGE'       ||
                  $token eq 'ptgLT'       ||
                  $token eq 'ptgGT')
          {
              my $operand = shift @expression;
              push @stack, $operand;
          }
  
          push @stack, $token;
      }
  
      # Recurse through the parse tree
      foreach my $token (@stack) {
          if (ref($token)) {
              push @tokens, $self->_reverse_tree(@$token);
          }
          else {
              push @tokens, $token;
          }
      }
  
      return  @tokens;
  }
  
  
  ###############################################################################
  #
  #  _check_volatile()
  #
  # Check if the formula contains a volatile function, i.e. a function that must
  # be recalculated each time a cell is updated. These formulas require a ptgAttr
  # with the volatile flag set as the first token in the parsed expression.
  #
  # Examples of volatile functions: RAND(), NOW(), TODAY()
  #
  sub _check_volatile {
  
      my $self     = shift;
      my @tokens   = @_;
      my $volatile = 0;
  
      for my $i (0..@tokens-1) {
          # If the next token is a function check if it is volatile.
          if ($tokens[$i] =~ m/^_func/ and $functions{$tokens[$i+1]}[3]) {
              $volatile = 1;
              last;
          }
      }
  
      return $volatile;
  }
  
  
  ###############################################################################
  #
  # _convert_volatile()
  #
  # Convert _vol to a ptgAttr tag formatted to indicate that the formula contains
  # a volatile function. See _check_volatile()
  #
  sub _convert_volatile {
  
      my $self = shift;
  
      # Set bitFattrSemi flag to indicate volatile function, "w" is set to zero.
      return pack("CCv", $ptg{ptgAttr}, 0x1, 0x0);
  }
  
  
  ###############################################################################
  #
  # _convert_bool()
  #
  # Convert a boolean token to ptgBool
  #
  sub _convert_bool {
  
      my $self = shift;
      my $bool = shift;
  
      return pack("CC", $ptg{ptgBool}, $bool);
  }
  
  
  ###############################################################################
  #
  # _convert_number()
  #
  # Convert a number token to ptgInt or ptgNum
  #
  sub _convert_number {
  
      my $self = shift;
      my $num  = shift;
  
      # Integer in the range 0..2**16-1
      if (($num =~ /^\d+$/) && ($num <= 65535)) {
          return pack("Cv", $ptg{ptgInt}, $num);
      }
      else { # A float
          $num = pack("d", $num);
          $num = reverse $num if $self->{_byte_order};
          return pack("C", $ptg{ptgNum}) . $num;
      }
  }
  
  
  ###############################################################################
  #
  # _convert_string()
  #
  # Convert a string to a ptg Str.
  #
  sub _convert_string {
  
      my $self     = shift;
      my $str      = shift;
      my $encoding = 0;
  
      $str =~ s/^"//;   # Remove leading  "
      $str =~ s/"$//;   # Remove trailing "
      $str =~ s/""/"/g; # Substitute Excel's escaped double quote "" for "
  
      my $length = length($str);
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($str)) {
              $str = Encode::encode("UTF-16LE", $str);
              $encoding = 1;
          }
      }
  
      die "String in formula has more than 255 chars\n" if $length > 255;
  
      return pack("CCC", $ptg{ptgStr}, $length, $encoding) . $str;
  }
  
  
  ###############################################################################
  #
  # _convert_ref2d()
  #
  # Convert an Excel reference such as A1, $B2, C$3 or $D$4 to a ptgRefV.
  #
  sub _convert_ref2d {
  
      my $self  = shift;
      my $cell  = shift;
      my $class = shift;
      my $ptgRef;
  
      # Convert the cell reference
      my ($row, $col) = $self->_cell_to_packed_rowcol($cell);
  
      # The ptg value depends on the class of the ptg.
      if    ($class == 0) {
          $ptgRef = pack("C", $ptg{ptgRef});
      }
      elsif ($class == 1) {
          $ptgRef = pack("C", $ptg{ptgRefV});
      }
      elsif ($class == 2) {
          $ptgRef = pack("C", $ptg{ptgRefA});
      }
      else{
          die "Unknown function class in formula\n";
      }
  
      return $ptgRef . $row . $col;
  }
  
  
  ###############################################################################
  #
  # _convert_ref3d
  #
  # Convert an Excel 3d reference such as "Sheet1!A1" or "Sheet1:Sheet2!A1" to a
  # ptgRef3dV.
  #
  sub _convert_ref3d {
  
      my $self  = shift;
      my $token = shift;
      my $class = shift;
      my $ptgRef;
  
      # Split the ref at the ! symbol
      my ($ext_ref, $cell) = split '!', $token;
  
      # Convert the external reference part
      $ext_ref = $self->_pack_ext_ref($ext_ref);
  
      # Convert the cell reference part
      my ($row, $col) = $self->_cell_to_packed_rowcol($cell);
  
      # The ptg value depends on the class of the ptg.
      if    ($class == 0) {
          $ptgRef = pack("C", $ptg{ptgRef3d});
      }
      elsif ($class == 1) {
          $ptgRef = pack("C", $ptg{ptgRef3dV});
      }
      elsif ($class == 2) {
          $ptgRef = pack("C", $ptg{ptgRef3dA});
      }
      else{
          die "Unknown function class in formula\n";
      }
  
      return $ptgRef . $ext_ref. $row . $col;
  }
  
  
  ###############################################################################
  #
  # _convert_range2d()
  #
  # Convert an Excel range such as A1:D4 or A:D to a ptgRefV.
  #
  sub _convert_range2d {
  
      my $self  = shift;
      my $range = shift;
      my $class = shift;
      my $ptgArea;
  
      # Split the range into 2 cell refs
      my ($cell1, $cell2) = split ':', $range;
  
      # A range such as A:D is equivalent to A1:D65536, so add rows as required
      $cell1 .= '1'     if $cell1 !~ /\d/;
      $cell2 .= '65536' if $cell2 !~ /\d/;
  
      # Convert the cell references
      my ($row1, $col1) = $self->_cell_to_packed_rowcol($cell1);
      my ($row2, $col2) = $self->_cell_to_packed_rowcol($cell2);
  
      # The ptg value depends on the class of the ptg.
      if    ($class == 0) {
          $ptgArea = pack("C", $ptg{ptgArea});
      }
      elsif ($class == 1) {
          $ptgArea = pack("C", $ptg{ptgAreaV});
      }
      elsif ($class == 2) {
          $ptgArea = pack("C", $ptg{ptgAreaA});
      }
      else{
          die "Unknown function class in formula\n";
      }
  
      return $ptgArea . $row1 . $row2 . $col1. $col2;
  }
  
  
  ###############################################################################
  #
  # _convert_range3d
  #
  # Convert an Excel 3d range such as "Sheet1!A1:D4" or "Sheet1:Sheet2!A1:D4" to
  # a ptgArea3dV.
  #
  sub _convert_range3d {
  
      my $self      = shift;
      my $token     = shift;
      my $class = shift;
      my $ptgArea;
  
      # Split the ref at the ! symbol
      my ($ext_ref, $range) = split '!', $token;
  
      # Convert the external reference part
      $ext_ref = $self->_pack_ext_ref($ext_ref);
  
      # Split the range into 2 cell refs
      my ($cell1, $cell2) = split ':', $range;
  
      # A range such as A:D is equivalent to A1:D65536, so add rows as required
      $cell1 .= '1'     if $cell1 !~ /\d/;
      $cell2 .= '65536' if $cell2 !~ /\d/;
  
      # Convert the cell references
      my ($row1, $col1) = $self->_cell_to_packed_rowcol($cell1);
      my ($row2, $col2) = $self->_cell_to_packed_rowcol($cell2);
  
      # The ptg value depends on the class of the ptg.
      if    ($class == 0) {
          $ptgArea = pack("C", $ptg{ptgArea3d});
      }
      elsif ($class == 1) {
          $ptgArea = pack("C", $ptg{ptgArea3dV});
      }
      elsif ($class == 2) {
          $ptgArea = pack("C", $ptg{ptgArea3dA});
      }
      else{
          die "Unknown function class in formula\n";
      }
  
      return $ptgArea . $ext_ref . $row1 . $row2 . $col1. $col2;
  }
  
  
  ###############################################################################
  #
  # _pack_ext_ref()
  #
  # Convert the sheet name part of an external reference, for example "Sheet1" or
  # "Sheet1:Sheet2", to a packed structure.
  #
  sub _pack_ext_ref {
  
      my $self    = shift;
      my $ext_ref = shift;
      my $sheet1;
      my $sheet2;
  
      $ext_ref =~ s/^'//;   # Remove leading  ' if any.
      $ext_ref =~ s/'$//;   # Remove trailing ' if any.
  
      # Check if there is a sheet range eg., Sheet1:Sheet2.
      if ($ext_ref =~ /:/) {
          ($sheet1, $sheet2) = split ':', $ext_ref;
  
          $sheet1 = $self->_get_sheet_index($sheet1);
          $sheet2 = $self->_get_sheet_index($sheet2);
  
          # Reverse max and min sheet numbers if necessary
          if ($sheet1 > $sheet2) {
              ($sheet1, $sheet2) = ($sheet2, $sheet1);
          }
      }
      else {
          # Single sheet name only.
          ($sheet1, $sheet2) = ($ext_ref, $ext_ref);
  
          $sheet1 = $self->_get_sheet_index($sheet1);
          $sheet2 = $sheet1;
      }
  
      my $key = "$sheet1:$sheet2";
      my $index;
  
      if (exists $self->{_ext_refs}->{$key}) {
          $index = $self->{_ext_refs}->{$key};
      }
      else {
          $index = $self->{_ext_ref_count};
          $self->{_ext_refs}->{$key} = $index;
          $self->{_ext_ref_count}++;
      }
  
      return pack("v",$index);
  }
  
  
  ###############################################################################
  #
  # _get_sheet_index()
  #
  # Look up the index that corresponds to an external sheet name. The hash of
  # sheet names is updated by the add_worksheet() method of the Workbook class.
  #
  sub _get_sheet_index {
  
      my $self        = shift;
      my $sheet_name  = shift;
  
      # Handle utf8 sheetnames in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($sheet_name)) {
              $sheet_name = Encode::encode("UTF-16BE", $sheet_name);
          }
      }
  
  
      if (not exists $self->{_ext_sheets}->{$sheet_name}) {
          die "Unknown sheet name $sheet_name in formula\n";
      }
      else {
          return $self->{_ext_sheets}->{$sheet_name};
      }
  }
  
  
  ###############################################################################
  #
  # set_ext_sheets()
  #
  # This semi-public method is used to update the hash of sheet names. It is
  # updated by the add_worksheet() method of the Workbook class.
  #
  sub set_ext_sheets {
  
      my $self        = shift;
      my $worksheet   = shift;
      my $index       = shift;
  
      # The _ext_sheets hash is used to translate between worksheet names
      # and their index
      $self->{_ext_sheets}->{$worksheet} = $index;
  
  }
  
  
  ###############################################################################
  #
  # get_ext_sheets()
  #
  # This semi-public method is used to get the worksheet references that were
  # used in formulas for inclusion in the EXTERNSHEET Workbook record.
  #
  sub get_ext_sheets {
  
      my $self  = shift;
  
      return %{$self->{_ext_refs}};
  }
  
  
  ###############################################################################
  #
  # get_ext_ref_count()
  #
  # This semi-public method is used to update the hash of sheet names. It is
  # updated by the add_worksheet() method of the Workbook class.
  #
  sub get_ext_ref_count {
  
      my $self  = shift;
  
      return $self->{_ext_ref_count};
  }
  
  
  ###############################################################################
  #
  # _get_name_index()
  #
  # Look up the index that corresponds to an external defined name. The hash of
  # defined names is updated by the define_name() method in the Workbook class.
  #
  sub _get_name_index {
  
      my $self        = shift;
      my $name        = shift;
  
      if (not exists $self->{_ext_names}->{$name}) {
          die "Unknown defined name $name in formula\n";
      }
      else {
          return $self->{_ext_names}->{$name};
      }
  }
  
  
  ###############################################################################
  #
  # set_ext_name()
  #
  # This semi-public method is used to update the hash of defined names.
  #
  sub set_ext_name {
  
      my $self        = shift;
      my $name        = shift;
      my $index       = shift;
  
      $self->{_ext_names}->{$name} = $index;
  }
  
  
  ###############################################################################
  #
  # _convert_function()
  #
  # Convert a function to a ptgFuncV or ptgFuncVarV depending on the number of
  # args that it takes.
  #
  sub _convert_function {
  
      my $self     = shift;
      my $token    = shift;
      my $num_args = shift;
      my $non_var  = shift;
  
      die "Unknown function $token() in formula\n"
          unless defined $functions{$token}[0];
  
      my $args = $functions{$token}[1];
  
      # Fixed number of args eg. TIME($i,$j,$k).
      if ($args >= 0) {
          # Check that the number of args is valid.
          if ($args != $num_args) {
              die "Incorrect number of arguments for $token() in formula\n";
          }
          else {
              if ($non_var) {
                  return pack("Cv", $ptg{ptgFunc},  $functions{$token}[0]);
              }
              else {
                  return pack("Cv", $ptg{ptgFuncV}, $functions{$token}[0]);
              }
          }
      }
  
      # Variable number of args eg. SUM($i,$j,$k, ..).
      if ($args == -1) {
          if ($non_var) {
              return pack "CCv", $ptg{ptgFuncVar},
                                  $num_args, $functions{$token}[0];
          }
          else {
              return pack "CCv", $ptg{ptgFuncVarV},
                                  $num_args, $functions{$token}[0];
          }
      }
  }
  
  
  ###############################################################################
  #
  # _convert_name()
  #
  # Convert a symbolic name into a name reference.
  #
  sub _convert_name {
  
      my $self     = shift;
      my $name     = shift;
      my $class    = shift;
  
      my $ptgName;
  
      my $name_index = $self->_get_name_index($name);
  
      # The ptg value depends on the class of the ptg.
      if    ($class == 0) {
          $ptgName = $ptg{ptgName};
      }
      elsif ($class == 1) {
          $ptgName = $ptg{ptgNameV};
      }
      elsif ($class == 2) {
          $ptgName = $ptg{ptgNameA};
      }
  
  
      return pack 'CV', $ptgName, $name_index;
  }
  
  
  ###############################################################################
  #
  # _cell_to_rowcol($cell_ref)
  #
  # Convert an Excel cell reference such as A1 or $B2 or C$3 or $D$4 to a zero
  # indexed row and column number. Also returns two boolean values to indicate
  # whether the row or column are relative references.
  # TODO use function in Utility.pm
  #
  sub _cell_to_rowcol {
  
      my $self = shift;
      my $cell = shift;
  
      $cell =~ /(\$?)([A-I]?[A-Z])(\$?)(\d+)/;
  
      my $col_rel = $1 eq "" ? 1 : 0;
      my $col     = $2;
      my $row_rel = $3 eq "" ? 1 : 0;
      my $row     = $4;
  
      # Convert base26 column string to a number.
      # All your Base are belong to us.
      my @chars  = split //, $col;
      my $expn   = 0;
      $col       = 0;
  
      while (@chars) {
          my $char = pop(@chars); # LS char first
          $col += (ord($char) - ord('A') + 1) * (26**$expn);
          $expn++;
      }
  
      # Convert 1-index to zero-index
      $row--;
      $col--;
  
      return $row, $col, $row_rel, $col_rel;
  }
  
  
  ###############################################################################
  #
  # _cell_to_packed_rowcol($row, $col, $row_rel, $col_rel)
  #
  # pack() row and column into the required 3 byte format.
  #
  sub _cell_to_packed_rowcol {
  
      use integer;    # Avoid << shift bug in Perl 5.6.0 on HP-UX
  
      my $self = shift;
      my $cell = shift;
  
      my ($row, $col, $row_rel, $col_rel) = $self->_cell_to_rowcol($cell);
  
      die "Column $cell greater than IV in formula\n" if $col >= 256;
      die "Row $cell greater than 65536 in formula\n" if $row >= 65536;
  
      # Set the high bits to indicate if row or col are relative.
      $col    |= $col_rel << 14;
      $col    |= $row_rel << 15;
  
      $row     = pack('v', $row);
      $col     = pack('v', $col);
  
      return ($row, $col);
  }
  
  
  ###############################################################################
  #
  # _initialize_hashes()
  #
  sub _initialize_hashes {
  
      # The Excel ptg indices
      %ptg = (
          'ptgExp'            => 0x01,
          'ptgTbl'            => 0x02,
          'ptgAdd'            => 0x03,
          'ptgSub'            => 0x04,
          'ptgMul'            => 0x05,
          'ptgDiv'            => 0x06,
          'ptgPower'          => 0x07,
          'ptgConcat'         => 0x08,
          'ptgLT'             => 0x09,
          'ptgLE'             => 0x0A,
          'ptgEQ'             => 0x0B,
          'ptgGE'             => 0x0C,
          'ptgGT'             => 0x0D,
          'ptgNE'             => 0x0E,
          'ptgIsect'          => 0x0F,
          'ptgUnion'          => 0x10,
          'ptgRange'          => 0x11,
          'ptgUplus'          => 0x12,
          'ptgUminus'         => 0x13,
          'ptgPercent'        => 0x14,
          'ptgParen'          => 0x15,
          'ptgMissArg'        => 0x16,
          'ptgStr'            => 0x17,
          'ptgAttr'           => 0x19,
          'ptgSheet'          => 0x1A,
          'ptgEndSheet'       => 0x1B,
          'ptgErr'            => 0x1C,
          'ptgBool'           => 0x1D,
          'ptgInt'            => 0x1E,
          'ptgNum'            => 0x1F,
          'ptgArray'          => 0x20,
          'ptgFunc'           => 0x21,
          'ptgFuncVar'        => 0x22,
          'ptgName'           => 0x23,
          'ptgRef'            => 0x24,
          'ptgArea'           => 0x25,
          'ptgMemArea'        => 0x26,
          'ptgMemErr'         => 0x27,
          'ptgMemNoMem'       => 0x28,
          'ptgMemFunc'        => 0x29,
          'ptgRefErr'         => 0x2A,
          'ptgAreaErr'        => 0x2B,
          'ptgRefN'           => 0x2C,
          'ptgAreaN'          => 0x2D,
          'ptgMemAreaN'       => 0x2E,
          'ptgMemNoMemN'      => 0x2F,
          'ptgNameX'          => 0x39,
          'ptgRef3d'          => 0x3A,
          'ptgArea3d'         => 0x3B,
          'ptgRefErr3d'       => 0x3C,
          'ptgAreaErr3d'      => 0x3D,
          'ptgArrayV'         => 0x40,
          'ptgFuncV'          => 0x41,
          'ptgFuncVarV'       => 0x42,
          'ptgNameV'          => 0x43,
          'ptgRefV'           => 0x44,
          'ptgAreaV'          => 0x45,
          'ptgMemAreaV'       => 0x46,
          'ptgMemErrV'        => 0x47,
          'ptgMemNoMemV'      => 0x48,
          'ptgMemFuncV'       => 0x49,
          'ptgRefErrV'        => 0x4A,
          'ptgAreaErrV'       => 0x4B,
          'ptgRefNV'          => 0x4C,
          'ptgAreaNV'         => 0x4D,
          'ptgMemAreaNV'      => 0x4E,
          'ptgMemNoMemN'      => 0x4F,
          'ptgFuncCEV'        => 0x58,
          'ptgNameXV'         => 0x59,
          'ptgRef3dV'         => 0x5A,
          'ptgArea3dV'        => 0x5B,
          'ptgRefErr3dV'      => 0x5C,
          'ptgAreaErr3d'      => 0x5D,
          'ptgArrayA'         => 0x60,
          'ptgFuncA'          => 0x61,
          'ptgFuncVarA'       => 0x62,
          'ptgNameA'          => 0x63,
          'ptgRefA'           => 0x64,
          'ptgAreaA'          => 0x65,
          'ptgMemAreaA'       => 0x66,
          'ptgMemErrA'        => 0x67,
          'ptgMemNoMemA'      => 0x68,
          'ptgMemFuncA'       => 0x69,
          'ptgRefErrA'        => 0x6A,
          'ptgAreaErrA'       => 0x6B,
          'ptgRefNA'          => 0x6C,
          'ptgAreaNA'         => 0x6D,
          'ptgMemAreaNA'      => 0x6E,
          'ptgMemNoMemN'      => 0x6F,
          'ptgFuncCEA'        => 0x78,
          'ptgNameXA'         => 0x79,
          'ptgRef3dA'         => 0x7A,
          'ptgArea3dA'        => 0x7B,
          'ptgRefErr3dA'      => 0x7C,
          'ptgAreaErr3d'      => 0x7D,
      );
  
      # Thanks to Michael Meeks and Gnumeric for the initial arg values.
      #
      # The following hash was generated by "function_locale.pl" in the distro.
      # Refer to function_locale.pl for non-English function names.
      #
      # The array elements are as follow:
      # ptg:   The Excel function ptg code.
      # args:  The number of arguments that the function takes:
      #           >=0 is a fixed number of arguments.
      #           -1  is a variable  number of arguments.
      # class: The reference, value or array class of the function args.
      # vol:   The function is volatile.
      #
      %functions  = (
          #                                     ptg  args  class  vol
          'COUNT'                         => [   0,   -1,    0,    0 ],
          'IF'                            => [   1,   -1,    1,    0 ],
          'ISNA'                          => [   2,    1,    1,    0 ],
          'ISERROR'                       => [   3,    1,    1,    0 ],
          'SUM'                           => [   4,   -1,    0,    0 ],
          'AVERAGE'                       => [   5,   -1,    0,    0 ],
          'MIN'                           => [   6,   -1,    0,    0 ],
          'MAX'                           => [   7,   -1,    0,    0 ],
          'ROW'                           => [   8,   -1,    0,    0 ],
          'COLUMN'                        => [   9,   -1,    0,    0 ],
          'NA'                            => [  10,    0,    0,    0 ],
          'NPV'                           => [  11,   -1,    1,    0 ],
          'STDEV'                         => [  12,   -1,    0,    0 ],
          'DOLLAR'                        => [  13,   -1,    1,    0 ],
          'FIXED'                         => [  14,   -1,    1,    0 ],
          'SIN'                           => [  15,    1,    1,    0 ],
          'COS'                           => [  16,    1,    1,    0 ],
          'TAN'                           => [  17,    1,    1,    0 ],
          'ATAN'                          => [  18,    1,    1,    0 ],
          'PI'                            => [  19,    0,    1,    0 ],
          'SQRT'                          => [  20,    1,    1,    0 ],
          'EXP'                           => [  21,    1,    1,    0 ],
          'LN'                            => [  22,    1,    1,    0 ],
          'LOG10'                         => [  23,    1,    1,    0 ],
          'ABS'                           => [  24,    1,    1,    0 ],
          'INT'                           => [  25,    1,    1,    0 ],
          'SIGN'                          => [  26,    1,    1,    0 ],
          'ROUND'                         => [  27,    2,    1,    0 ],
          'LOOKUP'                        => [  28,   -1,    0,    0 ],
          'INDEX'                         => [  29,   -1,    0,    1 ],
          'REPT'                          => [  30,    2,    1,    0 ],
          'MID'                           => [  31,    3,    1,    0 ],
          'LEN'                           => [  32,    1,    1,    0 ],
          'VALUE'                         => [  33,    1,    1,    0 ],
          'TRUE'                          => [  34,    0,    1,    0 ],
          'FALSE'                         => [  35,    0,    1,    0 ],
          'AND'                           => [  36,   -1,    1,    0 ],
          'OR'                            => [  37,   -1,    1,    0 ],
          'NOT'                           => [  38,    1,    1,    0 ],
          'MOD'                           => [  39,    2,    1,    0 ],
          'DCOUNT'                        => [  40,    3,    0,    0 ],
          'DSUM'                          => [  41,    3,    0,    0 ],
          'DAVERAGE'                      => [  42,    3,    0,    0 ],
          'DMIN'                          => [  43,    3,    0,    0 ],
          'DMAX'                          => [  44,    3,    0,    0 ],
          'DSTDEV'                        => [  45,    3,    0,    0 ],
          'VAR'                           => [  46,   -1,    0,    0 ],
          'DVAR'                          => [  47,    3,    0,    0 ],
          'TEXT'                          => [  48,    2,    1,    0 ],
          'LINEST'                        => [  49,   -1,    0,    0 ],
          'TREND'                         => [  50,   -1,    0,    0 ],
          'LOGEST'                        => [  51,   -1,    0,    0 ],
          'GROWTH'                        => [  52,   -1,    0,    0 ],
          'PV'                            => [  56,   -1,    1,    0 ],
          'FV'                            => [  57,   -1,    1,    0 ],
          'NPER'                          => [  58,   -1,    1,    0 ],
          'PMT'                           => [  59,   -1,    1,    0 ],
          'RATE'                          => [  60,   -1,    1,    0 ],
          'MIRR'                          => [  61,    3,    0,    0 ],
          'IRR'                           => [  62,   -1,    0,    0 ],
          'RAND'                          => [  63,    0,    1,    1 ],
          'MATCH'                         => [  64,   -1,    0,    0 ],
          'DATE'                          => [  65,    3,    1,    0 ],
          'TIME'                          => [  66,    3,    1,    0 ],
          'DAY'                           => [  67,    1,    1,    0 ],
          'MONTH'                         => [  68,    1,    1,    0 ],
          'YEAR'                          => [  69,    1,    1,    0 ],
          'WEEKDAY'                       => [  70,   -1,    1,    0 ],
          'HOUR'                          => [  71,    1,    1,    0 ],
          'MINUTE'                        => [  72,    1,    1,    0 ],
          'SECOND'                        => [  73,    1,    1,    0 ],
          'NOW'                           => [  74,    0,    1,    1 ],
          'AREAS'                         => [  75,    1,    0,    1 ],
          'ROWS'                          => [  76,    1,    0,    1 ],
          'COLUMNS'                       => [  77,    1,    0,    1 ],
          'OFFSET'                        => [  78,   -1,    0,    1 ],
          'SEARCH'                        => [  82,   -1,    1,    0 ],
          'TRANSPOSE'                     => [  83,    1,    1,    0 ],
          'TYPE'                          => [  86,    1,    1,    0 ],
          'ATAN2'                         => [  97,    2,    1,    0 ],
          'ASIN'                          => [  98,    1,    1,    0 ],
          'ACOS'                          => [  99,    1,    1,    0 ],
          'CHOOSE'                        => [ 100,   -1,    1,    0 ],
          'HLOOKUP'                       => [ 101,   -1,    0,    0 ],
          'VLOOKUP'                       => [ 102,   -1,    0,    0 ],
          'ISREF'                         => [ 105,    1,    0,    0 ],
          'LOG'                           => [ 109,   -1,    1,    0 ],
          'CHAR'                          => [ 111,    1,    1,    0 ],
          'LOWER'                         => [ 112,    1,    1,    0 ],
          'UPPER'                         => [ 113,    1,    1,    0 ],
          'PROPER'                        => [ 114,    1,    1,    0 ],
          'LEFT'                          => [ 115,   -1,    1,    0 ],
          'RIGHT'                         => [ 116,   -1,    1,    0 ],
          'EXACT'                         => [ 117,    2,    1,    0 ],
          'TRIM'                          => [ 118,    1,    1,    0 ],
          'REPLACE'                       => [ 119,    4,    1,    0 ],
          'SUBSTITUTE'                    => [ 120,   -1,    1,    0 ],
          'CODE'                          => [ 121,    1,    1,    0 ],
          'FIND'                          => [ 124,   -1,    1,    0 ],
          'CELL'                          => [ 125,   -1,    0,    1 ],
          'ISERR'                         => [ 126,    1,    1,    0 ],
          'ISTEXT'                        => [ 127,    1,    1,    0 ],
          'ISNUMBER'                      => [ 128,    1,    1,    0 ],
          'ISBLANK'                       => [ 129,    1,    1,    0 ],
          'T'                             => [ 130,    1,    0,    0 ],
          'N'                             => [ 131,    1,    0,    0 ],
          'DATEVALUE'                     => [ 140,    1,    1,    0 ],
          'TIMEVALUE'                     => [ 141,    1,    1,    0 ],
          'SLN'                           => [ 142,    3,    1,    0 ],
          'SYD'                           => [ 143,    4,    1,    0 ],
          'DDB'                           => [ 144,   -1,    1,    0 ],
          'INDIRECT'                      => [ 148,   -1,    1,    1 ],
          'CALL'                          => [ 150,   -1,    1,    0 ],
          'CLEAN'                         => [ 162,    1,    1,    0 ],
          'MDETERM'                       => [ 163,    1,    2,    0 ],
          'MINVERSE'                      => [ 164,    1,    2,    0 ],
          'MMULT'                         => [ 165,    2,    2,    0 ],
          'IPMT'                          => [ 167,   -1,    1,    0 ],
          'PPMT'                          => [ 168,   -1,    1,    0 ],
          'COUNTA'                        => [ 169,   -1,    0,    0 ],
          'PRODUCT'                       => [ 183,   -1,    0,    0 ],
          'FACT'                          => [ 184,    1,    1,    0 ],
          'DPRODUCT'                      => [ 189,    3,    0,    0 ],
          'ISNONTEXT'                     => [ 190,    1,    1,    0 ],
          'STDEVP'                        => [ 193,   -1,    0,    0 ],
          'VARP'                          => [ 194,   -1,    0,    0 ],
          'DSTDEVP'                       => [ 195,    3,    0,    0 ],
          'DVARP'                         => [ 196,    3,    0,    0 ],
          'TRUNC'                         => [ 197,   -1,    1,    0 ],
          'ISLOGICAL'                     => [ 198,    1,    1,    0 ],
          'DCOUNTA'                       => [ 199,    3,    0,    0 ],
          'ROUNDUP'                       => [ 212,    2,    1,    0 ],
          'ROUNDDOWN'                     => [ 213,    2,    1,    0 ],
          'RANK'                          => [ 216,   -1,    0,    0 ],
          'ADDRESS'                       => [ 219,   -1,    1,    0 ],
          'DAYS360'                       => [ 220,   -1,    1,    0 ],
          'TODAY'                         => [ 221,    0,    1,    1 ],
          'VDB'                           => [ 222,   -1,    1,    0 ],
          'MEDIAN'                        => [ 227,   -1,    0,    0 ],
          'SUMPRODUCT'                    => [ 228,   -1,    2,    0 ],
          'SINH'                          => [ 229,    1,    1,    0 ],
          'COSH'                          => [ 230,    1,    1,    0 ],
          'TANH'                          => [ 231,    1,    1,    0 ],
          'ASINH'                         => [ 232,    1,    1,    0 ],
          'ACOSH'                         => [ 233,    1,    1,    0 ],
          'ATANH'                         => [ 234,    1,    1,    0 ],
          'DGET'                          => [ 235,    3,    0,    0 ],
          'INFO'                          => [ 244,    1,    1,    1 ],
          'DB'                            => [ 247,   -1,    1,    0 ],
          'FREQUENCY'                     => [ 252,    2,    0,    0 ],
          'ERROR.TYPE'                    => [ 261,    1,    1,    0 ],
          'REGISTER.ID'                   => [ 267,   -1,    1,    0 ],
          'AVEDEV'                        => [ 269,   -1,    0,    0 ],
          'BETADIST'                      => [ 270,   -1,    1,    0 ],
          'GAMMALN'                       => [ 271,    1,    1,    0 ],
          'BETAINV'                       => [ 272,   -1,    1,    0 ],
          'BINOMDIST'                     => [ 273,    4,    1,    0 ],
          'CHIDIST'                       => [ 274,    2,    1,    0 ],
          'CHIINV'                        => [ 275,    2,    1,    0 ],
          'COMBIN'                        => [ 276,    2,    1,    0 ],
          'CONFIDENCE'                    => [ 277,    3,    1,    0 ],
          'CRITBINOM'                     => [ 278,    3,    1,    0 ],
          'EVEN'                          => [ 279,    1,    1,    0 ],
          'EXPONDIST'                     => [ 280,    3,    1,    0 ],
          'FDIST'                         => [ 281,    3,    1,    0 ],
          'FINV'                          => [ 282,    3,    1,    0 ],
          'FISHER'                        => [ 283,    1,    1,    0 ],
          'FISHERINV'                     => [ 284,    1,    1,    0 ],
          'FLOOR'                         => [ 285,    2,    1,    0 ],
          'GAMMADIST'                     => [ 286,    4,    1,    0 ],
          'GAMMAINV'                      => [ 287,    3,    1,    0 ],
          'CEILING'                       => [ 288,    2,    1,    0 ],
          'HYPGEOMDIST'                   => [ 289,    4,    1,    0 ],
          'LOGNORMDIST'                   => [ 290,    3,    1,    0 ],
          'LOGINV'                        => [ 291,    3,    1,    0 ],
          'NEGBINOMDIST'                  => [ 292,    3,    1,    0 ],
          'NORMDIST'                      => [ 293,    4,    1,    0 ],
          'NORMSDIST'                     => [ 294,    1,    1,    0 ],
          'NORMINV'                       => [ 295,    3,    1,    0 ],
          'NORMSINV'                      => [ 296,    1,    1,    0 ],
          'STANDARDIZE'                   => [ 297,    3,    1,    0 ],
          'ODD'                           => [ 298,    1,    1,    0 ],
          'PERMUT'                        => [ 299,    2,    1,    0 ],
          'POISSON'                       => [ 300,    3,    1,    0 ],
          'TDIST'                         => [ 301,    3,    1,    0 ],
          'WEIBULL'                       => [ 302,    4,    1,    0 ],
          'SUMXMY2'                       => [ 303,    2,    2,    0 ],
          'SUMX2MY2'                      => [ 304,    2,    2,    0 ],
          'SUMX2PY2'                      => [ 305,    2,    2,    0 ],
          'CHITEST'                       => [ 306,    2,    2,    0 ],
          'CORREL'                        => [ 307,    2,    2,    0 ],
          'COVAR'                         => [ 308,    2,    2,    0 ],
          'FORECAST'                      => [ 309,    3,    2,    0 ],
          'FTEST'                         => [ 310,    2,    2,    0 ],
          'INTERCEPT'                     => [ 311,    2,    2,    0 ],
          'PEARSON'                       => [ 312,    2,    2,    0 ],
          'RSQ'                           => [ 313,    2,    2,    0 ],
          'STEYX'                         => [ 314,    2,    2,    0 ],
          'SLOPE'                         => [ 315,    2,    2,    0 ],
          'TTEST'                         => [ 316,    4,    2,    0 ],
          'PROB'                          => [ 317,   -1,    2,    0 ],
          'DEVSQ'                         => [ 318,   -1,    0,    0 ],
          'GEOMEAN'                       => [ 319,   -1,    0,    0 ],
          'HARMEAN'                       => [ 320,   -1,    0,    0 ],
          'SUMSQ'                         => [ 321,   -1,    0,    0 ],
          'KURT'                          => [ 322,   -1,    0,    0 ],
          'SKEW'                          => [ 323,   -1,    0,    0 ],
          'ZTEST'                         => [ 324,   -1,    0,    0 ],
          'LARGE'                         => [ 325,    2,    0,    0 ],
          'SMALL'                         => [ 326,    2,    0,    0 ],
          'QUARTILE'                      => [ 327,    2,    0,    0 ],
          'PERCENTILE'                    => [ 328,    2,    0,    0 ],
          'PERCENTRANK'                   => [ 329,   -1,    0,    0 ],
          'MODE'                          => [ 330,   -1,    2,    0 ],
          'TRIMMEAN'                      => [ 331,    2,    0,    0 ],
          'TINV'                          => [ 332,    2,    1,    0 ],
          'CONCATENATE'                   => [ 336,   -1,    1,    0 ],
          'POWER'                         => [ 337,    2,    1,    0 ],
          'RADIANS'                       => [ 342,    1,    1,    0 ],
          'DEGREES'                       => [ 343,    1,    1,    0 ],
          'SUBTOTAL'                      => [ 344,   -1,    0,    0 ],
          'SUMIF'                         => [ 345,   -1,    0,    0 ],
          'COUNTIF'                       => [ 346,    2,    0,    0 ],
          'COUNTBLANK'                    => [ 347,    1,    0,    0 ],
          'ROMAN'                         => [ 354,   -1,    1,    0 ],
      );
  
  }
  
  
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Formula - A class for generating Excel formulas
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::WriteExcel
  
  =head1 DESCRIPTION
  
  This module is used by Spreadsheet::WriteExcel. You do not need to use it directly.
  
  
  =head1 NOTES
  
  The following notes are to help developers and maintainers understand the sequence of operation. They are also intended as a pro-memoria for the author. ;-)
  
  Spreadsheet::WriteExcel::Formula converts a textual representation of a formula into the pre-parsed binary format that Excel uses to store formulas. For example C<1+2*3> is stored as follows: C<1E 01 00 1E 02 00 1E 03 00 05 03>.
  
  This string is comprised of operators and operands arranged in a reverse-Polish format. The meaning of the tokens in the above example is shown in the following table:
  
      Token   Name        Value
      1E      ptgInt      0001   (stored as 01 00)
      1E      ptgInt      0002   (stored as 02 00)
      1E      ptgInt      0003   (stored as 03 00)
      05      ptgMul
      03      ptgAdd
  
  The tokens and token names are defined in the "Excel Developer's Kit" from Microsoft Press. C<ptg> stands for Parse ThinG (as in "That lexer can't grok it, it's a parse thang.")
  
  In general the tokens fall into two categories: operators such as C<ptgMul> and operands such as C<ptgInt>. When the formula is evaluated by Excel the operand tokens push values onto a stack. The operator tokens then pop the required number of operands off of the stack, perform an operation and push the resulting value back onto the stack. This methodology is similar to the basic operation of a reverse-Polish (RPN) calculator.
  
  Spreadsheet::WriteExcel::Formula parses a formula using a C<Parse::RecDescent> parser (at a later stage it may use a C<Parse::Yapp> parser or C<Parse::FastDescent>).
  
  The parser converts the textual representation of a formula into a parse tree. Thus, C<1+2*3> is converted into something like the following, C<e> stands for expression:
  
               e
             / | \
           1   +   e
                 / | \
               2   *   3
  
  
  The function C<_reverse_tree()> recurses down through this structure swapping the order of operators followed by operands to produce a reverse-Polish tree. In other words the formula is converted from in-fix notation to post-fix. Following the above example the resulting tree would look like this:
  
  
               e
             / | \
           1   e   +
             / | \
           2   3   *
  
  The result of the recursion is a single array of tokens. In our example the simplified form would look like the following:
  
      (1, 2, 3, *, +)
  
  The actual return value contains some additional information to help in the secondary parsing stage:
  
      (_num, 1, _num, 2, _num, 3, ptgMul, ptgAdd, _arg, 1)
  
  The additional tokens are:
  
      Token       Meaning
      _num        The next token is a number
      _str        The next token is a string
      _ref2d      The next token is a 2d cell reference
      _ref3d      The next token is a 3d cell reference
      _range2d    The next token is a 2d range
      _range3d    The next token is a 3d range
      _funcV       The next token is a function
      _arg        The next token is the number of args for a function
      _class      The next token is a function name
      _vol        The formula contains a voltile function
  
  The C<_arg> token is generated for all lists but is only used for functions that take a variable number of arguments.
  
  The C<_class> token indicates the start of the arguments to a function. This allows the post-processor to decide the "class" of the ref and range arguments that the function takes. The class can be reference, value or array. Since function calls can be nested, the class variable is stored on a stack in the C<@class> array. The class of the ref or range is then read as the top element of the stack C<$class[-1]>. When a C<_funcV> is read it pops the class value.
  
  Certain Excel functions such as RAND() and NOW() are designated as volatile and must be recalculated by Excel every time that a cell is updated. Any formulas that contain one of these functions has a specially formatted C<ptgAttr> tag prepended to it to indicate that it is volatile.
  
  A secondary parsing stage is carried out by C<parse_tokens()> which converts these tokens into a binary string. For the C<1+2*3> example this would give:
  
      1E 01 00 1E 02 00 1E 03 00 05 03
  
  This two-pass method could probably have been reduced to a single pass through the C<Parse::RecDescent> parser. However, it was easier to develop and debug this way.
  
  The token values and formula values are stored in the C<%ptg> and C<%functions> hashes. These hashes and the parser object C<$parser> are exposed as global data. This breaks the OO encapsulation, but means that they can be shared by several instances of Spreadsheet::WriteExcel called from the same program.
  
  Non-English function names can be added to the C<%functions> hash using the C<function_locale.pl> program in the C<examples> directory of the distro. The supported languages are: German, French, Spanish, Portuguese, Dutch, Finnish, Italian and Swedish. These languages are not added by default because there are conflicts between functions names in different languages.
  
  The parser is initialised by C<_init_parser()>. The initialisation is delayed until the first formula is parsed. This eliminates the overhead of generating the parser in programs that are not processing formulas. (The parser should really be pre-compiled, this is to-do when the grammar stabilises).
  
  
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
   MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL_FORMULA

$fatpacked{"Spreadsheet/WriteExcel/OLEwriter.pm"} = <<'SPREADSHEET_WRITEEXCEL_OLEWRITER';
  package Spreadsheet::WriteExcel::OLEwriter;
  
  ###############################################################################
  #
  # OLEwriter - A writer class to store BIFF data in a OLE compound storage file.
  #
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use Exporter;
  use strict;
  use Carp;
  use FileHandle;
  
  
  
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor
  #
  sub new {
  
      my $class  = shift;
      my $self   = {
                      _olefilename   => $_[0],
                      _filehandle    => "",
                      _fileclosed    => 0,
                      _internal_fh   => 0,
                      _biff_only     => 0,
                      _size_allowed  => 0,
                      _biffsize      => 0,
                      _booksize      => 0,
                      _big_blocks    => 0,
                      _list_blocks   => 0,
                      _root_start    => 0,
                      _block_count   => 4,
                   };
  
      bless $self, $class;
      $self->_initialize();
      return $self;
  }
  
  
  ###############################################################################
  #
  # _initialize()
  #
  # Create a new filehandle or use the provided filehandle.
  #
  sub _initialize {
  
      my $self    = shift;
      my $olefile = $self->{_olefilename};
      my $fh;
  
      # If the filename is a reference it is assumed that it is a valid
      # filehandle, if not we create a filehandle.
      #
      if (ref($olefile)) {
          $fh = $olefile;
      }
      else{
  
          # Create a new file, open for writing
          $fh = FileHandle->new("> $olefile");
  
          # Workbook.pm also checks this but something may have happened since
          # then.
          if (not defined $fh) {
              croak "Can't open $olefile. It may be in use or protected.\n";
          }
  
          # binmode file whether platform requires it or not
          binmode($fh);
  
          $self->{_internal_fh} = 1;
      }
  
      # Store filehandle
      $self->{_filehandle} = $fh;
  }
  
  
  ###############################################################################
  #
  # set_size($biffsize)
  #
  # Set the size of the data to be written to the OLE stream
  #
  #   $big_blocks = (109 depot block x (128 -1 marker word)
  #                 - (1 x end words)) = 13842
  #   $maxsize    = $big_blocks * 512 bytes = 7087104
  #
  sub set_size {
  
      my $self    = shift;
      my $maxsize = 7_087_104; # Use Spreadsheet::WriteExcel::Big to exceed this
  
      if ($_[0] > $maxsize) {
          return $self->{_size_allowed} = 0;
      }
  
      $self->{_biffsize} = $_[0];
  
      # Set the min file size to 4k to avoid having to use small blocks
      if ($_[0] > 4096) {
          $self->{_booksize} = $_[0];
      }
      else {
          $self->{_booksize} = 4096;
      }
  
      return $self->{_size_allowed} = 1;
  
  }
  
  
  ###############################################################################
  #
  # _calculate_sizes()
  #
  # Calculate various sizes needed for the OLE stream
  #
  sub _calculate_sizes {
  
      my $self     = shift;
      my $datasize = $self->{_booksize};
  
      if ($datasize % 512 == 0) {
          $self->{_big_blocks} = $datasize/512;
      }
      else {
          $self->{_big_blocks} = int($datasize/512) +1;
      }
      # There are 127 list blocks and 1 marker blocks for each big block
      # depot + 1 end of chain block
      $self->{_list_blocks} = int(($self->{_big_blocks})/127) +1;
      $self->{_root_start}  = $self->{_big_blocks};
  }
  
  
  ###############################################################################
  #
  # close()
  #
  # Write root entry, big block list and close the filehandle.
  # This routine is used to explicitly close the open filehandle without
  # having to wait for DESTROY.
  #
  sub close {
  
      my $self = shift;
  
      return if not $self->{_size_allowed};
  
      $self->_write_padding()          if not $self->{_biff_only};
      $self->_write_property_storage() if not $self->{_biff_only};
      $self->_write_big_block_depot()  if not $self->{_biff_only};
  
      my $close = 1; # Default to no error for external filehandles.
  
      # Close the filehandle if it was created internally.
      $close = CORE::close($self->{_filehandle}) if $self->{_internal_fh};
  
      $self->{_fileclosed} = 1;
  
      return $close;
  }
  
  
  ###############################################################################
  #
  # DESTROY()
  #
  # Close the filehandle if it hasn't already been explicitly closed.
  #
  sub DESTROY {
  
      my $self = shift;
  
      local ($@, $!, $^E, $?);
  
      $self->close() unless $self->{_fileclosed};
  }
  
  
  ###############################################################################
  #
  # write($data)
  #
  # Write BIFF data to OLE file.
  #
  sub write {
  
      my $self = shift;
  
      # Protect print() from -l on the command line.
      local $\ = undef;
      print {$self->{_filehandle}} $_[0];
  }
  
  
  ###############################################################################
  #
  # write_header()
  #
  # Write OLE header block.
  #
  sub write_header {
  
      my $self            = shift;
  
      return if $self->{_biff_only};
      $self->_calculate_sizes();
  
      my $root_start      = $self->{_root_start};
      my $num_lists       = $self->{_list_blocks};
  
      my $id              = pack("NN",   0xD0CF11E0, 0xA1B11AE1);
      my $unknown1        = pack("VVVV", 0x00, 0x00, 0x00, 0x00);
      my $unknown2        = pack("vv",   0x3E, 0x03);
      my $unknown3        = pack("v",    -2);
      my $unknown4        = pack("v",    0x09);
      my $unknown5        = pack("VVV",  0x06, 0x00, 0x00);
      my $num_bbd_blocks  = pack("V",    $num_lists);
      my $root_startblock = pack("V",    $root_start);
      my $unknown6        = pack("VV",   0x00, 0x1000);
      my $sbd_startblock  = pack("V",    -2);
      my $unknown7        = pack("VVV",  0x00, -2 ,0x00);
      my $unused          = pack("V",    -1);
  
      # Protect print() from -l on the command line.
      local $\ = undef;
  
      print {$self->{_filehandle}}  $id;
      print {$self->{_filehandle}}  $unknown1;
      print {$self->{_filehandle}}  $unknown2;
      print {$self->{_filehandle}}  $unknown3;
      print {$self->{_filehandle}}  $unknown4;
      print {$self->{_filehandle}}  $unknown5;
      print {$self->{_filehandle}}  $num_bbd_blocks;
      print {$self->{_filehandle}}  $root_startblock;
      print {$self->{_filehandle}}  $unknown6;
      print {$self->{_filehandle}}  $sbd_startblock;
      print {$self->{_filehandle}}  $unknown7;
  
      for (1..$num_lists) {
          $root_start++;
          print {$self->{_filehandle}}  pack("V", $root_start);
      }
  
      for ($num_lists..108) {
          print {$self->{_filehandle}}  $unused;
      }
  }
  
  
  ###############################################################################
  #
  # _write_big_block_depot()
  #
  # Write big block depot.
  #
  sub _write_big_block_depot {
  
      my $self         = shift;
      my $num_blocks   = $self->{_big_blocks};
      my $num_lists    = $self->{_list_blocks};
      my $total_blocks = $num_lists *128;
      my $used_blocks  = $num_blocks + $num_lists +2;
  
      my $marker       = pack("V", -3);
      my $end_of_chain = pack("V", -2);
      my $unused       = pack("V", -1);
  
  
      # Protect print() from -l on the command line.
      local $\ = undef;
  
      for my $i (1..$num_blocks-1) {
          print {$self->{_filehandle}}  pack("V",$i);
      }
  
      print {$self->{_filehandle}}  $end_of_chain;
      print {$self->{_filehandle}}  $end_of_chain;
  
      for (1..$num_lists) {
          print {$self->{_filehandle}}  $marker;
      }
  
      for ($used_blocks..$total_blocks) {
          print {$self->{_filehandle}}  $unused;
      }
  }
  
  
  ###############################################################################
  #
  # _write_property_storage()
  #
  # Write property storage. TODO: add summary sheets
  #
  sub _write_property_storage {
  
      my $self     = shift;
  
      my $rootsize = -2;
      my $booksize = $self->{_booksize};
  
      #################  name         type   dir start size
      $self->_write_pps('Root Entry', 0x05,   1,   -2, 0x00);
      $self->_write_pps('Workbook',   0x02,  -1, 0x00, $booksize);
      $self->_write_pps('',           0x00,  -1, 0x00, 0x0000);
      $self->_write_pps('',           0x00,  -1, 0x00, 0x0000);
  }
  
  
  ###############################################################################
  #
  # _write_pps()
  #
  # Write property sheet in property storage
  #
  sub _write_pps {
  
      my $self            = shift;
  
      my $name            = $_[0];
      my @name            = ();
      my $length          = 0;
  
      if ($name ne '') {
          $name   = $_[0] . "\0";
          # Simulate a Unicode string
          @name   = map(ord, split('', $name));
          $length = length($name) * 2;
      }
  
      my $rawname         = pack("v*", @name);
      my $zero            = pack("C",  0);
  
      my $pps_sizeofname  = pack("v",  $length);    #0x40
      my $pps_type        = pack("v",  $_[1]);      #0x42
      my $pps_prev        = pack("V",  -1);         #0x44
      my $pps_next        = pack("V",  -1);         #0x48
      my $pps_dir         = pack("V",  $_[2]);      #0x4c
  
      my $unknown1        = pack("V",  0);
  
      my $pps_ts1s        = pack("V",  0);          #0x64
      my $pps_ts1d        = pack("V",  0);          #0x68
      my $pps_ts2s        = pack("V",  0);          #0x6c
      my $pps_ts2d        = pack("V",  0);          #0x70
      my $pps_sb          = pack("V",  $_[3]);      #0x74
      my $pps_size        = pack("V",  $_[4]);      #0x78
  
  
      # Protect print() from -l on the command line.
      local $\ = undef;
  
      print {$self->{_filehandle}}  $rawname;
      print {$self->{_filehandle}}  $zero x (64 -$length);
      print {$self->{_filehandle}}  $pps_sizeofname;
      print {$self->{_filehandle}}  $pps_type;
      print {$self->{_filehandle}}  $pps_prev;
      print {$self->{_filehandle}}  $pps_next;
      print {$self->{_filehandle}}  $pps_dir;
      print {$self->{_filehandle}}  $unknown1 x 5;
      print {$self->{_filehandle}}  $pps_ts1s;
      print {$self->{_filehandle}}  $pps_ts1d;
      print {$self->{_filehandle}}  $pps_ts2d;
      print {$self->{_filehandle}}  $pps_ts2d;
      print {$self->{_filehandle}}  $pps_sb;
      print {$self->{_filehandle}}  $pps_size;
      print {$self->{_filehandle}}  $unknown1;
  }
  
  
  ###############################################################################
  #
  # _write_padding()
  #
  # Pad the end of the file
  #
  sub _write_padding {
  
      my $self     = shift;
      my $biffsize = $self->{_biffsize};
      my $min_size;
  
      if ($biffsize < 4096) {
          $min_size = 4096;
      }
      else {
          $min_size = 512;
      }
  
      # Protect print() from -l on the command line.
      local $\ = undef;
  
      if ($biffsize % $min_size != 0) {
          my $padding  = $min_size - ($biffsize % $min_size);
          print {$self->{_filehandle}}  "\0" x $padding;
      }
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  OLEwriter - A writer class to store BIFF data in a OLE compound storage file.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::WriteExcel
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::WriteExcel.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
   MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL_OLEWRITER

$fatpacked{"Spreadsheet/WriteExcel/Properties.pm"} = <<'SPREADSHEET_WRITEEXCEL_PROPERTIES';
  package Spreadsheet::WriteExcel::Properties;
  
  ###############################################################################
  #
  # Properties - A module for creating Excel property sets.
  #
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # Copyright 2000-2010, John McNamara.
  #
  # Documentation after __END__
  #
  
  use Exporter;
  use strict;
  use Carp;
  use POSIX 'fmod';
  use Time::Local 'timelocal';
  
  
  
  
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
  @ISA        = qw(Exporter);
  
  $VERSION    = '2.38';
  
  # Set up the exports.
  my @all_functions = qw(
      create_summary_property_set
      create_doc_summary_property_set
      _pack_property_data
      _pack_VT_I2
      _pack_VT_LPSTR
      _pack_VT_FILETIME
  );
  
  my @pps_summaries = qw(
      create_summary_property_set
      create_doc_summary_property_set
  );
  
  @EXPORT         = ();
  @EXPORT_OK      = (@all_functions);
  %EXPORT_TAGS    = (testing          => \@all_functions,
                     property_sets    => \@pps_summaries,
                    );
  
  
  ###############################################################################
  #
  # create_summary_property_set().
  #
  # Create the SummaryInformation property set. This is mainly used for the
  # Title, Subject, Author, Keywords, Comments, Last author keywords and the
  # creation date.
  #
  sub create_summary_property_set {
  
      my @properties          = @{$_[0]};
  
      my $byte_order          = pack 'v',  0xFFFE;
      my $version             = pack 'v',  0x0000;
      my $system_id           = pack 'V',  0x00020105;
      my $class_id            = pack 'H*', '00000000000000000000000000000000';
      my $num_property_sets   = pack 'V',  0x0001;
      my $format_id           = pack 'H*', 'E0859FF2F94F6810AB9108002B27B3D9';
      my $offset              = pack 'V',  0x0030;
      my $num_property        = pack 'V',  scalar @properties;
      my $property_offsets    = '';
  
      # Create the property set data block and calculate the offsets into it.
      my ($property_data, $offsets) = _pack_property_data(\@properties);
  
      # Create the property type and offsets based on the previous calculation.
      for my $i (0 .. @properties -1) {
          $property_offsets .= pack('VV', $properties[$i]->[0], $offsets->[$i]);
      }
  
      # Size of $size (4 bytes) +  $num_property (4 bytes) + the data structures.
      my $size = 8 + length($property_offsets) + length($property_data);
         $size = pack 'V',  $size;
  
  
      return  $byte_order         .
              $version            .
              $system_id          .
              $class_id           .
              $num_property_sets  .
              $format_id          .
              $offset             .
              $size               .
              $num_property       .
              $property_offsets   .
              $property_data;
  }
  
  
  ###############################################################################
  #
  # Create the DocSummaryInformation property set. This is mainly used for the
  # Manager, Company and Category keywords.
  #
  # The DocSummary also contains a stream for user defined properties. However
  # this is a little arcane and probably not worth the implementation effort.
  #
  sub create_doc_summary_property_set {
  
      my @properties          = @{$_[0]};
  
      my $byte_order          = pack 'v',  0xFFFE;
      my $version             = pack 'v',  0x0000;
      my $system_id           = pack 'V',  0x00020105;
      my $class_id            = pack 'H*', '00000000000000000000000000000000';
      my $num_property_sets   = pack 'V',  0x0002;
  
      my $format_id_0         = pack 'H*', '02D5CDD59C2E1B10939708002B2CF9AE';
      my $format_id_1         = pack 'H*', '05D5CDD59C2E1B10939708002B2CF9AE';
      my $offset_0            = pack 'V',  0x0044;
      my $num_property_0      = pack 'V',  scalar @properties;
      my $property_offsets_0  = '';
  
      # Create the property set data block and calculate the offsets into it.
      my ($property_data_0, $offsets) = _pack_property_data(\@properties);
  
      # Create the property type and offsets based on the previous calculation.
      for my $i (0 .. @properties -1) {
          $property_offsets_0 .= pack('VV', $properties[$i]->[0], $offsets->[$i]);
      }
  
      # Size of $size (4 bytes) +  $num_property (4 bytes) + the data structures.
      my $data_len = 8 + length($property_offsets_0) + length($property_data_0);
      my $size_0   = pack 'V',  $data_len;
  
  
      # The second property set offset is at the end of the first property set.
      my $offset_1 = pack 'V',  0x0044 + $data_len;
  
      # We will use a static property set stream rather than try to generate it.
      my $property_data_1 = pack 'H*', join '', qw (
          98 00 00 00 03 00 00 00 00 00 00 00 20 00 00 00
          01 00 00 00 36 00 00 00 02 00 00 00 3E 00 00 00
          01 00 00 00 02 00 00 00 0A 00 00 00 5F 50 49 44
          5F 47 55 49 44 00 02 00 00 00 E4 04 00 00 41 00
          00 00 4E 00 00 00 7B 00 31 00 36 00 43 00 34 00
          42 00 38 00 33 00 42 00 2D 00 39 00 36 00 35 00
          46 00 2D 00 34 00 42 00 32 00 31 00 2D 00 39 00
          30 00 33 00 44 00 2D 00 39 00 31 00 30 00 46 00
          41 00 44 00 46 00 41 00 37 00 30 00 31 00 42 00
          7D 00 00 00 00 00 00 00 2D 00 39 00 30 00 33 00
      );
  
  
      return  $byte_order         .
              $version            .
              $system_id          .
              $class_id           .
              $num_property_sets  .
              $format_id_0        .
              $offset_0           .
              $format_id_1        .
              $offset_1           .
  
              $size_0             .
              $num_property_0     .
              $property_offsets_0 .
              $property_data_0    .
  
              $property_data_1;
  }
  
  
  ###############################################################################
  #
  # _pack_property_data().
  #
  # Create a packed property set structure. Strings are null terminated and
  # padded to a 4 byte boundary. We also use this function to keep track of the
  # property offsets within the data structure. These offsets are used by the
  # calling functions. Currently we only need to handle 4 property types:
  # VT_I2, VT_LPSTR, VT_FILETIME.
  #
  sub _pack_property_data {
  
      my @properties          = @{$_[0]};
      my $offset              = $_[1] || 0;
      my $packed_property     = '';
      my $data                = '';
      my @offsets;
  
      # Get the strings codepage from the first property.
      my $codepage = $properties[0]->[2];
  
      # The properties start after 8 bytes for size + num_properties + 8 bytes
      # for each propety type/offset pair.
      $offset += 8 * (@properties + 1);
  
      for my $property (@properties) {
          push @offsets, $offset;
  
          my $property_type = $property->[1];
  
          if    ($property_type eq 'VT_I2') {
              $packed_property = _pack_VT_I2($property->[2]);
          }
          elsif ($property_type eq 'VT_LPSTR') {
              $packed_property = _pack_VT_LPSTR($property->[2], $codepage);
          }
          elsif ($property_type eq 'VT_FILETIME') {
              $packed_property = _pack_VT_FILETIME($property->[2]);
          }
          else {
              croak "Unknown property type: $property_type\n";
          }
  
          $offset += length $packed_property;
          $data   .= $packed_property;
      }
  
      return $data, \@offsets;
  }
  
  
  ###############################################################################
  #
  # _pack_VT_I2().
  #
  # Pack an OLE property type: VT_I2, 16-bit signed integer.
  #
  sub _pack_VT_I2 {
  
      my $type    = 0x0002;
      my $value   = $_[0];
  
      my $data = pack 'VV', $type, $value;
  
      return $data;
  }
  
  
  ###############################################################################
  #
  # _pack_VT_LPSTR().
  #
  # Pack an OLE property type: VT_LPSTR, String in the Codepage encoding.
  # The strings are null terminated and padded to a 4 byte boundary.
  #
  sub _pack_VT_LPSTR {
  
      my $type        = 0x001E;
      my $string      = $_[0] . "\0";
      my $codepage    = $_[1];
      my $length;
      my $byte_string;
  
      if ($codepage == 0x04E4) {
          # Latin1
          $byte_string = $string;
          $length      = length $byte_string;
      }
      elsif ($codepage == 0xFDE9) {
          # UTF-8
          if ( $] > 5.008 ) {
              require Encode;
              if (Encode::is_utf8($string)) {
                  $byte_string = Encode::encode_utf8($string);
              }
              else {
                  $byte_string = $string;
              }
          }
          else {
              $byte_string = $string;
          }
  
          $length = length $byte_string;
      }
      else {
          croak "Unknown codepage: $codepage\n";
      }
  
      # Pack the data.
      my $data  = pack 'VV', $type, $length;
         $data .= $byte_string;
  
      # The packed data has to null padded to a 4 byte boundary.
      if (my $extra = $length % 4) {
          $data .= "\0" x (4 - $extra);
      }
  
      return $data;
  }
  
  
  ###############################################################################
  #
  # _pack_VT_FILETIME().
  #
  # Pack an OLE property type: VT_FILETIME.
  #
  sub _pack_VT_FILETIME {
  
      my $type        = 0x0040;
      my $localtime   = $_[0];
  
      # Convert from localtime to seconds.
      my $seconds = Time::Local::timelocal(@{$localtime});
  
      # Add the number of seconds between the 1601 and 1970 epochs.
      $seconds += 11644473600;
  
      # The FILETIME seconds are in units of 100 nanoseconds.
      my $nanoseconds = $seconds * 1E7;
  
      # Pack the total nanoseconds into 64 bits.
      my $time_hi = int($nanoseconds / 2**32);
      my $time_lo = POSIX::fmod($nanoseconds, 2**32);
  
      my $data = pack 'VVV', $type, $time_lo, $time_hi;
  
      return $data;
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Properties - A module for creating Excel property sets.
  
  =head1 SYNOPSIS
  
  See the C<set_properties()> method in the Spreadsheet::WriteExcel documentation.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::WriteExcel.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
   MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL_PROPERTIES

$fatpacked{"Spreadsheet/WriteExcel/Utility.pm"} = <<'SPREADSHEET_WRITEEXCEL_UTILITY';
  package Spreadsheet::WriteExcel::Utility;
  
  ###############################################################################
  #
  # Utility - Helper functions for Spreadsheet::WriteExcel.
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  #
  
  use Exporter;
  use strict;
  use autouse 'Date::Calc'  => qw(Delta_DHMS Decode_Date_EU Decode_Date_US);
  use autouse 'Date::Manip' => qw(ParseDate Date_Init);
  
  
  # Do all of the export preparation
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
  
  # Row and column functions
  my @rowcol      = qw(
                          xl_rowcol_to_cell
                          xl_cell_to_rowcol
                          xl_range_formula
                          xl_inc_row
                          xl_dec_row
                          xl_inc_col
                          xl_dec_col
                      );
  
  # Date and Time functions
  my @dates       = qw(
                          xl_date_list
                          xl_date_1904
                          xl_parse_time
                          xl_parse_date
                          xl_parse_date_init
                          xl_decode_date_EU
                          xl_decode_date_US
                      );
  
  
  @ISA            = qw(Exporter);
  @EXPORT_OK      =   ();
  @EXPORT         =   (@rowcol, @dates);
  %EXPORT_TAGS    =   (
                          rowcol  => \@rowcol,
                          dates   => \@dates
                      );
  
  $VERSION        = '2.38';
  
  
  
  
  =head1 NAME
  
  Utility - Helper functions for Spreadsheet::WriteExcel.
  
  
  
  =head1 SYNOPSIS
  
  Functions to help with some common tasks when using Spreadsheet::WriteExcel.
  
  These functions mainly relate to dealing with rows and columns in A1 notation and to handling dates and times.
  
      use Spreadsheet::WriteExcel::Utility;               # Import everything
  
      ($row, $col)    = xl_cell_to_rowcol('C2');          # (1, 2)
      $str            = xl_rowcol_to_cell(1, 2);          # C2
      $str            = xl_inc_col('Z1'  );               # AA1
      $str            = xl_dec_col('AA1' );               # Z1
  
      $date           = xl_date_list(2002, 1, 1);         # 37257
      $date           = xl_parse_date("11 July 1997");    # 35622
      $time           = xl_parse_time('3:21:36 PM');      # 0.64
      $date           = xl_decode_date_EU("13 May 2002"); # 37389
  
  
  
  
  =head1 DESCRIPTION
  
  This module provides a set of functions to help with some common tasks encountered when using the Spreadsheet::WriteExcel module. The two main categories of function are:
  
  Row and column functions: these are used to deal with Excel's A1 representation of cells. The functions in this category are:
  
      xl_rowcol_to_cell
      xl_cell_to_rowcol
      xl_range_formula
      xl_inc_row
      xl_dec_row
      xl_inc_col
      xl_dec_col
  
  Date and Time functions: these are used to convert dates and times to the numeric format used by Excel. The functions in this category are:
  
      xl_date_list
      xl_date_1904
      xl_parse_time
      xl_parse_date
      xl_parse_date_init
      xl_decode_date_EU
      xl_decode_date_US
  
  All of these functions are exported by default. However, you can use import lists if you wish to limit the functions that are imported:
  
      use Spreadsheet::WriteExcel::Utility;                  # Import everything
      use Spreadsheet::WriteExcel::Utility qw(xl_date_list); # xl_date_list only
      use Spreadsheet::WriteExcel::Utility qw(:rowcol);      # Row/col functions
      use Spreadsheet::WriteExcel::Utility qw(:dates);       # Date functions
  
  
  
  =head1 ROW AND COLUMN FUNCTIONS
  
  
  Spreadsheet::WriteExcel supports two forms of notation to designate the position of cells: Row-column notation and A1 notation.
  
  Row-column notation uses a zero based index for both row and column while A1 notation uses the standard Excel alphanumeric sequence of column letter and 1-based row. Columns range from A to IV i.e. 0 to 255, rows range from 1 to 16384 in Excel 5 and 65536 in Excel 97. For example:
  
      (0, 0)      # The top left cell in row-column notation.
      ('A1')      # The top left cell in A1 notation.
  
      (1999, 29)  # Row-column notation.
      ('AD2000')  # The same cell in A1 notation.
  
  Row-column notation is useful if you are referring to cells programmatically:
  
      for my $i (0 .. 9) {
          $worksheet->write($i, 0, 'Hello'); # Cells A1 to A10
      }
  
  A1 notation is useful for setting up a worksheet manually and for working with formulas:
  
      $worksheet->write('H1', 200);
      $worksheet->write('H2', '=H7+1');
  
  The functions in the following sections can be used for dealing with A1 notation, for example:
  
      ($row, $col)    = xl_cell_to_rowcol('C2');  # (1, 2)
      $str            = xl_rowcol_to_cell(1, 2);  # C2
  
  
  Cell references in Excel can be either relative or absolute. Absolute references are prefixed by the dollar symbol as shown below:
  
      A1      # Column and row are relative
      $A1     # Column is absolute and row is relative
      A$1     # Column is relative and row is absolute
      $A$1    # Column and row are absolute
  
  An absolute reference only has an effect if the cell is copied. Refer to the Excel documentation for further details. All of the following functions support absolute references.
  
  =cut
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_rowcol_to_cell($row, $col, $row_absolute, $col_absolute)
  
      Parameters: $row:           Integer
                  $col:           Integer
                  $row_absolute:  Boolean (1/0) [optional, default is 0]
                  $col_absolute:  Boolean (1/0) [optional, default is 0]
  
      Returns:    A string in A1 cell notation
  
  
  This function converts a zero based row and column cell reference to a A1 style string:
  
      $str = xl_rowcol_to_cell(0, 0); # A1
      $str = xl_rowcol_to_cell(0, 1); # B1
      $str = xl_rowcol_to_cell(1, 0); # A2
  
  
  The optional parameters C<$row_absolute> and C<$col_absolute> can be used to indicate if the row or column is absolute:
  
      $str = xl_rowcol_to_cell(0, 0, 0, 1); # $A1
      $str = xl_rowcol_to_cell(0, 0, 1, 0); # A$1
      $str = xl_rowcol_to_cell(0, 0, 1, 1); # $A$1
  
  See L<ROW AND COLUMN FUNCTIONS> for an explanation of absolute cell references.
  
  
  =cut
  ###############################################################################
  #
  # xl_rowcol_to_cell($row, $col, $row_absolute, $col_absolute)
  #
  sub xl_rowcol_to_cell {
  
      my $row     = $_[0];
      my $col     = $_[1];
      my $row_abs = $_[2] ? '$' : '';
      my $col_abs = $_[3] ? '$' : '';
      my $col_str = '';
  
      # Change from 0-indexed to 1 indexed.
      $row++;
      $col++;
  
      while ( $col ) {
          # Set remainder from 1 .. 26
          my $remainder = $col % 26 || 26;
  
          # Convert the $remainder to a character. C-ishly.
          my $col_letter = chr( ord( 'A' ) + $remainder - 1 );
  
          # Accumulate the column letters, right to left.
          $col_str = $col_letter . $col_str;
  
          # Get the next order of magnitude.
          $col = int( ( $col - 1 ) / 26 );
      }
  
      return $col_abs . $col_str . $row_abs . $row;
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_cell_to_rowcol($string)
  
  
      Parameters: $string         String in A1 format
  
      Returns:    List            ($row, $col)
  
  This function converts an Excel cell reference in A1 notation to a zero based row and column. The function will also handle Excel's absolute, C<$>, cell notation.
  
      my ($row, $col) = xl_cell_to_rowcol('A1');     # (0, 0)
      my ($row, $col) = xl_cell_to_rowcol('B1');     # (0, 1)
      my ($row, $col) = xl_cell_to_rowcol('C2');     # (1, 2)
      my ($row, $col) = xl_cell_to_rowcol('$C2' );   # (1, 2)
      my ($row, $col) = xl_cell_to_rowcol('C$2' );   # (1, 2)
      my ($row, $col) = xl_cell_to_rowcol('$C$2');   # (1, 2)
  
  =cut
  ###############################################################################
  #
  # xl_cell_to_rowcol($string)
  #
  # Returns: ($row, $col, $row_absolute, $col_absolute)
  #
  # The $row_absolute and $col_absolute parameters aren't documented because they
  # mainly used internally and aren't very useful to the user.
  #
  sub xl_cell_to_rowcol {
  
      my $cell = shift;
  
      $cell =~ /(\$?)([A-Z]{1,3})(\$?)(\d+)/;
  
      my $col_abs = $1 eq "" ? 0 : 1;
      my $col     = $2;
      my $row_abs = $3 eq "" ? 0 : 1;
      my $row     = $4;
  
      # Convert base26 column string to number
      # All your Base are belong to us.
      my @chars  = split //, $col;
      my $expn   = 0;
      $col       = 0;
  
      while (@chars) {
          my $char = pop(@chars); # LS char first
          $col += (ord($char) -ord('A') +1) * (26**$expn);
          $expn++;
      }
  
      # Convert 1-index to zero-index
      $row--;
      $col--;
  
      return $row, $col, $row_abs, $col_abs;
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_range_formula($sheetname, $row_1, $row_2, $col_1, $col_2)
  
      Parameters: $sheetname      String
                  $row_1:         Integer
                  $row_2:         Integer
                  $col_1:         Integer
                  $col_2:         Integer
  
      Returns:    A worksheet range formula as a string.
  
  This function converts zero based row and column cell references to an A1 style formula string:
  
      my $str = xl_range_formula('Sheet1',   0,  9, 0, 0); # =Sheet1!$A$1:$A$10
      my $str = xl_range_formula('Sheet2',   6, 65, 1, 1); # =Sheet2!$B$7:$B$66
      my $str = xl_range_formula('New data', 1,  8, 2, 2); # ='New data'!$C$2:$C$9
  
  
  This is useful for setting ranges in Chart objects:
  
  
      $chart->add_series(
          categories    => xl_range_formula('Sheet1', 1, 9, 0, 0),
          values        => xl_range_formula('Sheet1', 1, 9, 1, 1),
      );
  
      # Which is the same as:
  
      $chart->add_series(
          categories    => '=Sheet1!$A$2:$A$10',
          values        => '=Sheet1!$B$2:$B$10',
      );
  
  
  =cut
  ###############################################################################
  #
  # xl_range_formula($sheetname, $row_1, $row_2, $col_1, $col_2)
  #
  sub xl_range_formula {
  
      my ($sheetname, $row_1, $row_2, $col_1, $col_2) = @_;
  
      # Use Excel's conventions and quote the sheet name if it contains any
      # non-word character or if it isn't already quoted.
      if ($sheetname =~ /\W/ && $sheetname !~ /^'/) {
          $sheetname = q(') . $sheetname . q(');
      }
  
      my $range1 = xl_rowcol_to_cell($row_1, $col_1, 1, 1);
      my $range2 = xl_rowcol_to_cell($row_2, $col_2, 1, 1);
  
      return '=' . $sheetname . '!' . $range1 . ':' . $range2;
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_inc_row($string)
  
  
      Parameters: $string, a string in A1 format
  
      Returns:    Incremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and increments the row. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_inc_row('A1'  ); # A2
      my $str = xl_inc_row('B$2' ); # B$3
      my $str = xl_inc_row('$C3' ); # $C4
      my $str = xl_inc_row('$D$4'); # $D$5
  
  
  =cut
  ###############################################################################
  #
  # xl_inc_row($string)
  #
  sub xl_inc_row {
  
      my $cell = shift;
      my ($row, $col, $row_abs, $col_abs) = xl_cell_to_rowcol($cell);
  
      return xl_rowcol_to_cell(++$row, $col, $row_abs, $col_abs);
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_dec_row($string)
  
  
      Parameters: $string, a string in A1 format
  
      Returns:    Decremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and decrements the row. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_dec_row('A2'  ); # A1
      my $str = xl_dec_row('B$3' ); # B$2
      my $str = xl_dec_row('$C4' ); # $C3
      my $str = xl_dec_row('$D$5'); # $D$4
  
  
  =cut
  ###############################################################################
  #
  # xl_dec_row($string)
  #
  # Decrements the row number of an Excel cell reference in A1 notation.
  # For example C4 to C3
  #
  # Returns: a cell reference string.
  #
  sub xl_dec_row {
  
      my $cell = shift;
      my ($row, $col, $row_abs, $col_abs) = xl_cell_to_rowcol($cell);
  
      return xl_rowcol_to_cell(--$row, $col, $row_abs, $col_abs);
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_inc_col($string)
  
  
      Parameters: $string, a string in A1 format
  
      Returns:    Incremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and increments the column. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_inc_col('A1'  ); # B1
      my $str = xl_inc_col('Z1'  ); # AA1
      my $str = xl_inc_col('$B1' ); # $C1
      my $str = xl_inc_col('$D$5'); # $E$5
  
  
  =cut
  ###############################################################################
  #
  # xl_inc_col($string)
  #
  # Increments the column number of an Excel cell reference in A1 notation.
  # For example C3 to D3
  #
  # Returns: a cell reference string.
  #
  sub xl_inc_col {
  
      my $cell = shift;
      my ($row, $col, $row_abs, $col_abs) = xl_cell_to_rowcol($cell);
  
      return xl_rowcol_to_cell($row, ++$col, $row_abs, $col_abs);
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_dec_col($string)
  
      Parameters: $string, a string in A1 format
  
      Returns:    Decremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and decrements the column. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_dec_col('B1'  ); # A1
      my $str = xl_dec_col('AA1' ); # Z1
      my $str = xl_dec_col('$C1' ); # $B1
      my $str = xl_dec_col('$E$5'); # $D$5
  
  
  =cut
  ###############################################################################
  #
  # xl_dec_col($string)
  #
  sub xl_dec_col {
  
      my $cell = shift;
      my ($row, $col, $row_abs, $col_abs) = xl_cell_to_rowcol($cell);
  
      return xl_rowcol_to_cell($row, --$col, $row_abs, $col_abs);
  }
  
  
  
  
  =head1 TIME AND DATE FUNCTIONS
  
  
  Dates and times in Excel are represented by real numbers, for example "Jan 1 2001 12:30 AM" is represented by the number 36892.521.
  
  The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day in seconds.
  
  The epoch can be either 1900 or 1904. Excel for Windows uses 1900 and Excel for Macintosh uses 1904. The epochs are:
  
      1900: 0 January 1900 i.e. 31 December 1899
      1904: 1 January 1904
  
  Excel on Windows and the Macintosh will convert automatically between one system and the other. By default Spreadsheet::WriteExcel uses the 1900 format. To use the 1904 epoch you must use the C<set_1904()> workbook method, see the Spreadsheet::WriteExcel documentation.
  
  There are two things to note about the 1900 date format. The first is that the epoch starts on 0 January 1900. The second is that the year 1900 is erroneously but deliberately treated as a leap year. Therefore you must add an extra day to dates after 28 February 1900. The functions in the following section will deal with these issues automatically. The reason for this anomaly is explained at http://support.microsoft.com/support/kb/articles/Q181/3/70.asp
  
  Note, a date or time in Excel is like any other number. To display the number as a date you must apply a number format to it: Refer to the C<set_num_format()> method in the Spreadsheet::WriteExcel documentation:
  
      $date = xl_date_list(2001, 1, 1, 12, 30);
      $format->set_num_format('mmm d yyyy hh:mm AM/PM');
      $worksheet->write('A1', $date , $format); # Jan 1 2001 12:30 AM
  
  To use these functions you must install the C<Date::Manip> and C<Date::Calc> modules. See L<REQUIREMENTS> and the individual requirements of each functions.
  
  See also the DateTime::Format::Excel module,http://search.cpan.org/search?dist=DateTime-Format-Excel which is part of the DateTime project and which deals specifically with converting dates and times to and from Excel's format.
  
  
  =cut
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_date_list($years, $months, $days, $hours, $minutes, $seconds)
  
  
      Parameters: $years:         Integer
                  $months:        Integer [optional, default is 1]
                  $days:          Integer [optional, default is 1]
                  $hours:         Integer [optional, default is 0]
                  $minutes:       Integer [optional, default is 0]
                  $seconds:       Float   [optional, default is 0]
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Calc
  
  This function converts an array of data into a number that represents an Excel date. All of the parameters are optional except for C<$years>.
  
      $date1 = xl_date_list(2002, 1, 2);              # 2 Jan 2002
      $date2 = xl_date_list(2002, 1, 2, 12);          # 2 Jan 2002 12:00 pm
      $date3 = xl_date_list(2002, 1, 2, 12, 30);      # 2 Jan 2002 12:30 pm
      $date4 = xl_date_list(2002, 1, 2, 12, 30, 45);  # 2 Jan 2002 12:30:45 pm
  
  This function can be used in conjunction with functions that parse date and time strings. In fact it is used in most of the following functions.
  
  
  =cut
  ###############################################################################
  #
  # xl_date_list($years, $months, $days, $hours, $minutes, $seconds)
  #
  sub xl_date_list {
  
      return undef unless @_;
  
      my $years   = $_[0];
      my $months  = $_[1] || 1;
      my $days    = $_[2] || 1;
      my $hours   = $_[3] || 0;
      my $minutes = $_[4] || 0;
      my $seconds = $_[5] || 0;
  
      my @date = ($years, $months, $days, $hours, $minutes, $seconds);
      my @epoch = (1899, 12, 31, 0, 0, 0);
  
      ($days, $hours, $minutes, $seconds) = Delta_DHMS(@epoch, @date);
  
      my $date = $days + ($hours*3600 +$minutes*60 +$seconds)/(24*60*60);
  
      # Add a day for Excel's missing leap day in 1900
      $date++ if ($date > 59);
  
      return $date;
  }
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_parse_time($string)
  
  
      Parameters: $string, a textual representation of a time
  
      Returns:    A number that represents an Excel time
                  or undef for an invalid time.
  
  This function converts a time string into a number that represents an Excel time. The following time formats are valid:
  
      hh:mm       [AM|PM]
      hh:mm       [AM|PM]
      hh:mm:ss    [AM|PM]
      hh:mm:ss.ss [AM|PM]
  
  
  The meridian, AM or PM, is optional and case insensitive. A 24 hour time is assumed if the meridian is omitted
  
      $time1 = xl_parse_time('12:18');
      $time2 = xl_parse_time('12:18:14');
      $time3 = xl_parse_time('12:18:14 AM');
      $time4 = xl_parse_time('1:18:14 AM');
  
  Time in Excel is expressed as a fraction of the day in seconds. Therefore you can calculate an Excel time as follows:
  
      $time = ($hours*3600 +$minutes*60 +$seconds)/(24*60*60);
  
  
  =cut
  ###############################################################################
  #
  # xl_parse_time($string)
  #
  sub xl_parse_time {
  
      my $time = shift;
  
      if ($time =~ /(\d{1,2}):(\d\d):?((?:\d\d)(?:\.\d+)?)?(?:\s+)?(am|pm)?/i) {
  
          my $hours       = $1;
          my $minutes     = $2;
          my $seconds     = $3     || 0;
          my $meridian    = lc($4) || '';
  
          # Normalise midnight and midday
          $hours = 0 if ($hours == 12 && $meridian ne '');
  
          # Add 12 hours to the pm times. Note: 12.00 pm has been set to 0.00.
          $hours += 12 if $meridian eq 'pm';
  
          # Calculate the time as a fraction of 24 hours in seconds
          return ($hours*3600 +$minutes*60 +$seconds)/(24*60*60);
  
      }
      else {
          return undef; # Not a valid time string
      }
  }
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_parse_date($string)
  
  
      Parameters: $string, a textual representation of a date and time
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Manip and Date::Calc
  
  This function converts a date and time string into a number that represents an Excel date.
  
  The parsing is performed using the C<ParseDate()> function of the Date::Manip module. Refer to the Date::Manip documentation for further information about the date and time formats that can be parsed. In order to use this function you will probably have to initialise some Date::Manip variables via the C<xl_parse_date_init()> function, see below.
  
      xl_parse_date_init("TZ=GMT","DateFormat=non-US");
  
      $date1 = xl_parse_date("11/7/97");
      $date2 = xl_parse_date("Friday 11 July 1997");
      $date3 = xl_parse_date("10:30 AM Friday 11 July 1997");
      $date4 = xl_parse_date("Today");
      $date5 = xl_parse_date("Yesterday");
  
  Note, if you parse a string that represents a time but not a date this function will add the current date. If you want the time without the date you can do something like the following:
  
      $time  = xl_parse_date("10:30 AM");
      $time -= int($time);
  
  
  =cut
  ###############################################################################
  #
  # xl_parse_date($string)
  #
  sub xl_parse_date {
  
      my $date = ParseDate($_[0]);
  
      return undef unless defined $date;
  
      # Unpack the return value from ParseDate()
      my    ($years, $months, $days, $hours, undef, $minutes, undef, $seconds) =
      unpack("A4     A2       A2     A2      C      A2        C      A2", $date);
  
      # Convert to Excel date
      return xl_date_list($years, $months, $days, $hours, $minutes, $seconds);
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_parse_date_init("variable=value", ...)
  
  
      Parameters: A list of Date::Manip variable strings
  
      Returns:    A list of all the Date::Manip strings
  
      Requires:   Date::Manip
  
  This function is used to initialise variables required by the Date::Manip module. You should call this function before calling C<xl_parse_date()>. It need only be called once.
  
  This function is a thin wrapper for the C<Date::Manip::Date_Init()> function. You can use C<Date_Init()>  directly if you wish. Refer to the Date::Manip documentation for further information.
  
      xl_parse_date_init("TZ=MST","DateFormat=US");
      $date1 = xl_parse_date("11/7/97");  # November 7th 1997
  
      xl_parse_date_init("TZ=GMT","DateFormat=non-US");
      $date1 = xl_parse_date("11/7/97");  # July 11th 1997
  
  
  =cut
  ###############################################################################
  #
  # xl_parse_date_init("variable=value", ...)
  #
  sub xl_parse_date_init {
  
      Date_Init(@_); # How lazy is that.
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_decode_date_EU($string)
  
  
      Parameters: $string, a textual representation of a date and time
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Calc
  
  This function converts a date and time string into a number that represents an Excel date.
  
  The date parsing is performed using the C<Decode_Date_EU()> function of the Date::Calc module. Refer to the Date::Calc for further information about the date formats that can be parsed. Also note the following from the Date::Calc documentation:
  
  "If the year is given as one or two digits only (i.e., if the year is less than 100), it is mapped to the window 1970 -2069 as follows":
  
       0 E<lt>= $year E<lt>  70  ==>  $year += 2000;
      70 E<lt>= $year E<lt> 100  ==>  $year += 1900;
  
  The time portion of the string is parsed using the C<xl_parse_time()> function described above.
  
  Note: the EU in the function name means that a European date format is assumed if it is not clear from the string. See the first example below.
  
      $date1 = xl_decode_date_EU("11/7/97"); #11 July 1997
      $date2 = xl_decode_date_EU("Sat 12 Sept 1998");
      $date3 = xl_decode_date_EU("4:30 AM Sat 12 Sept 1998");
  
  
  =cut
  ###############################################################################
  #
  # xl_decode_date_EU($string)
  #
  sub xl_decode_date_EU {
  
      return undef unless @_;
  
      my $date = shift;
      my @date;
      my $time = 0;
  
      # Remove and decode the time portion of the string
      if ($date =~ s/(\d{1,2}:\d\d:?(\d\d(\.\d+)?)?(\s+)?(am|pm)?)//i) {
          $time = xl_parse_time($1);
          return undef unless defined $time;
      }
  
      # Return if the string is now blank, i.e. it contained a time only.
      return $time if $date =~ /^\s*$/;
  
      # Decode the date portion of the string
      @date = Decode_Date_EU($date);
      return undef unless @date;
  
      return xl_date_list(@date) + $time;
  }
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_decode_date_US($string)
  
  
      Parameters: $string, a textual representation of a date and time
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Calc
  
  This function converts a date and time string into a number that represents an Excel date.
  
  The date parsing is performed using the C<Decode_Date_US()> function of the Date::Calc module. Refer to the Date::Calc for further information about the date formats that can be parsed. Also note the following from the Date::Calc documentation:
  
  "If the year is given as one or two digits only (i.e., if the year is less than 100), it is mapped to the window 1970 -2069 as follows":
  
       0 <= $year <  70  ==>  $year += 2000;
      70 <= $year < 100  ==>  $year += 1900;
  
  The time portion of the string is parsed using the C<xl_parse_time()> function described above.
  
  Note: the US in the function name means that an American date format is assumed if it is not clear from the string. See the first example below.
  
      $date1 = xl_decode_date_US("11/7/97"); # 7 November 1997
      $date2 = xl_decode_date_US("12 Sept Saturday 1998");
      $date3 = xl_decode_date_US("4:30 AM 12 Sept Sat 1998");
  
  
  =cut
  ###############################################################################
  #
  # xl_decode_date_US($string)
  #
  sub xl_decode_date_US {
  
      return undef unless @_;
  
      my $date = shift;
      my @date;
      my $time = 0;
  
      # Remove and decode the time portion of the string
      if ($date =~ s/(\d{1,2}:\d\d:?(\d\d(\.\d+)?)?(\s+)?(am|pm)?)//i) {
          $time = xl_parse_time($1);
          return undef unless defined $time;
      }
  
      # Return if the string is now blank, i.e. it contained a time only.
      return $time if $date =~ /^\s*$/;
  
      # Decode the date portion of the string
      @date = Decode_Date_US($date);
      return undef unless @date;
  
      return xl_date_list(@date) + $time;
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  
  =head2 xl_date_1904($date)
  
  
      Parameters: $date, an Excel date with a 1900 epoch
  
      Returns:    an Excel date with a 1904 epoch or zero if
                  the $date is before 1904
  
  
  This function converts an Excel date based on the 1900 epoch into a date based on the 1904 epoch.
  
  
      $date1 = xl_date_list(2002, 1, 13); # 13 Jan 2002, 1900 epoch
      $date2 = xl_date_1904($date1);      # 13 Jan 2002, 1904 epoch
  
  
  See also the C<set_1904()> workbook method in the Spreadsheet::WriteExcel documentation.
  
  =cut
  ###############################################################################
  #
  # xl_decode_date_US($string)
  #
  sub xl_date_1904 {
  
      my $date = $_[0] || 0;
  
      if ($date < 1462) {
          # before 1904
          $date = 0;
      }
      else {
          $date -= 1462;
      }
  
      return $date;
  }
  
  
  
  
  
  =head1 REQUIREMENTS
  
  The date and time functions require functions from the C<Date::Manip> and C<Date::Calc> modules. The required functions are "autoused" from these modules so that you do not have to install them unless you wish to use the date and time routines. Therefore it is possible to use the row and column functions without having C<Date::Manip> and C<Date::Calc> installed.
  
  For more information about "autousing" refer to the documentation on the C<autouse> pragma.
  
  
  
  =head1 BUGS
  
  When using the autoused functions from C<Date::Manip> and C<Date::Calc> on Perl 5.6.0 with C<-w> you will get a warning like this:
  
      "Subroutine xxx redefined ..."
  
  The current workaround for this is to put C<use warnings;> near the beginning of your program.
  
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  
  
  
  =head1 COPYRIGHT
  
  � MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =cut
  
  
  
  1;
  
  
  __END__
  
SPREADSHEET_WRITEEXCEL_UTILITY

$fatpacked{"Spreadsheet/WriteExcel/Workbook.pm"} = <<'SPREADSHEET_WRITEEXCEL_WORKBOOK';
  package Spreadsheet::WriteExcel::Workbook;
  
  ###############################################################################
  #
  # Workbook - A writer class for Excel Workbooks.
  #
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  use Exporter;
  use strict;
  use Carp;
  use Spreadsheet::WriteExcel::BIFFwriter;
  use Spreadsheet::WriteExcel::OLEwriter;
  use Spreadsheet::WriteExcel::Worksheet;
  use Spreadsheet::WriteExcel::Format;
  use Spreadsheet::WriteExcel::Chart;
  use Spreadsheet::WriteExcel::Properties ':property_sets';
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::BIFFwriter Exporter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor. Creates a new Workbook object from a BIFFwriter object.
  #
  sub new {
  
      my $class       = shift;
      my $self        = Spreadsheet::WriteExcel::BIFFwriter->new();
      my $byte_order  = $self->{_byte_order};
      my $parser      = Spreadsheet::WriteExcel::Formula->new($byte_order);
  
      $self->{_filename}              = $_[0] || '';
      $self->{_parser}                = $parser;
      $self->{_tempdir}               = undef;
      $self->{_1904}                  = 0;
      $self->{_activesheet}           = 0;
      $self->{_firstsheet}            = 0;
      $self->{_selected}              = 0;
      $self->{_xf_index}              = 0;
      $self->{_fileclosed}            = 0;
      $self->{_biffsize}              = 0;
      $self->{_sheet_name}             = 'Sheet';
      $self->{_chart_name}             = 'Chart';
      $self->{_sheet_count}           = 0;
      $self->{_chart_count}           = 0;
      $self->{_url_format}            = '';
      $self->{_codepage}              = 0x04E4;
      $self->{_country}               = 1;
      $self->{_worksheets}            = [];
      $self->{_sheetnames}            = [];
      $self->{_formats}               = [];
      $self->{_palette}               = [];
  
      $self->{_using_tmpfile}         = 1;
      $self->{_filehandle}            = "";
      $self->{_temp_file}             = "";
      $self->{_internal_fh}           = 0;
      $self->{_fh_out}                = "";
  
      $self->{_str_total}             = 0;
      $self->{_str_unique}            = 0;
      $self->{_str_table}             = {};
      $self->{_str_array}             = [];
      $self->{_str_block_sizes}       = [];
      $self->{_extsst_offsets}        = [];
      $self->{_extsst_buckets}        = 0;
      $self->{_extsst_bucket_size}    = 0;
  
      $self->{_ext_ref_count}         = 0;
      $self->{_ext_refs}              = {};
  
      $self->{_mso_clusters}          = [];
      $self->{_mso_size}              = 0;
  
      $self->{_hideobj}               = 0;
      $self->{_compatibility}         = 0;
  
      $self->{_add_doc_properties}    = 0;
      $self->{_localtime}             = [localtime()];
  
      $self->{_defined_names}         = [];
  
      bless $self, $class;
  
  
      # Add the in-built style formats and the default cell format.
      $self->add_format(type => 1);                       #  0 Normal
      $self->add_format(type => 1);                       #  1 RowLevel 1
      $self->add_format(type => 1);                       #  2 RowLevel 2
      $self->add_format(type => 1);                       #  3 RowLevel 3
      $self->add_format(type => 1);                       #  4 RowLevel 4
      $self->add_format(type => 1);                       #  5 RowLevel 5
      $self->add_format(type => 1);                       #  6 RowLevel 6
      $self->add_format(type => 1);                       #  7 RowLevel 7
      $self->add_format(type => 1);                       #  8 ColLevel 1
      $self->add_format(type => 1);                       #  9 ColLevel 2
      $self->add_format(type => 1);                       # 10 ColLevel 3
      $self->add_format(type => 1);                       # 11 ColLevel 4
      $self->add_format(type => 1);                       # 12 ColLevel 5
      $self->add_format(type => 1);                       # 13 ColLevel 6
      $self->add_format(type => 1);                       # 14 ColLevel 7
      $self->add_format();                                # 15 Cell XF
      $self->add_format(type => 1, num_format => 0x2B);   # 16 Comma
      $self->add_format(type => 1, num_format => 0x29);   # 17 Comma[0]
      $self->add_format(type => 1, num_format => 0x2C);   # 18 Currency
      $self->add_format(type => 1, num_format => 0x2A);   # 19 Currency[0]
      $self->add_format(type => 1, num_format => 0x09);   # 20 Percent
  
  
      # Add the default format for hyperlinks
      $self->{_url_format} = $self->add_format(color => 'blue', underline => 1);
  
  
      # Check for a filename unless it is an existing filehandle
      if (not ref $self->{_filename} and $self->{_filename} eq '') {
          carp 'Filename required by Spreadsheet::WriteExcel->new()';
          return undef;
      }
  
  
      # Convert the filename to a filehandle to pass to the OLE writer when the
      # file is closed. If the filename is a reference it is assumed that it is
      # a valid filehandle.
      #
      if (not ref $self->{_filename}) {
  
          my $fh = FileHandle->new('>'. $self->{_filename});
  
          if (not defined $fh) {
              carp "Can't open " .
                    $self->{_filename} .
                    ". It may be in use or protected";
              return undef;
          }
  
          # binmode file whether platform requires it or not
          binmode($fh);
          $self->{_internal_fh} = 1;
          $self->{_fh_out}      = $fh;
      }
      else {
          $self->{_internal_fh} = 0;
          $self->{_fh_out}      = $self->{_filename};
  
      }
  
  
      # Set colour palette.
      $self->set_palette_xl97();
  
      # Load Encode if we can.
      require Encode if $] >= 5.008;
  
      $self->_initialize();
      $self->_get_checksum_method();
      return $self;
  }
  
  
  ###############################################################################
  #
  # _initialize()
  #
  # Open a tmp file to store the majority of the Worksheet data. If this fails,
  # for example due to write permissions, store the data in memory. This can be
  # slow for large files.
  #
  # TODO: Move this and other methods shared with Worksheet up into BIFFwriter.
  #
  sub _initialize {
  
      my $self = shift;
      my $fh;
      my $tmp_dir;
  
      # The following code is complicated by Windows limitations. Porters can
      # choose a more direct method.
  
  
  
      # In the default case we use IO::File->new_tmpfile(). This may fail, in
      # particular with IIS on Windows, so we allow the user to specify a temp
      # directory via File::Temp.
      #
      if (defined $self->{_tempdir}) {
  
          # Delay loading File:Temp to reduce the module dependencies.
          eval { require File::Temp };
          die "The File::Temp module must be installed in order ".
              "to call set_tempdir().\n" if $@;
  
  
          # Trap but ignore File::Temp errors.
          eval { $fh = File::Temp::tempfile(DIR => $self->{_tempdir}) };
  
          # Store the failed tmp dir in case of errors.
          $tmp_dir = $self->{_tempdir} || File::Spec->tmpdir if not $fh;
      }
      else {
  
          $fh = IO::File->new_tmpfile();
  
          # Store the failed tmp dir in case of errors.
          $tmp_dir = "POSIX::tmpnam() directory" if not $fh;
      }
  
  
      # Check if the temp file creation was successful. Else store data in memory.
      if ($fh) {
  
          # binmode file whether platform requires it or not.
          binmode($fh);
  
          # Store filehandle
          $self->{_filehandle} = $fh;
      }
      else {
  
          # Set flag to store data in memory if XX::tempfile() failed.
          $self->{_using_tmpfile} = 0;
  
          if ($^W) {
              my $dir = $self->{_tempdir} || File::Spec->tmpdir();
  
              warn "Unable to create temp files in $tmp_dir. Data will be ".
                   "stored in memory. Refer to set_tempdir() in the ".
                   "Spreadsheet::WriteExcel documentation.\n" ;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _get_checksum_method.
  #
  # Check for modules available to calculate image checksum. Excel uses MD4 but
  # MD5 will also work.
  #
  sub _get_checksum_method {
  
      my $self = shift;
  
      eval { require Digest::MD4};
      if (not $@) {
          $self->{_checksum_method} = 1;
          return;
      }
  
  
      eval { require Digest::Perl::MD4};
      if (not $@) {
          $self->{_checksum_method} = 2;
          return;
      }
  
  
      eval { require Digest::MD5};
      if (not $@) {
          $self->{_checksum_method} = 3;
          return;
      }
  
      # Default.
      $self->{_checksum_method} = 0;
  }
  
  
  ###############################################################################
  #
  # _append(), overridden.
  #
  # Store Worksheet data in memory using the base class _append() or to a
  # temporary file, the default.
  #
  sub _append {
  
      my $self = shift;
      my $data = '';
  
      if ($self->{_using_tmpfile}) {
          $data = join('', @_);
  
          # Add CONTINUE records if necessary
          $data = $self->_add_continue($data) if length($data) > $self->{_limit};
  
          # Protect print() from -l on the command line.
          local $\ = undef;
  
          print {$self->{_filehandle}} $data;
          $self->{_datasize} += length($data);
      }
      else {
          $data = $self->SUPER::_append(@_);
      }
  
      return $data;
  }
  
  
  ###############################################################################
  #
  # get_data().
  #
  # Retrieves data from memory in one chunk, or from disk in $buffer
  # sized chunks.
  #
  sub get_data {
  
      my $self   = shift;
      my $buffer = 4096;
      my $tmp;
  
      # Return data stored in memory
      if (defined $self->{_data}) {
          $tmp           = $self->{_data};
          $self->{_data} = undef;
          my $fh         = $self->{_filehandle};
          seek($fh, 0, 0) if $self->{_using_tmpfile};
          return $tmp;
      }
  
      # Return data stored on disk
      if ($self->{_using_tmpfile}) {
          return $tmp if read($self->{_filehandle}, $tmp, $buffer);
      }
  
      # No data to return
      return undef;
  }
  
  
  ###############################################################################
  #
  # close()
  #
  # Calls finalization methods and explicitly close the OLEwriter file
  # handle.
  #
  sub close {
  
      my $self = shift;
  
      return if $self->{_fileclosed}; # Prevent close() from being called twice.
  
      $self->{_fileclosed} = 1;
  
      return $self->_store_workbook();
  }
  
  
  ###############################################################################
  #
  # DESTROY()
  #
  # Close the workbook if it hasn't already been explicitly closed.
  #
  sub DESTROY {
  
      my $self = shift;
  
      local ($@, $!, $^E, $?);
  
      $self->close() if not $self->{_fileclosed};
  }
  
  
  ###############################################################################
  #
  # sheets(slice,...)
  #
  # An accessor for the _worksheets[] array
  #
  # Returns: an optionally sliced list of the worksheet objects in a workbook.
  #
  sub sheets {
  
      my $self = shift;
  
      if (@_) {
          # Return a slice of the array
          return @{$self->{_worksheets}}[@_];
      }
      else {
          # Return the entire list
          return @{$self->{_worksheets}};
      }
  }
  
  
  ###############################################################################
  #
  # worksheets()
  #
  # An accessor for the _worksheets[] array.
  # This method is now deprecated. Use the sheets() method instead.
  #
  # Returns: an array reference
  #
  sub worksheets {
  
      my $self = shift;
  
      return $self->{_worksheets};
  }
  
  
  ###############################################################################
  #
  # add_worksheet($name, $encoding)
  #
  # Add a new worksheet to the Excel workbook.
  #
  # Returns: reference to a worksheet object
  #
  sub add_worksheet {
  
      my $self     = shift;
      my $index    = @{$self->{_worksheets}};
  
      my ($name, $encoding) = $self->_check_sheetname($_[0], $_[1]);
  
  
      # Porters take note, the following scheme of passing references to Workbook
      # data (in the \$self->{_foo} cases) instead of a reference to the Workbook
      # itself is a workaround to avoid circular references between Workbook and
      # Worksheet objects. Feel free to implement this in any way the suits your
      # language.
      #
      my @init_data = (
                           $name,
                           $index,
                           $encoding,
                          \$self->{_activesheet},
                          \$self->{_firstsheet},
                           $self->{_url_format},
                           $self->{_parser},
                           $self->{_tempdir},
                          \$self->{_str_total},
                          \$self->{_str_unique},
                          \$self->{_str_table},
                           $self->{_1904},
                           $self->{_compatibility},
                           undef, # Palette. Not used yet. See add_chart().
                      );
  
      my $worksheet = Spreadsheet::WriteExcel::Worksheet->new(@init_data);
      $self->{_worksheets}->[$index] = $worksheet;     # Store ref for iterator
      $self->{_sheetnames}->[$index] = $name;          # Store EXTERNSHEET names
      $self->{_parser}->set_ext_sheets($name, $index); # Store names in Formula.pm
      return $worksheet;
  }
  
  # Older method name for backwards compatibility.
  *addworksheet = *add_worksheet;
  
  
  ###############################################################################
  #
  # add_chart(%args)
  #
  # Create a chart for embedding or as as new sheet.
  #
  #
  sub add_chart {
  
      my $self     = shift;
      my %arg      = @_;
      my $name     = '';
      my $encoding = 0;
      my $index    = @{ $self->{_worksheets} };
  
      # Type must be specified so we can create the required chart instance.
      my $type = $arg{type};
      if ( !defined $type ) {
          croak "Must define chart type in add_chart()";
      }
  
      # Ensure that the chart defaults to non embedded.
      my $embedded = $arg{embedded} ||= 0;
  
      # Check the worksheet name for non-embedded charts.
      if ( !$embedded ) {
          ( $name, $encoding ) =
            $self->_check_sheetname( $arg{name}, $arg{name_encoding}, 1 );
      }
  
      my @init_data = (
                           $name,
                           $index,
                           $encoding,
                          \$self->{_activesheet},
                          \$self->{_firstsheet},
                           $self->{_url_format},
                           $self->{_parser},
                           $self->{_tempdir},
                          \$self->{_str_total},
                          \$self->{_str_unique},
                          \$self->{_str_table},
                           $self->{_1904},
                           $self->{_compatibility},
                           $self->{_palette},
                      );
  
      my $chart = Spreadsheet::WriteExcel::Chart->factory( $type, @init_data );
  
      # If the chart isn't embedded let the workbook control it.
      if ( !$embedded ) {
          $self->{_worksheets}->[$index] = $chart;    # Store ref for iterator
          $self->{_sheetnames}->[$index] = $name;     # Store EXTERNSHEET names
      }
      else {
          # Set index to 0 so that the activate() and set_first_sheet() methods
          # point back to the first worksheet if used for embedded charts.
          $chart->{_index} = 0;
  
          $chart->_set_embedded_config_data();
      }
  
      return $chart;
  }
  
  
  ###############################################################################
  #
  # add_chart_ext($filename, $name)
  #
  # Add an externally created chart.
  #
  #
  sub add_chart_ext {
  
      my $self     = shift;
      my $filename = $_[0];
      my $index    = @{$self->{_worksheets}};
      my $type     = 'external';
  
      my ($name, $encoding) = $self->_check_sheetname($_[1], $_[2]);
  
  
      my @init_data = (
                           $filename,
                           $name,
                           $index,
                           $encoding,
                          \$self->{_activesheet},
                          \$self->{_firstsheet},
                      );
  
      my $chart = Spreadsheet::WriteExcel::Chart->factory($type, @init_data);
      $self->{_worksheets}->[$index] = $chart;         # Store ref for iterator
      $self->{_sheetnames}->[$index] = $name;          # Store EXTERNSHEET names
  
      return $chart;
  }
  
  
  ###############################################################################
  #
  # _check_sheetname($name, $encoding)
  #
  # Check for valid worksheet names. We check the length, if it contains any
  # invalid characters and if the name is unique in the workbook.
  #
  sub _check_sheetname {
  
      my $self            = shift;
      my $name            = $_[0] || "";
      my $encoding        = $_[1] || 0;
      my $chart           = $_[2] || 0;
      my $limit           = $encoding ? 62 : 31;
      my $invalid_char    = qr([\[\]:*?/\\]);
  
      # Increment the Sheet/Chart number used for default sheet names below.
      if ( $chart ) {
          $self->{_chart_count}++;
      }
      else {
          $self->{_sheet_count}++;
      }
  
      # Supply default Sheet/Chart name if none has been defined.
      if ( $name eq "" ) {
          $encoding = 0;
  
          if ( $chart ) {
              $name = $self->{_chart_name} . $self->{_chart_count};
          }
          else {
              $name = $self->{_sheet_name} . $self->{_sheet_count};
          }
      }
  
  
      # Check that sheetname is <= 31 (1 or 2 byte chars). Excel limit.
      croak "Sheetname $name must be <= 31 chars" if length $name > $limit;
  
      # Check that Unicode sheetname has an even number of bytes
      croak 'Odd number of bytes in Unicode worksheet name:' . $name
            if $encoding == 1 and length($name) % 2;
  
  
      # Check that sheetname doesn't contain any invalid characters
      if ($encoding != 1 and $name =~ $invalid_char) {
          # Check ASCII names
          croak 'Invalid character []:*?/\\ in worksheet name: ' . $name;
      }
      else {
          # Extract any 8bit clean chars from the UTF16 name and validate them.
          for my $wchar ($name =~ /../sg) {
              my ($hi, $lo) = unpack "aa", $wchar;
              if ($hi eq "\0" and $lo =~ $invalid_char) {
                  croak 'Invalid character []:*?/\\ in worksheet name: ' . $name;
              }
          }
      }
  
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($name)) {
              $name = Encode::encode("UTF-16BE", $name);
              $encoding = 1;
          }
      }
  
  
      # Check that the worksheet name doesn't already exist since this is a fatal
      # error in Excel 97. The check must also exclude case insensitive matches
      # since the names 'Sheet1' and 'sheet1' are equivalent. The tests also have
      # to take the encoding into account.
      #
      foreach my $worksheet (@{$self->{_worksheets}}) {
          my $name_a  = $name;
          my $encd_a  = $encoding;
          my $name_b  = $worksheet->{_name};
          my $encd_b  = $worksheet->{_encoding};
          my $error   = 0;
  
          if    ($encd_a == 0 and $encd_b == 0) {
              $error  = 1 if lc($name_a) eq lc($name_b);
          }
          elsif ($encd_a == 0 and $encd_b == 1) {
              $name_a = pack "n*", unpack "C*", $name_a;
              $error  = 1 if lc($name_a) eq lc($name_b);
          }
          elsif ($encd_a == 1 and $encd_b == 0) {
              $name_b = pack "n*", unpack "C*", $name_b;
              $error  = 1 if lc($name_a) eq lc($name_b);
          }
          elsif ($encd_a == 1 and $encd_b == 1) {
              # We can do a true case insensitive test with Perl 5.8 and utf8.
              if ($] >= 5.008) {
                  $name_a = Encode::decode("UTF-16BE", $name_a);
                  $name_b = Encode::decode("UTF-16BE", $name_b);
                  $error  = 1 if lc($name_a) eq lc($name_b);
              }
              else {
              # We can't easily do a case insensitive test of the UTF16 names.
              # As a special case we check if all of the high bytes are nulls and
              # then do an ASCII style case insensitive test.
  
                  # Strip out the high bytes (funkily).
                  my $hi_a = grep {ord} $name_a =~ /(.)./sg;
                  my $hi_b = grep {ord} $name_b =~ /(.)./sg;
  
                  if ($hi_a or $hi_b) {
                      $error  = 1 if    $name_a  eq    $name_b;
                  }
                  else {
                      $error  = 1 if lc($name_a) eq lc($name_b);
                  }
              }
          }
  
          # If any of the cases failed we throw the error here.
          if ($error) {
              croak "Worksheet name '$name', with case ignored, " .
                    "is already in use";
          }
      }
  
      return ($name,  $encoding);
  }
  
  
  ###############################################################################
  #
  # add_format(%properties)
  #
  # Add a new format to the Excel workbook. This adds an XF record and
  # a FONT record. Also, pass any properties to the Format::new().
  #
  sub add_format {
  
      my $self = shift;
  
      my $format = Spreadsheet::WriteExcel::Format->new($self->{_xf_index}, @_);
  
      $self->{_xf_index} += 1;
      push @{$self->{_formats}}, $format; # Store format reference
  
      return $format;
  }
  
  # Older method name for backwards compatibility.
  *addformat = *add_format;
  
  
  ###############################################################################
  #
  # compatibility_mode()
  #
  # Set the compatibility mode.
  #
  # Excel doesn't require every possible Biff record to be present in a file.
  # In particular if the indexing records INDEX, ROW and DBCELL aren't present
  # it just ignores the fact and reads the cells anyway. This is also true of
  # the EXTSST record. Gnumeric and OOo also take this approach. This allows
  # WriteExcel to ignore these records in order to minimise the amount of data
  # stored in memory. However, other third party applications that read Excel
  # files often expect these records to be present. In "compatibility mode"
  # WriteExcel writes these records and tries to be as close to an Excel
  # generated file as possible.
  #
  # This requires additional data to be stored in memory until the file is
  # about to be written. This incurs a memory and speed penalty and may not be
  # suitable for very large files.
  #
  sub compatibility_mode {
  
      my $self      = shift;
  
      croak "compatibility_mode() must be called before add_worksheet()"
            if $self->sheets();
  
      if (defined($_[0])) {
          $self->{_compatibility} = $_[0];
      }
      else {
          $self->{_compatibility} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # set_1904()
  #
  # Set the date system: 0 = 1900 (the default), 1 = 1904
  #
  sub set_1904 {
  
      my $self      = shift;
  
      croak "set_1904() must be called before add_worksheet()"
            if $self->sheets();
  
  
      if (defined($_[0])) {
          $self->{_1904} = $_[0];
      }
      else {
          $self->{_1904} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # get_1904()
  #
  # Return the date system: 0 = 1900, 1 = 1904
  #
  sub get_1904 {
  
      my $self = shift;
  
      return $self->{_1904};
  }
  
  
  ###############################################################################
  #
  # set_custom_color()
  #
  # Change the RGB components of the elements in the colour palette.
  #
  sub set_custom_color {
  
      my $self    = shift;
  
  
      # Match a HTML #xxyyzz style parameter
      if (defined $_[1] and $_[1] =~ /^#(\w\w)(\w\w)(\w\w)/ ) {
          @_ = ($_[0], hex $1, hex $2, hex $3);
      }
  
  
      my $index   = $_[0] || 0;
      my $red     = $_[1] || 0;
      my $green   = $_[2] || 0;
      my $blue    = $_[3] || 0;
  
      my $aref    = $self->{_palette};
  
      # Check that the colour index is the right range
      if ($index < 8 or $index > 64) {
          carp "Color index $index outside range: 8 <= index <= 64";
          return 0;
      }
  
      # Check that the colour components are in the right range
      if ( ($red   < 0 or $red   > 255) ||
           ($green < 0 or $green > 255) ||
           ($blue  < 0 or $blue  > 255) )
      {
          carp "Color component outside range: 0 <= color <= 255";
          return 0;
      }
  
      $index -=8; # Adjust colour index (wingless dragonfly)
  
      # Set the RGB value
      $aref->[$index] = [$red, $green, $blue, 0];
  
      return $index +8;
  }
  
  
  ###############################################################################
  #
  # set_palette_xl97()
  #
  # Sets the colour palette to the Excel 97+ default.
  #
  sub set_palette_xl97 {
  
      my $self = shift;
  
      $self->{_palette} = [
                              [0x00, 0x00, 0x00, 0x00],   # 8
                              [0xff, 0xff, 0xff, 0x00],   # 9
                              [0xff, 0x00, 0x00, 0x00],   # 10
                              [0x00, 0xff, 0x00, 0x00],   # 11
                              [0x00, 0x00, 0xff, 0x00],   # 12
                              [0xff, 0xff, 0x00, 0x00],   # 13
                              [0xff, 0x00, 0xff, 0x00],   # 14
                              [0x00, 0xff, 0xff, 0x00],   # 15
                              [0x80, 0x00, 0x00, 0x00],   # 16
                              [0x00, 0x80, 0x00, 0x00],   # 17
                              [0x00, 0x00, 0x80, 0x00],   # 18
                              [0x80, 0x80, 0x00, 0x00],   # 19
                              [0x80, 0x00, 0x80, 0x00],   # 20
                              [0x00, 0x80, 0x80, 0x00],   # 21
                              [0xc0, 0xc0, 0xc0, 0x00],   # 22
                              [0x80, 0x80, 0x80, 0x00],   # 23
                              [0x99, 0x99, 0xff, 0x00],   # 24
                              [0x99, 0x33, 0x66, 0x00],   # 25
                              [0xff, 0xff, 0xcc, 0x00],   # 26
                              [0xcc, 0xff, 0xff, 0x00],   # 27
                              [0x66, 0x00, 0x66, 0x00],   # 28
                              [0xff, 0x80, 0x80, 0x00],   # 29
                              [0x00, 0x66, 0xcc, 0x00],   # 30
                              [0xcc, 0xcc, 0xff, 0x00],   # 31
                              [0x00, 0x00, 0x80, 0x00],   # 32
                              [0xff, 0x00, 0xff, 0x00],   # 33
                              [0xff, 0xff, 0x00, 0x00],   # 34
                              [0x00, 0xff, 0xff, 0x00],   # 35
                              [0x80, 0x00, 0x80, 0x00],   # 36
                              [0x80, 0x00, 0x00, 0x00],   # 37
                              [0x00, 0x80, 0x80, 0x00],   # 38
                              [0x00, 0x00, 0xff, 0x00],   # 39
                              [0x00, 0xcc, 0xff, 0x00],   # 40
                              [0xcc, 0xff, 0xff, 0x00],   # 41
                              [0xcc, 0xff, 0xcc, 0x00],   # 42
                              [0xff, 0xff, 0x99, 0x00],   # 43
                              [0x99, 0xcc, 0xff, 0x00],   # 44
                              [0xff, 0x99, 0xcc, 0x00],   # 45
                              [0xcc, 0x99, 0xff, 0x00],   # 46
                              [0xff, 0xcc, 0x99, 0x00],   # 47
                              [0x33, 0x66, 0xff, 0x00],   # 48
                              [0x33, 0xcc, 0xcc, 0x00],   # 49
                              [0x99, 0xcc, 0x00, 0x00],   # 50
                              [0xff, 0xcc, 0x00, 0x00],   # 51
                              [0xff, 0x99, 0x00, 0x00],   # 52
                              [0xff, 0x66, 0x00, 0x00],   # 53
                              [0x66, 0x66, 0x99, 0x00],   # 54
                              [0x96, 0x96, 0x96, 0x00],   # 55
                              [0x00, 0x33, 0x66, 0x00],   # 56
                              [0x33, 0x99, 0x66, 0x00],   # 57
                              [0x00, 0x33, 0x00, 0x00],   # 58
                              [0x33, 0x33, 0x00, 0x00],   # 59
                              [0x99, 0x33, 0x00, 0x00],   # 60
                              [0x99, 0x33, 0x66, 0x00],   # 61
                              [0x33, 0x33, 0x99, 0x00],   # 62
                              [0x33, 0x33, 0x33, 0x00],   # 63
                          ];
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # set_tempdir()
  #
  # Change the default temp directory used by _initialize() in Worksheet.pm.
  #
  sub set_tempdir {
  
      my $self = shift;
  
      # Windows workaround. See Worksheet::_initialize()
      my $dir  = shift || '';
  
      croak "$dir is not a valid directory"       if $dir ne '' and not -d $dir;
      croak "set_tempdir must be called before add_worksheet" if $self->sheets();
  
      $self->{_tempdir} = $dir ;
  }
  
  
  ###############################################################################
  #
  # set_codepage()
  #
  # See also the _store_codepage method. This is used to store the code page, i.e.
  # the character set used in the workbook.
  #
  sub set_codepage {
  
      my $self        = shift;
  
      my $codepage    = $_[0] || 1;
         $codepage    = 0x04E4 if $codepage == 1;
         $codepage    = 0x8000 if $codepage == 2;
  
      $self->{_codepage} = $codepage;
  }
  
  
  ###############################################################################
  #
  # set_country()
  #
  # See also the _store_country method. This is used to store the country code.
  # Some non-english versions of Excel may need this set to some value other
  # than 1 = "United States". In general the country code is equal to the
  # international dialling code.
  #
  sub set_country {
  
      my $self            = shift;
  
      $self->{_country}   = $_[0] || 1;
  }
  
  
  
  
  
  
  
  ###############################################################################
  #
  # define_name()
  #
  # TODO.
  #
  sub define_name {
  
      my $self        = shift;
      my $name        = shift;
      my $formula     = shift;
      my $encoding    = shift || 0;
      my $sheet_index = 0;
      my @tokens;
  
      my $full_name   = $name;
  
      if ($name =~ /^(.*)!(.*)$/) {
          my $sheetname   = $1;
          $name           = $2;
          $sheet_index    = 1 + $self->{_parser}->_get_sheet_index($sheetname);
      }
  
  
  
      # Strip the = sign at the beginning of the formula string
      $formula    =~ s(^=)();
  
      # Parse the formula using the parser in Formula.pm
      my $parser  = $self->{_parser};
  
      # In order to raise formula errors from the point of view of the calling
      # program we use an eval block and re-raise the error from here.
      #
      eval { @tokens = $parser->parse_formula($formula) };
  
      if ($@) {
          $@ =~ s/\n$//;  # Strip the \n used in the Formula.pm die()
          croak $@;       # Re-raise the error
      }
  
      # Force 2d ranges to be a reference class.
      s/_ref3d/_ref3dR/     for @tokens;
      s/_range3d/_range3dR/ for @tokens;
  
  
      # Parse the tokens into a formula string.
      $formula = $parser->parse_tokens(@tokens);
  
  
  
      $full_name = lc $full_name;
  
      push @{$self->{_defined_names}},   {
                                              name        => $name,
                                              encoding    => $encoding,
                                              sheet_index => $sheet_index,
                                              formula     => $formula,
                                          };
  
      my $index = scalar @{$self->{_defined_names}};
  
      $parser->set_ext_name($name, $index);
  }
  
  
  
  
  
  
  
  
  
  ###############################################################################
  #
  # set_properties()
  #
  # Set the document properties such as Title, Author etc. These are written to
  # property sets in the OLE container.
  #
  sub set_properties {
  
      my $self    = shift;
      my %param;
  
      # Ignore if no args were passed.
      return -1 unless @_;
  
  
      # Allow the parameters to be passed as a hash or hash ref.
      if (ref $_[0] eq 'HASH') {
          %param = %{$_[0]};
      }
      else {
          %param = @_;
      }
  
  
      # List of valid input parameters.
      my %properties = (
                            codepage      => [0x0001, 'VT_I2'      ],
                            title         => [0x0002, 'VT_LPSTR'   ],
                            subject       => [0x0003, 'VT_LPSTR'   ],
                            author        => [0x0004, 'VT_LPSTR'   ],
                            keywords      => [0x0005, 'VT_LPSTR'   ],
                            comments      => [0x0006, 'VT_LPSTR'   ],
                            last_author   => [0x0008, 'VT_LPSTR'   ],
                            created       => [0x000C, 'VT_FILETIME'],
                            category      => [0x0002, 'VT_LPSTR'   ],
                            manager       => [0x000E, 'VT_LPSTR'   ],
                            company       => [0x000F, 'VT_LPSTR'   ],
                            utf8          => 1,
                        );
  
      # Check for valid input parameters.
      for my $parameter (keys %param) {
          if (not exists $properties{$parameter}) {
              carp "Unknown parameter '$parameter' in set_properties()";
              return -1;
          }
      }
  
  
      # Set the creation time unless specified by the user.
      if (!exists $param{created}){
          $param{created} = $self->{_localtime};
      }
  
  
      #
      # Create the SummaryInformation property set.
      #
  
      # Get the codepage of the strings in the property set.
      my @strings      = qw(title subject author keywords comments last_author);
      $param{codepage} = $self->_get_property_set_codepage(\%param,
                                                           \@strings);
  
      # Create an array of property set values.
      my @property_sets;
  
      for my $property (qw(codepage title    subject     author
                           keywords comments last_author created))
      {
          if (exists $param{$property} && defined $param{$property}) {
              push @property_sets, [
                                      $properties{$property}->[0],
                                      $properties{$property}->[1],
                                      $param{$property}
                                   ];
          }
      }
  
      # Pack the property sets.
      $self->{summary} = create_summary_property_set(\@property_sets);
  
  
      #
      # Create the DocSummaryInformation property set.
      #
  
      # Get the codepage of the strings in the property set.
      @strings         = qw(category manager company);
      $param{codepage} = $self->_get_property_set_codepage(\%param,
                                                           \@strings);
  
      # Create an array of property set values.
      @property_sets = ();
  
      for my $property (qw(codepage category manager company))
      {
          if (exists $param{$property} && defined $param{$property}) {
              push @property_sets, [
                                      $properties{$property}->[0],
                                      $properties{$property}->[1],
                                      $param{$property}
                                   ];
          }
      }
  
      # Pack the property sets.
      $self->{doc_summary} = create_doc_summary_property_set(\@property_sets);
  
      # Set a flag for when the files is written.
      $self->{_add_doc_properties} = 1;
  }
  
  
  ###############################################################################
  #
  # _get_property_set_codepage()
  #
  # Get the character codepage used by the strings in a property set. If one of
  # the strings used is utf8 then the codepage is marked as utf8. Otherwise
  # Latin 1 is used (although in our case this is limited to 7bit ASCII).
  #
  sub _get_property_set_codepage {
  
      my $self        = shift;
  
      my $params      = $_[0];
      my $strings     = $_[1];
  
      # Allow for manually marked utf8 strings.
      return 0xFDE9 if defined $params->{utf8};
  
      # Check for utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
          for my $string (@{$strings }) {
              next unless exists $params->{$string};
              return 0xFDE9 if Encode::is_utf8($params->{$string});
          }
      }
  
      return 0x04E4; # Default codepage, Latin 1.
  }
  
  
  ###############################################################################
  #
  # _store_workbook()
  #
  # Assemble worksheets into a workbook and send the BIFF data to an OLE
  # storage.
  #
  sub _store_workbook {
  
      my $self = shift;
  
      # Add a default worksheet if non have been added.
      $self->add_worksheet() if not @{$self->{_worksheets}};
  
      # Calculate size required for MSO records and update worksheets.
      $self->_calc_mso_sizes();
  
      # Ensure that at least one worksheet has been selected.
      if ($self->{_activesheet} == 0) {
          @{$self->{_worksheets}}[0]->{_selected} = 1;
          @{$self->{_worksheets}}[0]->{_hidden}   = 0;
      }
  
      # Calculate the number of selected sheet tabs and set the active sheet.
      foreach my $sheet (@{$self->{_worksheets}}) {
          $self->{_selected}++ if $sheet->{_selected};
          $sheet->{_active} = 1 if $sheet->{_index} == $self->{_activesheet};
      }
  
      # Add Workbook globals
      $self->_store_bof(0x0005);
      $self->_store_codepage();
      $self->_store_window1();
      $self->_store_hideobj();
      $self->_store_1904();
      $self->_store_all_fonts();
      $self->_store_all_num_formats();
      $self->_store_all_xfs();
      $self->_store_all_styles();
      $self->_store_palette();
  
      # Calculate the offsets required by the BOUNDSHEET records
      $self->_calc_sheet_offsets();
  
      # Add BOUNDSHEET records.
      foreach my $sheet (@{$self->{_worksheets}}) {
          $self->_store_boundsheet($sheet->{_name},
                                   $sheet->{_offset},
                                   $sheet->{_sheet_type},
                                   $sheet->{_hidden},
                                   $sheet->{_encoding});
      }
  
      # NOTE: If any records are added between here and EOF the
      # _calc_sheet_offsets() should be updated to include the new length.
      $self->_store_country();
      if ($self->{_ext_ref_count}) {
          $self->_store_supbook();
          $self->_store_externsheet();
          $self->_store_names();
      }
      $self->_add_mso_drawing_group();
      $self->_store_shared_strings();
      $self->_store_extsst();
  
      # End Workbook globals
      $self->_store_eof();
  
      # Store the workbook in an OLE container
      return $self->_store_OLE_file();
  }
  
  
  ###############################################################################
  #
  # _store_OLE_file()
  #
  # Store the workbook in an OLE container using the default handler or using
  # OLE::Storage_Lite if the workbook data is > ~ 7MB.
  #
  sub _store_OLE_file {
  
      my $self    = shift;
      my $maxsize = 7_087_104;
  
      if (!$self->{_add_doc_properties} && $self->{_biffsize} <= $maxsize) {
          # Write the OLE file using OLEwriter if data <= 7MB
          my $OLE  = Spreadsheet::WriteExcel::OLEwriter->new($self->{_fh_out});
  
          # Write the BIFF data without the OLE container for testing.
          $OLE->{_biff_only} = $self->{_biff_only};
  
          # Indicate that we created the filehandle and want to close it.
          $OLE->{_internal_fh} = $self->{_internal_fh};
  
          $OLE->set_size($self->{_biffsize});
          $OLE->write_header();
  
          while (my $tmp = $self->get_data()) {
              $OLE->write($tmp);
          }
  
          foreach my $worksheet (@{$self->{_worksheets}}) {
              while (my $tmp = $worksheet->get_data()) {
                  $OLE->write($tmp);
              }
          }
  
          return $OLE->close();
      }
      else {
          # Write the OLE file using OLE::Storage_Lite if data > 7MB
          eval { require OLE::Storage_Lite };
  
          if (not $@) {
  
              # Protect print() from -l on the command line.
              local $\ = undef;
  
              my @streams;
  
              # Create the Workbook stream.
              my $stream   = pack 'v*', unpack 'C*', 'Workbook';
              my $workbook = OLE::Storage_Lite::PPS::File->newFile($stream);
  
              while (my $tmp = $self->get_data()) {
                  $workbook->append($tmp);
              }
  
              foreach my $worksheet (@{$self->{_worksheets}}) {
                  while (my $tmp = $worksheet->get_data()) {
                      $workbook->append($tmp);
                  }
              }
  
              push @streams, $workbook;
  
  
              # Create the properties streams, if any.
              if ($self->{_add_doc_properties}) {
                  my $stream;
                  my $summary;
  
                  $stream  = pack 'v*', unpack 'C*', "\5SummaryInformation";
                  $summary = $self->{summary};
                  $summary = OLE::Storage_Lite::PPS::File->new($stream, $summary);
                  push @streams, $summary;
  
                  $stream  = pack 'v*', unpack 'C*', "\5DocumentSummaryInformation";
                  $summary = $self->{doc_summary};
                  $summary = OLE::Storage_Lite::PPS::File->new($stream, $summary);
                  push @streams, $summary;
              }
  
              # Create the OLE root document and add the substreams.
              my @localtime = @{ $self->{_localtime} };
              splice(@localtime, 6);
  
              my $ole_root = OLE::Storage_Lite::PPS::Root->new(\@localtime,
                                                               \@localtime,
                                                               \@streams);
              $ole_root->save($self->{_filename});
  
  
              # Close the filehandle if it was created internally.
              return CORE::close($self->{_fh_out}) if $self->{_internal_fh};
          }
          else {
              # File in greater than limit, set $! to "File too large"
              $! = 27; # Perl error code "File too large"
  
              croak "Maximum Spreadsheet::WriteExcel filesize, $maxsize bytes, ".
                    "exceeded. To create files bigger than this limit please "  .
                    "install OLE::Storage_Lite\n";
  
              # return 0;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _calc_sheet_offsets()
  #
  # Calculate Worksheet BOF offsets records for use in the BOUNDSHEET records.
  #
  sub _calc_sheet_offsets {
  
      my $self    = shift;
      my $BOF     = 12;
      my $EOF     = 4;
      my $offset  = $self->{_datasize};
  
      # Add the length of the COUNTRY record
      $offset += 8;
  
      # Add the length of the SST and associated CONTINUEs
      $offset += $self->_calculate_shared_string_sizes();
  
      # Add the length of the EXTSST record.
      $offset += $self->_calculate_extsst_size();
  
      # Add the length of the SUPBOOK, EXTERNSHEET and NAME records
      $offset += $self->_calculate_extern_sizes();
  
      # Add the length of the MSODRAWINGGROUP records including an extra 4 bytes
      # for any CONTINUE headers. See _add_mso_drawing_group_continue().
      my $mso_size = $self->{_mso_size};
      $mso_size += 4 * int(($mso_size -1) / $self->{_limit});
      $offset   += $mso_size ;
  
      foreach my $sheet (@{$self->{_worksheets}}) {
          $offset += $BOF + length($sheet->{_name});
      }
  
      $offset += $EOF;
  
      foreach my $sheet (@{$self->{_worksheets}}) {
          $sheet->{_offset} = $offset;
          $sheet->_close();
          $offset += $sheet->{_datasize};
      }
  
      $self->{_biffsize} = $offset;
  }
  
  
  ###############################################################################
  #
  # _calc_mso_sizes()
  #
  # Calculate the MSODRAWINGGROUP sizes and the indexes of the Worksheet
  # MSODRAWING records.
  #
  # In the following SPID is shape id, according to Escher nomenclature.
  #
  sub _calc_mso_sizes {
  
      my $self            = shift;
  
      my $mso_size        = 0;    # Size of the MSODRAWINGGROUP record
      my $start_spid      = 1024; # Initial spid for each sheet
      my $max_spid        = 1024; # spidMax
      my $num_clusters    = 1;    # cidcl
      my $shapes_saved    = 0;    # cspSaved
      my $drawings_saved  = 0;    # cdgSaved
      my @clusters        = ();
  
  
      $self->_process_images();
  
      # Add Bstore container size if there are images.
      $mso_size += 8 if @{$self->{_images_data}};
  
  
      # Iterate through the worksheets, calculate the MSODRAWINGGROUP parameters
      # and space required to store the record and the MSODRAWING parameters
      # required by each worksheet.
      #
      foreach my $sheet (@{$self->{_worksheets}}) {
          next unless $sheet->{_sheet_type} == 0x0000; # Ignore charts.
  
          my $num_images     = $sheet->{_num_images} || 0;
          my $image_mso_size = $sheet->{_image_mso_size} || 0;
          my $num_comments   = $sheet->_prepare_comments();
          my $num_charts     = $sheet->_prepare_charts();
          my $num_filters    = $sheet->{_filter_count};
  
          next unless $num_images + $num_comments + $num_charts +$num_filters;
  
  
          # Include 1 parent MSODRAWING shape, per sheet, in the shape count.
          my $num_shapes   += 1 + $num_images
                                + $num_comments
                                + $num_charts
                                + $num_filters;
             $shapes_saved += $num_shapes;
             $mso_size     += $image_mso_size;
  
  
          # Add a drawing object for each sheet with comments.
          $drawings_saved++;
  
  
          # For each sheet start the spids at the next 1024 interval.
          $max_spid   = 1024 * (1 + int(($max_spid -1)/1024));
          $start_spid = $max_spid;
  
  
          # Max spid for each sheet and eventually for the workbook.
          $max_spid  += $num_shapes;
  
  
          # Store the cluster ids
          for (my $i = $num_shapes; $i > 0; $i -= 1024) {
              $num_clusters  += 1;
              $mso_size      += 8;
              my $size        = $i > 1024 ? 1024 : $i;
  
              push @clusters, [$drawings_saved, $size];
          }
  
  
          # Pass calculated values back to the worksheet
          $sheet->{_object_ids} = [$start_spid, $drawings_saved,
                                    $num_shapes, $max_spid -1];
      }
  
  
      # Calculate the MSODRAWINGGROUP size if we have stored some shapes.
      $mso_size              += 86 if $mso_size; # Smallest size is 86+8=94
  
  
      $self->{_mso_size}      = $mso_size;
      $self->{_mso_clusters}  = [
                                  $max_spid, $num_clusters, $shapes_saved,
                                  $drawings_saved, [@clusters]
                                ];
  }
  
  
  
  ###############################################################################
  #
  # _process_images()
  #
  # We need to process each image in each worksheet and extract information.
  # Some of this information is stored and used in the Workbook and some is
  # passed back into each Worksheet. The overall size for the image related
  # BIFF structures in the Workbook is calculated here.
  #
  # MSO size =  8 bytes for bstore_container +
  #            44 bytes for blip_store_entry +
  #            25 bytes for blip
  #          = 77 + image size.
  #
  sub _process_images {
  
      my $self = shift;
  
      my %images_seen;
      my @image_data;
      my @previous_images;
      my $image_id    = 1;
      my $images_size = 0;
  
  
      foreach my $sheet (@{$self->{_worksheets}}) {
          next unless $sheet->{_sheet_type} == 0x0000; # Ignore charts.
          next unless $sheet->_prepare_images();
  
          my $num_images      = 0;
          my $image_mso_size  = 0;
  
  
          for my $image_ref (@{$sheet->{_images_array}}) {
              my $filename = $image_ref->[2];
              $num_images++;
  
              #
              # For each Worksheet image we get a structure like this
              # [
              #   $row,
              #   $col,
              #   $name,
              #   $x_offset,
              #   $y_offset,
              #   $scale_x,
              #   $scale_y,
              # ]
              #
              # And we add additional information:
              #
              #   $image_id,
              #   $type,
              #   $width,
              #   $height;
  
              if (not exists $images_seen{$filename}) {
                  # TODO should also match seen images based on checksum.
  
                  # Open the image file and import the data.
                  my $fh = FileHandle->new($filename);
                  croak "Couldn't import $filename: $!" unless defined $fh;
                  binmode $fh;
  
                  # Slurp the file into a string and do some size calcs.
                  my $data        = do {local $/; <$fh>};
                  my $size        = length $data;
                  my $checksum1   = $self->_image_checksum($data, $image_id);
                  my $checksum2   = $checksum1;
                  my $ref_count   = 1;
  
  
                  # Process the image and extract dimensions.
                  my ($type, $width, $height);
  
                  # Test for PNGs...
                  if    (unpack('x A3', $data) eq 'PNG') {
                      ($type, $width, $height) = $self->_process_png($data);
                  }
                  # Test for JFIF and Exif JPEGs...
                  elsif ( (unpack('n', $data) == 0xFFD8) &&
                              ( (unpack('x6 A4', $data) eq 'JFIF') ||
                                (unpack('x6 A4', $data) eq 'Exif')
                              )
                        )
                  {
                      ($type, $width, $height) = $self->_process_jpg($data, $filename);
                  }
                  # Test for BMPs...
                  elsif (unpack('A2',   $data) eq 'BM') {
                      ($type, $width, $height) = $self->_process_bmp($data,
                                                                     $filename);
                      # The 14 byte header of the BMP is stripped off.
                      $data       = substr $data, 14;
  
                      # A checksum of the new image data is also required.
                      $checksum2  = $self->_image_checksum($data,
                                                           $image_id,
                                                           $image_id
                                                           );
  
                      # Adjust size -14 (header) + 16 (extra checksum).
                      $size += 2;
                  }
                  else {
                      croak "Unsupported image format for file: $filename\n";
                  }
  
  
                  # Push the new data back into the Worksheet array;
                  push @$image_ref, $image_id, $type, $width, $height;
  
                  # Also store new data for use in duplicate images.
                  push @previous_images, [$image_id, $type, $width, $height];
  
  
                  # Store information required by the Workbook.
                  push @image_data, [$ref_count, $type, $data, $size,
                                     $checksum1, $checksum2];
  
                  # Keep track of overall data size.
                  $images_size       += $size +61; # Size for bstore container.
                  $image_mso_size    += $size +69; # Size for dgg container.
  
                  $images_seen{$filename} = $image_id++;
                  $fh->close;
              }
              else {
                  # We've processed this file already.
                  my $index = $images_seen{$filename} -1;
  
                  # Increase image reference count.
                  $image_data[$index]->[0]++;
  
                  # Add previously calculated data back onto the Worksheet array.
                  # $image_id, $type, $width, $height
                  my $a_ref = $sheet->{_images_array}->[$index];
                  push @$image_ref, @{$previous_images[$index]};
              }
          }
  
          # Store information required by the Worksheet.
          $sheet->{_num_images}     = $num_images;
          $sheet->{_image_mso_size} = $image_mso_size;
  
      }
  
  
      # Store information required by the Workbook.
      $self->{_images_size} = $images_size;
      $self->{_images_data} = \@image_data; # Store the data for MSODRAWINGGROUP.
  
  }
  
  
  ###############################################################################
  #
  # _image_checksum()
  #
  # Generate a checksum for the image using whichever module is available..The
  # available modules are checked in _get_checksum_method(). Excel uses an MD4
  # checksum but any other will do. In the event of no checksum module being
  # available we simulate a checksum using the image index.
  #
  sub _image_checksum {
  
      my $self    = shift;
  
      my $data    = $_[0];
      my $index1  = $_[1];
      my $index2  = $_[2] || 0;
  
      if    ($self->{_checksum_method} == 1) {
          # Digest::MD4
          return Digest::MD4::md4_hex($data);
      }
      elsif ($self->{_checksum_method} == 2) {
          # Digest::Perl::MD4
          return Digest::Perl::MD4::md4_hex($data);
      }
      elsif ($self->{_checksum_method} == 3) {
          # Digest::MD5
          return Digest::MD5::md5_hex($data);
      }
      else {
          # Default
          return sprintf '%016X%016X', $index2, $index1;
      }
  }
  
  
  ###############################################################################
  #
  # _process_png()
  #
  # Extract width and height information from a PNG file.
  #
  sub _process_png {
  
      my $self    = shift;
  
      my $type    = 6; # Excel Blip type (MSOBLIPTYPE).
      my $width   = unpack "N", substr $_[0], 16, 4;
      my $height  = unpack "N", substr $_[0], 20, 4;
  
      return ($type, $width, $height);
  }
  
  
  ###############################################################################
  #
  # _process_bmp()
  #
  # Extract width and height information from a BMP file.
  #
  # Most of these checks came from the old Worksheet::_process_bitmap() method.
  #
  sub _process_bmp {
  
      my $self     = shift;
      my $data     = $_[0];
      my $filename = $_[1];
      my $type     = 7; # Excel Blip type (MSOBLIPTYPE).
  
  
      # Check that the file is big enough to be a bitmap.
      if (length $data <= 0x36) {
          croak "$filename doesn't contain enough data.";
      }
  
  
      # Read the bitmap width and height. Verify the sizes.
      my ($width, $height) = unpack "x18 V2", $data;
  
      if ($width > 0xFFFF) {
          croak "$filename: largest image width $width supported is 65k.";
      }
  
      if ($height > 0xFFFF) {
          croak "$filename: largest image height supported is 65k.";
      }
  
      # Read the bitmap planes and bpp data. Verify them.
      my ($planes, $bitcount) = unpack "x26 v2", $data;
  
      if ($bitcount != 24) {
          croak "$filename isn't a 24bit true color bitmap.";
      }
  
      if ($planes != 1) {
          croak "$filename: only 1 plane supported in bitmap image.";
      }
  
  
      # Read the bitmap compression. Verify compression.
      my $compression = unpack "x30 V", $data;
  
      if ($compression != 0) {
          croak "$filename: compression not supported in bitmap image.";
      }
  
      return ($type, $width, $height);
  }
  
  
  ###############################################################################
  #
  # _process_jpg()
  #
  # Extract width and height information from a JPEG file.
  #
  sub _process_jpg {
  
      my $self     = shift;
      my $data     = $_[0];
      my $filename = $_[1];
      my $type     = 5; # Excel Blip type (MSOBLIPTYPE).
      my $width;
      my $height;
  
      my $offset = 2;
      my $data_length = length $data;
  
      # Search through the image data to find the 0xFFC0 marker. The height and
      # width are contained in the data for that sub element.
      while ($offset < $data_length) {
  
          my $marker  = unpack "n", substr $data, $offset,    2;
          my $length  = unpack "n", substr $data, $offset +2, 2;
  
          if ($marker == 0xFFC0 || $marker == 0xFFC2) {
              $height = unpack "n", substr $data, $offset +5, 2;
              $width  = unpack "n", substr $data, $offset +7, 2;
              last;
          }
  
          $offset = $offset + $length + 2;
          last if $marker == 0xFFDA;
      }
  
      if (not defined $height) {
          croak "$filename: no size data found in jpeg image.\n";
      }
  
      return ($type, $width, $height);
  }
  
  
  ###############################################################################
  #
  # _store_all_fonts()
  #
  # Store the Excel FONT records.
  #
  sub _store_all_fonts {
  
      my $self    = shift;
  
      my $format  = $self->{_formats}->[15]; # The default cell format.
      my $font    = $format->get_font();
  
      # Fonts are 0-indexed. According to the SDK there is no index 4,
      for (0..3) {
          $self->_append($font);
      }
  
  
      # Add the default fonts for charts and comments. This aren't connected
      # to XF formats. Note, the font size, and some other properties of
      # chart fonts are set in the FBI record of the chart.
      my $tmp_format;
  
      # Index 5. Axis numbers.
      $tmp_format = Spreadsheet::WriteExcel::Format->new(
          undef,
          font_only => 1,
      );
      $self->_append( $tmp_format->get_font() );
  
      # Index 6. Series names.
      $tmp_format = Spreadsheet::WriteExcel::Format->new(
          undef,
          font_only => 1,
      );
      $self->_append( $tmp_format->get_font() );
  
      # Index 7. Title.
      $tmp_format = Spreadsheet::WriteExcel::Format->new(
          undef,
          font_only => 1,
          bold      => 1,
      );
      $self->_append( $tmp_format->get_font() );
  
      # Index 8. Axes.
      $tmp_format = Spreadsheet::WriteExcel::Format->new(
          undef,
          font_only => 1,
          bold      => 1,
      );
      $self->_append( $tmp_format->get_font() );
  
      # Index 9. Comments.
      $tmp_format = Spreadsheet::WriteExcel::Format->new(
          undef,
          font_only => 1,
          font      => 'Tahoma',
          size      => 8,
      );
      $self->_append( $tmp_format->get_font() );
  
  
      # Iterate through the XF objects and write a FONT record if it isn't the
      # same as the default FONT and if it hasn't already been used.
      #
      my %fonts;
      my $key;
      my $index = 10;                  # The first user defined FONT
  
      $key = $format->get_font_key(); # The default font for cell formats.
      $fonts{$key} = 0;               # Index of the default font
  
      # Fonts that are marked as '_font_only' are always stored. These are used
      # mainly for charts and may not have an associated XF record.
  
      foreach $format (@{$self->{_formats}}) {
          $key = $format->get_font_key();
  
          if (not $format->{_font_only} and exists $fonts{$key}) {
              # FONT has already been used
              $format->{_font_index} = $fonts{$key};
          }
          else {
              # Add a new FONT record
  
              if (not $format->{_font_only}) {
                  $fonts{$key} = $index;
              }
  
              $format->{_font_index} = $index;
              $index++;
              $font = $format->get_font();
              $self->_append($font);
          }
      }
  }
  
  
  ###############################################################################
  #
  # _store_all_num_formats()
  #
  # Store user defined numerical formats i.e. FORMAT records
  #
  sub _store_all_num_formats {
  
      my $self = shift;
  
      my %num_formats;
      my @num_formats;
      my $num_format;
      my $index = 164; # User defined FORMAT records start from 0xA4
  
  
      # Iterate through the XF objects and write a FORMAT record if it isn't a
      # built-in format type and if the FORMAT string hasn't already been used.
      #
      foreach my $format (@{$self->{_formats}}) {
          my $num_format = $format->{_num_format};
          my $encoding   = $format->{_num_format_enc};
  
          # Check if $num_format is an index to a built-in format.
          # Also check for a string of zeros, which is a valid format string
          # but would evaluate to zero.
          #
          if ($num_format !~ m/^0+\d/) {
              next if $num_format =~ m/^\d+$/; # built-in
          }
  
          if (exists($num_formats{$num_format})) {
              # FORMAT has already been used
              $format->{_num_format} = $num_formats{$num_format};
          }
          else{
              # Add a new FORMAT
              $num_formats{$num_format} = $index;
              $format->{_num_format}    = $index;
              $self->_store_num_format($num_format, $index, $encoding);
              $index++;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _store_all_xfs()
  #
  # Write all XF records.
  #
  sub _store_all_xfs {
  
      my $self = shift;
  
      foreach my $format (@{$self->{_formats}}) {
          my $xf = $format->get_xf();
          $self->_append($xf);
      }
  }
  
  
  ###############################################################################
  #
  # _store_all_styles()
  #
  # Write all STYLE records.
  #
  sub _store_all_styles {
  
      my $self = shift;
  
      # Excel adds the built-in styles in alphabetical order.
      my @built_ins = (
          [0x03, 16], # Comma
          [0x06, 17], # Comma[0]
          [0x04, 18], # Currency
          [0x07, 19], # Currency[0]
          [0x00,  0], # Normal
          [0x05, 20], # Percent
  
          # We don't deal with these styles yet.
          #[0x08, 21], # Hyperlink
          #[0x02,  8], # ColLevel_n
          #[0x01,  1], # RowLevel_n
      );
  
  
      for my $aref (@built_ins) {
          my $type     = $aref->[0];
          my $xf_index = $aref->[1];
  
          $self->_store_style($type, $xf_index);
      }
  }
  
  
  ###############################################################################
  #
  # _store_names()
  #
  # Write the NAME record to define the print area and the repeat rows and cols.
  #
  sub _store_names {
  
      my $self        = shift;
      my $index;
      my %ext_refs    = %{$self->{_ext_refs}};
  
  
      # Create the user defined names.
      for my $defined_name (@{$self->{_defined_names}}) {
  
          $self->_store_name(
              $defined_name->{name},
              $defined_name->{encoding},
              $defined_name->{sheet_index},
              $defined_name->{formula},
          );
      }
  
      # Sort the worksheets into alphabetical order by name. This is a
      # requirement for some non-English language Excel patch levels.
      my @worksheets = @{$self->{_worksheets}};
         @worksheets = sort { $a->{_name} cmp $b->{_name} } @worksheets;
  
      # Create the autofilter NAME records
      foreach my $worksheet (@worksheets) {
          $index  = $worksheet->{_index};
          my $key = "$index:$index";
          my $ref = $ext_refs{$key};
  
          # Write a Name record if Autofilter has been defined
          if ($worksheet->{_filter_count}) {
              $self->_store_name_short(
                  $worksheet->{_index},
                  0x0D, # NAME type = Filter Database
                  $ref,
                  $worksheet->{_filter_area}->[0],
                  $worksheet->{_filter_area}->[1],
                  $worksheet->{_filter_area}->[2],
                  $worksheet->{_filter_area}->[3],
                  1, # Hidden
              );
          }
      }
  
      # Create the print area NAME records
      foreach my $worksheet (@worksheets) {
          $index  = $worksheet->{_index};
          my $key = "$index:$index";
          my $ref = $ext_refs{$key};
  
          # Write a Name record if the print area has been defined
          if (defined $worksheet->{_print_rowmin}) {
              $self->_store_name_short(
                  $worksheet->{_index},
                  0x06, # NAME type = Print_Area
                  $ref,
                  $worksheet->{_print_rowmin},
                  $worksheet->{_print_rowmax},
                  $worksheet->{_print_colmin},
                  $worksheet->{_print_colmax}
              );
          }
      }
  
      # Create the print title NAME records
      foreach my $worksheet (@worksheets) {
          $index  = $worksheet->{_index};
  
          my $rowmin = $worksheet->{_title_rowmin};
          my $rowmax = $worksheet->{_title_rowmax};
          my $colmin = $worksheet->{_title_colmin};
          my $colmax = $worksheet->{_title_colmax};
          my $key    = "$index:$index";
          my $ref    = $ext_refs{$key};
  
          # Determine if row + col, row, col or nothing has been defined
          # and write the appropriate record
          #
          if (defined $rowmin && defined $colmin) {
              # Row and column titles have been defined.
              # Row title has been defined.
              $self->_store_name_long(
                  $worksheet->{_index},
                  0x07, # NAME type = Print_Titles
                  $ref,
                  $rowmin,
                  $rowmax,
                  $colmin,
                  $colmax
             );
          }
          elsif (defined $rowmin) {
              # Row title has been defined.
              $self->_store_name_short(
                  $worksheet->{_index},
                  0x07, # NAME type = Print_Titles
                  $ref,
                  $rowmin,
                  $rowmax,
                  0x00,
                  0xff
              );
          }
          elsif (defined $colmin) {
              # Column title has been defined.
              $self->_store_name_short(
                  $worksheet->{_index},
                  0x07, # NAME type = Print_Titles
                  $ref,
                  0x0000,
                  0xffff,
                  $colmin,
                  $colmax
              );
          }
          else {
              # Nothing left to do
          }
      }
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  #
  # BIFF RECORDS
  #
  
  
  ###############################################################################
  #
  # _store_window1()
  #
  # Write Excel BIFF WINDOW1 record.
  #
  sub _store_window1 {
  
      my $self      = shift;
  
      my $record    = 0x003D;                 # Record identifier
      my $length    = 0x0012;                 # Number of bytes to follow
  
      my $xWn       = 0x0000;                 # Horizontal position of window
      my $yWn       = 0x0000;                 # Vertical position of window
      my $dxWn      = 0x355C;                 # Width of window
      my $dyWn      = 0x30ED;                 # Height of window
  
      my $grbit     = 0x0038;                 # Option flags
      my $ctabsel   = $self->{_selected};     # Number of workbook tabs selected
      my $wTabRatio = 0x0258;                 # Tab to scrollbar ratio
  
      my $itabFirst = $self->{_firstsheet};   # 1st displayed worksheet
      my $itabCur   = $self->{_activesheet};  # Active worksheet
  
      my $header    = pack("vv",        $record, $length);
      my $data      = pack("vvvvvvvvv", $xWn, $yWn, $dxWn, $dyWn,
                                        $grbit,
                                        $itabCur, $itabFirst,
                                        $ctabsel, $wTabRatio);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_boundsheet()
  #
  # Writes Excel BIFF BOUNDSHEET record.
  #
  sub _store_boundsheet {
  
      my $self      = shift;
  
      my $record    = 0x0085;               # Record identifier
      my $length    = 0x08 + length($_[0]); # Number of bytes to follow
  
      my $sheetname = $_[0];                # Worksheet name
      my $offset    = $_[1];                # Location of worksheet BOF
      my $type      = $_[2];                # Worksheet type
      my $hidden    = $_[3];                # Worksheet hidden flag
      my $encoding  = $_[4];                # Sheet name encoding
      my $cch       = length($sheetname);   # Length of sheet name
  
      my $grbit     = $type | $hidden;
  
      # Character length is num of chars not num of bytes
      $cch /= 2 if $encoding;
  
      # Change the UTF-16 name from BE to LE
      $sheetname = pack 'n*', unpack 'v*', $sheetname if $encoding;
  
      my $header    = pack("vv",   $record, $length);
      my $data      = pack("VvCC", $offset, $grbit, $cch, $encoding);
  
      $self->_append($header, $data, $sheetname);
  }
  
  
  ###############################################################################
  #
  # _store_style()
  #
  # Write Excel BIFF STYLE records.
  #
  sub _store_style {
  
      my $self      = shift;
  
      my $record    = 0x0293; # Record identifier
      my $length    = 0x0004; # Bytes to follow
  
      my $type      = $_[0];  # Built-in style
      my $xf_index  = $_[1];  # Index to style XF
      my $level     = 0xff;   # Outline style level
  
      $xf_index    |= 0x8000; # Add flag to indicate built-in style.
  
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("vCC", $xf_index, $type, $level);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_num_format()
  #
  # Writes Excel FORMAT record for non "built-in" numerical formats.
  #
  sub _store_num_format {
  
      my $self      = shift;
  
      my $record    = 0x041E;         # Record identifier
      my $length;                     # Number of bytes to follow
  
      my $format    = $_[0];          # Custom format string
      my $ifmt      = $_[1];          # Format index code
      my $encoding  = $_[2];          # Char encoding for format string
  
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($format)) {
              $format = Encode::encode("UTF-16BE", $format);
              $encoding = 1;
          }
      }
  
  
      # Char length of format string
      my $cch = length $format;
  
  
      # Handle Unicode format strings.
      if ($encoding == 1) {
          croak "Uneven number of bytes in Unicode font name" if $cch % 2;
          $cch    /= 2 if $encoding;
          $format  = pack 'v*', unpack 'n*', $format;
      }
  
  
      # Special case to handle Euro symbol, 0x80, in non-Unicode strings.
      if ($encoding == 0 and $format =~ /\x80/) {
          $format   =  pack 'v*', unpack 'C*', $format;
          $format   =~ s/\x80\x00/\xAC\x20/g;
          $encoding =  1;
      }
  
      $length       = 0x05 + length $format;
  
      my $header    = pack("vv", $record, $length);
      my $data      = pack("vvC", $ifmt, $cch, $encoding);
  
      $self->_append($header, $data, $format);
  }
  
  
  ###############################################################################
  #
  # _store_1904()
  #
  # Write Excel 1904 record to indicate the date system in use.
  #
  sub _store_1904 {
  
      my $self      = shift;
  
      my $record    = 0x0022;         # Record identifier
      my $length    = 0x0002;         # Bytes to follow
  
      my $f1904     = $self->{_1904}; # Flag for 1904 date system
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("v", $f1904);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_supbook()
  #
  # Write BIFF record SUPBOOK to indicate that the workbook contains external
  # references, in our case, formula, print area and print title refs.
  #
  sub _store_supbook {
  
      my $self        = shift;
  
      my $record      = 0x01AE;                   # Record identifier
      my $length      = 0x0004;                   # Number of bytes to follow
  
      my $ctabs       = @{$self->{_worksheets}};  # Number of worksheets
      my $StVirtPath  = 0x0401;                   # Encoded workbook filename
  
      my $header      = pack("vv", $record, $length);
      my $data        = pack("vv", $ctabs, $StVirtPath);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_externsheet()
  #
  # Writes the Excel BIFF EXTERNSHEET record. These references are used by
  # formulas. TODO NAME record is required to define the print area and the
  # repeat rows and columns.
  #
  sub _store_externsheet {
  
      my $self        = shift;
  
      my $record      = 0x0017;                   # Record identifier
      my $length;                                 # Number of bytes to follow
  
  
      # Get the external refs
      my %ext_refs = %{$self->{_ext_refs}};
      my @ext_refs = sort {$ext_refs{$a} <=> $ext_refs{$b}} keys %ext_refs;
  
      # Change the external refs from stringified "1:1" to [1, 1]
      foreach my $ref (@ext_refs) {
          $ref = [split /:/, $ref];
      }
  
  
      my $cxti        = scalar @ext_refs;         # Number of Excel XTI structures
      my $rgxti       = '';                       # Array of XTI structures
  
      # Write the XTI structs
      foreach my $ext_ref (@ext_refs) {
          $rgxti .= pack("vvv", 0, $ext_ref->[0], $ext_ref->[1])
      }
  
  
      my $data        = pack("v", $cxti) . $rgxti;
      my $header      = pack("vv", $record, length $data);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_name()
  #
  #
  # Store the NAME record used for storing the print area, repeat rows, repeat
  # columns, autofilters and defined names.
  #
  # TODO. This is a more generic version that will replace _store_name_short()
  #       and _store_name_long().
  #
  sub _store_name {
  
      my $self            = shift;
  
      my $record          = 0x0018;       # Record identifier
      my $length;                         # Number of bytes to follow
  
      my $name            = shift;
      my $encoding        = shift;
      my $sheet_index     = shift;
      my $formula         = shift;
  
      my $text_length     = length $name;
      my $formula_length  = length $formula;
  
      # UTF-16 string length is in characters not bytes.
      $text_length       /= 2 if $encoding;
  
  
      my $grbit           = 0x0000;       # Option flags
      my $shortcut        = 0x00;         # Keyboard shortcut
      my $ixals           = 0x0000;       # Unused index.
      my $menu_length     = 0x00;         # Length of cust menu text
      my $desc_length     = 0x00;         # Length of description text
      my $help_length     = 0x00;         # Length of help topic text
      my $status_length   = 0x00;         # Length of status bar text
  
      # Set grbit built-in flag and the hidden flag for autofilters.
      if ($text_length == 1) {
          $grbit = 0x0020 if ord $name == 0x06; # Print area
          $grbit = 0x0020 if ord $name == 0x07; # Print titles
          $grbit = 0x0021 if ord $name == 0x0D; # Autofilter
      }
  
      my $data            = pack "v", $grbit;
      $data              .= pack "C", $shortcut;
      $data              .= pack "C", $text_length;
      $data              .= pack "v", $formula_length;
      $data              .= pack "v", $ixals;
      $data              .= pack "v", $sheet_index;
      $data              .= pack "C", $menu_length;
      $data              .= pack "C", $desc_length;
      $data              .= pack "C", $help_length;
      $data              .= pack "C", $status_length;
      $data              .= pack "C", $encoding;
      $data              .= $name;
      $data              .= $formula;
  
      my $header          = pack "vv", $record, length $data;
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_name_short()
  #
  #
  # Store the NAME record in the short format that is used for storing the print
  # area, repeat rows only and repeat columns only.
  #
  sub _store_name_short {
  
      my $self            = shift;
  
      my $record          = 0x0018;       # Record identifier
      my $length          = 0x001b;       # Number of bytes to follow
  
      my $index           = shift;        # Sheet index
      my $type            = shift;
      my $ext_ref         = shift;        # TODO
  
      my $grbit           = 0x0020;       # Option flags
      my $chKey           = 0x00;         # Keyboard shortcut
      my $cch             = 0x01;         # Length of text name
      my $cce             = 0x000b;       # Length of text definition
      my $unknown01       = 0x0000;       #
      my $ixals           = $index +1;    # Sheet index
      my $unknown02       = 0x00;         #
      my $cchCustMenu     = 0x00;         # Length of cust menu text
      my $cchDescription  = 0x00;         # Length of description text
      my $cchHelptopic    = 0x00;         # Length of help topic text
      my $cchStatustext   = 0x00;         # Length of status bar text
      my $rgch            = $type;        # Built-in name type
      my $unknown03       = 0x3b;         #
  
      my $rowmin          = $_[0];        # Start row
      my $rowmax          = $_[1];        # End row
      my $colmin          = $_[2];        # Start column
      my $colmax          = $_[3];        # end column
  
      my $hidden          = $_[4];        # Name is hidden
      $grbit              = 0x0021 if $hidden;
  
      my $header          = pack("vv", $record, $length);
      my $data            = pack("v",  $grbit);
      $data              .= pack("C",  $chKey);
      $data              .= pack("C",  $cch);
      $data              .= pack("v",  $cce);
      $data              .= pack("v",  $unknown01);
      $data              .= pack("v",  $ixals);
      $data              .= pack("C",  $unknown02);
      $data              .= pack("C",  $cchCustMenu);
      $data              .= pack("C",  $cchDescription);
      $data              .= pack("C",  $cchHelptopic);
      $data              .= pack("C",  $cchStatustext);
      $data              .= pack("C",  $rgch);
      $data              .= pack("C",  $unknown03);
      $data              .= pack("v",  $ext_ref);
  
      $data              .= pack("v",  $rowmin);
      $data              .= pack("v",  $rowmax);
      $data              .= pack("v",  $colmin);
      $data              .= pack("v",  $colmax);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_name_long()
  #
  #
  # Store the NAME record in the long format that is used for storing the repeat
  # rows and columns when both are specified. This share a lot of code with
  # _store_name_short() but we use a separate method to keep the code clean.
  # Code abstraction for reuse can be carried too far, and I should know. ;-)
  #
  sub _store_name_long {
  
      my $self            = shift;
  
      my $record          = 0x0018;       # Record identifier
      my $length          = 0x002a;       # Number of bytes to follow
  
      my $index           = shift;        # Sheet index
      my $type            = shift;
      my $ext_ref         = shift;        # TODO
  
      my $grbit           = 0x0020;       # Option flags
      my $chKey           = 0x00;         # Keyboard shortcut
      my $cch             = 0x01;         # Length of text name
      my $cce             = 0x001a;       # Length of text definition
      my $unknown01       = 0x0000;       #
      my $ixals           = $index +1;    # Sheet index
      my $unknown02       = 0x00;         #
      my $cchCustMenu     = 0x00;         # Length of cust menu text
      my $cchDescription  = 0x00;         # Length of description text
      my $cchHelptopic    = 0x00;         # Length of help topic text
      my $cchStatustext   = 0x00;         # Length of status bar text
      my $rgch            = $type;        # Built-in name type
  
      my $unknown03       = 0x29;
      my $unknown04       = 0x0017;
      my $unknown05       = 0x3b;
  
      my $rowmin          = $_[0];        # Start row
      my $rowmax          = $_[1];        # End row
      my $colmin          = $_[2];        # Start column
      my $colmax          = $_[3];        # end column
  
  
      my $header          = pack("vv", $record, $length);
      my $data            = pack("v",  $grbit);
      $data              .= pack("C",  $chKey);
      $data              .= pack("C",  $cch);
      $data              .= pack("v",  $cce);
      $data              .= pack("v",  $unknown01);
      $data              .= pack("v",  $ixals);
      $data              .= pack("C",  $unknown02);
      $data              .= pack("C",  $cchCustMenu);
      $data              .= pack("C",  $cchDescription);
      $data              .= pack("C",  $cchHelptopic);
      $data              .= pack("C",  $cchStatustext);
      $data              .= pack("C",  $rgch);
  
      # Column definition
      $data              .= pack("C",  $unknown03);
      $data              .= pack("v",  $unknown04);
      $data              .= pack("C",  $unknown05);
      $data              .= pack("v",  $ext_ref);
      $data              .= pack("v",  0x0000);
      $data              .= pack("v",  0xffff);
      $data              .= pack("v",  $colmin);
      $data              .= pack("v",  $colmax);
  
      # Row definition
      $data              .= pack("C",  $unknown05);
      $data              .= pack("v",  $ext_ref);
      $data              .= pack("v",  $rowmin);
      $data              .= pack("v",  $rowmax);
      $data              .= pack("v",  0x00);
      $data              .= pack("v",  0xff);
      # End of data
      $data              .= pack("C",  0x10);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_palette()
  #
  # Stores the PALETTE biff record.
  #
  sub _store_palette {
  
      my $self            = shift;
  
      my $aref            = $self->{_palette};
  
      my $record          = 0x0092;           # Record identifier
      my $length          = 2 + 4 * @$aref;   # Number of bytes to follow
      my $ccv             =         @$aref;   # Number of RGB values to follow
      my $data;                               # The RGB data
  
      # Pack the RGB data
      $data .= pack "CCCC", @$_ for @$aref;
  
      my $header = pack("vvv",  $record, $length, $ccv);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_codepage()
  #
  # Stores the CODEPAGE biff record.
  #
  sub _store_codepage {
  
      my $self            = shift;
  
      my $record          = 0x0042;               # Record identifier
      my $length          = 0x0002;               # Number of bytes to follow
      my $cv              = $self->{_codepage};   # The code page
  
      my $header          = pack("vv", $record, $length);
      my $data            = pack("v",  $cv);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_country()
  #
  # Stores the COUNTRY biff record.
  #
  sub _store_country {
  
      my $self            = shift;
  
      my $record          = 0x008C;               # Record identifier
      my $length          = 0x0004;               # Number of bytes to follow
      my $country_default = $self->{_country};
      my $country_win_ini = $self->{_country};
  
      my $header          = pack("vv", $record, $length);
      my $data            = pack("vv", $country_default, $country_win_ini);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_hideobj()
  #
  # Stores the HIDEOBJ biff record.
  #
  sub _store_hideobj {
  
      my $self            = shift;
  
      my $record          = 0x008D;               # Record identifier
      my $length          = 0x0002;               # Number of bytes to follow
      my $hide            = $self->{_hideobj};    # Option to hide objects
  
      my $header          = pack("vv", $record, $length);
      my $data            = pack("v",  $hide);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  ###############################################################################
  ###############################################################################
  
  
  
  ###############################################################################
  #
  # _calculate_extern_sizes()
  #
  # We need to calculate the space required by the SUPBOOK, EXTERNSHEET and NAME
  # records so that it can be added to the BOUNDSHEET offsets.
  #
  sub _calculate_extern_sizes {
  
      my $self   = shift;
  
  
      my %ext_refs        = $self->{_parser}->get_ext_sheets();
      my $ext_ref_count   = scalar keys %ext_refs;
      my $length          = 0;
      my $index           = 0;
  
  
      if (@{$self->{_defined_names}}) {
          my $index   = 0;
          my $key     = "$index:$index";
  
          if (not exists $ext_refs{$key}) {
              $ext_refs{$key} = $ext_ref_count++;
          }
      }
  
      for my $defined_name (@{$self->{_defined_names}}) {
          $length += 19
                     + length($defined_name->{name})
                     + length($defined_name->{formula});
      }
  
  
      foreach my $worksheet (@{$self->{_worksheets}}) {
  
          my $rowmin      = $worksheet->{_title_rowmin};
          my $colmin      = $worksheet->{_title_colmin};
          my $filter      = $worksheet->{_filter_count};
          my $key         = "$index:$index";
          $index++;
  
  
          # Add area NAME records
          #
          if (defined $worksheet->{_print_rowmin}) {
              $ext_refs{$key} = $ext_ref_count++ if not exists $ext_refs{$key};
  
              $length += 31 ;
          }
  
  
          # Add title  NAME records
          #
          if (defined $rowmin and defined $colmin) {
              $ext_refs{$key} = $ext_ref_count++ if not exists $ext_refs{$key};
  
              $length += 46;
          }
          elsif (defined $rowmin or defined $colmin) {
              $ext_refs{$key} = $ext_ref_count++ if not exists $ext_refs{$key};
  
              $length += 31;
          }
          else {
              # TODO, may need this later.
          }
  
  
          # Add Autofilter  NAME records
          #
          if ($filter) {
              $ext_refs{$key} = $ext_ref_count++ if not exists $ext_refs{$key};
  
              $length += 31;
          }
      }
  
  
      # Update the ref counts.
      $self->{_ext_ref_count} = $ext_ref_count;
      $self->{_ext_refs}      = {%ext_refs};
  
  
      # If there are no external refs then we don't write, SUPBOOK, EXTERNSHEET
      # and NAME. Therefore the length is 0.
  
      return $length = 0 if $ext_ref_count == 0;
  
  
      # The SUPBOOK record is 8 bytes
      $length += 8;
  
      # The EXTERNSHEET record is 6 bytes + 6 bytes for each external ref
      $length += 6 * (1 + $ext_ref_count);
  
      return $length;
  }
  
  
  ###############################################################################
  #
  # _calculate_shared_string_sizes()
  #
  # Handling of the SST continue blocks is complicated by the need to include an
  # additional continuation byte depending on whether the string is split between
  # blocks or whether it starts at the beginning of the block. (There are also
  # additional complications that will arise later when/if Rich Strings are
  # supported). As such we cannot use the simple CONTINUE mechanism provided by
  # the _add_continue() method in BIFFwriter.pm. Thus we have to make two passes
  # through the strings data. The first is to calculate the required block sizes
  # and the second, in _store_shared_strings(), is to write the actual strings.
  # The first pass through the data is also used to calculate the size of the SST
  # and CONTINUE records for use in setting the BOUNDSHEET record offsets. The
  # downside of this is that the same algorithm repeated in _store_shared_strings.
  #
  sub _calculate_shared_string_sizes {
  
      my $self    = shift;
  
      my @strings;
      $#strings = $self->{_str_unique} -1; # Pre-extend array
  
      while (my $key = each %{$self->{_str_table}}) {
          $strings[$self->{_str_table}->{$key}] = $key;
      }
  
      # The SST data could be very large, free some memory (maybe).
      $self->{_str_table} = undef;
      $self->{_str_array} = [@strings];
  
  
      # Iterate through the strings to calculate the CONTINUE block sizes.
      #
      # The SST blocks requires a specialised CONTINUE block, so we have to
      # ensure that the maximum data block size is less than the limit used by
      # _add_continue() in BIFFwriter.pm. For simplicity we use the same size
      # for the SST and CONTINUE records:
      #   8228 : Maximum Excel97 block size
      #     -4 : Length of block header
      #     -8 : Length of additional SST header information
      #     -8 : Arbitrary number to keep within _add_continue() limit
      # = 8208
      #
      my $continue_limit = 8208;
      my $block_length   = 0;
      my $written        = 0;
      my @block_sizes;
      my $continue       = 0;
  
      for my $string (@strings) {
  
          my $string_length = length $string;
          my $encoding      = unpack "xx C", $string;
          my $split_string  = 0;
  
  
          # Block length is the total length of the strings that will be
          # written out in a single SST or CONTINUE block.
          #
          $block_length += $string_length;
  
  
          # We can write the string if it doesn't cross a CONTINUE boundary
          if ($block_length < $continue_limit) {
              $written += $string_length;
              next;
          }
  
  
          # Deal with the cases where the next string to be written will exceed
          # the CONTINUE boundary. If the string is very long it may need to be
          # written in more than one CONTINUE record.
          #
          while ($block_length >= $continue_limit) {
  
              # We need to avoid the case where a string is continued in the first
              # n bytes that contain the string header information.
              #
              my $header_length   = 3; # Min string + header size -1
              my $space_remaining = $continue_limit -$written -$continue;
  
  
              # Unicode data should only be split on char (2 byte) boundaries.
              # Therefore, in some cases we need to reduce the amount of available
              # space by 1 byte to ensure the correct alignment.
              my $align = 0;
  
              # Only applies to Unicode strings
              if ($encoding == 1) {
                  # Min string + header size -1
                  $header_length = 4;
  
                  if ($space_remaining > $header_length) {
                      # String contains 3 byte header => split on odd boundary
                      if (not $split_string and $space_remaining % 2 != 1) {
                          $space_remaining--;
                          $align = 1;
                      }
                      # Split section without header => split on even boundary
                      elsif ($split_string and $space_remaining % 2 == 1) {
                          $space_remaining--;
                          $align = 1;
                      }
  
                      $split_string = 1;
                  }
              }
  
  
              if ($space_remaining > $header_length) {
                  # Write as much as possible of the string in the current block
                  $written      += $space_remaining;
  
                  # Reduce the current block length by the amount written
                  $block_length -= $continue_limit -$continue -$align;
  
                  # Store the max size for this block
                  push @block_sizes, $continue_limit -$align;
  
                  # If the current string was split then the next CONTINUE block
                  # should have the string continue flag (grbit) set unless the
                  # split string fits exactly into the remaining space.
                  #
                  if ($block_length > 0) {
                      $continue = 1;
                  }
                  else {
                      $continue = 0;
                  }
  
              }
              else {
                  # Store the max size for this block
                  push @block_sizes, $written +$continue;
  
                  # Not enough space to start the string in the current block
                  $block_length -= $continue_limit -$space_remaining -$continue;
                  $continue = 0;
  
              }
  
              # If the string (or substr) is small enough we can write it in the
              # new CONTINUE block. Else, go through the loop again to write it in
              # one or more CONTINUE blocks
              #
              if ($block_length < $continue_limit) {
                  $written = $block_length;
              }
              else {
                  $written = 0;
              }
          }
      }
  
      # Store the max size for the last block unless it is empty
      push @block_sizes, $written +$continue if $written +$continue;
  
  
      $self->{_str_block_sizes} = [@block_sizes];
  
  
      # Calculate the total length of the SST and associated CONTINUEs (if any).
      # The SST record will have a length even if it contains no strings.
      # This length is required to set the offsets in the BOUNDSHEET records since
      # they must be written before the SST records
      #
      my $length  = 12;
      $length    +=     shift @block_sizes if    @block_sizes; # SST
      $length    += 4 + shift @block_sizes while @block_sizes; # CONTINUEs
  
      return $length;
  }
  
  
  ###############################################################################
  #
  # _store_shared_strings()
  #
  # Write all of the workbooks strings into an indexed array.
  #
  # See the comments in _calculate_shared_string_sizes() for more information.
  #
  # We also use this routine to record the offsets required by the EXTSST table.
  # In order to do this we first identify the first string in an EXTSST bucket
  # and then store its global and local offset within the SST table. The offset
  # occurs wherever the start of the bucket string is written out via append().
  #
  sub _store_shared_strings {
  
      my $self                = shift;
  
      my @strings = @{$self->{_str_array}};
  
  
      my $record              = 0x00FC;   # Record identifier
      my $length              = 0x0008;   # Number of bytes to follow
      my $total               = 0x0000;
  
      # Iterate through the strings to calculate the CONTINUE block sizes
      my $continue_limit = 8208;
      my $block_length   = 0;
      my $written        = 0;
      my $continue       = 0;
  
      # The SST and CONTINUE block sizes have been pre-calculated by
      # _calculate_shared_string_sizes()
      my @block_sizes    = @{$self->{_str_block_sizes}};
  
  
      # The SST record is required even if it contains no strings. Thus we will
      # always have a length
      #
      if (@block_sizes) {
          $length = 8 + shift @block_sizes;
      }
      else {
          # No strings
          $length = 8;
      }
  
  
      # Initialise variables used to track EXTSST bucket offsets.
      my $extsst_str_num  = -1;
      my $sst_block_start = $self->{_datasize};
  
  
      # Write the SST block header information
      my $header      = pack("vv", $record, $length);
      my $data        = pack("VV", $self->{_str_total}, $self->{_str_unique});
      $self->_append($header, $data);
  
  
      # Iterate through the strings and write them out
      for my $string (@strings) {
  
          my $string_length = length $string;
          my $encoding      = unpack "xx C", $string;
          my $split_string  = 0;
          my $bucket_string = 0; # Used to track EXTSST bucket offsets.
  
  
          # Check if the string is at the start of a EXTSST bucket.
          if (++$extsst_str_num % $self->{_extsst_bucket_size} == 0) {
              $bucket_string = 1;
          }
  
  
          # Block length is the total length of the strings that will be
          # written out in a single SST or CONTINUE block.
          #
          $block_length += $string_length;
  
  
          # We can write the string if it doesn't cross a CONTINUE boundary
          if ($block_length < $continue_limit) {
  
              # Store location of EXTSST bucket string.
              if ($bucket_string) {
                  my $global_offset   = $self->{_datasize};
                  my $local_offset    = $self->{_datasize} - $sst_block_start;
  
                  push @{$self->{_extsst_offsets}}, [$global_offset, $local_offset];
                  $bucket_string = 0;
              }
  
              $self->_append($string);
              $written += $string_length;
              next;
          }
  
  
          # Deal with the cases where the next string to be written will exceed
          # the CONTINUE boundary. If the string is very long it may need to be
          # written in more than one CONTINUE record.
          #
          while ($block_length >= $continue_limit) {
  
              # We need to avoid the case where a string is continued in the first
              # n bytes that contain the string header information.
              #
              my $header_length   = 3; # Min string + header size -1
              my $space_remaining = $continue_limit -$written -$continue;
  
  
              # Unicode data should only be split on char (2 byte) boundaries.
              # Therefore, in some cases we need to reduce the amount of available
              # space by 1 byte to ensure the correct alignment.
              my $align = 0;
  
              # Only applies to Unicode strings
              if ($encoding == 1) {
                  # Min string + header size -1
                  $header_length = 4;
  
                  if ($space_remaining > $header_length) {
                      # String contains 3 byte header => split on odd boundary
                      if (not $split_string and $space_remaining % 2 != 1) {
                          $space_remaining--;
                          $align = 1;
                      }
                      # Split section without header => split on even boundary
                      elsif ($split_string and $space_remaining % 2 == 1) {
                          $space_remaining--;
                          $align = 1;
                      }
  
                      $split_string = 1;
                  }
              }
  
  
              if ($space_remaining > $header_length) {
                  # Write as much as possible of the string in the current block
                  my $tmp = substr $string, 0, $space_remaining;
  
                  # Store location of EXTSST bucket string.
                  if ($bucket_string) {
                      my $global_offset   = $self->{_datasize};
                      my $local_offset    = $self->{_datasize} - $sst_block_start;
  
                      push @{$self->{_extsst_offsets}}, [$global_offset, $local_offset];
                      $bucket_string = 0;
                  }
  
                  $self->_append($tmp);
  
  
                  # The remainder will be written in the next block(s)
                  $string = substr $string, $space_remaining;
  
                  # Reduce the current block length by the amount written
                  $block_length -= $continue_limit -$continue -$align;
  
                  # If the current string was split then the next CONTINUE block
                  # should have the string continue flag (grbit) set unless the
                  # split string fits exactly into the remaining space.
                  #
                  if ($block_length > 0) {
                      $continue = 1;
                  }
                  else {
                      $continue = 0;
                  }
              }
              else {
                  # Not enough space to start the string in the current block
                  $block_length -= $continue_limit -$space_remaining -$continue;
                  $continue = 0;
              }
  
              # Write the CONTINUE block header
              if (@block_sizes) {
                  $sst_block_start= $self->{_datasize}; # Reset EXTSST offset.
  
                  $record         = 0x003C;
                  $length         = shift @block_sizes;
  
                  $header         = pack("vv", $record, $length);
                  $header        .= pack("C", $encoding) if $continue;
  
                  $self->_append($header);
              }
  
              # If the string (or substr) is small enough we can write it in the
              # new CONTINUE block. Else, go through the loop again to write it in
              # one or more CONTINUE blocks
              #
              if ($block_length < $continue_limit) {
  
                  # Store location of EXTSST bucket string.
                  if ($bucket_string) {
                      my $global_offset   = $self->{_datasize};
                      my $local_offset    = $self->{_datasize} - $sst_block_start;
  
                      push @{$self->{_extsst_offsets}}, [$global_offset, $local_offset];
  
                      $bucket_string = 0;
                  }
                  $self->_append($string);
  
                  $written = $block_length;
              }
              else {
                  $written = 0;
              }
          }
      }
  }
  
  
  ###############################################################################
  #
  # _calculate_extsst_size
  #
  # The number of buckets used in the EXTSST is between 0 and 128. The number of
  # strings per bucket (bucket size) has a minimum value of 8 and a theoretical
  # maximum of 2^16. For "number of strings" < 1024 there is a constant bucket
  # size of 8. The following algorithm generates the same size/bucket ratio
  # as Excel.
  #
  sub _calculate_extsst_size {
  
      my $self            = shift;
  
      my $unique_strings  = $self->{_str_unique};
  
      my $bucket_size;
      my $buckets;
  
      if ($unique_strings < 1024) {
          $bucket_size = 8;
      }
      else {
          $bucket_size = 1 + int($unique_strings / 128);
      }
  
      $buckets = int(($unique_strings + $bucket_size -1)  / $bucket_size);
  
  
      $self->{_extsst_buckets}        = $buckets ;
      $self->{_extsst_bucket_size}    = $bucket_size;
  
  
      return 6 + 8 * $buckets;
  }
  
  
  ###############################################################################
  #
  # _store_extsst
  #
  # Write EXTSST table using the offsets calculated in _store_shared_strings().
  #
  sub _store_extsst {
  
      my $self = shift;
  
      my @offsets     = @{$self->{_extsst_offsets}};
      my $bucket_size = $self->{_extsst_bucket_size};
  
      my $record      = 0x00FF;             # Record identifier
      my $length      = 2 + 8 * @offsets;   # Bytes to follow
  
      my $header      = pack 'vv',   $record, $length;
      my $data        = pack 'v',    $bucket_size,;
  
      for my $offset (@offsets) {
         $data .= pack 'Vvv', $offset->[0], $offset->[1], 0;
      }
  
      $self->_append($header, $data);
  
  }
  
  
  
  
  #
  # Methods related to comments and MSO objects.
  #
  
  ###############################################################################
  #
  # _add_mso_drawing_group()
  #
  # Write the MSODRAWINGGROUP record that keeps track of the Escher drawing
  # objects in the file such as images, comments and filters.
  #
  sub _add_mso_drawing_group {
  
      my $self    = shift;
  
      return unless $self->{_mso_size};
  
      my $record  = 0x00EB;               # Record identifier
      my $length  = 0x0000;               # Number of bytes to follow
  
      my $data    = $self->_store_mso_dgg_container();
         $data   .= $self->_store_mso_dgg(@{$self->{_mso_clusters}});
         $data   .= $self->_store_mso_bstore_container();
         $data   .= $self->_store_mso_images(@$_) for @{$self->{_images_data}};
         $data   .= $self->_store_mso_opt();
         $data   .= $self->_store_mso_split_menu_colors();
  
         $length  = length $data;
      my $header  = pack("vv", $record, $length);
  
      $self->_add_mso_drawing_group_continue($header . $data);
  
      return $header . $data; # For testing only.
  }
  
  
  ###############################################################################
  #
  # _add_mso_drawing_group_continue()
  #
  # See first the Spreadsheet::WriteExcel::BIFFwriter::_add_continue() method.
  #
  # Add specialised CONTINUE headers to large MSODRAWINGGROUP data block.
  # We use the Excel 97 max block size of 8228 - 4 bytes for the header = 8224.
  #
  # The structure depends on the size of the data block:
  #
  #     Case 1:  <=   8224 bytes      1 MSODRAWINGGROUP
  #     Case 2:  <= 2*8224 bytes      1 MSODRAWINGGROUP + 1 CONTINUE
  #     Case 3:  >  2*8224 bytes      2 MSODRAWINGGROUP + n CONTINUE
  #
  sub _add_mso_drawing_group_continue {
  
      my $self        = shift;
  
      my $data        = $_[0];
      my $limit       = 8228 -4;
      my $mso_group   = 0x00EB; # Record identifier
      my $continue    = 0x003C; # Record identifier
      my $block_count = 1;
      my $header;
      my $tmp;
  
      # Ignore the base class _add_continue() method.
      $self->{_ignore_continue} = 1;
  
      # Case 1 above. Just return the data as it is.
      if (length $data <= $limit) {
          $self->_append($data);
          return;
      }
  
      # Change length field of the first MSODRAWINGGROUP block. Case 2 and 3.
      $tmp = substr($data, 0, $limit +4, "");
      substr($tmp, 2, 2, pack("v", $limit));
      $self->_append($tmp);
  
  
      # Add MSODRAWINGGROUP and CONTINUE blocks for Case 3 above.
      while (length($data) > $limit) {
          if ($block_count == 1) {
              # Add extra MSODRAWINGGROUP block header.
              $header = pack("vv", $mso_group, $limit);
              $block_count++;
          }
          else {
              # Add normal CONTINUE header.
              $header = pack("vv", $continue, $limit);
          }
  
          $tmp = substr($data, 0, $limit, "");
          $self->_append($header, $tmp);
      }
  
  
      # Last CONTINUE block for remaining data. Case 2 and 3 above.
      $header = pack("vv", $continue, length($data));
      $self->_append($header, $data);
  
  
      # Turn the base class _add_continue() method back on.
      $self->{_ignore_continue} = 0;
  }
  
  
  ###############################################################################
  #
  # _store_mso_dgg_container()
  #
  # Write the Escher DggContainer record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_dgg_container {
  
      my $self        = shift;
  
      my $type        = 0xF000;
      my $version     = 15;
      my $instance    = 0;
      my $data        = '';
      my $length      = $self->{_mso_size} -12; # -4 (biff header) -8 (for this).
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_dgg()
  #
  # Write the Escher Dgg record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_dgg {
  
      my $self            = shift;
  
      my $type            = 0xF006;
      my $version         = 0;
      my $instance        = 0;
      my $data            = '';
      my $length          = undef; # Calculate automatically.
  
      my $max_spid        = $_[0];
      my $num_clusters    = $_[1];
      my $shapes_saved    = $_[2];
      my $drawings_saved  = $_[3];
      my $clusters        = $_[4];
  
      $data               = pack "VVVV",  $max_spid,     $num_clusters,
                                          $shapes_saved, $drawings_saved;
  
      for my $aref (@$clusters) {
          my $drawing_id      = $aref->[0];
          my $shape_ids_used  = $aref->[1];
  
          $data              .= pack "VV",  $drawing_id, $shape_ids_used;
      }
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_bstore_container()
  #
  # Write the Escher BstoreContainer record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_bstore_container {
  
      my $self        = shift;
  
      return '' unless $self->{_images_size};
  
      my $type        = 0xF001;
      my $version     = 15;
      my $instance    = @{$self->{_images_data}}; # Number of images.
      my $data        = '';
      my $length      = $self->{_images_size} +8 *$instance;
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  
  ###############################################################################
  #
  # _store_mso_images()
  #
  # Write the Escher BstoreContainer record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_images {
  
      my $self        = shift;
  
      my $ref_count   = $_[0];
      my $image_type  = $_[1];
      my $image       = $_[2];
      my $size        = $_[3];
      my $checksum1   = $_[4];
      my $checksum2   = $_[5];
  
      my $blip_store_entry =  $self->_store_mso_blip_store_entry($ref_count,
                                                                 $image_type,
                                                                 $size,
                                                                 $checksum1);
  
      my $blip             =  $self->_store_mso_blip($image_type,
                                                     $image,
                                                     $size,
                                                     $checksum1,
                                                     $checksum2);
  
      return $blip_store_entry . $blip;
  }
  
  
  
  ###############################################################################
  #
  # _store_mso_blip_store_entry()
  #
  # Write the Escher BlipStoreEntry record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_blip_store_entry {
  
      my $self        = shift;
  
      my $ref_count   = $_[0];
      my $image_type  = $_[1];
      my $size        = $_[2];
      my $checksum1   = $_[3];
  
  
      my $type        = 0xF007;
      my $version     = 2;
      my $instance    = $image_type;
      my $length      = $size +61;
      my $data        = pack('C',  $image_type)   # Win32
                      . pack('C',  $image_type)   # Mac
                      . pack('H*', $checksum1)    # Uid checksum
                      . pack('v',  0xFF)          # Tag
                      . pack('V',  $size +25)     # Next Blip size
                      . pack('V',  $ref_count)    # Image ref count
                      . pack('V',  0x00000000)    # File offset
                      . pack('C',  0x00)          # Usage
                      . pack('C',  0x00)          # Name length
                      . pack('C',  0x00)          # Unused
                      . pack('C',  0x00)          # Unused
                      ;
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_blip()
  #
  # Write the Escher Blip record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_blip {
  
      my $self        = shift;
  
      my $image_type  = $_[0];
      my $image_data  = $_[1];
      my $size        = $_[2];
      my $checksum1   = $_[3];
      my $checksum2   = $_[4];
      my $instance;
  
      $instance = 0x046A if $image_type == 5; # JPG
      $instance = 0x06E0 if $image_type == 6; # PNG
      $instance = 0x07A9 if $image_type == 7; # BMP
  
      # BMPs contain an extra checksum for the stripped data.
      if ( $image_type == 7) {
          $checksum1 = $checksum2 . $checksum1;
      }
  
      my $type        = 0xF018 + $image_type;
      my $version     = 0x0000;
      my $length      = $size +17;
      my $data        = pack('H*', $checksum1) # Uid checksum
                      . pack('C',  0xFF)       # Tag
                      . $image_data            # Image
                      ;
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  
  ###############################################################################
  #
  # _store_mso_opt()
  #
  # Write the Escher Opt record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_opt {
  
      my $self        = shift;
  
      my $type        = 0xF00B;
      my $version     = 3;
      my $instance    = 3;
      my $data        = '';
      my $length      = 18;
  
      $data           = pack "H*", 'BF0008000800810109000008C0014000' .
                                   '0008';
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_split_menu_colors()
  #
  # Write the Escher SplitMenuColors record that is part of MSODRAWINGGROUP.
  #
  sub _store_mso_split_menu_colors {
  
      my $self        = shift;
  
      my $type        = 0xF11E;
      my $version     = 0;
      my $instance    = 4;
      my $data        = '';
      my $length      = 16;
  
      $data           = pack "H*", '0D0000080C00000817000008F7000010';
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Workbook - A writer class for Excel Workbooks.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::WriteExcel
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::WriteExcel.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
   MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
SPREADSHEET_WRITEEXCEL_WORKBOOK

$fatpacked{"Spreadsheet/WriteExcel/Worksheet.pm"} = <<'SPREADSHEET_WRITEEXCEL_WORKSHEET';
  package Spreadsheet::WriteExcel::Worksheet;
  
  ###############################################################################
  #
  # Worksheet - A writer class for Excel Worksheets.
  #
  #
  # Used in conjunction with Spreadsheet::WriteExcel
  #
  # Copyright 2000-2010, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use Exporter;
  use strict;
  use Carp;
  use Spreadsheet::WriteExcel::BIFFwriter;
  use Spreadsheet::WriteExcel::Format;
  use Spreadsheet::WriteExcel::Formula;
  
  
  
  use vars qw($VERSION @ISA);
  @ISA = qw(Spreadsheet::WriteExcel::BIFFwriter);
  
  $VERSION = '2.38';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor. Creates a new Worksheet object from a BIFFwriter object
  #
  sub new {
  
      my $class                     = shift;
      my $self                      = Spreadsheet::WriteExcel::BIFFwriter->new();
      my $rowmax                    = 65536;
      my $colmax                    = 256;
      my $strmax                    = 0;
  
      $self->{_name}                = $_[0];
      $self->{_index}               = $_[1];
      $self->{_encoding}            = $_[2];
      $self->{_activesheet}         = $_[3];
      $self->{_firstsheet}          = $_[4];
      $self->{_url_format}          = $_[5];
      $self->{_parser}              = $_[6];
      $self->{_tempdir}             = $_[7];
  
      $self->{_str_total}           = $_[8];
      $self->{_str_unique}          = $_[9];
      $self->{_str_table}           = $_[10];
      $self->{_1904}                = $_[11];
      $self->{_compatibility}       = $_[12];
      $self->{_palette}             = $_[13];
  
      $self->{_sheet_type}          = 0x0000;
      $self->{_ext_sheets}          = [];
      $self->{_using_tmpfile}       = 1;
      $self->{_filehandle}          = "";
      $self->{_fileclosed}          = 0;
      $self->{_offset}              = 0;
      $self->{_xls_rowmax}          = $rowmax;
      $self->{_xls_colmax}          = $colmax;
      $self->{_xls_strmax}          = $strmax;
      $self->{_dim_rowmin}          = undef;
      $self->{_dim_rowmax}          = undef;
      $self->{_dim_colmin}          = undef;
      $self->{_dim_colmax}          = undef;
      $self->{_colinfo}             = [];
      $self->{_selection}           = [0, 0];
      $self->{_panes}               = [];
      $self->{_active_pane}         = 3;
      $self->{_frozen}              = 0;
      $self->{_frozen_no_split}     = 1;
      $self->{_selected}            = 0;
      $self->{_hidden}              = 0;
      $self->{_active}              = 0;
      $self->{_tab_color}           = 0;
  
      $self->{_first_row}           = 0;
      $self->{_first_col}           = 0;
      $self->{_display_formulas}    = 0;
      $self->{_display_headers}     = 1;
      $self->{_display_zeros}       = 1;
      $self->{_display_arabic}      = 0;
  
      $self->{_paper_size}          = 0x0;
      $self->{_orientation}         = 0x1;
      $self->{_header}              = '';
      $self->{_footer}              = '';
      $self->{_header_encoding}     = 0;
      $self->{_footer_encoding}     = 0;
      $self->{_hcenter}             = 0;
      $self->{_vcenter}             = 0;
      $self->{_margin_header}       = 0.50;
      $self->{_margin_footer}       = 0.50;
      $self->{_margin_left}         = 0.75;
      $self->{_margin_right}        = 0.75;
      $self->{_margin_top}          = 1.00;
      $self->{_margin_bottom}       = 1.00;
  
      $self->{_title_rowmin}        = undef;
      $self->{_title_rowmax}        = undef;
      $self->{_title_colmin}        = undef;
      $self->{_title_colmax}        = undef;
      $self->{_print_rowmin}        = undef;
      $self->{_print_rowmax}        = undef;
      $self->{_print_colmin}        = undef;
      $self->{_print_colmax}        = undef;
  
      $self->{_print_gridlines}     = 1;
      $self->{_screen_gridlines}    = 1;
      $self->{_print_headers}       = 0;
  
      $self->{_page_order}          = 0;
      $self->{_black_white}         = 0;
      $self->{_draft_quality}       = 0;
      $self->{_print_comments}      = 0;
      $self->{_page_start}          = 1;
      $self->{_custom_start}        = 0;
  
      $self->{_fit_page}            = 0;
      $self->{_fit_width}           = 0;
      $self->{_fit_height}          = 0;
  
      $self->{_hbreaks}             = [];
      $self->{_vbreaks}             = [];
  
      $self->{_protect}             = 0;
      $self->{_password}            = undef;
  
      $self->{_col_sizes}           = {};
      $self->{_row_sizes}           = {};
  
      $self->{_col_formats}         = {};
      $self->{_row_formats}         = {};
  
      $self->{_zoom}                = 100;
      $self->{_print_scale}         = 100;
      $self->{_page_view}           = 0;
  
      $self->{_leading_zeros}       = 0;
  
      $self->{_outline_row_level}   = 0;
      $self->{_outline_style}       = 0;
      $self->{_outline_below}       = 1;
      $self->{_outline_right}       = 1;
      $self->{_outline_on}          = 1;
  
      $self->{_write_match}         = [];
  
      $self->{_object_ids}          = [];
      $self->{_images}              = {};
      $self->{_images_array}        = [];
      $self->{_charts}              = {};
      $self->{_charts_array}        = [];
      $self->{_comments}            = {};
      $self->{_comments_array}      = [];
      $self->{_comments_author}     = '';
      $self->{_comments_author_enc} = 0;
      $self->{_comments_visible}    = 0;
  
      $self->{_filter_area}         = [];
      $self->{_filter_count}        = 0;
      $self->{_filter_on}           = 0;
  
      $self->{_writing_url}         = 0;
  
      $self->{_db_indices}          = [];
  
      $self->{_validations}         = [];
  
      bless $self, $class;
      $self->_initialize();
      return $self;
  }
  
  
  ###############################################################################
  #
  # _initialize()
  #
  # Open a tmp file to store the majority of the Worksheet data. If this fails,
  # for example due to write permissions, store the data in memory. This can be
  # slow for large files.
  #
  sub _initialize {
  
      my $self = shift;
      my $fh;
      my $tmp_dir;
  
      # The following code is complicated by Windows limitations. Porters can
      # choose a more direct method.
  
  
  
      # In the default case we use IO::File->new_tmpfile(). This may fail, in
      # particular with IIS on Windows, so we allow the user to specify a temp
      # directory via File::Temp.
      #
      if (defined $self->{_tempdir}) {
  
          # Delay loading File:Temp to reduce the module dependencies.
          eval { require File::Temp };
          die "The File::Temp module must be installed in order ".
              "to call set_tempdir().\n" if $@;
  
  
          # Trap but ignore File::Temp errors.
          eval { $fh = File::Temp::tempfile(DIR => $self->{_tempdir}) };
  
          # Store the failed tmp dir in case of errors.
          $tmp_dir = $self->{_tempdir} || File::Spec->tmpdir if not $fh;
      }
      else {
  
          $fh = IO::File->new_tmpfile();
  
          # Store the failed tmp dir in case of errors.
          $tmp_dir = "POSIX::tmpnam() directory" if not $fh;
      }
  
  
      # Check if the temp file creation was successful. Else store data in memory.
      if ($fh) {
  
          # binmode file whether platform requires it or not.
          binmode($fh);
  
          # Store filehandle
          $self->{_filehandle} = $fh;
      }
      else {
  
          # Set flag to store data in memory if XX::tempfile() failed.
          $self->{_using_tmpfile} = 0;
  
          if ($self->{_index} == 0 && $^W) {
              my $dir = $self->{_tempdir} || File::Spec->tmpdir();
  
              warn "Unable to create temp files in $tmp_dir. Data will be ".
                   "stored in memory. Refer to set_tempdir() in the ".
                   "Spreadsheet::WriteExcel documentation.\n" ;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _close()
  #
  # Add data to the beginning of the workbook (note the reverse order)
  # and to the end of the workbook.
  #
  sub _close {
  
      my $self = shift;
  
      ################################################
      # Prepend in reverse order!!
      #
  
      # Prepend the sheet dimensions
      $self->_store_dimensions();
  
      # Prepend the autofilter filters.
      $self->_store_autofilters;
  
      # Prepend the sheet autofilter info.
      $self->_store_autofilterinfo();
  
      # Prepend the sheet filtermode record.
      $self->_store_filtermode();
  
      # Prepend the COLINFO records if they exist
      if (@{$self->{_colinfo}}){
          my @colinfo = @{$self->{_colinfo}};
          while (@colinfo) {
              my $arrayref = pop @colinfo;
              $self->_store_colinfo(@$arrayref);
          }
      }
  
      # Prepend the DEFCOLWIDTH record
      $self->_store_defcol();
  
      # Prepend the sheet password
      $self->_store_password();
  
      # Prepend the sheet protection
      $self->_store_protect();
      $self->_store_obj_protect();
  
      # Prepend the page setup
      $self->_store_setup();
  
      # Prepend the bottom margin
      $self->_store_margin_bottom();
  
      # Prepend the top margin
      $self->_store_margin_top();
  
      # Prepend the right margin
      $self->_store_margin_right();
  
      # Prepend the left margin
      $self->_store_margin_left();
  
      # Prepend the page vertical centering
      $self->_store_vcenter();
  
      # Prepend the page horizontal centering
      $self->_store_hcenter();
  
      # Prepend the page footer
      $self->_store_footer();
  
      # Prepend the page header
      $self->_store_header();
  
      # Prepend the vertical page breaks
      $self->_store_vbreak();
  
      # Prepend the horizontal page breaks
      $self->_store_hbreak();
  
      # Prepend WSBOOL
      $self->_store_wsbool();
  
      # Prepend the default row height.
      $self->_store_defrow();
  
      # Prepend GUTS
      $self->_store_guts();
  
      # Prepend GRIDSET
      $self->_store_gridset();
  
      # Prepend PRINTGRIDLINES
      $self->_store_print_gridlines();
  
      # Prepend PRINTHEADERS
      $self->_store_print_headers();
  
      #
      # End of prepend. Read upwards from here.
      ################################################
  
      # Append
      $self->_store_table();
      $self->_store_images();
      $self->_store_charts();
      $self->_store_filters();
      $self->_store_comments();
      $self->_store_window2();
      $self->_store_page_view();
      $self->_store_zoom();
      $self->_store_panes(@{$self->{_panes}}) if @{$self->{_panes}};
      $self->_store_selection(@{$self->{_selection}});
      $self->_store_validation_count();
      $self->_store_validations();
      $self->_store_tab_color();
      $self->_store_eof();
  
      # Prepend the BOF and INDEX records
      $self->_store_index();
      $self->_store_bof(0x0010);
  }
  
  
  ###############################################################################
  #
  # _compatibility_mode()
  #
  # Set the compatibility mode.
  #
  # See the explanation in Workbook::compatibility_mode(). This private method
  # is mainly used for test purposes.
  #
  sub _compatibility_mode {
  
      my $self      = shift;
  
      if (defined($_[0])) {
          $self->{_compatibility} = $_[0];
      }
      else {
          $self->{_compatibility} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # get_name().
  #
  # Retrieve the worksheet name.
  #
  # Note, there is no set_name() method because names are used in formulas and
  # converted to internal indices. Allowing the user to change sheet names
  # after they have been set in add_worksheet() is asking for trouble.
  #
  sub get_name {
  
      my $self    = shift;
  
      return $self->{_name};
  }
  
  
  ###############################################################################
  #
  # get_data().
  #
  # Retrieves data from memory in one chunk, or from disk in $buffer
  # sized chunks.
  #
  sub get_data {
  
      my $self   = shift;
      my $buffer = 4096;
      my $tmp;
  
      # Return data stored in memory
      if (defined $self->{_data}) {
          $tmp           = $self->{_data};
          $self->{_data} = undef;
          my $fh         = $self->{_filehandle};
          seek($fh, 0, 0) if $self->{_using_tmpfile};
          return $tmp;
      }
  
      # Return data stored on disk
      if ($self->{_using_tmpfile}) {
          return $tmp if read($self->{_filehandle}, $tmp, $buffer);
      }
  
      # No data to return
      return undef;
  }
  
  
  ###############################################################################
  #
  # select()
  #
  # Set this worksheet as a selected worksheet, i.e. the worksheet has its tab
  # highlighted.
  #
  sub select {
  
      my $self = shift;
  
      $self->{_hidden}         = 0; # Selected worksheet can't be hidden.
      $self->{_selected}       = 1;
  }
  
  
  ###############################################################################
  #
  # activate()
  #
  # Set this worksheet as the active worksheet, i.e. the worksheet that is
  # displayed when the workbook is opened. Also set it as selected.
  #
  sub activate {
  
      my $self = shift;
  
      $self->{_hidden}         = 0; # Active worksheet can't be hidden.
      $self->{_selected}       = 1;
      ${$self->{_activesheet}} = $self->{_index};
  }
  
  
  ###############################################################################
  #
  # hide()
  #
  # Hide this worksheet.
  #
  sub hide {
  
      my $self = shift;
  
      $self->{_hidden}         = 1;
  
      # A hidden worksheet shouldn't be active or selected.
      $self->{_selected}       = 0;
      ${$self->{_activesheet}} = 0;
      ${$self->{_firstsheet}}  = 0;
  }
  
  
  ###############################################################################
  #
  # set_first_sheet()
  #
  # Set this worksheet as the first visible sheet. This is necessary
  # when there are a large number of worksheets and the activated
  # worksheet is not visible on the screen.
  #
  sub set_first_sheet {
  
      my $self = shift;
  
      $self->{_hidden}         = 0; # Active worksheet can't be hidden.
      ${$self->{_firstsheet}}  = $self->{_index};
  }
  
  
  ###############################################################################
  #
  # protect($password)
  #
  # Set the worksheet protection flag to prevent accidental modification and to
  # hide formulas if the locked and hidden format properties have been set.
  #
  sub protect {
  
      my $self = shift;
  
      $self->{_protect}   = 1;
      $self->{_password}  = $self->_encode_password($_[0]) if defined $_[0];
  
  }
  
  
  ###############################################################################
  #
  # set_column($firstcol, $lastcol, $width, $format, $hidden, $level)
  #
  # Set the width of a single column or a range of columns.
  # See also: _store_colinfo
  #
  sub set_column {
  
      my $self = shift;
      my @data = @_;
      my $cell = $data[0];
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($cell =~ /^\D/) {
          @data = $self->_substitute_cellref(@_);
  
          # Returned values $row1 and $row2 aren't required here. Remove them.
          shift  @data;       # $row1
          splice @data, 1, 1; # $row2
      }
  
      return if @data < 3; # Ensure at least $firstcol, $lastcol and $width
      return if not defined $data[0]; # Columns must be defined.
      return if not defined $data[1];
  
      # Assume second column is the same as first if 0. Avoids KB918419 bug.
      $data[1] = $data[0] if $data[1] == 0;
  
      # Ensure 2nd col is larger than first. Also for KB918419 bug.
      ($data[0], $data[1]) = ($data[1], $data[0]) if $data[0] > $data[1];
  
      # Limit columns to Excel max of 255.
      $data[0] = 255 if $data[0] > 255;
      $data[1] = 255 if $data[1] > 255;
  
      push @{$self->{_colinfo}}, [ @data ];
  
  
      # Store the col sizes for use when calculating image vertices taking
      # hidden columns into account. Also store the column formats.
      #
      my $width  = $data[4] ? 0 : $data[2]; # Set width to zero if col is hidden
         $width  ||= 0;                     # Ensure width isn't undef.
      my $format = $data[3];
  
      my ($firstcol, $lastcol) = @data;
  
      foreach my $col ($firstcol .. $lastcol) {
          $self->{_col_sizes}->{$col}   = $width;
          $self->{_col_formats}->{$col} = $format if defined $format;
      }
  }
  
  
  ###############################################################################
  #
  # set_selection()
  #
  # Set which cell or cells are selected in a worksheet: see also the
  # sub _store_selection
  #
  sub set_selection {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      $self->{_selection} = [ @_ ];
  }
  
  
  ###############################################################################
  #
  # freeze_panes()
  #
  # Set panes and mark them as frozen. See also _store_panes().
  #
  sub freeze_panes {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      # Extra flag indicated a split and freeze.
      $self->{_frozen_no_split} = 0 if $_[4];
  
      $self->{_frozen} = 1;
      $self->{_panes}  = [ @_ ];
  }
  
  
  ###############################################################################
  #
  # split_panes()
  #
  # Set panes and mark them as split. See also _store_panes().
  #
  sub split_panes {
  
      my $self = shift;
  
      $self->{_frozen}            = 0;
      $self->{_frozen_no_split}   = 0;
      $self->{_panes}             = [ @_ ];
  }
  
  # Older method name for backwards compatibility.
  *thaw_panes = *split_panes;
  
  
  ###############################################################################
  #
  # set_portrait()
  #
  # Set the page orientation as portrait.
  #
  sub set_portrait {
  
      my $self = shift;
  
      $self->{_orientation} = 1;
  }
  
  
  ###############################################################################
  #
  # set_landscape()
  #
  # Set the page orientation as landscape.
  #
  sub set_landscape {
  
      my $self = shift;
  
      $self->{_orientation} = 0;
  }
  
  
  ###############################################################################
  #
  # set_page_view()
  #
  # Set the page view mode for Mac Excel.
  #
  sub set_page_view {
  
      my $self = shift;
  
      $self->{_page_view} = defined $_[0] ? $_[0] : 1;
  }
  
  
  ###############################################################################
  #
  # set_tab_color()
  #
  # Set the colour of the worksheet colour.
  #
  sub set_tab_color {
  
      my $self  = shift;
  
      my $color = &Spreadsheet::WriteExcel::Format::_get_color($_[0]);
         $color = 0 if $color == 0x7FFF; # Default color.
  
      $self->{_tab_color} = $color;
  }
  
  
  ###############################################################################
  #
  # set_paper()
  #
  # Set the paper type. Ex. 1 = US Letter, 9 = A4
  #
  sub set_paper {
  
      my $self = shift;
  
      $self->{_paper_size} = $_[0] || 0;
  }
  
  
  ###############################################################################
  #
  # set_header()
  #
  # Set the page header caption and optional margin.
  #
  sub set_header {
  
      my $self     = shift;
      my $string   = $_[0] || '';
      my $margin   = $_[1] || 0.50;
      my $encoding = $_[2] || 0;
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($string)) {
              $string = Encode::encode("UTF-16BE", $string);
              $encoding = 1;
          }
      }
  
      my $limit    = $encoding ? 255 *2 : 255;
  
      if (length $string >= $limit) {
          carp 'Header string must be less than 255 characters';
          return;
      }
  
      $self->{_header}          = $string;
      $self->{_margin_header}   = $margin;
      $self->{_header_encoding} = $encoding;
  }
  
  
  ###############################################################################
  #
  # set_footer()
  #
  # Set the page footer caption and optional margin.
  #
  sub set_footer {
  
      my $self     = shift;
      my $string   = $_[0] || '';
      my $margin   = $_[1] || 0.50;
      my $encoding = $_[2] || 0;
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($string)) {
              $string = Encode::encode("UTF-16BE", $string);
              $encoding = 1;
          }
      }
  
      my $limit    = $encoding ? 255 *2 : 255;
  
  
      if (length $string >= $limit) {
          carp 'Footer string must be less than 255 characters';
          return;
      }
  
      $self->{_footer}          = $string;
      $self->{_margin_footer}   = $margin;
      $self->{_footer_encoding} = $encoding;
  }
  
  
  ###############################################################################
  #
  # center_horizontally()
  #
  # Center the page horizontally.
  #
  sub center_horizontally {
  
      my $self = shift;
  
      if (defined $_[0]) {
          $self->{_hcenter} = $_[0];
      }
      else {
          $self->{_hcenter} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # center_vertically()
  #
  # Center the page horizontally.
  #
  sub center_vertically {
  
      my $self = shift;
  
      if (defined $_[0]) {
          $self->{_vcenter} = $_[0];
      }
      else {
          $self->{_vcenter} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # set_margins()
  #
  # Set all the page margins to the same value in inches.
  #
  sub set_margins {
  
      my $self = shift;
  
      $self->set_margin_left($_[0]);
      $self->set_margin_right($_[0]);
      $self->set_margin_top($_[0]);
      $self->set_margin_bottom($_[0]);
  }
  
  
  ###############################################################################
  #
  # set_margins_LR()
  #
  # Set the left and right margins to the same value in inches.
  #
  sub set_margins_LR {
  
      my $self = shift;
  
      $self->set_margin_left($_[0]);
      $self->set_margin_right($_[0]);
  }
  
  
  ###############################################################################
  #
  # set_margins_TB()
  #
  # Set the top and bottom margins to the same value in inches.
  #
  sub set_margins_TB {
  
      my $self = shift;
  
      $self->set_margin_top($_[0]);
      $self->set_margin_bottom($_[0]);
  }
  
  
  ###############################################################################
  #
  # set_margin_left()
  #
  # Set the left margin in inches.
  #
  sub set_margin_left {
  
      my $self = shift;
  
      $self->{_margin_left} = defined $_[0] ? $_[0] : 0.75;
  }
  
  
  ###############################################################################
  #
  # set_margin_right()
  #
  # Set the right margin in inches.
  #
  sub set_margin_right {
  
      my $self = shift;
  
      $self->{_margin_right} = defined $_[0] ? $_[0] : 0.75;
  }
  
  
  ###############################################################################
  #
  # set_margin_top()
  #
  # Set the top margin in inches.
  #
  sub set_margin_top {
  
      my $self = shift;
  
      $self->{_margin_top} = defined $_[0] ? $_[0] : 1.00;
  }
  
  
  ###############################################################################
  #
  # set_margin_bottom()
  #
  # Set the bottom margin in inches.
  #
  sub set_margin_bottom {
  
      my $self = shift;
  
      $self->{_margin_bottom} = defined $_[0] ? $_[0] : 1.00;
  }
  
  
  ###############################################################################
  #
  # repeat_rows($first_row, $last_row)
  #
  # Set the rows to repeat at the top of each printed page. See also the
  # _store_name_xxxx() methods in Workbook.pm.
  #
  sub repeat_rows {
  
      my $self = shift;
  
      $self->{_title_rowmin}  = $_[0];
      $self->{_title_rowmax}  = $_[1] || $_[0]; # Second row is optional
  }
  
  
  ###############################################################################
  #
  # repeat_columns($first_col, $last_col)
  #
  # Set the columns to repeat at the left hand side of each printed page.
  # See also the _store_names() methods in Workbook.pm.
  #
  sub repeat_columns {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
  
          # Returned values $row1 and $row2 aren't required here. Remove them.
          shift  @_;       # $row1
          splice @_, 1, 1; # $row2
      }
  
      $self->{_title_colmin}  = $_[0];
      $self->{_title_colmax}  = $_[1] || $_[0]; # Second col is optional
  }
  
  
  ###############################################################################
  #
  # print_area($first_row, $first_col, $last_row, $last_col)
  #
  # Set the area of each worksheet that will be printed. See also the
  # _store_names() methods in Workbook.pm.
  #
  sub print_area {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      return if @_ != 4; # Require 4 parameters
  
      $self->{_print_rowmin} = $_[0];
      $self->{_print_colmin} = $_[1];
      $self->{_print_rowmax} = $_[2];
      $self->{_print_colmax} = $_[3];
  }
  
  
  ###############################################################################
  #
  # autofilter($first_row, $first_col, $last_row, $last_col)
  #
  # Set the autofilter area in the worksheet.
  #
  sub autofilter {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      return if @_ != 4; # Require 4 parameters
  
      my ($row1, $col1, $row2, $col2) = @_;
  
      # Reverse max and min values if necessary.
      ($row1, $row2) = ($row2, $row1) if $row2 < $row1;
      ($col1, $col2) = ($col2, $col1) if $col2 < $col1;
  
      # Store the Autofilter information
      $self->{_filter_area}  = [$row1, $row2, $col1, $col2];
      $self->{_filter_count} = 1+ $col2 -$col1;
  }
  
  
  ###############################################################################
  #
  # filter_column($column, $criteria, ...)
  #
  # Set the column filter criteria.
  #
  sub filter_column {
  
      my $self        = shift;
      my $col         = $_[0];
      my $expression  = $_[1];
  
  
      croak "Must call autofilter() before filter_column()"
                                                   unless $self->{_filter_count};
      croak "Incorrect number of arguments to filter_column()" unless @_ == 2;
  
  
      # Check for a column reference in A1 notation and substitute.
      if ($col =~ /^\D/) {
          # Convert col ref to a cell ref and then to a col number.
          (undef, $col) = $self->_substitute_cellref($col . '1');
      }
  
      my (undef, undef, $col_first, $col_last) = @{$self->{_filter_area}};
  
      # Reject column if it is outside filter range.
      if ($col < $col_first or $col > $col_last) {
          croak "Column '$col' outside autofilter() column range " .
                "($col_first .. $col_last)";
      }
  
  
      my @tokens = $self->_extract_filter_tokens($expression);
  
      croak "Incorrect number of tokens in expression '$expression'"
            unless (@tokens == 3 or @tokens == 7);
  
  
      @tokens = $self->_parse_filter_expression($expression, @tokens);
  
      $self->{_filter_cols}->{$col} = [@tokens];
      $self->{_filter_on}           = 1;
  }
  
  
  ###############################################################################
  #
  # _extract_filter_tokens($expression)
  #
  # Extract the tokens from the filter expression. The tokens are mainly non-
  # whitespace groups. The only tricky part is to extract string tokens that
  # contain whitespace and/or quoted double quotes (Excel's escaped quotes).
  #
  # Examples: 'x <  2000'
  #           'x >  2000 and x <  5000'
  #           'x = "foo"'
  #           'x = "foo bar"'
  #           'x = "foo "" bar"'
  #
  sub _extract_filter_tokens {
  
      my $self        = shift;
      my $expression  = $_[0];
  
      return unless $expression;
  
      my @tokens = ($expression  =~ /"(?:[^"]|"")*"|\S+/g); #"
  
      # Remove leading and trailing quotes and unescape other quotes
      for (@tokens) {
          s/^"//;     #"
          s/"$//;     #"
          s/""/"/g;   #"
      }
  
      return @tokens;
  }
  
  
  ###############################################################################
  #
  # _parse_filter_expression(@token)
  #
  # Converts the tokens of a possibly conditional expression into 1 or 2
  # sub expressions for further parsing.
  #
  # Examples:
  #          ('x', '==', 2000) -> exp1
  #          ('x', '>',  2000, 'and', 'x', '<', 5000) -> exp1 and exp2
  #
  sub _parse_filter_expression {
  
      my $self        = shift;
      my $expression  = shift;
      my @tokens      = @_;
  
      # The number of tokens will be either 3 (for 1 expression)
      # or 7 (for 2  expressions).
      #
      if (@tokens == 7) {
  
          my $conditional = $tokens[3];
  
          if    ($conditional =~ /^(and|&&)$/) {
              $conditional = 0;
          }
          elsif ($conditional =~ /^(or|\|\|)$/) {
              $conditional = 1;
          }
          else {
              croak "Token '$conditional' is not a valid conditional " .
                    "in filter expression '$expression'";
          }
  
          my @expression_1 = $self->_parse_filter_tokens($expression,
                                                         @tokens[0, 1, 2]);
          my @expression_2 = $self->_parse_filter_tokens($expression,
                                                         @tokens[4, 5, 6]);
  
          return (@expression_1, $conditional, @expression_2);
      }
      else {
          return $self->_parse_filter_tokens($expression, @tokens);
      }
  }
  
  
  ###############################################################################
  #
  # _parse_filter_tokens(@token)
  #
  # Parse the 3 tokens of a filter expression and return the operator and token.
  #
  sub _parse_filter_tokens {
  
      my $self        = shift;
      my $expression  = shift;
      my @tokens      = @_;
  
      my %operators = (
                          '==' => 2,
                          '='  => 2,
                          '=~' => 2,
                          'eq' => 2,
  
                          '!=' => 5,
                          '!~' => 5,
                          'ne' => 5,
                          '<>' => 5,
  
                          '<'  => 1,
                          '<=' => 3,
                          '>'  => 4,
                          '>=' => 6,
                      );
  
      my $operator = $operators{$tokens[1]};
      my $token    = $tokens[2];
  
  
      # Special handling of "Top" filter expressions.
      if ($tokens[0] =~ /^top|bottom$/i) {
  
          my $value = $tokens[1];
  
          if ($value =~ /\D/ or
              $value < 1     or
              $value > 500)
          {
              croak "The value '$value' in expression '$expression' " .
                     "must be in the range 1 to 500";
          }
  
          $token = lc $token;
  
          if ($token ne 'items' and $token ne '%') {
              croak "The type '$token' in expression '$expression' " .
                     "must be either 'items' or '%'";
          }
  
          if ($tokens[0] =~ /^top$/i) {
              $operator = 30;
          }
          else {
              $operator = 32;
          }
  
          if ($tokens[2] eq '%') {
              $operator++;
          }
  
          $token    = $value;
      }
  
  
      if (not $operator and $tokens[0]) {
          croak "Token '$tokens[1]' is not a valid operator " .
                "in filter expression '$expression'";
      }
  
  
      # Special handling for Blanks/NonBlanks.
      if ($token =~ /^blanks|nonblanks$/i) {
  
          # Only allow Equals or NotEqual in this context.
          if ($operator != 2 and $operator != 5) {
              croak "The operator '$tokens[1]' in expression '$expression' " .
                     "is not valid in relation to Blanks/NonBlanks'";
          }
  
          $token = lc $token;
  
          # The operator should always be 2 (=) to flag a "simple" equality in
          # the binary record. Therefore we convert <> to =.
          if ($token eq 'blanks') {
              if ($operator == 5) {
                  $operator = 2;
                  $token    = 'nonblanks';
              }
          }
          else {
              if ($operator == 5) {
                  $operator = 2;
                  $token    = 'blanks';
              }
          }
      }
  
  
      # if the string token contains an Excel match character then change the
      # operator type to indicate a non "simple" equality.
      if ($operator == 2 and $token =~ /[*?]/) {
          $operator = 22;
      }
  
  
      return ($operator, $token);
  }
  
  
  ###############################################################################
  #
  # hide_gridlines()
  #
  # Set the option to hide gridlines on the screen and the printed page.
  # There are two ways of doing this in the Excel BIFF format: The first is by
  # setting the DspGrid field of the WINDOW2 record, this turns off the screen
  # and subsequently the print gridline. The second method is to via the
  # PRINTGRIDLINES and GRIDSET records, this turns off the printed gridlines
  # only. The first method is probably sufficient for most cases. The second
  # method is supported for backwards compatibility. Porters take note.
  #
  sub hide_gridlines {
  
      my $self   = shift;
      my $option = $_[0];
  
      $option = 1 unless defined $option; # Default to hiding printed gridlines
  
      if ($option == 0) {
          $self->{_print_gridlines}  = 1; # 1 = display, 0 = hide
          $self->{_screen_gridlines} = 1;
      }
      elsif ($option == 1) {
          $self->{_print_gridlines}  = 0;
          $self->{_screen_gridlines} = 1;
      }
      else {
          $self->{_print_gridlines}  = 0;
          $self->{_screen_gridlines} = 0;
      }
  }
  
  
  ###############################################################################
  #
  # print_row_col_headers()
  #
  # Set the option to print the row and column headers on the printed page.
  # See also the _store_print_headers() method below.
  #
  sub print_row_col_headers {
  
      my $self = shift;
  
      if (defined $_[0]) {
          $self->{_print_headers} = $_[0];
      }
      else {
          $self->{_print_headers} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # fit_to_pages($width, $height)
  #
  # Store the vertical and horizontal number of pages that will define the
  # maximum area printed. See also _store_setup() and _store_wsbool() below.
  #
  sub fit_to_pages {
  
      my $self = shift;
  
      $self->{_fit_page}      = 1;
      $self->{_fit_width}     = $_[0] || 0;
      $self->{_fit_height}    = $_[1] || 0;
  }
  
  
  ###############################################################################
  #
  # set_h_pagebreaks(@breaks)
  #
  # Store the horizontal page breaks on a worksheet.
  #
  sub set_h_pagebreaks {
  
      my $self = shift;
  
      push @{$self->{_hbreaks}}, @_;
  }
  
  
  ###############################################################################
  #
  # set_v_pagebreaks(@breaks)
  #
  # Store the vertical page breaks on a worksheet.
  #
  sub set_v_pagebreaks {
  
      my $self = shift;
  
      push @{$self->{_vbreaks}}, @_;
  }
  
  
  ###############################################################################
  #
  # set_zoom($scale)
  #
  # Set the worksheet zoom factor.
  #
  sub set_zoom {
  
      my $self  = shift;
      my $scale = $_[0] || 100;
  
      # Confine the scale to Excel's range
      if ($scale < 10 or $scale > 400) {
          carp "Zoom factor $scale outside range: 10 <= zoom <= 400";
          $scale = 100;
      }
  
      $self->{_zoom} = int $scale;
  }
  
  
  ###############################################################################
  #
  # set_print_scale($scale)
  #
  # Set the scale factor for the printed page.
  #
  sub set_print_scale {
  
      my $self  = shift;
      my $scale = $_[0] || 100;
  
      # Confine the scale to Excel's range
      if ($scale < 10 or $scale > 400) {
          carp "Print scale $scale outside range: 10 <= zoom <= 400";
          $scale = 100;
      }
  
      # Turn off "fit to page" option
      $self->{_fit_page}    = 0;
  
      $self->{_print_scale} = int $scale;
  }
  
  
  ###############################################################################
  #
  # keep_leading_zeros()
  #
  # Causes the write() method to treat integers with a leading zero as a string.
  # This ensures that any leading zeros such, as in zip codes, are maintained.
  #
  sub keep_leading_zeros {
  
      my $self = shift;
  
      if (defined $_[0]) {
          $self->{_leading_zeros} = $_[0];
      }
      else {
          $self->{_leading_zeros} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # show_comments()
  #
  # Make any comments in the worksheet visible.
  #
  sub show_comments {
  
      my $self = shift;
  
      $self->{_comments_visible} = defined $_[0] ? $_[0] : 1;
  }
  
  
  ###############################################################################
  #
  # set_comments_author()
  #
  # Set the default author of the cell comments.
  #
  sub set_comments_author {
  
      my $self = shift;
  
      $self->{_comments_author}     = defined $_[0] ? $_[0] : '';
      $self->{_comments_author_enc} =         $_[1] ? 1     : 0;
  }
  
  
  ###############################################################################
  #
  # right_to_left()
  #
  # Display the worksheet right to left for some eastern versions of Excel.
  #
  sub right_to_left {
  
      my $self = shift;
  
      $self->{_display_arabic} = defined $_[0] ? $_[0] : 1;
  }
  
  
  ###############################################################################
  #
  # hide_zero()
  #
  # Hide cell zero values.
  #
  sub hide_zero {
  
      my $self = shift;
  
      $self->{_display_zeros} = defined $_[0] ? not $_[0] : 0;
  }
  
  
  ###############################################################################
  #
  # print_across()
  #
  # Set the order in which pages are printed.
  #
  sub print_across {
  
      my $self = shift;
  
      $self->{_page_order} = defined $_[0] ? $_[0] : 1;
  }
  
  
  ###############################################################################
  #
  # set_start_page()
  #
  # Set the start page number.
  #
  sub set_start_page {
  
      my $self = shift;
      return unless defined $_[0];
  
      $self->{_page_start}    = $_[0];
      $self->{_custom_start}  = 1;
  }
  
  
  ###############################################################################
  #
  # set_first_row_column()
  #
  # Set the topmost and leftmost visible row and column.
  # TODO: Document this when tested fully for interaction with panes.
  #
  sub set_first_row_column {
  
      my $self = shift;
  
      my $row  = $_[0] || 0;
      my $col  = $_[1] || 0;
  
      $row = 65535 if $row > 65535;
      $col = 255   if $col > 255;
  
      $self->{_first_row} = $row;
      $self->{_first_col} = $col;
  }
  
  
  ###############################################################################
  #
  # add_write_handler($re, $code_ref)
  #
  # Allow the user to add their own matches and handlers to the write() method.
  #
  sub add_write_handler {
  
      my $self = shift;
  
      return unless @_ == 2;
      return unless ref $_[1] eq 'CODE';
  
      push @{$self->{_write_match}}, [ @_ ];
  }
  
  
  
  ###############################################################################
  #
  # write($row, $col, $token, $format)
  #
  # Parse $token and call appropriate write method. $row and $column are zero
  # indexed. $format is optional.
  #
  # The write_url() methods have a flag to prevent recursion when writing a
  # string that looks like a url.
  #
  # Returns: return value of called subroutine
  #
  sub write {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      my $token = $_[2];
  
      # Handle undefs as blanks
      $token = '' unless defined $token;
  
  
      # First try user defined matches.
      for my $aref (@{$self->{_write_match}}) {
          my $re  = $aref->[0];
          my $sub = $aref->[1];
  
          if ($token =~ /$re/) {
              my $match = &$sub($self, @_);
              return $match if defined $match;
          }
      }
  
  
      # Match an array ref.
      if (ref $token eq "ARRAY") {
          return $self->write_row(@_);
      }
      # Match integer with leading zero(s)
      elsif ($self->{_leading_zeros} and $token =~ /^0\d+$/) {
          return $self->write_string(@_);
      }
      # Match number
      elsif ($token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/) {
          return $self->write_number(@_);
      }
      # Match http, https or ftp URL
      elsif ($token =~ m|^[fh]tt?ps?://|    and not $self->{_writing_url}) {
          return $self->write_url(@_);
      }
      # Match mailto:
      elsif ($token =~ m/^mailto:/          and not $self->{_writing_url}) {
          return $self->write_url(@_);
      }
      # Match internal or external sheet link
      elsif ($token =~ m[^(?:in|ex)ternal:] and not $self->{_writing_url}) {
          return $self->write_url(@_);
      }
      # Match formula
      elsif ($token =~ /^=/) {
          return $self->write_formula(@_);
      }
      # Match blank
      elsif ($token eq '') {
          splice @_, 2, 1; # remove the empty string from the parameter list
          return $self->write_blank(@_);
      }
      else {
          return $self->write_string(@_);
      }
  }
  
  
  ###############################################################################
  #
  # write_row($row, $col, $array_ref, $format)
  #
  # Write a row of data starting from ($row, $col). Call write_col() if any of
  # the elements of the array ref are in turn array refs. This allows the writing
  # of 1D or 2D arrays of data in one go.
  #
  # Returns: the first encountered error value or zero for no errors
  #
  sub write_row {
  
      my $self = shift;
  
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      # Catch non array refs passed by user.
      if (ref $_[2] ne 'ARRAY') {
          croak "Not an array ref in call to write_row()$!";
      }
  
      my $row     = shift;
      my $col     = shift;
      my $tokens  = shift;
      my @options = @_;
      my $error   = 0;
      my $ret;
  
      foreach my $token (@$tokens) {
  
          # Check for nested arrays
          if (ref $token eq "ARRAY") {
              $ret = $self->write_col($row, $col, $token, @options);
          } else {
              $ret = $self->write    ($row, $col, $token, @options);
          }
  
          # Return only the first error encountered, if any.
          $error ||= $ret;
          $col++;
      }
  
      return $error;
  }
  
  
  ###############################################################################
  #
  # write_col($row, $col, $array_ref, $format)
  #
  # Write a column of data starting from ($row, $col). Call write_row() if any of
  # the elements of the array ref are in turn array refs. This allows the writing
  # of 1D or 2D arrays of data in one go.
  #
  # Returns: the first encountered error value or zero for no errors
  #
  sub write_col {
  
      my $self = shift;
  
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      # Catch non array refs passed by user.
      if (ref $_[2] ne 'ARRAY') {
          croak "Not an array ref in call to write_col()$!";
      }
  
      my $row     = shift;
      my $col     = shift;
      my $tokens  = shift;
      my @options = @_;
      my $error   = 0;
      my $ret;
  
      foreach my $token (@$tokens) {
  
          # write() will deal with any nested arrays
          $ret = $self->write($row, $col, $token, @options);
  
          # Return only the first error encountered, if any.
          $error ||= $ret;
          $row++;
      }
  
      return $error;
  }
  
  
  ###############################################################################
  #
  # write_comment($row, $col, $comment)
  #
  # Write a comment to the specified row and column (zero indexed).
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_comment {
  
      my $self = shift;
  
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 3) { return -1 } # Check the number of args
  
  
      my $row = $_[0];
      my $col = $_[1];
  
      # Check for pairs of optional arguments, i.e. an odd number of args.
      croak "Uneven number of additional arguments" unless @_ % 2;
  
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
  
      # We have to avoid duplicate comments in cells or else Excel will complain.
      $self->{_comments}->{$row}->{$col} = [ $self->_comment_params(@_) ];
  
  }
  
  
  ###############################################################################
  #
  # _XF()
  #
  # Returns an index to the XF record in the workbook.
  #
  # Note: this is a function, not a method.
  #
  sub _XF {
  
      my $self   = $_[0];
      my $row    = $_[1];
      my $col    = $_[2];
      my $format = $_[3];
  
      my $error = "Error: refer to merge_range() in the documentation. " .
                   "Can't use previously merged format in non-merged cell";
  
      if (ref($format)) {
          # Temp code to prevent merged formats in non-merged cells.
          croak $error if $format->{_used_merge} == 1;
          $format->{_used_merge} = -1;
  
          return $format->get_xf_index();
      }
      elsif (exists $self->{_row_formats}->{$row}) {
          # Temp code to prevent merged formats in non-merged cells.
          croak $error if $self->{_row_formats}->{$row}->{_used_merge} == 1;
          $self->{_row_formats}->{$row}->{_used_merge} = -1;
  
          return $self->{_row_formats}->{$row}->get_xf_index();
      }
      elsif (exists $self->{_col_formats}->{$col}) {
          # Temp code to prevent merged formats in non-merged cells.
          croak $error if $self->{_col_formats}->{$col}->{_used_merge} == 1;
          $self->{_col_formats}->{$col}->{_used_merge} = -1;
  
          return $self->{_col_formats}->{$col}->get_xf_index();
      }
      else {
          return 0x0F;
      }
  }
  
  
  ###############################################################################
  ###############################################################################
  #
  # Internal methods
  #
  
  
  ###############################################################################
  #
  # _append(), overridden.
  #
  # Store Worksheet data in memory using the base class _append() or to a
  # temporary file, the default.
  #
  sub _append {
  
      my $self = shift;
      my $data = '';
  
      if ($self->{_using_tmpfile}) {
          $data = join('', @_);
  
          # Add CONTINUE records if necessary
          $data = $self->_add_continue($data) if length($data) > $self->{_limit};
  
          # Protect print() from -l on the command line.
          local $\ = undef;
  
          print {$self->{_filehandle}} $data;
          $self->{_datasize} += length($data);
      }
      else {
          $data = $self->SUPER::_append(@_);
      }
  
      return $data;
  }
  
  
  ###############################################################################
  #
  # _substitute_cellref()
  #
  # Substitute an Excel cell reference in A1 notation for  zero based row and
  # column values in an argument list.
  #
  # Ex: ("A4", "Hello") is converted to (3, 0, "Hello").
  #
  sub _substitute_cellref {
  
      my $self = shift;
      my $cell = uc(shift);
  
      # Convert a column range: 'A:A' or 'B:G'.
      # A range such as A:A is equivalent to A1:65536, so add rows as required
      if ($cell =~ /\$?([A-I]?[A-Z]):\$?([A-I]?[A-Z])/) {
          my ($row1, $col1) =  $self->_cell_to_rowcol($1 .'1');
          my ($row2, $col2) =  $self->_cell_to_rowcol($2 .'65536');
          return $row1, $col1, $row2, $col2, @_;
      }
  
      # Convert a cell range: 'A1:B7'
      if ($cell =~ /\$?([A-I]?[A-Z]\$?\d+):\$?([A-I]?[A-Z]\$?\d+)/) {
          my ($row1, $col1) =  $self->_cell_to_rowcol($1);
          my ($row2, $col2) =  $self->_cell_to_rowcol($2);
          return $row1, $col1, $row2, $col2, @_;
      }
  
      # Convert a cell reference: 'A1' or 'AD2000'
      if ($cell =~ /\$?([A-I]?[A-Z]\$?\d+)/) {
          my ($row1, $col1) =  $self->_cell_to_rowcol($1);
          return $row1, $col1, @_;
  
      }
  
      croak("Unknown cell reference $cell");
  }
  
  
  ###############################################################################
  #
  # _cell_to_rowcol($cell_ref)
  #
  # Convert an Excel cell reference in A1 notation to a zero based row and column
  # reference; converts C1 to (0, 2).
  #
  # Returns: row, column
  #
  sub _cell_to_rowcol {
  
      my $self = shift;
      my $cell = shift;
  
      $cell =~ /\$?([A-I]?[A-Z])\$?(\d+)/;
  
      my $col     = $1;
      my $row     = $2;
  
      # Convert base26 column string to number
      # All your Base are belong to us.
      my @chars = split //, $col;
      my $expn  = 0;
      $col      = 0;
  
      while (@chars) {
          my $char = pop(@chars); # LS char first
          $col += (ord($char) -ord('A') +1) * (26**$expn);
          $expn++;
      }
  
      # Convert 1-index to zero-index
      $row--;
      $col--;
  
      return $row, $col;
  }
  
  
  ###############################################################################
  #
  # _sort_pagebreaks()
  #
  #
  # This is an internal method that is used to filter elements of the array of
  # pagebreaks used in the _store_hbreak() and _store_vbreak() methods. It:
  #   1. Removes duplicate entries from the list.
  #   2. Sorts the list.
  #   3. Removes 0 from the list if present.
  #
  sub _sort_pagebreaks {
  
      my $self= shift;
  
      my %hash;
      my @array;
  
      @hash{@_} = undef;                       # Hash slice to remove duplicates
      @array    = sort {$a <=> $b} keys %hash; # Numerical sort
      shift @array if $array[0] == 0;          # Remove zero
  
      # 1000 vertical pagebreaks appears to be an internal Excel 5 limit.
      # It is slightly higher in Excel 97/200, approx. 1026
      splice(@array, 1000) if (@array > 1000);
  
      return @array
  }
  
  
  ###############################################################################
  #
  # _encode_password($password)
  #
  # Based on the algorithm provided by Daniel Rentz of OpenOffice.
  #
  #
  sub _encode_password {
  
      use integer;
  
      my $self      = shift;
      my $plaintext = $_[0];
      my $password;
      my $count;
      my @chars;
      my $i = 0;
  
      $count = @chars = split //, $plaintext;
  
      foreach my $char (@chars) {
          my $low_15;
          my $high_15;
          $char     = ord($char) << ++$i;
          $low_15   = $char & 0x7fff;
          $high_15  = $char & 0x7fff << 15;
          $high_15  = $high_15 >> 15;
          $char     = $low_15 | $high_15;
      }
  
      $password  = 0x0000;
      $password ^= $_ for @chars;
      $password ^= $count;
      $password ^= 0xCE4B;
  
      return $password;
  }
  
  
  ###############################################################################
  #
  # outline_settings($visible, $symbols_below, $symbols_right, $auto_style)
  #
  # This method sets the properties for outlining and grouping. The defaults
  # correspond to Excel's defaults.
  #
  sub outline_settings {
  
      my $self                = shift;
  
      $self->{_outline_on}    = defined $_[0] ? $_[0] : 1;
      $self->{_outline_below} = defined $_[1] ? $_[1] : 1;
      $self->{_outline_right} = defined $_[2] ? $_[2] : 1;
      $self->{_outline_style} =         $_[3] || 0;
  
      # Ensure this is a boolean vale for Window2
      $self->{_outline_on}    = 1 if $self->{_outline_on};
  }
  
  
  
  
  ###############################################################################
  ###############################################################################
  #
  # BIFF RECORDS
  #
  
  
  ###############################################################################
  #
  # write_number($row, $col, $num, $format)
  #
  # Write a double to the specified row and column (zero indexed).
  # An integer can be written as a double. Excel will display an
  # integer. $format is optional.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_number {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 3) { return -1 }                    # Check the number of args
  
      my $record  = 0x0203;                        # Record identifier
      my $length  = 0x000E;                        # Number of bytes to follow
  
      my $row     = $_[0];                         # Zero indexed row
      my $col     = $_[1];                         # Zero indexed column
      my $num     = $_[2];
      my $xf      = _XF($self, $row, $col, $_[3]); # The cell format
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("vvv", $row, $col, $xf);
      my $xl_double = pack("d",   $num);
  
      if ($self->{_byte_order}) { $xl_double = reverse $xl_double }
  
      # Store the data or write immediately depending on the compatibility mode.
      if ($self->{_compatibility}) {
          $self->{_table}->[$row]->[$col] = $header . $data . $xl_double;
      }
      else {
          $self->_append($header, $data, $xl_double);
      }
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_string ($row, $col, $string, $format)
  #
  # Write a string to the specified row and column (zero indexed).
  # $format is optional.
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : long string truncated to max chars
  #
  sub write_string {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 3) { return -1 }                        # Check the number of args
  
      my $record      = 0x00FD;                        # Record identifier
      my $length      = 0x000A;                        # Bytes to follow
  
      my $row         = $_[0];                         # Zero indexed row
      my $col         = $_[1];                         # Zero indexed column
      my $strlen      = length($_[2]);
      my $str         = $_[2];
      my $xf          = _XF($self, $row, $col, $_[3]); # The cell format
      my $encoding    = 0x0;
      my $str_error   = 0;
  
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($str)) {
              my $tmp = Encode::encode("UTF-16LE", $str);
              return $self->write_utf16le_string($row, $col, $tmp, $_[3]);
          }
      }
  
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
      # Limit the string to the max number of chars.
      if ($strlen > 32767) {
          $str       = substr($str, 0, 32767);
          $str_error = -3;
      }
  
  
      # Prepend the string with the type.
      my $str_header  = pack("vC", length($str), $encoding);
      $str            = $str_header . $str;
  
  
      if (not exists ${$self->{_str_table}}->{$str}) {
          ${$self->{_str_table}}->{$str} = ${$self->{_str_unique}}++;
      }
  
  
      ${$self->{_str_total}}++;
  
  
      my $header = pack("vv",   $record, $length);
      my $data   = pack("vvvV", $row, $col, $xf, ${$self->{_str_table}}->{$str});
  
  
      # Store the data or write immediately depending on the compatibility mode.
      if ($self->{_compatibility}) {
          $self->{_table}->[$row]->[$col] = $header . $data;
      }
      else {
          $self->_append($header, $data);
      }
  
      return $str_error;
  }
  
  
  ###############################################################################
  #
  # write_blank($row, $col, $format)
  #
  # Write a blank cell to the specified row and column (zero indexed).
  # A blank cell is used to specify formatting without adding a string
  # or a number.
  #
  # A blank cell without a format serves no purpose. Therefore, we don't write
  # a BLANK record unless a format is specified. This is mainly an optimisation
  # for the write_row() and write_col() methods.
  #
  # Returns  0 : normal termination (including no format)
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_blank {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      # Check the number of args
      return -1 if @_ < 2;
  
      # Don't write a blank cell unless it has a format
      return 0 if not defined $_[2];
  
  
      my $record  = 0x0201;                        # Record identifier
      my $length  = 0x0006;                        # Number of bytes to follow
  
      my $row     = $_[0];                         # Zero indexed row
      my $col     = $_[1];                         # Zero indexed column
      my $xf      = _XF($self, $row, $col, $_[2]); # The cell format
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("vvv", $row, $col, $xf);
  
      # Store the data or write immediately depending on the compatibility mode.
      if ($self->{_compatibility}) {
          $self->{_table}->[$row]->[$col] = $header . $data;
      }
      else {
          $self->_append($header, $data);
      }
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_formula($row, $col, $formula, $format, $value)
  #
  # Write a formula to the specified row and column (zero indexed).
  # The textual representation of the formula is passed to the parser in
  # Formula.pm which returns a packed binary string.
  #
  # $format is optional.
  #
  # $value is an optional result of the formula that can be supplied by the user.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_formula {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 3) { return -1 }   # Check the number of args
  
      return if ! defined $_[2];
  
      my $record    = 0x0006;     # Record identifier
      my $length;                 # Bytes to follow
  
      my $row       = $_[0];      # Zero indexed row
      my $col       = $_[1];      # Zero indexed column
      my $formula   = $_[2];      # The formula text string
      my $value     = $_[4];      # The formula value.
  
  
      my $xf        = _XF($self, $row, $col, $_[3]);  # The cell format
      my $chn       = 0x0000;                         # Must be zero
      my $is_string = 0;                              # Formula evaluates to str
      my $num;                                        # Current value of formula
      my $grbit;                                      # Option flags
  
  
      # Excel normally stores the last calculated value of the formula in $num.
      # Clearly we are not in a position to calculate this "a priori". Instead
      # we set $num to zero and set the option flags in $grbit to ensure
      # automatic calculation of the formula when the file is opened.
      # As a workaround for some non-Excel apps we also allow the user to
      # specify the result of the formula.
      #
      ($num, $grbit, $is_string) = $self->_encode_formula_result($value);
  
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
      # Strip the = sign at the beginning of the formula string
      $formula    =~ s(^=)();
  
      my $tmp     = $formula;
  
      # Parse the formula using the parser in Formula.pm
      my $parser  = $self->{_parser};
  
      # In order to raise formula errors from the point of view of the calling
      # program we use an eval block and re-raise the error from here.
      #
      eval { $formula = $parser->parse_formula($formula) };
  
      if ($@) {
          $@ =~ s/\n$//;  # Strip the \n used in the Formula.pm die()
          croak $@;       # Re-raise the error
      }
  
  
      my $formlen = length($formula); # Length of the binary string
         $length  = 0x16 + $formlen;  # Length of the record data
  
      my $header  = pack("vv",    $record, $length);
      my $data    = pack("vvv",   $row, $col, $xf);
         $data   .= $num;
         $data   .= pack("vVv",   $grbit, $chn, $formlen);
  
      # The STRING record if the formula evaluates to a string.
      my $string  = '';
         $string  = $self->_get_formula_string($value) if $is_string;
  
  
      # Store the data or write immediately depending on the compatibility mode.
      if ($self->{_compatibility}) {
          $self->{_table}->[$row]->[$col] = $header . $data . $formula . $string;
      }
      else {
          $self->_append($header, $data, $formula, $string);
      }
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # _encode_formula_result()
  #
  # Encode the user supplied result for a formula.
  #
  sub _encode_formula_result {
  
      my $self = shift;
  
      my $value     = $_[0];      # Result to be encoded.
      my $is_string = 0;          # Formula evaluates to str.
      my $num;                    # Current value of formula.
      my $grbit;                  # Option flags.
  
      if (not defined $value) {
          $grbit  = 0x03;
          $num    = pack "d", 0;
      }
      else {
          # The user specified the result of the formula. We turn off the recalc
          # flag and check the result type.
          $grbit  = 0x00;
  
          if ($value =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/) {
              # Value is a number.
              $num = pack "d", $value;
          }
          else {
  
              my %bools = (
                              'TRUE'    => [1,  1],
                              'FALSE'   => [1,  0],
                              '#NULL!'  => [2,  0],
                              '#DIV/0!' => [2,  7],
                              '#VALUE!' => [2, 15],
                              '#REF!'   => [2, 23],
                              '#NAME?'  => [2, 29],
                              '#NUM!'   => [2, 36],
                              '#N/A'    => [2, 42],
                          );
  
              if (exists $bools{$value}) {
                  # Value is a boolean.
                  $num = pack "vvvv", $bools{$value}->[0],
                                      $bools{$value}->[1],
                                      0,
                                      0xFFFF;
              }
              else {
                  # Value is a string.
                  $num = pack "vvvv", 0,
                                      0,
                                      0,
                                      0xFFFF;
                  $is_string = 1;
              }
          }
      }
  
      return ($num, $grbit, $is_string);
  }
  
  
  ###############################################################################
  #
  # _get_formula_string()
  #
  # Pack the string value when a formula evaluates to a string. The value cannot
  # be calculated by the module and thus must be supplied by the user.
  #
  sub _get_formula_string {
  
      my $self = shift;
  
      my $record    = 0x0207;         # Record identifier
      my $length    = 0x00;           # Bytes to follow
      my $string    = $_[0];          # Formula string.
      my $strlen    = length $_[0];   # Length of the formula string (chars).
      my $encoding  = 0;              # String encoding.
  
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($string)) {
              $string = Encode::encode("UTF-16BE", $string);
              $encoding = 1;
          }
      }
  
  
      $length       = 0x03 + length $string;  # Length of the record data
  
      my $header    = pack("vv", $record, $length);
      my $data      = pack("vC", $strlen, $encoding);
  
      return $header . $data . $string;
  }
  
  
  ###############################################################################
  #
  # store_formula($formula)
  #
  # Pre-parse a formula. This is used in conjunction with repeat_formula()
  # to repetitively rewrite a formula without re-parsing it.
  #
  sub store_formula {
  
      my $self    = shift;
      my $formula = $_[0];      # The formula text string
  
      # Strip the = sign at the beginning of the formula string
      $formula    =~ s(^=)();
  
      # Parse the formula using the parser in Formula.pm
      my $parser  = $self->{_parser};
  
      # In order to raise formula errors from the point of view of the calling
      # program we use an eval block and re-raise the error from here.
      #
      my @tokens;
      eval { @tokens = $parser->parse_formula($formula) };
  
      if ($@) {
          $@ =~ s/\n$//;  # Strip the \n used in the Formula.pm die()
          croak $@;       # Re-raise the error
      }
  
  
      # Return the parsed tokens in an anonymous array
      return [@tokens];
  }
  
  
  ###############################################################################
  #
  # repeat_formula($row, $col, $formula, $format, ($pattern => $replacement,...))
  #
  # Write a formula to the specified row and column (zero indexed) by
  # substituting $pattern $replacement pairs in the $formula created via
  # store_formula(). This allows the user to repetitively rewrite a formula
  # without the significant overhead of parsing.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub repeat_formula {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 2) { return -1 }   # Check the number of args
  
      my $record      = 0x0006;   # Record identifier
      my $length;                 # Bytes to follow
  
      my $row         = shift;    # Zero indexed row
      my $col         = shift;    # Zero indexed column
      my $formula_ref = shift;    # Array ref with formula tokens
      my $format      = shift;    # XF format
      my @pairs       = @_;       # Pattern/replacement pairs
  
  
      # Enforce an even number of arguments in the pattern/replacement list
      croak "Odd number of elements in pattern/replacement list" if @pairs %2;
  
      # Check that $formula is an array ref
      croak "Not a valid formula" if ref $formula_ref ne 'ARRAY';
  
      my @tokens  = @$formula_ref;
  
      # Ensure that there are tokens to substitute
      croak "No tokens in formula" unless @tokens;
  
  
      # As a temporary and undocumented measure we allow the user to specify the
      # result of the formula by appending a result => $value pair to the end
      # of the arguments.
      my $value = undef;
      if (@pairs && $pairs[-2] eq 'result') {
          $value = pop @pairs;
                   pop @pairs;
      }
  
  
      while (@pairs) {
          my $pattern = shift @pairs;
          my $replace = shift @pairs;
  
          foreach my $token (@tokens) {
              last if $token =~ s/$pattern/$replace/;
          }
      }
  
  
      # Change the parameters in the formula cached by the Formula.pm object
      my $parser    = $self->{_parser};
      my $formula   = $parser->parse_tokens(@tokens);
  
      croak "Unrecognised token in formula" unless defined $formula;
  
  
      my $xf        = _XF($self, $row, $col, $format); # The cell format
      my $chn       = 0x0000;                          # Must be zero
      my $is_string = 0;                               # Formula evaluates to str
      my $num;                                         # Current value of formula
      my $grbit;                                       # Option flags
  
      # Excel normally stores the last calculated value of the formula in $num.
      # Clearly we are not in a position to calculate this "a priori". Instead
      # we set $num to zero and set the option flags in $grbit to ensure
      # automatic calculation of the formula when the file is opened.
      # As a workaround for some non-Excel apps we also allow the user to
      # specify the result of the formula.
      #
      ($num, $grbit, $is_string) = $self->_encode_formula_result($value);
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
  
      my $formlen   = length($formula); # Length of the binary string
      $length       = 0x16 + $formlen;  # Length of the record data
  
      my $header    = pack("vv",    $record, $length);
      my $data      = pack("vvv",   $row, $col, $xf);
         $data     .= $num;
         $data     .= pack("vVv",   $grbit, $chn, $formlen);
  
  
      # The STRING record if the formula evaluates to a string.
      my $string  = '';
         $string  = $self->_get_formula_string($value) if $is_string;
  
  
      # Store the data or write immediately depending on the compatibility mode.
      if ($self->{_compatibility}) {
          $self->{_table}->[$row]->[$col] = $header . $data . $formula . $string;
      }
      else {
          $self->_append($header, $data, $formula, $string);
      }
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_url($row, $col, $url, $string, $format)
  #
  # Write a hyperlink. This is comprised of two elements: the visible label and
  # the invisible link. The visible label is the same as the link unless an
  # alternative string is specified.
  #
  # The parameters $string and $format are optional and their order is
  # interchangeable for backward compatibility reasons.
  #
  # The hyperlink can be to a http, ftp, mail, internal sheet, or external
  # directory url.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : long string truncated to 255 chars
  #
  sub write_url {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      # Check the number of args
      return -1 if @_ < 3;
  
      # Add start row and col to arg list
      return $self->write_url_range($_[0], $_[1], @_);
  }
  
  
  ###############################################################################
  #
  # write_url_range($row1, $col1, $row2, $col2, $url, $string, $format)
  #
  # This is the more general form of write_url(). It allows a hyperlink to be
  # written to a range of cells. This function also decides the type of hyperlink
  # to be written. These are either, Web (http, ftp, mailto), Internal
  # (Sheet1!A1) or external ('c:\temp\foo.xls#Sheet1!A1').
  #
  # See also write_url() above for a general description and return values.
  #
  sub write_url_range {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      # Check the number of args
      return -1 if @_ < 5;
  
  
      # Reverse the order of $string and $format if necessary. We work on a copy
      # in order to protect the callers args. We don't use "local @_" in case of
      # perl50005 threads.
      #
      my @args = @_;
  
      ($args[5], $args[6]) = ($args[6], $args[5]) if ref $args[5];
  
      my $url = $args[4];
  
  
      # Check for internal/external sheet links or default to web link
      return $self->_write_url_internal(@args) if $url =~ m[^internal:];
      return $self->_write_url_external(@args) if $url =~ m[^external:];
      return $self->_write_url_web(@args);
  }
  
  
  ###############################################################################
  #
  # _write_url_web($row1, $col1, $row2, $col2, $url, $string, $format)
  #
  # Used to write http, ftp and mailto hyperlinks.
  # The link type ($options) is 0x03 is the same as absolute dir ref without
  # sheet. However it is differentiated by the $unknown2 data stream.
  #
  # See also write_url() above for a general description and return values.
  #
  sub _write_url_web {
  
      my $self    = shift;
  
      my $record      = 0x01B8;                       # Record identifier
      my $length      = 0x00000;                      # Bytes to follow
  
      my $row1        = $_[0];                        # Start row
      my $col1        = $_[1];                        # Start column
      my $row2        = $_[2];                        # End row
      my $col2        = $_[3];                        # End column
      my $url         = $_[4];                        # URL string
      my $str         = $_[5];                        # Alternative label
      my $xf          = $_[6] || $self->{_url_format};# The cell format
  
  
      # Write the visible label but protect against url recursion in write().
      $str                  = $url unless defined $str;
      $self->{_writing_url} = 1;
      my $error             = $self->write($row1, $col1, $str, $xf);
      $self->{_writing_url} = 0;
      return $error         if $error == -2;
  
  
      # Pack the undocumented parts of the hyperlink stream
      my $unknown1    = pack("H*", "D0C9EA79F9BACE118C8200AA004BA90B02000000");
      my $unknown2    = pack("H*", "E0C9EA79F9BACE118C8200AA004BA90B");
  
  
      # Pack the option flags
      my $options     = pack("V", 0x03);
  
  
      # URL encoding.
      my $encoding    = 0;
  
      # Convert an Utf8 URL type and to a null terminated wchar string.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($url)) {
              $url      = Encode::encode("UTF-16LE", $url);
              $url     .= "\0\0"; # URL is null terminated.
              $encoding = 1;
          }
      }
  
      # Convert an Ascii URL type and to a null terminated wchar string.
      if ($encoding == 0) {
          $url       .= "\0";
          $url        = pack 'v*', unpack 'c*', $url;
      }
  
  
      # Pack the length of the URL
      my $url_len     = pack("V", length($url));
  
  
      # Calculate the data length
      $length         = 0x34 + length($url);
  
  
      # Pack the header data
      my $header      = pack("vv",   $record, $length);
      my $data        = pack("vvvv", $row1, $row2, $col1, $col2);
  
  
      # Write the packed data
      $self->_append( $header,
                      $data,
                      $unknown1,
                      $options,
                      $unknown2,
                      $url_len,
                      $url);
  
      return $error;
  }
  
  
  ###############################################################################
  #
  # _write_url_internal($row1, $col1, $row2, $col2, $url, $string, $format)
  #
  # Used to write internal reference hyperlinks such as "Sheet1!A1".
  #
  # See also write_url() above for a general description and return values.
  #
  sub _write_url_internal {
  
      my $self    = shift;
  
      my $record      = 0x01B8;                       # Record identifier
      my $length      = 0x00000;                      # Bytes to follow
  
      my $row1        = $_[0];                        # Start row
      my $col1        = $_[1];                        # Start column
      my $row2        = $_[2];                        # End row
      my $col2        = $_[3];                        # End column
      my $url         = $_[4];                        # URL string
      my $str         = $_[5];                        # Alternative label
      my $xf          = $_[6] || $self->{_url_format};# The cell format
  
      # Strip URL type
      $url            =~ s[^internal:][];
  
  
      # Write the visible label but protect against url recursion in write().
      $str                  = $url unless defined $str;
      $self->{_writing_url} = 1;
      my $error             = $self->write($row1, $col1, $str, $xf);
      $self->{_writing_url} = 0;
      return $error         if $error == -2;
  
  
      # Pack the undocumented parts of the hyperlink stream
      my $unknown1    = pack("H*", "D0C9EA79F9BACE118C8200AA004BA90B02000000");
  
  
      # Pack the option flags
      my $options     = pack("V", 0x08);
  
  
      # URL encoding.
      my $encoding    = 0;
  
  
      # Convert an Utf8 URL type and to a null terminated wchar string.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($url)) {
              # Quote sheet name if not already, i.e., Sheet!A1 to 'Sheet!A1'.
              $url      =~ s/^(.+)!/'$1'!/ if not $url =~ /^'/;
  
              $url      = Encode::encode("UTF-16LE", $url);
              $url     .= "\0\0"; # URL is null terminated.
              $encoding = 1;
          }
      }
  
  
      # Convert an Ascii URL type and to a null terminated wchar string.
      if ($encoding == 0) {
          $url       .= "\0";
          $url        = pack 'v*', unpack 'c*', $url;
      }
  
  
      # Pack the length of the URL as chars (not wchars)
      my $url_len     = pack("V", int(length($url)/2));
  
  
      # Calculate the data length
      $length         = 0x24 + length($url);
  
  
      # Pack the header data
      my $header      = pack("vv",   $record, $length);
      my $data        = pack("vvvv", $row1, $row2, $col1, $col2);
  
  
      # Write the packed data
      $self->_append( $header,
                      $data,
                      $unknown1,
                      $options,
                      $url_len,
                      $url);
  
      return $error;
  }
  
  
  ###############################################################################
  #
  # _write_url_external($row1, $col1, $row2, $col2, $url, $string, $format)
  #
  # Write links to external directory names such as 'c:\foo.xls',
  # c:\foo.xls#Sheet1!A1', '../../foo.xls'. and '../../foo.xls#Sheet1!A1'.
  #
  # Note: Excel writes some relative links with the $dir_long string. We ignore
  # these cases for the sake of simpler code.
  #
  # See also write_url() above for a general description and return values.
  #
  sub _write_url_external {
  
      my $self    = shift;
  
      # Network drives are different. We will handle them separately
      # MS/Novell network drives and shares start with \\
      return $self->_write_url_external_net(@_) if $_[4] =~ m[^external:\\\\];
  
  
      my $record      = 0x01B8;                       # Record identifier
      my $length      = 0x00000;                      # Bytes to follow
  
      my $row1        = $_[0];                        # Start row
      my $col1        = $_[1];                        # Start column
      my $row2        = $_[2];                        # End row
      my $col2        = $_[3];                        # End column
      my $url         = $_[4];                        # URL string
      my $str         = $_[5];                        # Alternative label
      my $xf          = $_[6] || $self->{_url_format};# The cell format
  
  
      # Strip URL type and change Unix dir separator to Dos style (if needed)
      #
      $url            =~ s[^external:][];
      $url            =~ s[/][\\]g;
  
  
      # Write the visible label but protect against url recursion in write().
      ($str = $url)         =~ s[\#][ - ] unless defined $str;
      $self->{_writing_url} = 1;
      my $error             = $self->write($row1, $col1, $str, $xf);
      $self->{_writing_url} = 0;
      return $error         if $error == -2;
  
  
      # Determine if the link is relative or absolute:
      # Absolute if link starts with DOS drive specifier like C:
      # Otherwise default to 0x00 for relative link.
      #
      my $absolute    = 0x00;
         $absolute    = 0x02  if $url =~ m/^[A-Za-z]:/;
  
  
      # Determine if the link contains a sheet reference and change some of the
      # parameters accordingly.
      # Split the dir name and sheet name (if it exists)
      #
      my ($dir_long , $sheet) = split /\#/, $url;
      my $link_type           = 0x01 | $absolute;
      my $sheet_len;
  
      if (defined $sheet) {
          $link_type |= 0x08;
          $sheet_len  = pack("V", length($sheet) + 0x01);
          $sheet      = join("\0", split('', $sheet));
          $sheet     .= "\0\0\0";
      }
      else {
          $sheet_len  = '';
          $sheet      = '';
      }
  
  
      # Pack the link type
      $link_type      = pack("V", $link_type);
  
  
      # Calculate the up-level dir count e.g. (..\..\..\ == 3)
      my $up_count    = 0;
      $up_count++       while $dir_long =~ s[^\.\.\\][];
      $up_count       = pack("v", $up_count);
  
  
      # Store the short dos dir name (null terminated)
      my $dir_short   = $dir_long . "\0";
  
  
      # Store the long dir name as a wchar string (non-null terminated)
      $dir_long       = join("\0", split('', $dir_long));
      $dir_long       = $dir_long . "\0";
  
  
      # Pack the lengths of the dir strings
      my $dir_short_len = pack("V", length $dir_short      );
      my $dir_long_len  = pack("V", length $dir_long       );
      my $stream_len    = pack("V", length($dir_long) + 0x06);
  
  
      # Pack the undocumented parts of the hyperlink stream
      my $unknown1 =pack("H*",'D0C9EA79F9BACE118C8200AA004BA90B02000000'       );
      my $unknown2 =pack("H*",'0303000000000000C000000000000046'               );
      my $unknown3 =pack("H*",'FFFFADDE000000000000000000000000000000000000000');
      my $unknown4 =pack("v",  0x03                                            );
  
  
      # Pack the main data stream
      my $data        = pack("vvvv", $row1, $row2, $col1, $col2) .
                        $unknown1     .
                        $link_type    .
                        $unknown2     .
                        $up_count     .
                        $dir_short_len.
                        $dir_short    .
                        $unknown3     .
                        $stream_len   .
                        $dir_long_len .
                        $unknown4     .
                        $dir_long     .
                        $sheet_len    .
                        $sheet        ;
  
  
      # Pack the header data
      $length         = length $data;
      my $header      = pack("vv",   $record, $length);
  
  
      # Write the packed data
      $self->_append($header, $data);
  
      return $error;
  }
  
  
  
  
  ###############################################################################
  #
  # _write_url_external_net($row1, $col1, $row2, $col2, $url, $string, $format)
  #
  # Write links to external MS/Novell network drives and shares such as
  # '//NETWORK/share/foo.xls' and '//NETWORK/share/foo.xls#Sheet1!A1'.
  #
  # See also write_url() above for a general description and return values.
  #
  sub _write_url_external_net {
  
      my $self    = shift;
  
      my $record      = 0x01B8;                       # Record identifier
      my $length      = 0x00000;                      # Bytes to follow
  
      my $row1        = $_[0];                        # Start row
      my $col1        = $_[1];                        # Start column
      my $row2        = $_[2];                        # End row
      my $col2        = $_[3];                        # End column
      my $url         = $_[4];                        # URL string
      my $str         = $_[5];                        # Alternative label
      my $xf          = $_[6] || $self->{_url_format};# The cell format
  
  
      # Strip URL type and change Unix dir separator to Dos style (if needed)
      #
      $url            =~ s[^external:][];
      $url            =~ s[/][\\]g;
  
  
      # Write the visible label but protect against url recursion in write().
      ($str = $url)         =~ s[\#][ - ] unless defined $str;
      $self->{_writing_url} = 1;
      my $error             = $self->write($row1, $col1, $str, $xf);
      $self->{_writing_url} = 0;
      return $error         if $error == -2;
  
  
      # Determine if the link contains a sheet reference and change some of the
      # parameters accordingly.
      # Split the dir name and sheet name (if it exists)
      #
      my ($dir_long , $sheet) = split /\#/, $url;
      my $link_type           = 0x0103; # Always absolute
      my $sheet_len;
  
      if (defined $sheet) {
          $link_type |= 0x08;
          $sheet_len  = pack("V", length($sheet) + 0x01);
          $sheet      = join("\0", split('', $sheet));
          $sheet     .= "\0\0\0";
      }
      else {
          $sheet_len   = '';
          $sheet       = '';
      }
  
      # Pack the link type
      $link_type      = pack("V", $link_type);
  
  
      # Make the string null terminated
      $dir_long       = $dir_long . "\0";
  
  
      # Pack the lengths of the dir string
      my $dir_long_len  = pack("V", length $dir_long);
  
  
      # Store the long dir name as a wchar string (non-null terminated)
      $dir_long       = join("\0", split('', $dir_long));
      $dir_long       = $dir_long . "\0";
  
  
      # Pack the undocumented part of the hyperlink stream
      my $unknown1    = pack("H*",'D0C9EA79F9BACE118C8200AA004BA90B02000000');
  
  
      # Pack the main data stream
      my $data        = pack("vvvv", $row1, $row2, $col1, $col2) .
                        $unknown1     .
                        $link_type    .
                        $dir_long_len .
                        $dir_long     .
                        $sheet_len    .
                        $sheet        ;
  
  
      # Pack the header data
      $length         = length $data;
      my $header      = pack("vv",   $record, $length);
  
  
      # Write the packed data
      $self->_append($header, $data);
  
      return $error;
  }
  
  
  ###############################################################################
  #
  # write_date_time ($row, $col, $string, $format)
  #
  # Write a datetime string in ISO8601 "yyyy-mm-ddThh:mm:ss.ss" format as a
  # number representing an Excel date. $format is optional.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : Invalid date_time, written as string
  #
  sub write_date_time {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 3) { return -1 }                        # Check the number of args
  
      my $row       = $_[0];                           # Zero indexed row
      my $col       = $_[1];                           # Zero indexed column
      my $str       = $_[2];
  
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
      my $error     = 0;
      my $date_time = $self->convert_date_time($str);
  
      if (defined $date_time) {
          $error = $self->write_number($row, $col, $date_time, $_[3]);
      }
      else {
          # The date isn't valid so write it as a string.
          $self->write_string($row, $col, $str, $_[3]);
          $error = -3;
      }
      return $error;
  }
  
  
  
  ###############################################################################
  #
  # convert_date_time($date_time_string)
  #
  # The function takes a date and time in ISO8601 "yyyy-mm-ddThh:mm:ss.ss" format
  # and converts it to a decimal number representing a valid Excel date.
  #
  # Dates and times in Excel are represented by real numbers. The integer part of
  # the number stores the number of days since the epoch and the fractional part
  # stores the percentage of the day in seconds. The epoch can be either 1900 or
  # 1904.
  #
  # Parameter: Date and time string in one of the following formats:
  #               yyyy-mm-ddThh:mm:ss.ss  # Standard
  #               yyyy-mm-ddT             # Date only
  #                         Thh:mm:ss.ss  # Time only
  #
  # Returns:
  #            A decimal number representing a valid Excel date, or
  #            undef if the date is invalid.
  #
  sub convert_date_time {
  
      my $self      = shift;
      my $date_time = $_[0];
  
      my $days      = 0; # Number of days since epoch
      my $seconds   = 0; # Time expressed as fraction of 24h hours in seconds
  
      my ($year, $month, $day);
      my ($hour, $min, $sec);
  
  
      # Strip leading and trailing whitespace.
      $date_time =~ s/^\s+//;
      $date_time =~ s/\s+$//;
  
      # Check for invalid date char.
      return if     $date_time =~ /[^0-9T:\-\.Z]/;
  
      # Check for "T" after date or before time.
      return unless $date_time =~ /\dT|T\d/;
  
      # Strip trailing Z in ISO8601 date.
      $date_time =~ s/Z$//;
  
  
      # Split into date and time.
      my ($date, $time) = split /T/, $date_time;
  
  
      # We allow the time portion of the input DateTime to be optional.
      if ($time ne '') {
          # Match hh:mm:ss.sss+ where the seconds are optional
          if ($time =~ /^(\d\d):(\d\d)(:(\d\d(\.\d+)?))?/) {
              $hour   = $1;
              $min    = $2;
              $sec    = $4 || 0;
          }
          else {
              return undef; # Not a valid time format.
          }
  
          # Some boundary checks
          return if $hour >= 24;
          return if $min  >= 60;
          return if $sec  >= 60;
  
          # Excel expresses seconds as a fraction of the number in 24 hours.
          $seconds = ($hour *60*60 + $min *60 + $sec) / (24 *60 *60);
      }
  
  
      # We allow the date portion of the input DateTime to be optional.
      return $seconds if $date eq '';
  
  
      # Match date as yyyy-mm-dd.
      if ($date =~ /^(\d\d\d\d)-(\d\d)-(\d\d)$/) {
          $year   = $1;
          $month  = $2;
          $day    = $3;
      }
      else {
          return undef; # Not a valid date format.
      }
  
      # Set the epoch as 1900 or 1904. Defaults to 1900.
      my $date_1904 = $self->{_1904};
  
  
      # Special cases for Excel.
      if (not $date_1904) {
          return      $seconds if $date eq '1899-12-31'; # Excel 1900 epoch
          return      $seconds if $date eq '1900-01-00'; # Excel 1900 epoch
          return 60 + $seconds if $date eq '1900-02-29'; # Excel false leapday
      }
  
  
      # We calculate the date by calculating the number of days since the epoch
      # and adjust for the number of leap days. We calculate the number of leap
      # days by normalising the year in relation to the epoch. Thus the year 2000
      # becomes 100 for 4 and 100 year leapdays and 400 for 400 year leapdays.
      #
      my $epoch   = $date_1904 ? 1904 : 1900;
      my $offset  = $date_1904 ?    4 :    0;
      my $norm    = 300;
      my $range   = $year -$epoch;
  
  
      # Set month days and check for leap year.
      my @mdays   = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
      my $leap    = 0;
         $leap    = 1  if $year % 4 == 0 and $year % 100 or $year % 400 == 0;
      $mdays[1]   = 29 if $leap;
  
  
      # Some boundary checks
      return if $year  < $epoch or $year  > 9999;
      return if $month < 1      or $month > 12;
      return if $day   < 1      or $day   > $mdays[$month -1];
  
      # Accumulate the number of days since the epoch.
      $days  = $day;                              # Add days for current month
      $days += $mdays[$_] for 0 .. $month -2;     # Add days for past months
      $days += $range *365;                       # Add days for past years
      $days += int(($range)                /  4); # Add leapdays
      $days -= int(($range +$offset)       /100); # Subtract 100 year leapdays
      $days += int(($range +$offset +$norm)/400); # Add 400 year leapdays
      $days -= $leap;                             # Already counted above
  
  
      # Adjust for Excel erroneously treating 1900 as a leap year.
      $days++ if $date_1904 == 0 and $days > 59;
  
      return $days + $seconds;
  }
  
  
  
  
  
  ###############################################################################
  #
  # set_row($row, $height, $XF, $hidden, $level)
  #
  # This method is used to set the height and XF format for a row.
  # Writes the  BIFF record ROW.
  #
  sub set_row {
  
      my $self        = shift;
      my $record      = 0x0208;               # Record identifier
      my $length      = 0x0010;               # Number of bytes to follow
  
      my $row         = $_[0];                # Row Number
      my $colMic      = 0x0000;               # First defined column
      my $colMac      = 0x0000;               # Last defined column
      my $miyRw;                              # Row height
      my $irwMac      = 0x0000;               # Used by Excel to optimise loading
      my $reserved    = 0x0000;               # Reserved
      my $grbit       = 0x0000;               # Option flags
      my $ixfe;                               # XF index
      my $height      = $_[1];                # Row height
      my $format      = $_[2];                # Format object
      my $hidden      = $_[3] || 0;           # Hidden flag
      my $level       = $_[4] || 0;           # Outline level
      my $collapsed   = $_[5] || 0;           # Collapsed row
  
  
      return unless defined $row;  # Ensure at least $row is specified.
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, 0, 0, 1);
  
      # Check for a format object
      if (ref $format) {
          $ixfe = $format->get_xf_index();
      }
      else {
          $ixfe = 0x0F;
      }
  
  
      # Set the row height in units of 1/20 of a point. Note, some heights may
      # not be obtained exactly due to rounding in Excel.
      #
      if (defined $height) {
          $miyRw = $height *20;
      }
      else {
          $miyRw = 0xff; # The default row height
          $height = 0;
      }
  
  
      # Set the limits for the outline levels (0 <= x <= 7).
      $level = 0 if $level < 0;
      $level = 7 if $level > 7;
  
      $self->{_outline_row_level} = $level if $level >$self->{_outline_row_level};
  
  
      # Set the options flags.
      # 0x10: The fCollapsed flag indicates that the row contains the "+"
      #       when an outline group is collapsed.
      # 0x20: The fDyZero height flag indicates a collapsed or hidden row.
      # 0x40: The fUnsynced flag is used to show that the font and row heights
      #       are not compatible. This is usually the case for WriteExcel.
      # 0x80: The fGhostDirty flag indicates that the row has been formatted.
      #
      $grbit |= $level;
      $grbit |= 0x0010 if $collapsed;
      $grbit |= 0x0020 if $hidden;
      $grbit |= 0x0040;
      $grbit |= 0x0080 if $format;
      $grbit |= 0x0100;
  
  
      my $header   = pack("vv",       $record, $length);
      my $data     = pack("vvvvvvvv", $row, $colMic, $colMac, $miyRw,
                                      $irwMac,$reserved, $grbit, $ixfe);
  
  
      # Store the data or write immediately depending on the compatibility mode.
      if ($self->{_compatibility}) {
          $self->{_row_data}->{$_[0]} = $header . $data;
      }
      else {
          $self->_append($header, $data);
      }
  
  
      # Store the row sizes for use when calculating image vertices.
      # Also store the row formats.
      $self->{_row_sizes}->{$_[0]}   = $height;
      $self->{_row_formats}->{$_[0]} = $format if defined $format;
  }
  
  
  
  ###############################################################################
  #
  # _write_row_default()
  #
  # Write a default row record, in compatibility mode, for rows that don't have
  # user specified values..
  #
  sub _write_row_default {
  
      my $self        = shift;
      my $record      = 0x0208;               # Record identifier
      my $length      = 0x0010;               # Number of bytes to follow
  
      my $row         = $_[0];                # Row Number
      my $colMic      = $_[1];                # First defined column
      my $colMac      = $_[2];                # Last defined column
      my $miyRw       = 0xFF;                 # Row height
      my $irwMac      = 0x0000;               # Used by Excel to optimise loading
      my $reserved    = 0x0000;               # Reserved
      my $grbit       = 0x0100;               # Option flags
      my $ixfe        = 0x0F;                 # XF index
  
      my $header   = pack("vv",       $record, $length);
      my $data     = pack("vvvvvvvv", $row, $colMic, $colMac, $miyRw,
                                      $irwMac,$reserved, $grbit, $ixfe);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _check_dimensions($row, $col, $ignore_row, $ignore_col)
  #
  # Check that $row and $col are valid and store max and min values for use in
  # DIMENSIONS record. See, _store_dimensions().
  #
  # The $ignore_row/$ignore_col flags is used to indicate that we wish to
  # perform the dimension check without storing the value.
  #
  # The ignore flags are use by set_row() and data_validate.
  #
  sub _check_dimensions {
  
      my $self        = shift;
      my $row         = $_[0];
      my $col         = $_[1];
      my $ignore_row  = $_[2];
      my $ignore_col  = $_[3];
  
  
      return -2 if not defined $row;
      return -2 if $row >= $self->{_xls_rowmax};
  
      return -2 if not defined $col;
      return -2 if $col >= $self->{_xls_colmax};
  
  
      if (not $ignore_row) {
  
          if (not defined $self->{_dim_rowmin} or $row < $self->{_dim_rowmin}) {
              $self->{_dim_rowmin} = $row;
          }
  
          if (not defined $self->{_dim_rowmax} or $row > $self->{_dim_rowmax}) {
              $self->{_dim_rowmax} = $row;
          }
      }
  
      if (not $ignore_col) {
  
          if (not defined $self->{_dim_colmin} or $col < $self->{_dim_colmin}) {
              $self->{_dim_colmin} = $col;
          }
  
          if (not defined $self->{_dim_colmax} or $col > $self->{_dim_colmax}) {
              $self->{_dim_colmax} = $col;
          }
      }
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # _store_dimensions()
  #
  # Writes Excel DIMENSIONS to define the area in which there is cell data.
  #
  # Notes:
  #   Excel stores the max row/col as row/col +1.
  #   Max and min values of 0 are used to indicate that no cell data.
  #   We set the undef member data to 0 since it is used by _store_table().
  #   Inserting images or charts doesn't change the DIMENSION data.
  #
  sub _store_dimensions {
  
      my $self      = shift;
      my $record    = 0x0200;         # Record identifier
      my $length    = 0x000E;         # Number of bytes to follow
      my $row_min;                    # First row
      my $row_max;                    # Last row plus 1
      my $col_min;                    # First column
      my $col_max;                    # Last column plus 1
      my $reserved  = 0x0000;         # Reserved by Excel
  
      if (defined $self->{_dim_rowmin}) {$row_min = $self->{_dim_rowmin}    }
      else                              {$row_min = 0                       }
  
      if (defined $self->{_dim_rowmax}) {$row_max = $self->{_dim_rowmax} + 1}
      else                              {$row_max = 0                       }
  
      if (defined $self->{_dim_colmin}) {$col_min = $self->{_dim_colmin}    }
      else                              {$col_min = 0                       }
  
      if (defined $self->{_dim_colmax}) {$col_max = $self->{_dim_colmax} + 1}
      else                              {$col_max = 0                       }
  
  
      # Set member data to the new max/min value for use by _store_table().
      $self->{_dim_rowmin} = $row_min;
      $self->{_dim_rowmax} = $row_max;
      $self->{_dim_colmin} = $col_min;
      $self->{_dim_colmax} = $col_max;
  
  
      my $header    = pack("vv",    $record, $length);
      my $data      = pack("VVvvv", $row_min, $row_max,
                                    $col_min, $col_max, $reserved);
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_window2()
  #
  # Write BIFF record Window2.
  #
  sub _store_window2 {
  
      use integer;    # Avoid << shift bug in Perl 5.6.0 on HP-UX
  
      my $self           = shift;
      my $record         = 0x023E;     # Record identifier
      my $length         = 0x0012;     # Number of bytes to follow
  
      my $grbit          = 0x00B6;     # Option flags
      my $rwTop          = $self->{_first_row};   # Top visible row
      my $colLeft        = $self->{_first_col};   # Leftmost visible column
      my $rgbHdr         = 0x00000040;            # Row/col heading, grid color
  
      my $wScaleSLV      = 0x0000;                # Zoom in page break preview
      my $wScaleNormal   = 0x0000;                # Zoom in normal view
      my $reserved       = 0x00000000;
  
  
      # The options flags that comprise $grbit
      my $fDspFmla       = $self->{_display_formulas}; # 0 - bit
      my $fDspGrid       = $self->{_screen_gridlines}; # 1
      my $fDspRwCol      = $self->{_display_headers};  # 2
      my $fFrozen        = $self->{_frozen};           # 3
      my $fDspZeros      = $self->{_display_zeros};    # 4
      my $fDefaultHdr    = 1;                          # 5
      my $fArabic        = $self->{_display_arabic};   # 6
      my $fDspGuts       = $self->{_outline_on};       # 7
      my $fFrozenNoSplit = $self->{_frozen_no_split};  # 0 - bit
      my $fSelected      = $self->{_selected};         # 1
      my $fPaged         = $self->{_active};           # 2
      my $fBreakPreview  = 0;                          # 3
  
      $grbit             = $fDspFmla;
      $grbit            |= $fDspGrid       << 1;
      $grbit            |= $fDspRwCol      << 2;
      $grbit            |= $fFrozen        << 3;
      $grbit            |= $fDspZeros      << 4;
      $grbit            |= $fDefaultHdr    << 5;
      $grbit            |= $fArabic        << 6;
      $grbit            |= $fDspGuts       << 7;
      $grbit            |= $fFrozenNoSplit << 8;
      $grbit            |= $fSelected      << 9;
      $grbit            |= $fPaged         << 10;
      $grbit            |= $fBreakPreview  << 11;
  
      my $header  = pack("vv",      $record, $length);
      my $data    = pack("vvvVvvV", $grbit, $rwTop, $colLeft, $rgbHdr,
                                    $wScaleSLV, $wScaleNormal, $reserved );
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_page_view()
  #
  # Set page view mode. Only applicable to Mac Excel.
  #
  sub _store_page_view {
  
      my $self    = shift;
  
      return unless $self->{_page_view};
  
      my $data    = pack "H*", 'C8081100C808000000000040000000000900000000';
  
      $self->_append($data);
  }
  
  
  ###############################################################################
  #
  # _store_tab_color()
  #
  # Write the Tab Color BIFF record.
  #
  sub _store_tab_color {
  
      my $self    = shift;
      my $color   = $self->{_tab_color};
  
      return unless $color;
  
      my $record  = 0x0862;      # Record identifier
      my $length  = 0x0014;      # Number of bytes to follow
  
      my $zero    = 0x0000;
      my $unknown = 0x0014;
  
      my $header  = pack("vv", $record, $length);
      my $data    = pack("vvvvvvvvvv", $record, $zero, $zero, $zero, $zero,
                                       $zero, $unknown, $zero, $color, $zero);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_defrow()
  #
  # Write BIFF record DEFROWHEIGHT.
  #
  sub _store_defrow {
  
      my $self     = shift;
      my $record   = 0x0225;      # Record identifier
      my $length   = 0x0004;      # Number of bytes to follow
  
      my $grbit    = 0x0000;      # Options.
      my $height   = 0x00FF;      # Default row height
  
      my $header   = pack("vv", $record, $length);
      my $data     = pack("vv", $grbit,  $height);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_defcol()
  #
  # Write BIFF record DEFCOLWIDTH.
  #
  sub _store_defcol {
  
      my $self     = shift;
      my $record   = 0x0055;      # Record identifier
      my $length   = 0x0002;      # Number of bytes to follow
  
      my $colwidth = 0x0008;      # Default column width
  
      my $header   = pack("vv", $record, $length);
      my $data     = pack("v",  $colwidth);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_colinfo($firstcol, $lastcol, $width, $format, $hidden)
  #
  # Write BIFF record COLINFO to define column widths
  #
  # Note: The SDK says the record length is 0x0B but Excel writes a 0x0C
  # length record.
  #
  sub _store_colinfo {
  
      my $self     = shift;
      my $record   = 0x007D;          # Record identifier
      my $length   = 0x000B;          # Number of bytes to follow
  
      my $colFirst = $_[0] || 0;      # First formatted column
      my $colLast  = $_[1] || 0;      # Last formatted column
      my $width    = $_[2] || 8.43;   # Col width in user units, 8.43 is default
      my $coldx;                      # Col width in internal units
      my $pixels;                     # Col width in pixels
  
      # Excel rounds the column width to the nearest pixel. Therefore we first
      # convert to pixels and then to the internal units. The pixel to users-units
      # relationship is different for values less than 1.
      #
      if ($width < 1) {
          $pixels = int($width *12);
      }
      else {
          $pixels = int($width *7 ) +5;
      }
  
      $coldx = int($pixels *256/7);
  
  
      my $ixfe;                          # XF index
      my $grbit       = 0x0000;          # Option flags
      my $reserved    = 0x00;            # Reserved
      my $format      = $_[3];           # Format object
      my $hidden      = $_[4] || 0;      # Hidden flag
      my $level       = $_[5] || 0;      # Outline level
      my $collapsed   = $_[6] || 0;      # Outline level
  
  
      # Check for a format object
      if (ref $format) {
          $ixfe = $format->get_xf_index();
      }
      else {
          $ixfe = 0x0F;
      }
  
  
      # Set the limits for the outline levels (0 <= x <= 7).
      $level = 0 if $level < 0;
      $level = 7 if $level > 7;
  
  
      # Set the options flags. (See set_row() for more details).
      $grbit |= 0x0001 if $hidden;
      $grbit |= $level << 8;
      $grbit |= 0x1000 if $collapsed;
  
  
      my $header   = pack("vv",     $record, $length);
      my $data     = pack("vvvvvC", $colFirst, $colLast, $coldx,
                                    $ixfe, $grbit, $reserved);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_filtermode()
  #
  # Write BIFF record FILTERMODE to indicate that the worksheet contains
  # AUTOFILTER record, ie. autofilters with a filter set.
  #
  sub _store_filtermode {
  
      my $self        = shift;
  
      my $record      = 0x009B;      # Record identifier
      my $length      = 0x0000;      # Number of bytes to follow
  
      # Only write the record if the worksheet contains a filtered autofilter.
      return unless $self->{_filter_on};
  
      my $header   = pack("vv", $record, $length);
  
      $self->_prepend($header);
  }
  
  
  ###############################################################################
  #
  # _store_autofilterinfo()
  #
  # Write BIFF record AUTOFILTERINFO.
  #
  sub _store_autofilterinfo {
  
      my $self        = shift;
  
      my $record      = 0x009D;      # Record identifier
      my $length      = 0x0002;      # Number of bytes to follow
      my $num_filters = $self->{_filter_count};
  
      # Only write the record if the worksheet contains an autofilter.
      return unless $self->{_filter_count};
  
      my $header   = pack("vv", $record, $length);
      my $data     = pack("v",  $num_filters);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_selection($first_row, $first_col, $last_row, $last_col)
  #
  # Write BIFF record SELECTION.
  #
  sub _store_selection {
  
      my $self     = shift;
      my $record   = 0x001D;                  # Record identifier
      my $length   = 0x000F;                  # Number of bytes to follow
  
      my $pnn      = $self->{_active_pane};   # Pane position
      my $rwAct    = $_[0];                   # Active row
      my $colAct   = $_[1];                   # Active column
      my $irefAct  = 0;                       # Active cell ref
      my $cref     = 1;                       # Number of refs
  
      my $rwFirst  = $_[0];                   # First row in reference
      my $colFirst = $_[1];                   # First col in reference
      my $rwLast   = $_[2] || $rwFirst;       # Last  row in reference
      my $colLast  = $_[3] || $colFirst;      # Last  col in reference
  
      # Swap last row/col for first row/col as necessary
      if ($rwFirst > $rwLast) {
          ($rwFirst, $rwLast) = ($rwLast, $rwFirst);
      }
  
      if ($colFirst > $colLast) {
          ($colFirst, $colLast) = ($colLast, $colFirst);
      }
  
  
      my $header   = pack("vv",           $record, $length);
      my $data     = pack("CvvvvvvCC",    $pnn, $rwAct, $colAct,
                                          $irefAct, $cref,
                                          $rwFirst, $rwLast,
                                          $colFirst, $colLast);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_externcount($count)
  #
  # Write BIFF record EXTERNCOUNT to indicate the number of external sheet
  # references in a worksheet.
  #
  # Excel only stores references to external sheets that are used in formulas.
  # For simplicity we store references to all the sheets in the workbook
  # regardless of whether they are used or not. This reduces the overall
  # complexity and eliminates the need for a two way dialogue between the formula
  # parser the worksheet objects.
  #
  sub _store_externcount {
  
      my $self     = shift;
      my $record   = 0x0016;          # Record identifier
      my $length   = 0x0002;          # Number of bytes to follow
  
      my $cxals    = $_[0];           # Number of external references
  
      my $header   = pack("vv", $record, $length);
      my $data     = pack("v",  $cxals);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_externsheet($sheetname)
  #
  #
  # Writes the Excel BIFF EXTERNSHEET record. These references are used by
  # formulas. A formula references a sheet name via an index. Since we store a
  # reference to all of the external worksheets the EXTERNSHEET index is the same
  # as the worksheet index.
  #
  sub _store_externsheet {
  
      my $self      = shift;
  
      my $record    = 0x0017;         # Record identifier
      my $length;                     # Number of bytes to follow
  
      my $sheetname = $_[0];          # Worksheet name
      my $cch;                        # Length of sheet name
      my $rgch;                       # Filename encoding
  
      # References to the current sheet are encoded differently to references to
      # external sheets.
      #
      if ($self->{_name} eq $sheetname) {
          $sheetname = '';
          $length    = 0x02;  # The following 2 bytes
          $cch       = 1;     # The following byte
          $rgch      = 0x02;  # Self reference
      }
      else {
          $length    = 0x02 + length($_[0]);
          $cch       = length($sheetname);
          $rgch      = 0x03;  # Reference to a sheet in the current workbook
      }
  
      my $header     = pack("vv",  $record, $length);
      my $data       = pack("CC", $cch, $rgch);
  
      $self->_prepend($header, $data, $sheetname);
  }
  
  
  ###############################################################################
  #
  # _store_panes()
  #
  #
  # Writes the Excel BIFF PANE record.
  # The panes can either be frozen or thawed (unfrozen).
  # Frozen panes are specified in terms of a integer number of rows and columns.
  # Thawed panes are specified in terms of Excel's units for rows and columns.
  #
  sub _store_panes {
  
      my $self        = shift;
      my $record      = 0x0041;       # Record identifier
      my $length      = 0x000A;       # Number of bytes to follow
  
      my $y           = $_[0] || 0;   # Vertical split position
      my $x           = $_[1] || 0;   # Horizontal split position
      my $rwTop       = $_[2];        # Top row visible
      my $colLeft     = $_[3];        # Leftmost column visible
      my $no_split    = $_[4];        # No used here.
      my $pnnAct      = $_[5];        # Active pane
  
  
      # Code specific to frozen or thawed panes.
      if ($self->{_frozen}) {
          # Set default values for $rwTop and $colLeft
          $rwTop   = $y unless defined $rwTop;
          $colLeft = $x unless defined $colLeft;
      }
      else {
          # Set default values for $rwTop and $colLeft
          $rwTop   = 0  unless defined $rwTop;
          $colLeft = 0  unless defined $colLeft;
  
          # Convert Excel's row and column units to the internal units.
          # The default row height is 12.75
          # The default column width is 8.43
          # The following slope and intersection values were interpolated.
          #
          $y = 20*$y      + 255;
          $x = 113.879*$x + 390;
      }
  
  
      # Determine which pane should be active. There is also the undocumented
      # option to override this should it be necessary: may be removed later.
      #
      if (not defined $pnnAct) {
          $pnnAct = 0 if ($x != 0 && $y != 0); # Bottom right
          $pnnAct = 1 if ($x != 0 && $y == 0); # Top right
          $pnnAct = 2 if ($x == 0 && $y != 0); # Bottom left
          $pnnAct = 3 if ($x == 0 && $y == 0); # Top left
      }
  
      $self->{_active_pane} = $pnnAct; # Used in _store_selection
  
      my $header     = pack("vv",    $record, $length);
      my $data       = pack("vvvvv", $x, $y, $rwTop, $colLeft, $pnnAct);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_setup()
  #
  # Store the page setup SETUP BIFF record.
  #
  sub _store_setup {
  
      use integer;    # Avoid << shift bug in Perl 5.6.0 on HP-UX
  
      my $self         = shift;
      my $record       = 0x00A1;                  # Record identifier
      my $length       = 0x0022;                  # Number of bytes to follow
  
  
      my $iPaperSize   = $self->{_paper_size};    # Paper size
      my $iScale       = $self->{_print_scale};   # Print scaling factor
      my $iPageStart   = $self->{_page_start};    # Starting page number
      my $iFitWidth    = $self->{_fit_width};     # Fit to number of pages wide
      my $iFitHeight   = $self->{_fit_height};    # Fit to number of pages high
      my $grbit        = 0x00;                    # Option flags
      my $iRes         = 0x0258;                  # Print resolution
      my $iVRes        = 0x0258;                  # Vertical print resolution
      my $numHdr       = $self->{_margin_header}; # Header Margin
      my $numFtr       = $self->{_margin_footer}; # Footer Margin
      my $iCopies      = 0x01;                    # Number of copies
  
  
      my $fLeftToRight = $self->{_page_order};    # Print over then down
      my $fLandscape   = $self->{_orientation};   # Page orientation
      my $fNoPls       = 0x0;                     # Setup not read from printer
      my $fNoColor     = $self->{_black_white};   # Print black and white
      my $fDraft       = $self->{_draft_quality}; # Print draft quality
      my $fNotes       = $self->{_print_comments};# Print notes
      my $fNoOrient    = 0x0;                     # Orientation not set
      my $fUsePage     = $self->{_custom_start};  # Use custom starting page
  
  
      $grbit           = $fLeftToRight;
      $grbit          |= $fLandscape    << 1;
      $grbit          |= $fNoPls        << 2;
      $grbit          |= $fNoColor      << 3;
      $grbit          |= $fDraft        << 4;
      $grbit          |= $fNotes        << 5;
      $grbit          |= $fNoOrient     << 6;
      $grbit          |= $fUsePage      << 7;
  
  
      $numHdr = pack("d", $numHdr);
      $numFtr = pack("d", $numFtr);
  
      if ($self->{_byte_order}) {
          $numHdr = reverse $numHdr;
          $numFtr = reverse $numFtr;
      }
  
      my $header = pack("vv",         $record, $length);
      my $data1  = pack("vvvvvvvv",   $iPaperSize,
                                      $iScale,
                                      $iPageStart,
                                      $iFitWidth,
                                      $iFitHeight,
                                      $grbit,
                                      $iRes,
                                      $iVRes);
      my $data2  = $numHdr .$numFtr;
      my $data3  = pack("v", $iCopies);
  
      $self->_prepend($header, $data1, $data2, $data3);
  
  }
  
  ###############################################################################
  #
  # _store_header()
  #
  # Store the header caption BIFF record.
  #
  sub _store_header {
  
      my $self        = shift;
  
      my $record      = 0x0014;                       # Record identifier
      my $length;                                     # Bytes to follow
  
      my $str         = $self->{_header};             # header string
      my $cch         = length($str);                 # Length of header string
      my $encoding    = $self->{_header_encoding};    # Character encoding
  
  
      # Character length is num of chars not num of bytes
      $cch           /= 2 if $encoding;
  
      # Change the UTF-16 name from BE to LE
      $str            = pack 'n*', unpack 'v*', $str if $encoding;
  
      $length         = 3 + length($str);
  
      my $header      = pack("vv",  $record, $length);
      my $data        = pack("vC",  $cch, $encoding);
  
      $self->_prepend($header, $data, $str);
  }
  
  
  ###############################################################################
  #
  # _store_footer()
  #
  # Store the footer caption BIFF record.
  #
  sub _store_footer {
  
      my $self        = shift;
  
      my $record      = 0x0015;                       # Record identifier
      my $length;                                     # Bytes to follow
  
      my $str         = $self->{_footer};             # footer string
      my $cch         = length($str);                 # Length of footer string
      my $encoding    = $self->{_footer_encoding};    # Character encoding
  
  
      # Character length is num of chars not num of bytes
      $cch           /= 2 if $encoding;
  
      # Change the UTF-16 name from BE to LE
      $str            = pack 'n*', unpack 'v*', $str if $encoding;
  
      $length         = 3 + length($str);
  
      my $header      = pack("vv",  $record, $length);
      my $data        = pack("vC",  $cch, $encoding);
  
      $self->_prepend($header, $data, $str);
  }
  
  
  ###############################################################################
  #
  # _store_hcenter()
  #
  # Store the horizontal centering HCENTER BIFF record.
  #
  sub _store_hcenter {
  
      my $self     = shift;
  
      my $record   = 0x0083;              # Record identifier
      my $length   = 0x0002;              # Bytes to follow
  
      my $fHCenter = $self->{_hcenter};   # Horizontal centering
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("v",   $fHCenter);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_vcenter()
  #
  # Store the vertical centering VCENTER BIFF record.
  #
  sub _store_vcenter {
  
      my $self     = shift;
  
      my $record   = 0x0084;              # Record identifier
      my $length   = 0x0002;              # Bytes to follow
  
      my $fVCenter = $self->{_vcenter};   # Horizontal centering
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("v",   $fVCenter);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_margin_left()
  #
  # Store the LEFTMARGIN BIFF record.
  #
  sub _store_margin_left {
  
      my $self    = shift;
  
      my $record  = 0x0026;                   # Record identifier
      my $length  = 0x0008;                   # Bytes to follow
  
      my $margin  = $self->{_margin_left};    # Margin in inches
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("d",   $margin);
  
      if ($self->{_byte_order}) { $data = reverse $data }
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_margin_right()
  #
  # Store the RIGHTMARGIN BIFF record.
  #
  sub _store_margin_right {
  
      my $self    = shift;
  
      my $record  = 0x0027;                   # Record identifier
      my $length  = 0x0008;                   # Bytes to follow
  
      my $margin  = $self->{_margin_right};   # Margin in inches
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("d",   $margin);
  
      if ($self->{_byte_order}) { $data = reverse $data }
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_margin_top()
  #
  # Store the TOPMARGIN BIFF record.
  #
  sub _store_margin_top {
  
      my $self    = shift;
  
      my $record  = 0x0028;                   # Record identifier
      my $length  = 0x0008;                   # Bytes to follow
  
      my $margin  = $self->{_margin_top};     # Margin in inches
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("d",   $margin);
  
      if ($self->{_byte_order}) { $data = reverse $data }
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_margin_bottom()
  #
  # Store the BOTTOMMARGIN BIFF record.
  #
  sub _store_margin_bottom {
  
      my $self    = shift;
  
      my $record  = 0x0029;                   # Record identifier
      my $length  = 0x0008;                   # Bytes to follow
  
      my $margin  = $self->{_margin_bottom};  # Margin in inches
  
      my $header    = pack("vv",  $record, $length);
      my $data      = pack("d",   $margin);
  
      if ($self->{_byte_order}) { $data = reverse $data }
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # merge_cells($first_row, $first_col, $last_row, $last_col)
  #
  # This is an Excel97/2000 method. It is required to perform more complicated
  # merging than the normal align merge in Format.pm
  #
  sub merge_cells {
  
      my $self    = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      my $record  = 0x00E5;                   # Record identifier
      my $length  = 0x000A;                   # Bytes to follow
  
      my $cref     = 1;                       # Number of refs
      my $rwFirst  = $_[0];                   # First row in reference
      my $colFirst = $_[1];                   # First col in reference
      my $rwLast   = $_[2] || $rwFirst;       # Last  row in reference
      my $colLast  = $_[3] || $colFirst;      # Last  col in reference
  
  
      # Excel doesn't allow a single cell to be merged
      return if $rwFirst == $rwLast and $colFirst == $colLast;
  
      # Swap last row/col with first row/col as necessary
      ($rwFirst,  $rwLast ) = ($rwLast,  $rwFirst ) if $rwFirst  > $rwLast;
      ($colFirst, $colLast) = ($colLast, $colFirst) if $colFirst > $colLast;
  
      my $header   = pack("vv",       $record, $length);
      my $data     = pack("vvvvv",    $cref,
                                      $rwFirst, $rwLast,
                                      $colFirst, $colLast);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # merge_range($row1, $col1, $row2, $col2, $string, $format, $encoding)
  #
  # This is a wrapper to ensure correct use of the merge_cells method, i.e., write
  # the first cell of the range, write the formatted blank cells in the range and
  # then call the merge_cells record. Failing to do the steps in this order will
  # cause Excel 97 to crash.
  #
  sub merge_range {
  
      my $self    = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
      croak "Incorrect number of arguments" if @_ != 6 and @_ != 7;
      croak "Format argument is not a format object" unless ref $_[5];
  
      my $rwFirst  = $_[0];
      my $colFirst = $_[1];
      my $rwLast   = $_[2];
      my $colLast  = $_[3];
      my $string   = $_[4];
      my $format   = $_[5];
      my $encoding = $_[6] ? 1 : 0;
  
  
      # Temp code to prevent merged formats in non-merged cells.
      my $error = "Error: refer to merge_range() in the documentation. " .
                  "Can't use previously non-merged format in merged cells";
  
      croak $error if $format->{_used_merge} == -1;
      $format->{_used_merge} = 0; # Until the end of this function.
  
  
      # Set the merge_range property of the format object. For BIFF8+.
      $format->set_merge_range();
  
      # Excel doesn't allow a single cell to be merged
      croak "Can't merge single cell" if $rwFirst  == $rwLast and
                                         $colFirst == $colLast;
  
      # Swap last row/col with first row/col as necessary
      ($rwFirst,  $rwLast ) = ($rwLast,  $rwFirst ) if $rwFirst  > $rwLast;
      ($colFirst, $colLast) = ($colLast, $colFirst) if $colFirst > $colLast;
  
      # Write the first cell
      if ($encoding) {
          $self->write_utf16be_string($rwFirst, $colFirst, $string, $format);
      }
      else {
          $self->write               ($rwFirst, $colFirst, $string, $format);
      }
  
      # Pad out the rest of the area with formatted blank cells.
      for my $row ($rwFirst .. $rwLast) {
          for my $col ($colFirst .. $colLast) {
              next if $row == $rwFirst and $col == $colFirst;
              $self->write_blank($row, $col, $format);
          }
      }
  
      $self->merge_cells($rwFirst, $colFirst, $rwLast, $colLast);
  
      # Temp code to prevent merged formats in non-merged cells.
      $format->{_used_merge} = 1;
  
  }
  
  
  ###############################################################################
  #
  # _store_print_headers()
  #
  # Write the PRINTHEADERS BIFF record.
  #
  sub _store_print_headers {
  
      my $self        = shift;
  
      my $record      = 0x002a;                   # Record identifier
      my $length      = 0x0002;                   # Bytes to follow
  
      my $fPrintRwCol = $self->{_print_headers};  # Boolean flag
  
      my $header      = pack("vv",  $record, $length);
      my $data        = pack("v",   $fPrintRwCol);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_print_gridlines()
  #
  # Write the PRINTGRIDLINES BIFF record. Must be used in conjunction with the
  # GRIDSET record.
  #
  sub _store_print_gridlines {
  
      my $self        = shift;
  
      my $record      = 0x002b;                    # Record identifier
      my $length      = 0x0002;                    # Bytes to follow
  
      my $fPrintGrid  = $self->{_print_gridlines}; # Boolean flag
  
      my $header      = pack("vv",  $record, $length);
      my $data        = pack("v",   $fPrintGrid);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_gridset()
  #
  # Write the GRIDSET BIFF record. Must be used in conjunction with the
  # PRINTGRIDLINES record.
  #
  sub _store_gridset {
  
      my $self        = shift;
  
      my $record      = 0x0082;                        # Record identifier
      my $length      = 0x0002;                        # Bytes to follow
  
      my $fGridSet    = not $self->{_print_gridlines}; # Boolean flag
  
      my $header      = pack("vv",  $record, $length);
      my $data        = pack("v",   $fGridSet);
  
      $self->_prepend($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # _store_guts()
  #
  # Write the GUTS BIFF record. This is used to configure the gutter margins
  # where Excel outline symbols are displayed. The visibility of the gutters is
  # controlled by a flag in WSBOOL. See also _store_wsbool().
  #
  # We are all in the gutter but some of us are looking at the stars.
  #
  sub _store_guts {
  
      my $self        = shift;
  
      my $record      = 0x0080;   # Record identifier
      my $length      = 0x0008;   # Bytes to follow
  
      my $dxRwGut     = 0x0000;   # Size of row gutter
      my $dxColGut    = 0x0000;   # Size of col gutter
  
      my $row_level   = $self->{_outline_row_level};
      my $col_level   = 0;
  
  
      # Calculate the maximum column outline level. The equivalent calculation
      # for the row outline level is carried out in set_row().
      #
      foreach my $colinfo (@{$self->{_colinfo}}) {
          # Skip cols without outline level info.
          next if @{$colinfo} < 6;
          $col_level = @{$colinfo}[5] if @{$colinfo}[5] > $col_level;
      }
  
  
      # Set the limits for the outline levels (0 <= x <= 7).
      $col_level = 0 if $col_level < 0;
      $col_level = 7 if $col_level > 7;
  
  
      # The displayed level is one greater than the max outline levels
      $row_level++ if $row_level > 0;
      $col_level++ if $col_level > 0;
  
      my $header      = pack("vv",   $record, $length);
      my $data        = pack("vvvv", $dxRwGut, $dxColGut, $row_level, $col_level);
  
      $self->_prepend($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # _store_wsbool()
  #
  # Write the WSBOOL BIFF record, mainly for fit-to-page. Used in conjunction
  # with the SETUP record.
  #
  sub _store_wsbool {
  
      my $self        = shift;
  
      my $record      = 0x0081;   # Record identifier
      my $length      = 0x0002;   # Bytes to follow
  
      my $grbit       = 0x0000;   # Option flags
  
      # Set the option flags
      $grbit |= 0x0001;                            # Auto page breaks visible
      $grbit |= 0x0020 if $self->{_outline_style}; # Auto outline styles
      $grbit |= 0x0040 if $self->{_outline_below}; # Outline summary below
      $grbit |= 0x0080 if $self->{_outline_right}; # Outline summary right
      $grbit |= 0x0100 if $self->{_fit_page};      # Page setup fit to page
      $grbit |= 0x0400 if $self->{_outline_on};    # Outline symbols displayed
  
  
      my $header      = pack("vv",  $record, $length);
      my $data        = pack("v",   $grbit);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_hbreak()
  #
  # Write the HORIZONTALPAGEBREAKS BIFF record.
  #
  sub _store_hbreak {
  
      my $self    = shift;
  
      # Return if the user hasn't specified pagebreaks
      return unless @{$self->{_hbreaks}};
  
      # Sort and filter array of page breaks
      my @breaks  = $self->_sort_pagebreaks(@{$self->{_hbreaks}});
  
      my $record  = 0x001b;               # Record identifier
      my $cbrk    = scalar @breaks;       # Number of page breaks
      my $length  = 2 + 6*$cbrk;          # Bytes to follow
  
  
      my $header  = pack("vv",  $record, $length);
      my $data    = pack("v",   $cbrk);
  
      # Append each page break
      foreach my $break (@breaks) {
          $data .= pack("vvv", $break, 0x0000, 0x00ff);
      }
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_vbreak()
  #
  # Write the VERTICALPAGEBREAKS BIFF record.
  #
  sub _store_vbreak {
  
      my $self    = shift;
  
      # Return if the user hasn't specified pagebreaks
      return unless @{$self->{_vbreaks}};
  
      # Sort and filter array of page breaks
      my @breaks  = $self->_sort_pagebreaks(@{$self->{_vbreaks}});
  
      my $record  = 0x001a;               # Record identifier
      my $cbrk    = scalar @breaks;       # Number of page breaks
      my $length  = 2 + 6*$cbrk;          # Bytes to follow
  
  
      my $header  = pack("vv",  $record, $length);
      my $data    = pack("v",   $cbrk);
  
      # Append each page break
      foreach my $break (@breaks) {
          $data .= pack("vvv", $break, 0x0000, 0xffff);
      }
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_protect()
  #
  # Set the Biff PROTECT record to indicate that the worksheet is protected.
  #
  sub _store_protect {
  
      my $self        = shift;
  
      # Exit unless sheet protection has been specified
      return unless $self->{_protect};
  
      my $record      = 0x0012;               # Record identifier
      my $length      = 0x0002;               # Bytes to follow
  
      my $fLock       = $self->{_protect};    # Worksheet is protected
  
      my $header      = pack("vv", $record, $length);
      my $data        = pack("v",  $fLock);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_obj_protect()
  #
  # Set the Biff OBJPROTECT record to indicate that objects are protected.
  #
  sub _store_obj_protect {
  
      my $self        = shift;
  
      # Exit unless sheet protection has been specified
      return unless $self->{_protect};
  
      my $record      = 0x0063;               # Record identifier
      my $length      = 0x0002;               # Bytes to follow
  
      my $fLock       = $self->{_protect};    # Worksheet is protected
  
      my $header      = pack("vv", $record, $length);
      my $data        = pack("v",  $fLock);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_password()
  #
  # Write the worksheet PASSWORD record.
  #
  sub _store_password {
  
      my $self        = shift;
  
      # Exit unless sheet protection and password have been specified
      return unless $self->{_protect} and defined $self->{_password};
  
      my $record      = 0x0013;               # Record identifier
      my $length      = 0x0002;               # Bytes to follow
  
      my $wPassword   = $self->{_password};   # Encoded password
  
      my $header      = pack("vv", $record, $length);
      my $data        = pack("v",  $wPassword);
  
      $self->_prepend($header, $data);
  }
  
  
  #
  # Note about compatibility mode.
  #
  # Excel doesn't require every possible Biff record to be present in a file.
  # In particular if the indexing records INDEX, ROW and DBCELL aren't present
  # it just ignores the fact and reads the cells anyway. This is also true of
  # the EXTSST record. Gnumeric and OOo also take this approach. This allows
  # WriteExcel to ignore these records in order to minimise the amount of data
  # stored in memory. However, other third party applications that read Excel
  # files often expect these records to be present. In "compatibility mode"
  # WriteExcel writes these records and tries to be as close to an Excel
  # generated file as possible.
  #
  # This requires additional data to be stored in memory until the file is
  # about to be written. This incurs a memory and speed penalty and may not be
  # suitable for very large files.
  #
  
  
  
  ###############################################################################
  #
  # _store_table()
  #
  # Write cell data stored in the worksheet row/col table.
  #
  # This is only used when compatibity_mode() is in operation.
  #
  # This method writes ROW data, then cell data (NUMBER, LABELSST, etc) and then
  # DBCELL records in blocks of 32 rows. This is explained in detail (for a
  # change) in the Excel SDK and in the OOo Excel file format doc.
  #
  sub _store_table {
  
      my $self = shift;
  
      return unless $self->{_compatibility};
  
      # Offset from the DBCELL record back to the first ROW of the 32 row block.
      my $row_offset = 0;
  
      # Track rows that have cell data or modified by set_row().
      my @written_rows;
  
  
      # Write the ROW records with updated max/min col fields.
      #
      for my $row (0 .. $self->{_dim_rowmax} -1) {
          # Skip unless there is cell data in row or the row has been modified.
          next unless $self->{_table}->[$row] or $self->{_row_data}->{$row};
  
          # Store the rows with data.
          push @written_rows, $row;
  
          # Increase the row offset by the length of a ROW record;
          $row_offset += 20;
  
          # The max/min cols in the ROW records are the same as in DIMENSIONS.
          my $col_min = $self->{_dim_colmin};
          my $col_max = $self->{_dim_colmax};
  
          # Write a user specified ROW record (modified by set_row()).
          if ($self->{_row_data}->{$row}) {
              # Rewrite the min and max cols for user defined row record.
              my $packed_row = $self->{_row_data}->{$row};
              substr $packed_row, 6, 4, pack('vv', $col_min, $col_max);
              $self->_append($packed_row);
          }
          else {
              # Write a default Row record if there isn't a  user defined ROW.
              $self->_write_row_default($row, $col_min, $col_max);
          }
  
  
  
          # If 32 rows have been written or we are at the last row in the
          # worksheet then write the cell data and the DBCELL record.
          #
          if (@written_rows == 32 or $row == $self->{_dim_rowmax} -1) {
  
              # Offsets to the first cell of each row.
              my @cell_offsets;
              push @cell_offsets, $row_offset - 20;
  
              # Write the cell data in each row and sum their lengths for the
              # cell offsets.
              #
              for my $row (@written_rows) {
                  my $cell_offset = 0;
  
                  for my $col (@{$self->{_table}->[$row]}) {
                      next unless $col;
                      $self->_append($col);
                      my $length = length $col;
                      $row_offset  += $length;
                      $cell_offset += $length;
                  }
                  push @cell_offsets, $cell_offset;
              }
  
              # The last offset isn't required.
              pop @cell_offsets;
  
              # Stores the DBCELL offset for use in the INDEX record.
              push @{$self->{_db_indices}}, $self->{_datasize};
  
              # Write the DBCELL record.
              $self->_store_dbcell($row_offset, @cell_offsets);
  
              # Clear the variable for the next block of rows.
              @written_rows   = ();
              @cell_offsets   = ();
              $row_offset     = 0;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _store_dbcell()
  #
  # Store the DBCELL record using the offset calculated in _store_table().
  #
  # This is only used when compatibity_mode() is in operation.
  #
  sub _store_dbcell {
  
      my $self            = shift;
      my $row_offset      = shift;
      my @cell_offsets    = @_;
  
  
      my $record          = 0x00D7;                 # Record identifier
      my $length          = 4 + 2 * @cell_offsets;  # Bytes to follow
  
  
      my $header          = pack 'vv', $record, $length;
      my $data            = pack 'V',  $row_offset;
         $data           .= pack 'v', $_ for @cell_offsets;
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_index()
  #
  # Store the INDEX record using the DBCELL offsets calculated in _store_table().
  #
  # This is only used when compatibity_mode() is in operation.
  #
  sub _store_index {
  
      my $self = shift;
  
      return unless $self->{_compatibility};
  
      my @indices     = @{$self->{_db_indices}};
      my $reserved    = 0x00000000;
      my $row_min     = $self->{_dim_rowmin};
      my $row_max     = $self->{_dim_rowmax};
  
      my $record      = 0x020B;             # Record identifier
      my $length      = 16 + 4 * @indices;  # Bytes to follow
  
      my $header      = pack 'vv',   $record, $length;
      my $data        = pack 'VVVV', $reserved,
                                     $row_min,
                                     $row_max,
                                     $reserved;
  
      for my $index (@indices) {
         $data .= pack 'V', $index + $self->{_offset} + 20 + $length +4;
      }
  
      $self->_prepend($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # insert_chart($row, $col, $chart, $x, $y, $scale_x, $scale_y)
  #
  # Insert a chart into a worksheet. The $chart argument should be a Chart
  # object or else it is assumed to be a filename of an external binary file.
  # The latter is for backwards compatibility.
  #
  sub insert_chart {
  
      my $self        = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      my $row         = $_[0];
      my $col         = $_[1];
      my $chart       = $_[2];
      my $x_offset    = $_[3] || 0;
      my $y_offset    = $_[4] || 0;
      my $scale_x     = $_[5] || 1;
      my $scale_y     = $_[6] || 1;
  
      croak "Insufficient arguments in insert_chart()" unless @_ >= 3;
  
      if ( ref $chart ) {
          # Check for a Chart object.
          croak "Not a Chart object in insert_chart()"
            unless $chart->isa( 'Spreadsheet::WriteExcel::Chart' );
  
          # Check that the chart is an embedded style chart.
          croak "Not a embedded style Chart object in insert_chart()"
            unless $chart->{_embedded};
  
      }
      else {
  
          # Assume an external bin filename.
          croak "Couldn't locate $chart in insert_chart(): $!" unless -e $chart;
      }
  
      $self->{_charts}->{$row}->{$col} =  [
                                             $row,
                                             $col,
                                             $chart,
                                             $x_offset,
                                             $y_offset,
                                             $scale_x,
                                             $scale_y,
                                          ];
  
  }
  
  # Older method name for backwards compatibility.
  *embed_chart = *insert_chart;
  
  ###############################################################################
  #
  # insert_image($row, $col, $filename, $x, $y, $scale_x, $scale_y)
  #
  # Insert an image into the worksheet.
  #
  sub insert_image {
  
      my $self        = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      my $row         = $_[0];
      my $col         = $_[1];
      my $image       = $_[2];
      my $x_offset    = $_[3] || 0;
      my $y_offset    = $_[4] || 0;
      my $scale_x     = $_[5] || 1;
      my $scale_y     = $_[6] || 1;
  
      croak "Insufficient arguments in insert_image()" unless @_ >= 3;
      croak "Couldn't locate $image: $!"               unless -e $image;
  
      $self->{_images}->{$row}->{$col} = [
                                             $row,
                                             $col,
                                             $image,
                                             $x_offset,
                                             $y_offset,
                                             $scale_x,
                                             $scale_y,
                                          ];
  
  }
  
  # Older method name for backwards compatibility.
  *insert_bitmap = *insert_image;
  
  
  ###############################################################################
  #
  #  _position_object()
  #
  # Calculate the vertices that define the position of a graphical object within
  # the worksheet.
  #
  #         +------------+------------+
  #         |     A      |      B     |
  #   +-----+------------+------------+
  #   |     |(x1,y1)     |            |
  #   |  1  |(A1)._______|______      |
  #   |     |    |              |     |
  #   |     |    |              |     |
  #   +-----+----|    BITMAP    |-----+
  #   |     |    |              |     |
  #   |  2  |    |______________.     |
  #   |     |            |        (B2)|
  #   |     |            |     (x2,y2)|
  #   +---- +------------+------------+
  #
  # Example of a bitmap that covers some of the area from cell A1 to cell B2.
  #
  # Based on the width and height of the bitmap we need to calculate 8 vars:
  #     $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
  # The width and height of the cells are also variable and have to be taken into
  # account.
  # The values of $col_start and $row_start are passed in from the calling
  # function. The values of $col_end and $row_end are calculated by subtracting
  # the width and height of the bitmap from the width and height of the
  # underlying cells.
  # The vertices are expressed as a percentage of the underlying cell width as
  # follows (rhs values are in pixels):
  #
  #       x1 = X / W *1024
  #       y1 = Y / H *256
  #       x2 = (X-1) / W *1024
  #       y2 = (Y-1) / H *256
  #
  #       Where:  X is distance from the left side of the underlying cell
  #               Y is distance from the top of the underlying cell
  #               W is the width of the cell
  #               H is the height of the cell
  #
  # Note: the SDK incorrectly states that the height should be expressed as a
  # percentage of 1024.
  #
  sub _position_object {
  
      my $self = shift;
  
      my $col_start;  # Col containing upper left corner of object
      my $x1;         # Distance to left side of object
  
      my $row_start;  # Row containing top left corner of object
      my $y1;         # Distance to top of object
  
      my $col_end;    # Col containing lower right corner of object
      my $x2;         # Distance to right side of object
  
      my $row_end;    # Row containing bottom right corner of object
      my $y2;         # Distance to bottom of object
  
      my $width;      # Width of image frame
      my $height;     # Height of image frame
  
      ($col_start, $row_start, $x1, $y1, $width, $height) = @_;
  
  
      # Adjust start column for offsets that are greater than the col width
      while ($x1 >= $self->_size_col($col_start)) {
          $x1 -= $self->_size_col($col_start);
          $col_start++;
      }
  
      # Adjust start row for offsets that are greater than the row height
      while ($y1 >= $self->_size_row($row_start)) {
          $y1 -= $self->_size_row($row_start);
          $row_start++;
      }
  
  
      # Initialise end cell to the same as the start cell
      $col_end    = $col_start;
      $row_end    = $row_start;
  
      $width      = $width  + $x1;
      $height     = $height + $y1;
  
  
      # Subtract the underlying cell widths to find the end cell of the image
      while ($width >= $self->_size_col($col_end)) {
          $width -= $self->_size_col($col_end);
          $col_end++;
      }
  
      # Subtract the underlying cell heights to find the end cell of the image
      while ($height >= $self->_size_row($row_end)) {
          $height -= $self->_size_row($row_end);
          $row_end++;
      }
  
      # Bitmap isn't allowed to start or finish in a hidden cell, i.e. a cell
      # with zero eight or width.
      #
      return if $self->_size_col($col_start) == 0;
      return if $self->_size_col($col_end)   == 0;
      return if $self->_size_row($row_start) == 0;
      return if $self->_size_row($row_end)   == 0;
  
      # Convert the pixel values to the percentage value expected by Excel
      $x1 = $x1     / $self->_size_col($col_start)   * 1024;
      $y1 = $y1     / $self->_size_row($row_start)   *  256;
      $x2 = $width  / $self->_size_col($col_end)     * 1024;
      $y2 = $height / $self->_size_row($row_end)     *  256;
  
      # Simulate ceil() without calling POSIX::ceil().
      $x1 = int($x1 +0.5);
      $y1 = int($y1 +0.5);
      $x2 = int($x2 +0.5);
      $y2 = int($y2 +0.5);
  
      return( $col_start, $x1,
              $row_start, $y1,
              $col_end,   $x2,
              $row_end,   $y2
            );
  }
  
  
  ###############################################################################
  #
  # _size_col($col)
  #
  # Convert the width of a cell from user's units to pixels. Excel rounds the
  # column width to the nearest pixel. If the width hasn't been set by the user
  # we use the default value. If the column is hidden we use a value of zero.
  #
  sub _size_col {
  
      my $self = shift;
      my $col  = $_[0];
  
      # Look up the cell value to see if it has been changed
      if (exists $self->{_col_sizes}->{$col}) {
          my $width = $self->{_col_sizes}->{$col};
  
          # The relationship is different for user units less than 1.
          if ($width < 1) {
              return int($width *12);
          }
          else {
              return int($width *7 ) +5;
          }
      }
      else {
          return 64;
      }
  }
  
  
  ###############################################################################
  #
  # _size_row($row)
  #
  # Convert the height of a cell from user's units to pixels. By interpolation
  # the relationship is: y = 4/3x. If the height hasn't been set by the user we
  # use the default value. If the row is hidden we use a value of zero. (Not
  # possible to hide row yet).
  #
  sub _size_row {
  
      my $self = shift;
      my $row  = $_[0];
  
      # Look up the cell value to see if it has been changed
      if (exists $self->{_row_sizes}->{$row}) {
          if ($self->{_row_sizes}->{$row} == 0) {
              return 0;
          }
          else {
              return int (4/3 * $self->{_row_sizes}->{$row});
          }
      }
      else {
          return 17;
      }
  }
  
  
  ###############################################################################
  #
  # _store_zoom($zoom)
  #
  #
  # Store the window zoom factor. This should be a reduced fraction but for
  # simplicity we will store all fractions with a numerator of 100.
  #
  sub _store_zoom {
  
      my $self        = shift;
  
      # If scale is 100 we don't need to write a record
      return if $self->{_zoom} == 100;
  
      my $record      = 0x00A0;               # Record identifier
      my $length      = 0x0004;               # Bytes to follow
  
      my $header      = pack("vv", $record, $length   );
      my $data        = pack("vv", $self->{_zoom}, 100);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # write_utf16be_string($row, $col, $string, $format)
  #
  # Write a Unicode string to the specified row and column (zero indexed).
  # $format is optional.
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : long string truncated to 255 chars
  #
  sub write_utf16be_string {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 3) { return -1 }                        # Check the number of args
  
      my $record      = 0x00FD;                        # Record identifier
      my $length      = 0x000A;                        # Bytes to follow
  
      my $row         = $_[0];                         # Zero indexed row
      my $col         = $_[1];                         # Zero indexed column
      my $strlen      = length($_[2]);
      my $str         = $_[2];
      my $xf          = _XF($self, $row, $col, $_[3]); # The cell format
      my $encoding    = 0x1;
      my $str_error   = 0;
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions($row, $col);
  
      # Limit the utf16 string to the max number of chars (not bytes).
      if ($strlen > 32767* 2) {
          $str       = substr($str, 0, 32767*2);
          $str_error = -3;
      }
  
  
      my $num_bytes = length $str;
      my $num_chars = int($num_bytes / 2);
  
  
      # Check for a valid 2-byte char string.
      croak "Uneven number of bytes in Unicode string" if $num_bytes % 2;
  
  
      # Change from UTF16 big-endian to little endian
      $str = pack "v*", unpack "n*", $str;
  
  
      # Add the encoding and length header to the string.
      my $str_header  = pack("vC", $num_chars, $encoding);
      $str            = $str_header . $str;
  
  
      if (not exists ${$self->{_str_table}}->{$str}) {
          ${$self->{_str_table}}->{$str} = ${$self->{_str_unique}}++;
      }
  
  
      ${$self->{_str_total}}++;
  
  
      my $header = pack("vv",   $record, $length);
      my $data   = pack("vvvV", $row, $col, $xf, ${$self->{_str_table}}->{$str});
  
      # Store the data or write immediately depending on the compatibility mode.
      if ($self->{_compatibility}) {
          $self->{_table}->[$row]->[$col] = $header . $data;
      }
      else {
          $self->_append($header, $data);
      }
  
      return $str_error;
  }
  
  
  ###############################################################################
  #
  # write_utf16le_string($row, $col, $string, $format)
  #
  # Write a UTF-16LE string to the specified row and column (zero indexed).
  # $format is optional.
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : long string truncated to 255 chars
  #
  sub write_utf16le_string {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      if (@_ < 3) { return -1 }                        # Check the number of args
  
      my $record      = 0x00FD;                        # Record identifier
      my $length      = 0x000A;                        # Bytes to follow
  
      my $row         = $_[0];                         # Zero indexed row
      my $col         = $_[1];                         # Zero indexed column
      my $str         = $_[2];
      my $format      = $_[3];                         # The cell format
  
  
      # Change from UTF16 big-endian to little endian
      $str = pack "v*", unpack "n*", $str;
  
  
      return $self->write_utf16be_string($row, $col, $str, $format);
  }
  
  
  # Older method name for backwards compatibility.
  *write_unicode    = *write_utf16be_string;
  *write_unicode_le = *write_utf16le_string;
  
  
  
  ###############################################################################
  #
  # _store_autofilters()
  #
  # Function to iterate through the columns that form part of an autofilter
  # range and write Biff AUTOFILTER records if a filter expression has been set.
  #
  sub _store_autofilters {
  
      my $self = shift;
  
      # Skip all columns if no filter have been set.
      return unless $self->{_filter_on};
  
      my (undef, undef, $col1, $col2) = @{$self->{_filter_area}};
  
      for my $i ($col1 .. $col2) {
          # Reverse order since records are being pre-pended.
          my $col = $col2 -$i;
  
          # Skip if column doesn't have an active filter.
          next unless $self->{_filter_cols}->{$col};
  
          # Retrieve the filter tokens
          my @tokens =  @{$self->{_filter_cols}->{$col}};
  
          # Filter columns are relative to the first column in the filter.
          my $filter_col = $col - $col1;
  
          # Write the autofilter records.
          $self->_store_autofilter($filter_col, @tokens);
      }
  }
  
  
  ###############################################################################
  #
  # _store_autofilter()
  #
  # Function to write worksheet AUTOFILTER records. These contain 2 Biff Doper
  # structures to represent the 2 possible filter conditions.
  #
  sub _store_autofilter {
  
      my $self            = shift;
  
      my $record          = 0x009E;
      my $length          = 0x0000;
  
      my $index           = $_[0];
      my $operator_1      = $_[1];
      my $token_1         = $_[2];
      my $join            = $_[3]; # And/Or
      my $operator_2      = $_[4];
      my $token_2         = $_[5];
  
      my $top10_active    = 0;
      my $top10_direction = 0;
      my $top10_percent   = 0;
      my $top10_value     = 101;
  
      my $grbit       = $join;
      my $optimised_1 = 0;
      my $optimised_2 = 0;
      my $doper_1     = '';
      my $doper_2     = '';
      my $string_1    = '';
      my $string_2    = '';
  
      # Excel used an optimisation in the case of a simple equality.
      $optimised_1 = 1 if                         $operator_1 == 2;
      $optimised_2 = 1 if defined $operator_2 and $operator_2 == 2;
  
  
      # Convert non-simple equalities back to type 2. See  _parse_filter_tokens().
      $operator_1 = 2 if                         $operator_1 == 22;
      $operator_2 = 2 if defined $operator_2 and $operator_2 == 22;
  
  
      # Handle a "Top" style expression.
      if ($operator_1 >= 30) {
          # Remove the second expression if present.
          $operator_2 = undef;
          $token_2    = undef;
  
          # Set the active flag.
          $top10_active    = 1;
  
          if ($operator_1 == 30 or $operator_1 == 31) {
              $top10_direction = 1;
          }
  
          if ($operator_1 == 31 or $operator_1 == 33) {
              $top10_percent = 1;
          }
  
          if ($top10_direction == 1) {
              $operator_1 = 6
          }
          else {
              $operator_1 = 3
          }
  
          $top10_value     = $token_1;
          $token_1         = 0;
      }
  
  
      $grbit     |= $optimised_1      << 2;
      $grbit     |= $optimised_2      << 3;
      $grbit     |= $top10_active     << 4;
      $grbit     |= $top10_direction  << 5;
      $grbit     |= $top10_percent    << 6;
      $grbit     |= $top10_value      << 7;
  
      ($doper_1, $string_1) = $self->_pack_doper($operator_1, $token_1);
      ($doper_2, $string_2) = $self->_pack_doper($operator_2, $token_2);
  
      my $data    = pack 'v', $index;
         $data   .= pack 'v', $grbit;
         $data   .= $doper_1;
         $data   .= $doper_2;
         $data   .= $string_1;
         $data   .= $string_2;
  
         $length  = length $data;
      my $header  = pack('vv',  $record, $length);
  
      $self->_prepend($header, $data);
  }
  
  
  ###############################################################################
  #
  # _pack_doper()
  #
  # Create a Biff Doper structure that represents a filter expression. Depending
  # on the type of the token we pack an Empty, String or Number doper.
  #
  sub _pack_doper {
  
      my $self        = shift;
  
      my $operator    = $_[0];
      my $token       = $_[1];
  
      my $doper       = '';
      my $string      = '';
  
  
      # Return default doper for non-defined filters.
      if (not defined $operator) {
          return ($self->_pack_unused_doper, $string);
      }
  
  
      if ($token =~ /^blanks|nonblanks$/i) {
          $doper  = $self->_pack_blanks_doper($operator, $token);
      }
      elsif ($operator == 2 or
          $token    !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
      {
          # Excel treats all tokens as strings if the operator is equality, =.
  
          $string = $token;
  
          my $encoding = 0;
          my $length   = length $string;
  
          # Handle utf8 strings in perl 5.8.
          if ($] >= 5.008) {
              require Encode;
  
              if (Encode::is_utf8($string)) {
                  $string = Encode::encode("UTF-16BE", $string);
                  $encoding = 1;
              }
          }
  
          $string = pack('C', $encoding) . $string;
          $doper  = $self->_pack_string_doper($operator, $length);
      }
      else {
          $string = '';
          $doper  = $self->_pack_number_doper($operator, $token);
      }
  
      return ($doper, $string);
  }
  
  
  ###############################################################################
  #
  # _pack_unused_doper()
  #
  # Pack an empty Doper structure.
  #
  sub _pack_unused_doper {
  
      my $self        = shift;
  
      return pack 'C10', (0x0) x 10;
  }
  
  
  ###############################################################################
  #
  # _pack_blanks_doper()
  #
  # Pack an Blanks/NonBlanks Doper structure.
  #
  sub _pack_blanks_doper {
  
      my $self        = shift;
  
      my $operator    = $_[0];
      my $token       = $_[1];
      my $type;
  
      if ($token eq 'blanks') {
          $type     = 0x0C;
          $operator = 2;
  
      }
      else {
          $type     = 0x0E;
          $operator = 5;
      }
  
  
      my $doper       = pack 'CCVV',    $type,         # Data type
                                        $operator,     #
                                        0x0000,        # Reserved
                                        0x0000;        # Reserved
      return $doper;
  }
  
  
  ###############################################################################
  #
  # _pack_string_doper()
  #
  # Pack an string Doper structure.
  #
  sub _pack_string_doper {
  
      my $self        = shift;
  
      my $operator    = $_[0];
      my $length      = $_[1];
      my $doper       = pack 'CCVCCCC', 0x06,          # Data type
                                        $operator,     #
                                        0x0000,        # Reserved
                                        $length,       # String char length.
                                        0x0, 0x0, 0x0; # Reserved
      return $doper;
  }
  
  
  ###############################################################################
  #
  # _pack_number_doper()
  #
  # Pack an IEEE double number Doper structure.
  #
  sub _pack_number_doper {
  
      my $self        = shift;
  
      my $operator    = $_[0];
      my $number      = $_[1];
         $number      = pack 'd', $number;
         $number      = reverse $number if $self->{_byte_order};
  
      my $doper       = pack 'CC', 0x04, $operator;
         $doper      .= $number;
  
      return $doper;
  }
  
  
  #
  # Methods related to comments and MSO objects.
  #
  
  
  ###############################################################################
  #
  # _prepare_images()
  #
  # Turn the HoH that stores the images into an array for easier handling.
  #
  sub _prepare_images {
  
      my $self    = shift;
  
      my $count   = 0;
      my @images;
  
  
      # We sort the images by row and column but that isn't strictly required.
      #
      my @rows = sort {$a <=> $b} keys %{$self->{_images}};
  
      for my $row (@rows) {
          my @cols = sort {$a <=> $b} keys %{$self->{_images}->{$row}};
  
          for my $col (@cols) {
              push @images, $self->{_images}->{$row}->{$col};
              $count++;
          }
      }
  
      $self->{_images}       = {};
      $self->{_images_array} = \@images;
  
      return $count;
  }
  
  
  ###############################################################################
  #
  # _prepare_comments()
  #
  # Turn the HoH that stores the comments into an array for easier handling.
  #
  sub _prepare_comments {
  
      my $self    = shift;
  
      my $count   = 0;
      my @comments;
  
  
      # We sort the comments by row and column but that isn't strictly required.
      #
      my @rows = sort {$a <=> $b} keys %{$self->{_comments}};
  
      for my $row (@rows) {
          my @cols = sort {$a <=> $b} keys %{$self->{_comments}->{$row}};
  
          for my $col (@cols) {
              push @comments, $self->{_comments}->{$row}->{$col};
              $count++;
          }
      }
  
      $self->{_comments}       = {};
      $self->{_comments_array} = \@comments;
  
      return $count;
  }
  
  
  ###############################################################################
  #
  # _prepare_charts()
  #
  # Turn the HoH that stores the charts into an array for easier handling.
  #
  sub _prepare_charts {
  
      my $self    = shift;
  
      my $count   = 0;
      my @charts;
  
  
      # We sort the charts by row and column but that isn't strictly required.
      #
      my @rows = sort {$a <=> $b} keys %{$self->{_charts}};
  
      for my $row (@rows) {
          my @cols = sort {$a <=> $b} keys %{$self->{_charts}->{$row}};
  
          for my $col (@cols) {
              push @charts, $self->{_charts}->{$row}->{$col};
              $count++;
          }
      }
  
      $self->{_charts}       = {};
      $self->{_charts_array} = \@charts;
  
      return $count;
  }
  
  
  ###############################################################################
  #
  # _store_images()
  #
  # Store the collections of records that make up images.
  #
  sub _store_images {
  
      my $self            = shift;
  
      my $record          = 0x00EC;           # Record identifier
      my $length          = 0x0000;           # Bytes to follow
  
      my @ids             = @{$self->{_object_ids  }};
      my $spid            = shift @ids;
  
      my @images          = @{$self->{_images_array}};
      my $num_images      = scalar @images;
  
      my $num_filters     = $self->{_filter_count};
      my $num_comments    = @{$self->{_comments_array}};
      my $num_charts      = @{$self->{_charts_array  }};
  
      # Skip this if there aren't any images.
      return unless $num_images;
  
      for my $i (0 .. $num_images-1) {
          my $row         =   $images[$i]->[0];
          my $col         =   $images[$i]->[1];
          my $name        =   $images[$i]->[2];
          my $x_offset    =   $images[$i]->[3];
          my $y_offset    =   $images[$i]->[4];
          my $scale_x     =   $images[$i]->[5];
          my $scale_y     =   $images[$i]->[6];
          my $image_id    =   $images[$i]->[7];
          my $type        =   $images[$i]->[8];
          my $width       =   $images[$i]->[9];
          my $height      =   $images[$i]->[10];
  
          $width  *= $scale_x if $scale_x;
          $height *= $scale_y if $scale_y;
  
  
          # Calculate the positions of image object.
          my @vertices = $self->_position_object( $col,
                                                  $row,
                                                  $x_offset,
                                                  $y_offset,
                                                  $width,
                                                  $height
                                                );
  
          if ($i == 0) {
              # Write the parent MSODRAWIING record.
              my $dg_length    = 156 + 84*($num_images -1);
              my $spgr_length  = 132 + 84*($num_images -1);
  
                 $dg_length   += 120 *$num_charts;
                 $spgr_length += 120 *$num_charts;
  
                 $dg_length   +=  96 *$num_filters;
                 $spgr_length +=  96 *$num_filters;
  
                 $dg_length   += 128 *$num_comments;
                 $spgr_length += 128 *$num_comments;
  
  
  
              my $data        = $self->_store_mso_dg_container($dg_length);
                 $data       .= $self->_store_mso_dg(@ids);
                 $data       .= $self->_store_mso_spgr_container($spgr_length);
                 $data       .= $self->_store_mso_sp_container(40);
                 $data       .= $self->_store_mso_spgr();
                 $data       .= $self->_store_mso_sp(0x0, $spid++, 0x0005);
                 $data       .= $self->_store_mso_sp_container(76);
                 $data       .= $self->_store_mso_sp(75, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_image($image_id);
                 $data       .= $self->_store_mso_client_anchor(2, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
          }
          else {
              # Write the child MSODRAWIING record.
              my $data        = $self->_store_mso_sp_container(76);
                 $data       .= $self->_store_mso_sp(75, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_image($image_id);
                 $data       .= $self->_store_mso_client_anchor(2, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
  
          }
  
          $self->_store_obj_image($i+1);
      }
  
      $self->{_object_ids}->[0] = $spid;
  }
  
  
  
  ###############################################################################
  #
  # _store_charts()
  #
  # Store the collections of records that make up charts.
  #
  sub _store_charts {
  
      my $self            = shift;
  
      my $record          = 0x00EC;           # Record identifier
      my $length          = 0x0000;           # Bytes to follow
  
      my @ids             = @{$self->{_object_ids}};
      my $spid            = shift @ids;
  
      my @charts          = @{$self->{_charts_array}};
      my $num_charts      = scalar @charts;
  
      my $num_filters     = $self->{_filter_count};
      my $num_comments    = @{$self->{_comments_array}};
  
      # Number of objects written so far.
      my $num_objects     = @{$self->{_images_array}};
  
      # Skip this if there aren't any charts.
      return unless $num_charts;
  
      for my $i (0 .. $num_charts-1 ) {
          my $row         =   $charts[$i]->[0];
          my $col         =   $charts[$i]->[1];
          my $chart        =   $charts[$i]->[2];
          my $x_offset    =   $charts[$i]->[3];
          my $y_offset    =   $charts[$i]->[4];
          my $scale_x     =   $charts[$i]->[5];
          my $scale_y     =   $charts[$i]->[6];
          my $width       =   526;
          my $height      =   319;
  
          $width  *= $scale_x if $scale_x;
          $height *= $scale_y if $scale_y;
  
          # Calculate the positions of chart object.
          my @vertices = $self->_position_object( $col,
                                                  $row,
                                                  $x_offset,
                                                  $y_offset,
                                                  $width,
                                                  $height
                                                );
  
  
          if ($i == 0 and not $num_objects) {
              # Write the parent MSODRAWIING record.
              my $dg_length    = 192 + 120*($num_charts -1);
              my $spgr_length  = 168 + 120*($num_charts -1);
  
                 $dg_length   +=  96 *$num_filters;
                 $spgr_length +=  96 *$num_filters;
  
                 $dg_length   += 128 *$num_comments;
                 $spgr_length += 128 *$num_comments;
  
  
              my $data        = $self->_store_mso_dg_container($dg_length);
                 $data       .= $self->_store_mso_dg(@ids);
                 $data       .= $self->_store_mso_spgr_container($spgr_length);
                 $data       .= $self->_store_mso_sp_container(40);
                 $data       .= $self->_store_mso_spgr();
                 $data       .= $self->_store_mso_sp(0x0, $spid++, 0x0005);
                 $data       .= $self->_store_mso_sp_container(112);
                 $data       .= $self->_store_mso_sp(201, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_chart();
                 $data       .= $self->_store_mso_client_anchor(0, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
          }
          else {
              # Write the child MSODRAWIING record.
              my $data        = $self->_store_mso_sp_container(112);
                 $data       .= $self->_store_mso_sp(201, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_chart();
                 $data       .= $self->_store_mso_client_anchor(0, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
  
          }
  
          $self->_store_obj_chart($num_objects+$i+1);
          $self->_store_chart_binary($chart);
      }
  
  
      # Simulate the EXTERNSHEET link between the chart and data using a formula
      # such as '=Sheet1!A1'.
      # TODO. Won't work for external data refs. Also should use a more direct
      #       method.
      #
      my $name = $self->{_name};
      if ($self->{_encoding} && $] >= 5.008) {
          require Encode;
          $name = Encode::decode('UTF-16BE', $name);
      }
      $self->store_formula("='$name'!A1");
  
      $self->{_object_ids}->[0] = $spid;
  }
  
  
  ###############################################################################
  #
  # _store_chart_binary
  #
  # Add the binary data for a chart. This could either be from a Chart object
  # or from an external binary file (for backwards compatibility).
  #
  sub _store_chart_binary {
  
      my $self  = shift;
      my $chart = $_[0];
      my $tmp;
  
  
      if ( ref $chart ) {
          $chart->_close();
          my $tmp = $chart->get_data();
          $self->_append( $tmp );
      }
      else {
  
          my $filehandle = FileHandle->new( $chart )
            or die "Couldn't open $chart in insert_chart(): $!.\n";
  
          binmode( $filehandle );
  
          while ( read( $filehandle, $tmp, 4096 ) ) {
              $self->_append( $tmp );
          }
      }
  }
  
  
  ###############################################################################
  #
  # _store_filters()
  #
  # Store the collections of records that make up filters.
  #
  sub _store_filters {
  
      my $self            = shift;
  
      my $record          = 0x00EC;           # Record identifier
      my $length          = 0x0000;           # Bytes to follow
  
      my @ids             = @{$self->{_object_ids}};
      my $spid            = shift @ids;
  
      my $filter_area     = $self->{_filter_area};
      my $num_filters     = $self->{_filter_count};
  
      my $num_comments    = @{$self->{_comments_array}};
  
      # Number of objects written so far.
      my $num_objects     = @{$self->{_images_array}}
                          + @{$self->{_charts_array}};
  
      # Skip this if there aren't any filters.
      return unless $num_filters;
  
  
      my ($row1, $row2, $col1, $col2) = @$filter_area;
  
      for my $i (0 .. $num_filters-1 ) {
  
          my @vertices = ( $col1 +$i,
                           0,
                           $row1,
                           0,
                           $col1 +$i +1,
                           0,
                           $row1 +1,
                           0);
  
          if ($i == 0 and not $num_objects) {
              # Write the parent MSODRAWIING record.
              my $dg_length    = 168 + 96*($num_filters -1);
              my $spgr_length  = 144 + 96*($num_filters -1);
  
                 $dg_length   += 128 *$num_comments;
                 $spgr_length += 128 *$num_comments;
  
  
              my $data        = $self->_store_mso_dg_container($dg_length);
                 $data       .= $self->_store_mso_dg(@ids);
                 $data       .= $self->_store_mso_spgr_container($spgr_length);
                 $data       .= $self->_store_mso_sp_container(40);
                 $data       .= $self->_store_mso_spgr();
                 $data       .= $self->_store_mso_sp(0x0, $spid++, 0x0005);
                 $data       .= $self->_store_mso_sp_container(88);
                 $data       .= $self->_store_mso_sp(201, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_filter();
                 $data       .= $self->_store_mso_client_anchor(1, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
          }
          else {
              # Write the child MSODRAWIING record.
              my $data        = $self->_store_mso_sp_container(88);
                 $data       .= $self->_store_mso_sp(201, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_filter();
                 $data       .= $self->_store_mso_client_anchor(1, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
  
          }
  
          $self->_store_obj_filter($num_objects+$i+1, $col1 +$i);
      }
  
  
      # Simulate the EXTERNSHEET link between the filter and data using a formula
      # such as '=Sheet1!A1'.
      # TODO. Won't work for external data refs. Also should use a more direct
      #       method.
      #
      my $formula = "='$self->{_name}'!A1";
      $self->store_formula($formula);
  
      $self->{_object_ids}->[0] = $spid;
  }
  
  
  ###############################################################################
  #
  # _store_comments()
  #
  # Store the collections of records that make up cell comments.
  #
  # NOTE: We write the comment objects last since that makes it a little easier
  # to write the NOTE records directly after the MSODRAWIING records.
  #
  sub _store_comments {
  
      my $self            = shift;
  
      my $record          = 0x00EC;           # Record identifier
      my $length          = 0x0000;           # Bytes to follow
  
      my @ids             = @{$self->{_object_ids}};
      my $spid            = shift @ids;
  
      my @comments        = @{$self->{_comments_array}};
      my $num_comments    = scalar @comments;
  
      # Number of objects written so far.
      my $num_objects     = @{$self->{_images_array}}
                          +   $self->{_filter_count}
                          + @{$self->{_charts_array}};
  
      # Skip this if there aren't any comments.
      return unless $num_comments;
  
      for my $i (0 .. $num_comments-1) {
  
          my $row         =   $comments[$i]->[0];
          my $col         =   $comments[$i]->[1];
          my $str         =   $comments[$i]->[2];
          my $encoding    =   $comments[$i]->[3];
          my $visible     =   $comments[$i]->[6];
          my $color       =   $comments[$i]->[7];
          my @vertices    = @{$comments[$i]->[8]};
          my $str_len     = length $str;
             $str_len    /= 2 if $encoding; # Num of chars not bytes.
          my $formats     = [[0, 9], [$str_len, 0]];
  
  
          if ($i == 0 and not $num_objects) {
              # Write the parent MSODRAWIING record.
              my $dg_length   = 200 + 128*($num_comments -1);
              my $spgr_length = 176 + 128*($num_comments -1);
  
              my $data        = $self->_store_mso_dg_container($dg_length);
                 $data       .= $self->_store_mso_dg(@ids);
                 $data       .= $self->_store_mso_spgr_container($spgr_length);
                 $data       .= $self->_store_mso_sp_container(40);
                 $data       .= $self->_store_mso_spgr();
                 $data       .= $self->_store_mso_sp(0x0, $spid++, 0x0005);
                 $data       .= $self->_store_mso_sp_container(120);
                 $data       .= $self->_store_mso_sp(202, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_comment(0x80, $visible, $color);
                 $data       .= $self->_store_mso_client_anchor(3, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
          }
          else {
              # Write the child MSODRAWIING record.
              my $data        = $self->_store_mso_sp_container(120);
                 $data       .= $self->_store_mso_sp(202, $spid++, 0x0A00);
                 $data       .= $self->_store_mso_opt_comment(0x80, $visible, $color);
                 $data       .= $self->_store_mso_client_anchor(3, @vertices);
                 $data       .= $self->_store_mso_client_data();
  
              $length         = length $data;
              my $header      = pack("vv", $record, $length);
              $self->_append($header, $data);
  
  
          }
  
          $self->_store_obj_comment($num_objects+$i+1);
          $self->_store_mso_drawing_text_box();
          $self->_store_txo($str_len);
          $self->_store_txo_continue_1($str, $encoding);
          $self->_store_txo_continue_2($formats);
      }
  
  
      # Write the NOTE records after MSODRAWIING records.
      for my $i (0 .. $num_comments-1) {
  
          my $row         = $comments[$i]->[0];
          my $col         = $comments[$i]->[1];
          my $author      = $comments[$i]->[4];
          my $author_enc  = $comments[$i]->[5];
          my $visible     = $comments[$i]->[6];
  
          $self->_store_note($row, $col, $num_objects+$i+1,
                             $author, $author_enc, $visible);
      }
  }
  
  
  ###############################################################################
  #
  # _store_mso_dg_container()
  #
  # Write the Escher DgContainer record that is part of MSODRAWING.
  #
  sub _store_mso_dg_container {
  
      my $self        = shift;
  
      my $type        = 0xF002;
      my $version     = 15;
      my $instance    = 0;
      my $data        = '';
      my $length      = $_[0];
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_dg()
  #
  # Write the Escher Dg record that is part of MSODRAWING.
  #
  sub _store_mso_dg {
  
      my $self        = shift;
  
      my $type        = 0xF008;
      my $version     = 0;
      my $instance    = $_[0];
      my $data        = '';
      my $length      = 8;
  
      my $num_shapes  = $_[1];
      my $max_spid    = $_[2];
  
      $data           = pack "VV", $num_shapes, $max_spid;
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_spgr_container()
  #
  # Write the Escher SpgrContainer record that is part of MSODRAWING.
  #
  sub _store_mso_spgr_container {
  
      my $self        = shift;
  
      my $type        = 0xF003;
      my $version     = 15;
      my $instance    = 0;
      my $data        = '';
      my $length      = $_[0];
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_sp_container()
  #
  # Write the Escher SpContainer record that is part of MSODRAWING.
  #
  sub _store_mso_sp_container {
  
      my $self        = shift;
  
      my $type        = 0xF004;
      my $version     = 15;
      my $instance    = 0;
      my $data        = '';
      my $length      = $_[0];
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_spgr()
  #
  # Write the Escher Spgr record that is part of MSODRAWING.
  #
  sub _store_mso_spgr {
  
      my $self        = shift;
  
      my $type        = 0xF009;
      my $version     = 1;
      my $instance    = 0;
      my $data        = pack "VVVV", 0, 0, 0, 0;
      my $length      = 16;
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_sp()
  #
  # Write the Escher Sp record that is part of MSODRAWING.
  #
  sub _store_mso_sp {
  
      my $self        = shift;
  
      my $type        = 0xF00A;
      my $version     = 2;
      my $instance    = $_[0];
      my $data        = '';
      my $length      = 8;
  
      my $spid        = $_[1];
      my $options     = $_[2];
  
      $data           = pack "VV", $spid, $options;
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_opt_comment()
  #
  # Write the Escher Opt record that is part of MSODRAWING.
  #
  sub _store_mso_opt_comment {
  
      my $self        = shift;
  
      my $type        = 0xF00B;
      my $version     = 3;
      my $instance    = 9;
      my $data        = '';
      my $length      = 54;
  
      my $spid        = $_[0];
      my $visible     = $_[1];
      my $colour      = $_[2] || 0x50;
  
  
      # Use the visible flag if set by the user or else use the worksheet value.
      # Note that the value used is the opposite of _store_note().
      #
      if (defined $visible) {
          $visible = $visible                   ? 0x0000 : 0x0002;
      }
      else {
          $visible = $self->{_comments_visible} ? 0x0000 : 0x0002;
      }
  
  
      $data    = pack "V",  $spid;
      $data   .= pack "H*", '0000BF00080008005801000000008101' ;
      $data   .= pack "C",  $colour;
      $data   .= pack "H*", '000008830150000008BF011000110001' .
                            '02000000003F0203000300BF03';
      $data   .= pack "v",  $visible;
      $data   .= pack "H*", '0A00';
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_opt_image()
  #
  # Write the Escher Opt record that is part of MSODRAWING.
  #
  sub _store_mso_opt_image {
  
      my $self        = shift;
  
      my $type        = 0xF00B;
      my $version     = 3;
      my $instance    = 3;
      my $data        = '';
      my $length      = undef;
      my $spid        = $_[0];
  
      $data    = pack 'v', 0x4104;        # Blip -> pib
      $data   .= pack 'V', $spid;
      $data   .= pack 'v', 0x01BF;        # Fill Style -> fNoFillHitTest
      $data   .= pack 'V', 0x00010000;
      $data   .= pack 'v', 0x03BF;        # Group Shape -> fPrint
      $data   .= pack 'V', 0x00080000;
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_opt_chart()
  #
  # Write the Escher Opt record that is part of MSODRAWING.
  #
  sub _store_mso_opt_chart {
  
      my $self        = shift;
  
      my $type        = 0xF00B;
      my $version     = 3;
      my $instance    = 9;
      my $data        = '';
      my $length      = undef;
  
      $data    = pack 'v', 0x007F;        # Protection -> fLockAgainstGrouping
      $data   .= pack 'V', 0x01040104;
  
      $data   .= pack 'v', 0x00BF;        # Text -> fFitTextToShape
      $data   .= pack 'V', 0x00080008;
  
      $data   .= pack 'v', 0x0181;        # Fill Style -> fillColor
      $data   .= pack 'V', 0x0800004E ;
  
      $data   .= pack 'v', 0x0183;        # Fill Style -> fillBackColor
      $data   .= pack 'V', 0x0800004D;
  
      $data   .= pack 'v', 0x01BF;        # Fill Style -> fNoFillHitTest
      $data   .= pack 'V', 0x00110010;
  
      $data   .= pack 'v', 0x01C0;        # Line Style -> lineColor
      $data   .= pack 'V', 0x0800004D;
  
      $data   .= pack 'v', 0x01FF;        # Line Style -> fNoLineDrawDash
      $data   .= pack 'V', 0x00080008;
  
      $data   .= pack 'v', 0x023F;        # Shadow Style -> fshadowObscured
      $data   .= pack 'V', 0x00020000;
  
      $data   .= pack 'v', 0x03BF;        # Group Shape -> fPrint
      $data   .= pack 'V', 0x00080000;
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_opt_filter()
  #
  # Write the Escher Opt record that is part of MSODRAWING.
  #
  sub _store_mso_opt_filter {
  
      my $self        = shift;
  
      my $type        = 0xF00B;
      my $version     = 3;
      my $instance    = 5;
      my $data        = '';
      my $length      = undef;
  
  
  
      $data    = pack 'v', 0x007F;        # Protection -> fLockAgainstGrouping
      $data   .= pack 'V', 0x01040104;
  
      $data   .= pack 'v', 0x00BF;        # Text -> fFitTextToShape
      $data   .= pack 'V', 0x00080008;
  
      $data   .= pack 'v', 0x01BF;        # Fill Style -> fNoFillHitTest
      $data   .= pack 'V', 0x00010000;
  
      $data   .= pack 'v', 0x01FF;        # Line Style -> fNoLineDrawDash
      $data   .= pack 'V', 0x00080000;
  
      $data   .= pack 'v', 0x03BF;        # Group Shape -> fPrint
      $data   .= pack 'V', 0x000A0000;
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_client_anchor()
  #
  # Write the Escher ClientAnchor record that is part of MSODRAWING.
  #
  sub _store_mso_client_anchor {
  
      my $self        = shift;
  
      my $type        = 0xF010;
      my $version     = 0;
      my $instance    = 0;
      my $data        = '';
      my $length      = 18;
  
      my $flag        = shift;
  
      my $col_start   = $_[0];    # Col containing upper left corner of object
      my $x1          = $_[1];    # Distance to left side of object
  
      my $row_start   = $_[2];    # Row containing top left corner of object
      my $y1          = $_[3];    # Distance to top of object
  
      my $col_end     = $_[4];    # Col containing lower right corner of object
      my $x2          = $_[5];    # Distance to right side of object
  
      my $row_end     = $_[6];    # Row containing bottom right corner of object
      my $y2          = $_[7];    # Distance to bottom of object
  
      $data   = pack "v9",    $flag,
                              $col_start, $x1,
                              $row_start, $y1,
                              $col_end,   $x2,
                              $row_end,   $y2;
  
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_mso_client_data()
  #
  # Write the Escher ClientData record that is part of MSODRAWING.
  #
  sub _store_mso_client_data {
  
      my $self        = shift;
  
      my $type        = 0xF011;
      my $version     = 0;
      my $instance    = 0;
      my $data        = '';
      my $length      = 0;
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_obj_comment()
  #
  # Write the OBJ record that is part of cell comments.
  #
  sub _store_obj_comment {
  
      my $self        = shift;
  
      my $record      = 0x005D;   # Record identifier
      my $length      = 0x0034;   # Bytes to follow
  
      my $obj_id      = $_[0];    # Object ID number.
      my $obj_type    = 0x0019;   # Object type (comment).
      my $data        = '';       # Record data.
  
      my $sub_record  = 0x0000;   # Sub-record identifier.
      my $sub_length  = 0x0000;   # Length of sub-record.
      my $sub_data    = '';       # Data of sub-record.
      my $options     = 0x4011;
      my $reserved    = 0x0000;
  
      # Add ftCmo (common object data) subobject
      $sub_record     = 0x0015;   # ftCmo
      $sub_length     = 0x0012;
      $sub_data       = pack "vvvVVV", $obj_type, $obj_id,   $options,
                                       $reserved, $reserved, $reserved;
      $data           = pack("vv",     $sub_record, $sub_length);
      $data          .= $sub_data;
  
  
      # Add ftNts (note structure) subobject
      $sub_record     = 0x000D;   # ftNts
      $sub_length     = 0x0016;
      $sub_data       = pack "VVVVVv", ($reserved) x 6;
      $data          .= pack("vv",     $sub_record, $sub_length);
      $data          .= $sub_data;
  
  
      # Add ftEnd (end of object) subobject
      $sub_record     = 0x0000;   # ftNts
      $sub_length     = 0x0000;
      $data          .= pack("vv",     $sub_record, $sub_length);
  
  
      # Pack the record.
      my $header  = pack("vv",        $record, $length);
  
      $self->_append($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # _store_obj_image()
  #
  # Write the OBJ record that is part of image records.
  #
  sub _store_obj_image {
  
      my $self        = shift;
  
      my $record      = 0x005D;   # Record identifier
      my $length      = 0x0026;   # Bytes to follow
  
      my $obj_id      = $_[0];    # Object ID number.
      my $obj_type    = 0x0008;   # Object type (Picture).
      my $data        = '';       # Record data.
  
      my $sub_record  = 0x0000;   # Sub-record identifier.
      my $sub_length  = 0x0000;   # Length of sub-record.
      my $sub_data    = '';       # Data of sub-record.
      my $options     = 0x6011;
      my $reserved    = 0x0000;
  
      # Add ftCmo (common object data) subobject
      $sub_record     = 0x0015;   # ftCmo
      $sub_length     = 0x0012;
      $sub_data       = pack 'vvvVVV', $obj_type, $obj_id,   $options,
                                       $reserved, $reserved, $reserved;
      $data           = pack 'vv',     $sub_record, $sub_length;
      $data          .= $sub_data;
  
  
      # Add ftCf (Clipboard format) subobject
      $sub_record     = 0x0007;   # ftCf
      $sub_length     = 0x0002;
      $sub_data       = pack 'v',      0xFFFF;
      $data          .= pack 'vv',     $sub_record, $sub_length;
      $data          .= $sub_data;
  
      # Add ftPioGrbit (Picture option flags) subobject
      $sub_record     = 0x0008;   # ftPioGrbit
      $sub_length     = 0x0002;
      $sub_data       = pack 'v',      0x0001;
      $data          .= pack 'vv',     $sub_record, $sub_length;
      $data          .= $sub_data;
  
  
      # Add ftEnd (end of object) subobject
      $sub_record     = 0x0000;   # ftNts
      $sub_length     = 0x0000;
      $data          .= pack 'vv',     $sub_record, $sub_length;
  
  
      # Pack the record.
      my $header  = pack('vv',        $record, $length);
  
      $self->_append($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # _store_obj_chart()
  #
  # Write the OBJ record that is part of chart records.
  #
  sub _store_obj_chart {
  
      my $self        = shift;
  
      my $record      = 0x005D;   # Record identifier
      my $length      = 0x001A;   # Bytes to follow
  
      my $obj_id      = $_[0];    # Object ID number.
      my $obj_type    = 0x0005;   # Object type (chart).
      my $data        = '';       # Record data.
  
      my $sub_record  = 0x0000;   # Sub-record identifier.
      my $sub_length  = 0x0000;   # Length of sub-record.
      my $sub_data    = '';       # Data of sub-record.
      my $options     = 0x6011;
      my $reserved    = 0x0000;
  
      # Add ftCmo (common object data) subobject
      $sub_record     = 0x0015;   # ftCmo
      $sub_length     = 0x0012;
      $sub_data       = pack 'vvvVVV', $obj_type, $obj_id,   $options,
                                       $reserved, $reserved, $reserved;
      $data           = pack 'vv',     $sub_record, $sub_length;
      $data          .= $sub_data;
  
      # Add ftEnd (end of object) subobject
      $sub_record     = 0x0000;   # ftNts
      $sub_length     = 0x0000;
      $data          .= pack 'vv',     $sub_record, $sub_length;
  
  
      # Pack the record.
      my $header  = pack('vv',        $record, $length);
  
      $self->_append($header, $data);
  
  }
  
  
  
  
  ###############################################################################
  #
  # _store_obj_filter()
  #
  # Write the OBJ record that is part of filter records.
  #
  sub _store_obj_filter {
  
      my $self        = shift;
  
      my $record      = 0x005D;   # Record identifier
      my $length      = 0x0046;   # Bytes to follow
  
      my $obj_id      = $_[0];    # Object ID number.
      my $obj_type    = 0x0014;   # Object type (combo box).
      my $data        = '';       # Record data.
  
      my $sub_record  = 0x0000;   # Sub-record identifier.
      my $sub_length  = 0x0000;   # Length of sub-record.
      my $sub_data    = '';       # Data of sub-record.
      my $options     = 0x2101;
      my $reserved    = 0x0000;
  
      # Add ftCmo (common object data) subobject
      $sub_record     = 0x0015;   # ftCmo
      $sub_length     = 0x0012;
      $sub_data       = pack 'vvvVVV', $obj_type, $obj_id,   $options,
                                       $reserved, $reserved, $reserved;
      $data           = pack 'vv',     $sub_record, $sub_length;
      $data          .= $sub_data;
  
      # Add ftSbs Scroll bar subobject
      $sub_record     = 0x000C;   # ftSbs
      $sub_length     = 0x0014;
      $sub_data       = pack 'H*', '0000000000000000640001000A00000010000100';
      $data          .= pack 'vv',     $sub_record, $sub_length;
      $data          .= $sub_data;
  
  
      # Add ftLbsData (List box data) subobject
      $sub_record     = 0x0013;   # ftLbsData
      $sub_length     = 0x1FEE;   # Special case (undocumented).
  
  
      # If the filter is active we set one of the undocumented flags.
      my $col         = $_[1];
  
      if ($self->{_filter_cols}->{$col}) {
          $sub_data       = pack 'H*', '000000000100010300000A0008005700';
      }
      else {
          $sub_data       = pack 'H*', '00000000010001030000020008005700';
      }
  
      $data          .= pack 'vv',     $sub_record, $sub_length;
      $data          .= $sub_data;
  
  
      # Add ftEnd (end of object) subobject
      $sub_record     = 0x0000;   # ftNts
      $sub_length     = 0x0000;
      $data          .= pack 'vv', $sub_record, $sub_length;
  
      # Pack the record.
      my $header  = pack('vv',        $record, $length);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_mso_drawing_text_box()
  #
  # Write the MSODRAWING ClientTextbox record that is part of comments.
  #
  sub _store_mso_drawing_text_box {
  
      my $self        = shift;
  
      my $record      = 0x00EC;           # Record identifier
      my $length      = 0x0008;           # Bytes to follow
  
  
      my $data        = $self->_store_mso_client_text_box();
      my $header      = pack("vv", $record, $length);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_mso_client_text_box()
  #
  # Write the Escher ClientTextbox record that is part of MSODRAWING.
  #
  sub _store_mso_client_text_box {
  
      my $self        = shift;
  
      my $type        = 0xF00D;
      my $version     = 0;
      my $instance    = 0;
      my $data        = '';
      my $length      = 0;
  
  
      return $self->_add_mso_generic($type, $version, $instance, $data, $length);
  }
  
  
  ###############################################################################
  #
  # _store_txo()
  #
  # Write the worksheet TXO record that is part of cell comments.
  #
  sub _store_txo {
  
      my $self        = shift;
  
      my $record      = 0x01B6;               # Record identifier
      my $length      = 0x0012;               # Bytes to follow
  
      my $string_len  = $_[0];                # Length of the note text.
      my $format_len  = $_[1] || 16;          # Length of the format runs.
      my $rotation    = $_[2] || 0;           # Options
      my $grbit       = 0x0212;               # Options
      my $reserved    = 0x0000;               # Options
  
      # Pack the record.
      my $header  = pack("vv",        $record, $length);
      my $data    = pack("vvVvvvV",   $grbit, $rotation, $reserved, $reserved,
                                      $string_len, $format_len, $reserved);
  
      $self->_append($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # _store_txo_continue_1()
  #
  # Write the first CONTINUE record to follow the TXO record. It contains the
  # text data.
  #
  sub _store_txo_continue_1 {
  
      my $self        = shift;
  
      my $record      = 0x003C;               # Record identifier
      my $string      = $_[0];                # Comment string.
      my $encoding    = $_[1] || 0;           # Encoding of the string.
  
  
      # Split long comment strings into smaller continue blocks if necessary.
      # We can't let BIFFwriter::_add_continue() handled this since an extra
      # encoding byte has to be added similar to the SST block.
      #
      # We make the limit size smaller than the _add_continue() size and even
      # so that UTF16 chars occur in the same block.
      #
      my $limit = 8218;
      while (length($string) > $limit) {
          my $tmp_str = substr($string, 0, $limit, "");
  
          my $data    = pack("C", $encoding) . $tmp_str;
          my $length  = length $data;
          my $header  = pack("vv", $record, $length);
  
          $self->_append($header, $data);
      }
  
      # Pack the record.
      my $data    = pack("C", $encoding) . $string;
      my $length  = length $data;
      my $header  = pack("vv", $record, $length);
  
      $self->_append($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # _store_txo_continue_2()
  #
  # Write the second CONTINUE record to follow the TXO record. It contains the
  # formatting information for the string.
  #
  sub _store_txo_continue_2 {
  
      my $self        = shift;
  
      my $record      = 0x003C;               # Record identifier
      my $length      = 0x0000;               # Bytes to follow
      my $formats     = $_[0];                # Formatting information
  
  
      # Pack the record.
      my $data = '';
  
      for my $a_ref (@$formats) {
          $data .= pack "vvV", $a_ref->[0], $a_ref->[1], 0x0;
      }
  
      $length     = length $data;
      my $header  = pack("vv", $record, $length);
  
  
      $self->_append($header, $data);
  
  }
  
  
  ###############################################################################
  #
  # _store_note()
  #
  # Write the worksheet NOTE record that is part of cell comments.
  #
  sub _store_note {
  
      my $self        = shift;
  
      my $record      = 0x001C;               # Record identifier
      my $length      = 0x000C;               # Bytes to follow
  
      my $row         = $_[0];
      my $col         = $_[1];
      my $obj_id      = $_[2];
      my $author      = $_[3] || $self->{_comments_author};
      my $author_enc  = $_[4] || $self->{_comments_author_enc};
      my $visible     = $_[5];
  
  
      # Use the visible flag if set by the user or else use the worksheet value.
      # The flag is also set in _store_mso_opt_comment() but with the opposite
      # value.
      if (defined $visible) {
          $visible = $visible                   ? 0x0002 : 0x0000;
      }
      else {
          $visible = $self->{_comments_visible} ? 0x0002 : 0x0000;
      }
  
  
      # Get the number of chars in the author string (not bytes).
      my $num_chars  = length $author;
         $num_chars /= 2 if $author_enc;
  
  
      # Null terminate the author string.
      $author .= "\0";
  
  
      # Pack the record.
      my $data    = pack("vvvvvC", $row, $col, $visible, $obj_id,
                                   $num_chars, $author_enc);
  
      $length     = length($data) + length($author);
      my $header  = pack("vv", $record, $length);
  
      $self->_append($header, $data, $author);
  }
  
  
  ###############################################################################
  #
  # _comment_params()
  #
  # This method handles the additional optional parameters to write_comment() as
  # well as calculating the comment object position and vertices.
  #
  sub _comment_params {
  
      my $self            = shift;
  
      my $row             = shift;
      my $col             = shift;
      my $string          = shift;
  
      my $default_width   = 128;
      my $default_height  = 74;
  
      my %params  = (
                      author          => '',
                      author_encoding => 0,
                      encoding        => 0,
                      color           => undef,
                      start_cell      => undef,
                      start_col       => undef,
                      start_row       => undef,
                      visible         => undef,
                      width           => $default_width,
                      height          => $default_height,
                      x_offset        => undef,
                      x_scale         => 1,
                      y_offset        => undef,
                      y_scale         => 1,
                    );
  
  
      # Overwrite the defaults with any user supplied values. Incorrect or
      # misspelled parameters are silently ignored.
      %params     = (%params, @_);
  
  
      # Ensure that a width and height have been set.
      $params{width}  = $default_width  if not $params{width};
      $params{height} = $default_height if not $params{height};
  
  
      # Check that utf16 strings have an even number of bytes.
      if ($params{encoding}) {
          croak "Uneven number of bytes in comment string"
                 if length($string) % 2;
  
          # Change from UTF-16BE to UTF-16LE
          $string = pack 'v*', unpack 'n*', $string;
      }
  
      if ($params{author_encoding}) {
          croak "Uneven number of bytes in author string"
                  if length($params{author}) % 2;
  
          # Change from UTF-16BE to UTF-16LE
          $params{author} = pack 'v*', unpack 'n*', $params{author};
      }
  
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($string)) {
              $string = Encode::encode("UTF-16LE", $string);
              $params{encoding} = 1;
          }
  
          if (Encode::is_utf8($params{author})) {
              $params{author} = Encode::encode("UTF-16LE", $params{author});
              $params{author_encoding} = 1;
          }
      }
  
  
      # Limit the string to the max number of chars (not bytes).
      my $max_len  = 32767;
         $max_len *= 2 if $params{encoding};
  
      if (length($string) > $max_len) {
          $string       = substr($string, 0, $max_len);
      }
  
  
      # Set the comment background colour.
      my $color       = $params{color};
         $color       = &Spreadsheet::WriteExcel::Format::_get_color($color);
         $color       = 0x50 if $color == 0x7FFF; # Default color.
      $params{color}  = $color;
  
  
      # Convert a cell reference to a row and column.
      if (defined $params{start_cell}) {
          my ($row, $col)    = $self->_substitute_cellref($params{start_cell});
          $params{start_row} = $row;
          $params{start_col} = $col;
      }
  
  
      # Set the default start cell and offsets for the comment. These are
      # generally fixed in relation to the parent cell. However there are
      # some edge cases for cells at the, er, edges.
      #
      if (not defined $params{start_row}) {
  
          if    ($row == 0    ) {$params{start_row} = 0      }
          elsif ($row == 65533) {$params{start_row} = 65529  }
          elsif ($row == 65534) {$params{start_row} = 65530  }
          elsif ($row == 65535) {$params{start_row} = 65531  }
          else                  {$params{start_row} = $row -1}
      }
  
      if (not defined $params{y_offset}) {
  
          if    ($row == 0    ) {$params{y_offset}  = 2      }
          elsif ($row == 65533) {$params{y_offset}  = 4      }
          elsif ($row == 65534) {$params{y_offset}  = 4      }
          elsif ($row == 65535) {$params{y_offset}  = 2      }
          else                  {$params{y_offset}  = 7      }
      }
  
      if (not defined $params{start_col}) {
  
          if    ($col == 253  ) {$params{start_col} = 250    }
          elsif ($col == 254  ) {$params{start_col} = 251    }
          elsif ($col == 255  ) {$params{start_col} = 252    }
          else                  {$params{start_col} = $col +1}
      }
  
      if (not defined $params{x_offset}) {
  
          if    ($col == 253  ) {$params{x_offset}  = 49     }
          elsif ($col == 254  ) {$params{x_offset}  = 49     }
          elsif ($col == 255  ) {$params{x_offset}  = 49     }
          else                  {$params{x_offset}  = 15     }
      }
  
  
      # Scale the size of the comment box if required.
      if ($params{x_scale}) {
          $params{width}  = $params{width}  * $params{x_scale};
      }
  
      if ($params{y_scale}) {
          $params{height} = $params{height} * $params{y_scale};
      }
  
  
      # Calculate the positions of comment object.
      my @vertices = $self->_position_object( $params{start_col},
                                              $params{start_row},
                                              $params{x_offset},
                                              $params{y_offset},
                                              $params{width},
                                              $params{height}
                                            );
  
      return(
             $row,
             $col,
             $string,
             $params{encoding},
             $params{author},
             $params{author_encoding},
             $params{visible},
             $params{color},
             [@vertices]
            );
  }
  
  
  
  #
  # DATA VALIDATION
  #
  
  ###############################################################################
  #
  # data_validation($row, $col, {...})
  #
  # This method handles the interface to Excel data validation.
  # Somewhat ironically the this requires a lot of validation code since the
  # interface is flexible and covers a several types of data validation.
  #
  # We allow data validation to be called on one cell or a range of cells. The
  # hashref contains the validation parameters and must be the last param:
  #    data_validation($row, $col, {...})
  #    data_validation($first_row, $first_col, $last_row, $last_col, {...})
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : incorrect parameter.
  #
  sub data_validation {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ($_[0] =~ /^\D/) {
          @_ = $self->_substitute_cellref(@_);
      }
  
      # Check for a valid number of args.
      if (@_ != 5 && @_ != 3) { return -1 }
  
      # The final hashref contains the validation parameters.
      my $param = pop;
  
      # Make the last row/col the same as the first if not defined.
      my ($row1, $col1, $row2, $col2) = @_;
      if (!defined $row2) {
          $row2 = $row1;
          $col2 = $col1;
      }
  
      # Check that row and col are valid without storing the values.
      return -2 if $self->_check_dimensions($row1, $col1, 1, 1);
      return -2 if $self->_check_dimensions($row2, $col2, 1, 1);
  
  
      # Check that the last parameter is a hash list.
      if (ref $param ne 'HASH') {
          carp "Last parameter '$param' in data_validation() must be a hash ref";
          return -3;
      }
  
      # List of valid input parameters.
      my %valid_parameter = (
                                validate          => 1,
                                criteria          => 1,
                                value             => 1,
                                source            => 1,
                                minimum           => 1,
                                maximum           => 1,
                                ignore_blank      => 1,
                                dropdown          => 1,
                                show_input        => 1,
                                input_title       => 1,
                                input_message     => 1,
                                show_error        => 1,
                                error_title       => 1,
                                error_message     => 1,
                                error_type        => 1,
                                other_cells       => 1,
                            );
  
      # Check for valid input parameters.
      for my $param_key (keys %$param) {
          if (not exists $valid_parameter{$param_key}) {
              carp "Unknown parameter '$param_key' in data_validation()";
              return -3;
          }
      }
  
      # Map alternative parameter names 'source' or 'minimum' to 'value'.
      $param->{value} = $param->{source}  if defined $param->{source};
      $param->{value} = $param->{minimum} if defined $param->{minimum};
  
      # 'validate' is a required parameter.
      if (not exists $param->{validate}) {
          carp "Parameter 'validate' is required in data_validation()";
          return -3;
      }
  
  
      # List of  valid validation types.
      my %valid_type = (
                                'any'             => 0,
                                'any value'       => 0,
                                'whole number'    => 1,
                                'whole'           => 1,
                                'integer'         => 1,
                                'decimal'         => 2,
                                'list'            => 3,
                                'date'            => 4,
                                'time'            => 5,
                                'text length'     => 6,
                                'length'          => 6,
                                'custom'          => 7,
                        );
  
  
      # Check for valid validation types.
      if (not exists $valid_type{lc($param->{validate})}) {
          carp "Unknown validation type '$param->{validate}' for parameter " .
               "'validate' in data_validation()";
          return -3;
      }
      else {
          $param->{validate} = $valid_type{lc($param->{validate})};
      }
  
  
      # No action is required for validation type 'any'.
      # TODO: we should perhaps store 'any' for message only validations.
      return 0 if $param->{validate} == 0;
  
  
      # The list and custom validations don't have a criteria so we use a default
      # of 'between'.
      if ($param->{validate} == 3 || $param->{validate} == 7) {
          $param->{criteria}  = 'between';
          $param->{maximum}   = undef;
      }
  
      # 'criteria' is a required parameter.
      if (not exists $param->{criteria}) {
          carp "Parameter 'criteria' is required in data_validation()";
          return -3;
      }
  
  
      # List of valid criteria types.
      my %criteria_type = (
                                'between'                     => 0,
                                'not between'                 => 1,
                                'equal to'                    => 2,
                                '='                           => 2,
                                '=='                          => 2,
                                'not equal to'                => 3,
                                '!='                          => 3,
                                '<>'                          => 3,
                                'greater than'                => 4,
                                '>'                           => 4,
                                'less than'                   => 5,
                                '<'                           => 5,
                                'greater than or equal to'    => 6,
                                '>='                          => 6,
                                'less than or equal to'       => 7,
                                '<='                          => 7,
                        );
  
      # Check for valid criteria types.
      if (not exists $criteria_type{lc($param->{criteria})}) {
          carp "Unknown criteria type '$param->{criteria}' for parameter " .
               "'criteria' in data_validation()";
          return -3;
      }
      else {
          $param->{criteria} = $criteria_type{lc($param->{criteria})};
      }
  
  
      # 'Between' and 'Not between' criteria require 2 values.
      if ($param->{criteria} == 0 || $param->{criteria} == 1) {
          if (not exists $param->{maximum}) {
              carp "Parameter 'maximum' is required in data_validation() " .
                   "when using 'between' or 'not between' criteria";
              return -3;
          }
      }
      else {
          $param->{maximum} = undef;
      }
  
  
  
      # List of valid error dialog types.
      my %error_type = (
                                'stop'        => 0,
                                'warning'     => 1,
                                'information' => 2,
                       );
  
      # Check for valid error dialog types.
      if (not exists $param->{error_type}) {
          $param->{error_type} = 0;
      }
      elsif (not exists $error_type{lc($param->{error_type})}) {
          carp "Unknown criteria type '$param->{error_type}' for parameter " .
               "'error_type' in data_validation()";
          return -3;
      }
      else {
          $param->{error_type} = $error_type{lc($param->{error_type})};
      }
  
  
      # Convert date/times value if required.
      if ($param->{validate} == 4 || $param->{validate} == 5) {
          if ($param->{value} =~ /T/) {
              my $date_time = $self->convert_date_time($param->{value});
  
              if (!defined $date_time) {
                  carp "Invalid date/time value '$param->{value}' " .
                       "in data_validation()";
                  return -3;
              }
              else {
                  $param->{value} = $date_time;
              }
          }
          if (defined $param->{maximum} && $param->{maximum} =~ /T/) {
              my $date_time = $self->convert_date_time($param->{maximum});
  
              if (!defined $date_time) {
                  carp "Invalid date/time value '$param->{maximum}' " .
                       "in data_validation()";
                  return -3;
              }
              else {
                  $param->{maximum} = $date_time;
              }
          }
      }
  
  
      # Set some defaults if they haven't been defined by the user.
      $param->{ignore_blank}  = 1 if !defined $param->{ignore_blank};
      $param->{dropdown}      = 1 if !defined $param->{dropdown};
      $param->{show_input}    = 1 if !defined $param->{show_input};
      $param->{show_error}    = 1 if !defined $param->{show_error};
  
  
      # These are the cells to which the validation is applied.
      $param->{cells} = [[$row1, $col1, $row2, $col2]];
  
      # A (for now) undocumented parameter to pass additional cell ranges.
      if (exists $param->{other_cells}) {
  
          push @{$param->{cells}}, @{$param->{other_cells}};
      }
  
      # Store the validation information until we close the worksheet.
      push @{$self->{_validations}}, $param;
  }
  
  
  ###############################################################################
  #
  # _store_validation_count()
  #
  # Store the count of the DV records to follow.
  #
  # Note, this could be wrapped into _store_dv() but we may require separate
  # handling of the object id at a later stage.
  #
  sub _store_validation_count {
  
      my $self = shift;
  
      my $dv_count = @{$self->{_validations}};
      my $obj_id   = -1;
  
      return unless $dv_count;
  
      $self->_store_dval($obj_id , $dv_count);
  }
  
  
  ###############################################################################
  #
  # _store_validations()
  #
  # Store the data_validation records.
  #
  sub _store_validations {
  
      my $self = shift;
  
      return unless scalar @{$self->{_validations}};
  
      for my $param (@{$self->{_validations}}) {
          $self->_store_dv(   $param->{cells},
                              $param->{validate},
                              $param->{criteria},
                              $param->{value},
                              $param->{maximum},
                              $param->{input_title},
                              $param->{input_message},
                              $param->{error_title},
                              $param->{error_message},
                              $param->{error_type},
                              $param->{ignore_blank},
                              $param->{dropdown},
                              $param->{show_input},
                              $param->{show_error},
                              );
      }
  }
  
  
  ###############################################################################
  #
  # _store_dval()
  #
  # Store the DV record which contains the number of and information common to
  # all DV structures.
  #
  sub _store_dval {
  
      my $self        = shift;
  
      my $record      = 0x01B2;       # Record identifier
      my $length      = 0x0012;       # Bytes to follow
  
      my $obj_id      = $_[0];        # Object ID number.
      my $dv_count    = $_[1];        # Count of DV structs to follow.
  
      my $flags       = 0x0004;       # Option flags.
      my $x_coord     = 0x00000000;   # X coord of input box.
      my $y_coord     = 0x00000000;   # Y coord of input box.
  
  
      # Pack the record.
      my $header = pack('vv', $record, $length);
      my $data   = pack('vVVVV', $flags, $x_coord, $y_coord, $obj_id, $dv_count);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _store_dv()
  #
  # Store the DV record that specifies the data validation criteria and options
  # for a range of cells..
  #
  sub _store_dv {
  
      my $self            = shift;
  
      my $record          = 0x01BE;       # Record identifier
      my $length          = 0x0000;       # Bytes to follow
  
      my $flags           = 0x00000000;   # DV option flags.
  
      my $cells           = $_[0];        # Aref of cells to which DV applies.
      my $validation_type = $_[1];        # Type of data validation.
      my $criteria_type   = $_[2];        # Validation criteria.
      my $formula_1       = $_[3];        # Value/Source/Minimum formula.
      my $formula_2       = $_[4];        # Maximum formula.
      my $input_title     = $_[5];        # Title of input message.
      my $input_message   = $_[6];        # Text of input message.
      my $error_title     = $_[7];        # Title of error message.
      my $error_message   = $_[8];        # Text of input message.
      my $error_type      = $_[9];        # Error dialog type.
      my $ignore_blank    = $_[10];       # Ignore blank cells.
      my $dropdown        = $_[11];       # Display dropdown with list.
      my $input_box       = $_[12];       # Display input box.
      my $error_box       = $_[13];       # Display error box.
      my $ime_mode        = 0;            # IME input mode for far east fonts.
      my $str_lookup      = 0;            # See below.
  
      # Set the string lookup flag for 'list' validations with a string array.
      if ($validation_type == 3 && ref $formula_1 eq 'ARRAY')  {
          $str_lookup = 1;
      }
  
      # The dropdown flag is stored as a negated value.
      my $no_dropdown = not $dropdown;
  
      # Set the required flags.
      $flags |= $validation_type;
      $flags |= $error_type       << 4;
      $flags |= $str_lookup       << 7;
      $flags |= $ignore_blank     << 8;
      $flags |= $no_dropdown      << 9;
      $flags |= $ime_mode         << 10;
      $flags |= $input_box        << 18;
      $flags |= $error_box        << 19;
      $flags |= $criteria_type    << 20;
  
      # Pack the validation formulas.
      $formula_1 = $self->_pack_dv_formula($formula_1);
      $formula_2 = $self->_pack_dv_formula($formula_2);
  
      # Pack the input and error dialog strings.
      $input_title   = $self->_pack_dv_string($input_title,   32 );
      $error_title   = $self->_pack_dv_string($error_title,   32 );
      $input_message = $self->_pack_dv_string($input_message, 255);
      $error_message = $self->_pack_dv_string($error_message, 255);
  
      # Pack the DV cell data.
      my $dv_count = scalar @$cells;
      my $dv_data  = pack 'v', $dv_count;
      for my $range (@$cells) {
          $dv_data .= pack 'vvvv', $range->[0],
                                   $range->[2],
                                   $range->[1],
                                   $range->[3];
      }
  
      # Pack the record.
      my $data   = pack 'V', $flags;
         $data  .= $input_title;
         $data  .= $error_title;
         $data  .= $input_message;
         $data  .= $error_message;
         $data  .= $formula_1;
         $data  .= $formula_2;
         $data  .= $dv_data;
  
      my $header = pack('vv', $record, length $data);
  
      $self->_append($header, $data);
  }
  
  
  ###############################################################################
  #
  # _pack_dv_string()
  #
  # Pack the strings used in the input and error dialog captions and messages.
  # Captions are limited to 32 characters. Messages are limited to 255 chars.
  #
  sub _pack_dv_string {
  
      my $self        = shift;
  
      my $string      = $_[0];
      my $max_length  = $_[1];
  
      my $str_length  = 0;
      my $encoding    = 0;
  
      # The default empty string is "\0".
      if (!defined $string || $string eq '') {
          $string = "\0";
      }
  
      # Excel limits DV captions to 32 chars and messages to 255.
      if (length $string > $max_length) {
          $string = substr($string, 0, $max_length);
      }
  
      $str_length = length $string;
  
      # Handle utf8 strings in perl 5.8.
      if ($] >= 5.008) {
          require Encode;
  
          if (Encode::is_utf8($string)) {
              $string = Encode::encode("UTF-16LE", $string);
              $encoding = 1;
          }
      }
  
      return pack('vC', $str_length, $encoding) . $string;
  }
  
  
  ###############################################################################
  #
  # _pack_dv_formula()
  #
  # Pack the formula used in the DV record. This is the same as an cell formula
  # with some additional header information. Note, DV formulas in Excel use
  # relative addressing (R1C1 and ptgXxxN) however we use the Formula.pm's
  # default absolute addressing (A1 and ptgXxx).
  #
  sub _pack_dv_formula {
  
      my $self        = shift;
  
      my $formula     = $_[0];
      my $encoding    = 0;
      my $length      = 0;
      my $unused      = 0x0000;
      my @tokens;
  
      # Return a default structure for unused formulas.
      if (!defined $formula || $formula eq '') {
          return pack('vv', 0, $unused);
      }
  
      # Pack a list array ref as a null separated string.
      if (ref $formula eq 'ARRAY') {
          $formula   = join "\0", @$formula;
          $formula   = qq("$formula");
      }
  
      # Strip the = sign at the beginning of the formula string
      $formula    =~ s(^=)();
  
      # Parse the formula using the parser in Formula.pm
      my $parser  = $self->{_parser};
  
      # In order to raise formula errors from the point of view of the calling
      # program we use an eval block and re-raise the error from here.
      #
      eval { @tokens = $parser->parse_formula($formula) };
  
      if ($@) {
          $@ =~ s/\n$//;  # Strip the \n used in the Formula.pm die()
          croak $@;       # Re-raise the error
      }
      else {
          # TODO test for non valid ptgs such as Sheet2!A1
      }
      # Force 2d ranges to be a reference class.
      s/_range2d/_range2dR/ for @tokens;
      s/_name/_nameR/       for @tokens;
  
      # Parse the tokens into a formula string.
      $formula = $parser->parse_tokens(@tokens);
  
  
      return pack('vv', length $formula, $unused) . $formula;
  }
  
  
  
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Worksheet - A writer class for Excel Worksheets.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::WriteExcel
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::WriteExcel.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
   MM-MMX, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
SPREADSHEET_WRITEEXCEL_WORKSHEET

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE


my $tool = "LF TMX maker";
my $version = "2.23";
use strict;
use warnings;
use File::Copy;
use File::Spec; use FindBin qw($Bin);# needed for ID of script folder
use IO::Handle;

# from CPAN
use Spreadsheet::ParseExcel::Simple;

binmode STDIN, ':encoding(UTF-8)';	# Works on Ubuntu, doesn't help on Win: "\xFB" does not map to Unicode"


# TODO

# if no note in 3rd column, use filename for TMX note by default

# logging




# declaring subs; the subs themselves are at the end
sub load_setup;
sub convert_xls;
sub ren_tmx;
sub getlocaltime;

# OS ID
my $OS;

if ($^O =~ /mswin/i) {$OS = "Windows";print "OS detected: Windows\n"}
elsif ($^O =~ /linux/i) {$OS = "Linux";print "OS detected: Linux\n"}
elsif ($^O =~ /darwin/i) {$OS = "Mac";print "OS detected: Mac OS X\n"} 
else {print "\nUnable to detect OS type, choose your OS:\n\nWindows	Any version of Microsoft Windows\nMac	Any flavour of Mac OS X\nLinux	Linux of some sort\n\n";
do {
chomp ($OS = <STDIN>);
print "\nIncorrect OS type. Try again.\n\n" unless $OS eq "Windows" or $OS eq "Mac" or $OS eq "Linux";} until ($OS eq "Windows" or $OS eq "Mac" or $OS eq "Linux");
}


# SCRIPT FOLDER ID

my $script = File::Spec->rel2abs( __FILE__ );

$script =~ /(.*)[\/|\\](.*)/;
my $scriptpath = $1;

$scriptpath =~ /(.*)[\/|\\](.*)/;
my $scriptpath_alt1 = $1;

$scriptpath_alt1 =~ /(.*)[\/|\\](.*)/;
my $scriptpath_alt2 = $1;

$Bin or $Bin = $script;		# avoid error msg
$Bin =~ /(.*)[\/|\\](.*)/;	# 2nd attempt at finding scripts directory
my $Bin_alt = $1;

$0 or $0 = $script;			# avoid error msg
$0 =~ /(.*)[\/|\\](.*)/;	# 3rd attempt at finding scripts directory
my $scriptpath_alt3 = $1;

$scriptpath_alt2 =~ /(.*)[\/|\\](.*)/;
my $scriptpath_alt4 = $1;


if (-d "$scriptpath/scripts/hunalign") {
	# print "\nScript folder found.\n";# comment out
} elsif (-d "$scriptpath_alt1/scripts/hunalign") {$scriptpath = $scriptpath_alt1}
elsif (-d "$scriptpath_alt2/scripts/hunalign") {$scriptpath = $scriptpath_alt2}
elsif (-d "$Bin/scripts/hunalign") {$scriptpath = $Bin}	# machinegun approach in case (__File__) fails
elsif (-d "$Bin_alt/scripts/hunalign") {$scriptpath = $Bin_alt}
elsif (-d "$scriptpath_alt2/scripts/hunalign") {$scriptpath = $scriptpath_alt3}
elsif (-d "$scriptpath_alt3/scripts/hunalign") {$scriptpath = $scriptpath_alt4}
else {
	do {
		print "\nThe script path found automatically (${scriptpath}) is not correct.\nPlease drag and drop the aligner script here and press enter. (If your OS doesn't support drag & drop, copy-paste the path here. You can paste by right clicking in the window or right clicking the icon in the top left corner of this window.)\n";
		chomp ($script = <STDIN>);
		$script =~ / *[\"\'](.*)[\/\\](.*)[\"\'] */;
		$scriptpath = $1;
		$scriptpath =~ s/^\s+//;					# strip leading whitespace
		$scriptpath =~ s/\s+$//;					# strip trailing whitespace

		if (-d "$scriptpath/scripts/hunalign") {print "\nScript folder identified correctly.\n"}
	} until (-d "$scriptpath/scripts/hunalign");
}



my ($filetype_def, $filetype_prompt, $l1_def, $l2_def, $l1_prompt, $l2_prompt, $segmenttext_def, $segmenttext_prompt, $merge_numbers_headings, $cleanup_def, $cleanup_prompt, $cleanup_remove_conf_value, $delete_dupes, $delete_untranslated, $review_def, $review_prompt, $create_tmx_def, $create_tmx_prompt, $l1_code_def, $l2_code_def, $l1_code_prompt, $l2_code_prompt, $creationdate_prompt, $creationid_def, $creationid_prompt, $tmxnote_def, $tmxnote_prompt, $ask_master_TM, $master_TM_path_1, $master_TM_path_2, $chopmode, $confirm_segmenting, $pdfmode, %charconv_source, %charconv_target, $localtime, $gui, $mw, @inputfiles, $outfile);



# CREATE LOGFILE

open (LOG, ">:encoding(UTF-8)", "$scriptpath/scripts/log.txt") or print "\nCan't create log file: $!\nContinuing anyway.\n";
LOG->autoflush;
getlocaltime; # so that the local time can be printed in the log
print LOG "$tool version $version, OS: $OS, started: $localtime\n\n";


# LOAD SETUP

load_setup;


# CUSTOMIZE

# OS-dependent GUI defaults are set in the setup sub
if ($gui ne "y") {$gui = ""}; # so that I can use the simple if ($gui) {}test

if ($gui) {require Tk;import Tk;$mw = MainWindow->new;$mw->withdraw;} # load the Tk GUI module if the gui is switched on (Win: on by default, other OS: off by default)

# $creationdate_prompt = "n"; $creationid_prompt ="n"; # $tmxnote_prompt  ="n"; # comment out

# GET INPUT FILE

my $inputfile_full;
my $folder;
my $full_filename;
my $filenotfound;
my $filename_noext;
# my $ext;
do {
	if ($gui) {
		print "\nPlease choose the input file(s) in the file browsing window\n";
		sleep 1;

		my $in_type = [	['Txt or Excel sheet', ['.txt', '.xls']],
						['All Files', '*']	];

		@inputfiles = $mw->getOpenFile(	-title => "Choose the input file(s)",
										-filetypes => $in_type,
										-multiple => 1);	# stores the files chosen in the browsing window in an array

	} else {		# drag and drop if gui is not available (*nix or disabled by user)

		print "\n\nDrag and drop the input file (tab delimited txt in UTF-8 encoding, or xls) here and press enter.\n";
		if ($OS eq "Windows") {print "(Vista users: sorry, Microsoft left you out in the cold. See readme; type [scr]/foldername/filename to run the script on files in the aligner folder.)\n"};
		chomp ($inputfile_full = <STDIN>);
		$inputfile_full =~ s/^\s+//;					# strip leading whitespace
		$inputfile_full =~ s/\s+$//;					# strip trailing whitespace

		if ($inputfile_full =~ /^\[scr\]\/(.*)/) {$inputfile_full = "$scriptpath/$1"};

		# strip any leading and trailing spaces and quotes
		# windows doesn't add quotes if there is no space in the path, linux adds single quotes
		$inputfile_full =~ s/^ *[\"\']?([^\"\']+)[\"\']? *$/$1/;

		push (@inputfiles, $inputfile_full);	# add the single dragged file to the array (using array for compatibility with gui open)
	}

	$filenotfound = "";
	print LOG "\nInput file(s):";
	foreach $inputfile_full (@inputfiles) {
		print LOG "\n\t$inputfile_full";
		# windows doesn't add quotes if there is no space in the path, linux adds single quotes
		# strip any leading and trailing spaces and quotes; $1=everything up to last / or \, $2= everything from there up to the end except spaces and "'.
		$inputfile_full =~ /^ *[\"\']?(.*)[\/\\]([^\"\']*)[\"\']? *$/;
		$folder = $1;
		$full_filename = $2;

		$full_filename =~ /(.*)\.(.*)/;
		$filename_noext = $1;#del
		# $ext = lc($2);
		unless (-e "$folder/$full_filename") {$filenotfound = $full_filename}
	}

	if ($filenotfound) {print "\n$full_filename doesn't exist (or its path or filename contains accented letters). Try again!\n\n";sleep 3;}
} while ($filenotfound); # if one or more file is not found, ask for input file again



# CONVERT XLS TO TABBED TXT - they are all put in $temptxt
# my $temptxt;
# if ($ext eq "xls") {
#c
# print LOG "\nInput file(s) identified as .xls, converting\n";
# my $timestamp = $localtime;			# we'e using the current date/time to get a unique temp filename
# $timestamp =~ s/[^0-9]//g;		# remove .:, etc from the date
# $temptxt = $folder .  "/" . ${filename_noext} . "_" . $timestamp . ".txt";	# name of last file in @inputfiles array plus _timestamp.txt

my $i = 0;
	foreach $inputfile_full (@inputfiles) {
	my $out = $inputfile_full;
	$out =~ /\.([^.]+)$/;
	my $extension = lc($1);
	next if $extension eq "txt";
	if ($extension eq "xls") {
		print LOG "\nInput file ($inputfile_full) detected as xls, converting to txt";
		$out =~ s/\.([^.])+$/\.txt/;	# change extenstion to txt
		if (-e "$out") {print "\nA file named $out already exists! Rename it or it will be overwritten.\nPress enter when done.";<STDIN>;}		#just in case the txt file already exists
		convert_xls ($inputfile_full, $out);	# all input files will be merged into the same txt
	}
	# work with txt file from now on (all input files merged into one txt)
	# @inputfiles = ();										# flush out the inputfiles array
	$inputfiles[$i]= $out;	# work with the txt file from here on
$i++;
}



# NUMBER OF LANGUAGES
my $no;

print "\n\n-------------------------------------------------";
print "\n\nNumber of languages? This will usually be 2.\n(Default: 2) ";

do {
chomp ($no = <STDIN>);
$no or $no = "2"; # default

$no =~ s/^\s+//;					# strip leading whitespace
$no =~ s/\s+$//;					# strip trailing whitespace
unless ($no =~ /^\d+$/) {print "\nPlease enter a number! Number of languages? "};
} until ($no =~ /^\d+$/);


# browse for output file

if ($gui) {
	print "\nPlease choose the output file to be created\n";
	sleep 1;

	my $out_type = [	['TMX file', '.tmx'],
					['All Files',        '*']	];

	my $def_out = $inputfiles[0];									# default
	$def_out =~ s/^ *[\"\']?(.*)[\/\\]([^\"\']*)[\"\']? *$/$2/;		# strip off folder from filename
	$def_out =~ s/\.[^.]+$/\.tmx/;									# change extension to tmx

	# if ($ext eq "xls") {$def_out =~ s/(_[0-9]{14})\.tmx/\.tmx/};		# remove timestamp from tmx filename


	# print "default output file: $def_out\n";

	$outfile = $mw->getSaveFile(	-title => "Choose a name and folder for the output file",
									-filetypes => $out_type,
									-initialfile => "$def_out",
									-defaultextension => '.tmx');

} else {

	$outfile = "$folder/$full_filename"; # we're naming the output file after the last input file
	$outfile =~ s/\.[^.]+$/\.tmx/;

	if (-e "$outfile") {print "\nA tmx file named $outfile already exists! Rename it or it will be overwritten.\nPress enter when done.";<STDIN>;}
}




# GET LANGUAGE CODES
my @langcode;

# LANG 1 -> [0]
print "\n\nType the language code of language 1 as used in TMX files by your CAT tool, (usually EN-GB, EN-US etc.) If in doubt, export a TM into TMX with the CAT tool you will be using and check the code. Alternatively, you can take a stab in the dark and hope the import works.\n(Default: $l1_code_def) ";
chomp ($langcode[0] = uc(<STDIN>));					# upper-case and chomp the langcode provided by the user
$langcode[0] or $langcode[0] = uc($l1_code_def);	# default for L1

# LANGS 2-.. ($langcode[1-..])
for (my $i = 1; $i < $no; $i++) {
	my $ii = $i;$ii ++;

	do {
		print "\n\nType the language code of language $ii.\n";
		print "(Default: $l2_code_def) " if ($i eq 1);
		chomp ($langcode[$i] = uc(<STDIN>));
		$langcode[1] or $langcode[1] = uc($l2_code_def); # default for L2
		unless ($langcode[$i] =~ /\w+/) {print "\n\nLanguage codes must contain at least two letters, try again.\n"} # L3 and up have no default
	} until ($langcode[$i] =~ /\w+/);
}



open (TMX, ">:encoding(UTF-8)", "$outfile") or die "Can't open file: $!";

foreach $inputfile_full (@inputfiles) {
# print "\ninput file: $inputfile_full\n";
	$inputfile_full =~ /^ *[\"\']?(.*)[\/\\]([^\"\']*)[\"\']? *$/;
	$folder = $1;
	$full_filename = $2;

	$full_filename =~ /(.*)\.(.*)/;
	# print "\ntrying to open: >$folder/$full_filename<\n";
	open (ALIGNED, "<:encoding(UTF-8)", "$folder/$full_filename") or die "Can't open file for reading (file: $folder/$full_filename)\nError message: $!";

	# strip BOM and replace characters that don't work in TMX
	while (<ALIGNED>) {
		s/^\x{FeFF}//;		#strip BOM


		s/&quot;/"/g;		# you never know where a quot shows up
		s/&nbsp;/ /g;		# you never know where a nbsp shows up
		s/&amp;/&/g;		# for rogue &amp;amp;
		s/&amp;/&/g;		# for rogue &amp;amp;

		# add the 5 TMX-approved char entities
		s/&/&amp;/g;		# Studio needs this, and it needs to be done before lt and gt
		s/</&lt;/g;
		s/>/&gt;/g;
		s/"/&quot;/g;		#	apparently not needed, I left it in anyway
		s/'/&apos;/g;		#	apparently not needed

		print TMX $_;
	}

}

close TMX;
open (TMX, "<:encoding(UTF-8)", "$outfile") or die "Can't open file: $!";



my ($sec, $min, $hr, $mday, $mon, $year);
($sec,$min,$hr,$mday,$mon,$year,,,) = gmtime(time);
$year += 1900;
$mon++;
my $month = sprintf("%02d", $mon);
my $day = sprintf("%02d", $mday);
my $hour = sprintf("%02d", $hr);
my $minute = sprintf("%02d", $min);
my $second = sprintf("%02d", $sec);
my $date = "$year$month${day}T$hour$minute${second}Z";

if ($date =~ /^[0-2][0-9]{3}[0-1][0-9][0-3][0-9]T[0-2][0-9][0-5][0-9][0-5][0-9]Z$/) {
	#print "\n\nCurrent GMT date and time (yyyymmddThhmmssZ): $date\n"
} else {
	print "\nAutomatic date/time identification unsuccessful, falling back to fixed date.\n";
	$date = "20100101T120000Z";
	print "\nDate and time (yyyymmddThhmmssZ): $date\n";
}

my $creationdate;
unless ($creationdate_prompt eq "n") {
	do {
		print "\n\n-------------------------------------------------";
		print "\n\nPress enter to use the autodetected date and time, or specify your own date and time to be recorded in the TMX. Use the format yyyymmddThhmmssZ, capital T and Z included. See details in readme.\nAutodetected default: $date ";
		chomp ($creationdate = <STDIN>);
		$creationdate or $creationdate = $date;

		print "\nIncorrect date format, try again\n" unless ($creationdate =~ /^[0-2][0-9]{3}[0-1][0-9][0-3][0-9]T[0-2][0-9][0-5][0-9][0-5][0-9]Z$/);
	} until ($creationdate =~ /^[0-2][0-9]{3}[0-1][0-9][0-3][0-9]T[0-2][0-9][0-5][0-9][0-5][0-9]Z$/);
}

$creationdate or $creationdate = $date;
print LOG "\nTMX date/time: $creationdate";

# ASK FOR CREATOR ID
my $creationid;
$creationid_def or $creationid_def = "$tool $version";
unless ($creationid_prompt eq "n") {
	print "\n\n-------------------------------------------------";
	print "\n\nType the creator name you wish to be recorded in the TMX. Do not use accented letters or other special characters.\n(Default: $creationid_def) ";
	chomp ($creationid = <STDIN>);
}
$creationid or $creationid = $creationid_def;
print LOG ", creator ID: $creationid";


# START WRITING TMX
open (TMX_MOD, ">:encoding(UTF-8)", "${outfile}.mod") or die "Can't open file: $!";
print TMX_MOD "\x{FeFF}<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE tmx SYSTEM \"tmx14.dtd\">\n<tmx version=\"1.4\">\n  <header\n    creationtool=\"${tool}\"\n    creationtoolversion=\"${version}\"\n    datatype=\"unknown\"\n    segtype=\"sentence\"\n    adminlang=\"$langcode[0]\"\n    srclang=\"$langcode[0]\"\n    o-tmf=\"TW4Win 2.0 Format\"\n  >\n  </header>\n  <body>\n";

# NOTE
my $tmxnote;
my $tmxnote_def_display;			# just to make the last column default clearer to the user

unless ($tmxnote_prompt eq "n") {
	print "\n\n-------------------------------------------------";
	print "\n\nYou can add a note to your TMX. Your options are:
	\n1) Add the contents of the last column of the txt as a note. This is the default, just press enter to apply. This allows you to use accented characters or assign different notes to the various lines/segments in your TM - very useful e.g. if the content comes from several different documents.
	\n2) Type the text you wish to add as note. (Accented letters and other special characters may get corrupted.)
	\n3) Create the TMX without a note. Type \"none\" to apply.";

	if ($tmxnote_def eq "") {$tmxnote_def_display = "last column"} else {$tmxnote_def_display = $tmxnote_def};
	print "\n\nleave empty/add your text/type \"none\" (default: $tmxnote_def_display): ";
	chomp ($tmxnote = <STDIN>);
}
$tmxnote or $tmxnote = $tmxnote_def;

print LOG ", note: $tmxnote";

my $tabs_req = $no;		# number of tab characers required (to make sure the file has all the expected columns)
$tabs_req-- unless $tmxnote eq "";		# less tabs required if there is no note in the last column


# NEW
my $skipped = "0";
my $written = "0";
my $tmxnote_print;
while (<TMX>) {
	chomp($_);

	unless (/(.*\t){$tabs_req}/) {print "\n\nLINE $. OF THE FILE DOESN'T HAVE ENOUGH COLUMNS, SO IT HAS BEEN SKIPPED.\nCHECK THE SOURCE FILE AND RUN THE TMX MAKER AGAIN IF NEEDED\n";$skipped++;next;}

	print TMX_MOD "<tu creationdate=\"$creationdate\" creationid=\"$creationid\">";
	unless ($tmxnote eq "none") { #do
		if ($tmxnote eq "") {/^([^\t]*\t){$no}([^\t]*)/; $tmxnote_print = $2} else {$tmxnote_print = $tmxnote}
		print TMX_MOD "<prop type=\"Txt::Note\">$tmxnote_print<\/prop>";
	}
	for (my $i = 0; $i < $no; $i++) { # loop through $no languages (2, usually)
		/^(?:[^\t]*\t){$i}([^\t]*)/; # capture the text that follows $i columns of previous stuff
		print TMX_MOD "\n<tuv xml:lang=\"$langcode[$i]\"><seg>$1<\/seg><\/tuv>";
	}
	$written++;
	print TMX_MOD " <\/tu>\n\n";
}


print TMX_MOD "\n<\/body>\n<\/tmx>";
close TMX_MOD; #added in 2.23
ren_tmx;


print "\n\n\n${outfile} created\n";



# END
# if ($gui) {MainLoop();} # gui over - unnecessary, it seems

close ALIGNED;
close TMX;
close TMX_MOD;

unlink "${outfile}.mod";
# unlink $temptxt;
print "\n\n-------------------------------------------------";
print "\n\n$written TUs have been written to the TMX; $skipped skipped.\n\nPress Enter to quit.\n";
print LOG "\n$written TUs written to the TMX; $skipped skipped.\nTerminated normally.";
<STDIN>;





# SUBS


sub getlocaltime {
	my ($lsec,$lmin,$lhr,$lmday,$lmon,$lyear,,,) = localtime(time);

	$lyear += 1900;
	$lmon++;
	my $lmonth = sprintf("%02d", $lmon);
	my $lday = sprintf("%02d", $lmday);
	my $lhour = sprintf("%02d", $lhr);
	my $lminute = sprintf("%02d", $lmin);
	my $lsecond = sprintf("%02d", $lsec);
	$localtime = "$lyear/$lmonth/${lday}, $lhour:$lminute:${lsecond}";
}



sub ren_tmx {

	close TMX;
	close TMX_MOD;
	rename ("${outfile}.mod", "$outfile") or die "Can't rename file: $!";

	open (TMX, "<:encoding(UTF-8)", "$outfile") or die "Can't open tmx file for reading: $!";
	open (TMX_MOD, ">:encoding(UTF-8)", "${outfile}.mod") or die "Can't open tmx file for writing: $!";
}



sub convert_xls($) { # do some error checking?

	# print "file: >$_[0]<"; # comment out
	open (TXTFROMXLS, ">>:encoding(UTF-8)", $_[1]) or print "\nCan't create output file: $!";	# we're appending all xls contents to one txt

	my $xls = Spreadsheet::ParseExcel::Simple->read ($_[0]);

	foreach my $sheet ($xls->sheets) {		# iterates through all available worksheets in the file named $xls (unless last; is used)
		while ($sheet->has_data) {
			my @data = $sheet->next_row;
			print TXTFROMXLS join ("\t", @data) . "\n";
		}
		# last;			# uncomment to get only the first worksheet
	}
	close TXTFROMXLS;
}



sub load_setup {
	# REGENERATE SETUP FILE IF NOT FOUND
	unless (-e "$scriptpath/LF_aligner_setup.txt") {
		print "\nSETUP FILE NOT FOUND, creating $scriptpath/LF_aligner_setup.txt with default settings\n";
		print LOG "Setup file not found, creating $scriptpath/LF_aligner_setup.txt with default settings\n";
		open (SETUP, ">:encoding(UTF-8)", "$scriptpath/LF_aligner_setup.txt") or print "Can't create setup file: $!";
		print SETUP "\x{FeFF}Here, you can specify settings for LF aligner. Put your choice (usually y or n) between the square brackets, and don't change anything else in this file. If you want to restore the default settings or you think you may have corrupted the file, just delete it. It will be recreated with default settings the next time the aligner runs.\n\n\n*** INPUT ***\n\nFiletype default (t/c/com/epr/w/h/p): [t]\nPrompt user for filetype: [y]\n\nLanguage 1 default: [en]\nPrompt user for language 1: [y]\nLanguage 2 default: [hu]\nPrompt user for language 2: [y]\n\n\n*** OUTPUT ***\n\nSegment to sentences default: [y]\nPrompt user whether to segment: [y]\n\nMerge numbers and chapter/point headings with the next segment: [y]\n\nCleanup default: [y]\nPrompt user whether to do cleanup: [y]\n\nRemove match confidence value: [y]\n\nDelete duplicate entries: [n]\n\nDelete entries where the text is the same in both languages (filters out untranslated text and segments than only contain numbers etc.): [n]\n\nReview default (n/t/x): [x]\nPrompt user whether/how to review pairings: [y]\n\nOffer to write to txt (allows you to add all aligned files to the same master TM): [n]\nMaster TM path: []\n\n\n*** TMX ***\n\nMake TMX by default: [y]\nPrompt user whether to make TMX: [y]\n\nLanguage code 1 default: []\nPrompt user for language code 1: [y]\nLanguage code 2 default: []\nPrompt user for language code 2: [y]\n\nPrompt user for creation date and time: [y]\n\nCreator ID default: []\nPrompt user for creator ID: [y]\n\nDefault TMX note: []\nPrompt user for TMX note: [y]\n\n\n*** MISC ***\n\nChop up files larger than this size (0 deactivates the feature; only activate for files larger than about 20,000 segments if the normal mode failed). [0]\n\nAsk for confirmation after segmenting (switch off only if you want the aligner to run unattended): [y]\n\nPdf conversion mode; formatted or not (-layout option in pdftotext) [y]\n\nForce GUI on (y) or off (n) []\n\n\nCharacter conversion: provide character pairs separated by a tab, one pair per line. The aligner will replace the first character with the second in your aligned file. The replacement is case-sensitive and can be used to decode character entities or fix corrupted characters.\n\nCharacter conversion table for language 1:\n\n\nCharacter conversion table for language 2:\n\n";

		close SETUP;
	}


	open (SETUP, "<:encoding(UTF-8)", "$scriptpath/LF_aligner_setup.txt") or print "Can't open setup file: $!\nDefaulting to basic settings.";

	while (<SETUP>) {
		# these vars are declared where load_setup is called
		if (/Filetype default/) {
			/\[(.*)\]/;
			$filetype_def = $1;
		}
		if (/Prompt user for filetype:/) {
			/\[(.*)\]/;
			$filetype_prompt = $1;
		}

		if (/Language 1 default:/) {
			/\[(.*)\]/;
			$l1_def = $1;
		}
		if (/Language 2 default:/) {
			/\[(.*)\]/;
			$l2_def = $1;
		}
		if (/Prompt user for language 1:/) {
			/\[(.*)\]/;
			$l1_prompt = $1;
		}
		if (/Prompt user for language 2:/) {
			/\[(.*)\]/;
			$l2_prompt = $1;
		}

		if (/Segment to sentences default:/) {
			/\[(.*)\]/;
			$segmenttext_def = $1;
		}

		if (/Prompt user whether to segment:/) {
			/\[(.*)\]/;
			$segmenttext_prompt = $1;
		}

		if (/Merge numbers and chapter\/point headings with the next segment:/) {
			/\[(.*)\]/;
			$merge_numbers_headings = $1;
		}

		if (/Cleanup default:/) {
			/\[(.*)\]/;
			$cleanup_def = $1;
		}
		if (/Prompt user whether to do cleanup:/) {
			/\[(.*)\]/;
			$cleanup_prompt = $1;
		}

		if (/Remove match confidence value:/) {
			/\[(.*)\]/;
			$cleanup_remove_conf_value = $1;
		}

		if (/Delete duplicate entries:/) {
			/\[(.*)\]/;
			$delete_dupes = $1;
		}

		if (/Delete entries where the text is the same in both languages/) {
			/\[(.*)\]/;
			$delete_untranslated = $1;
		}

		if (/Review default \(n\/t\/x\):/) {
			/\[(.*)\]/;
			$review_def = $1;
		}

		if (/Prompt user whether\/how to review pairings:/) {
			/\[(.*)\]/;
			$review_prompt = $1;
		}

		if (/Make TMX by default:/) {
			/\[(.*)\]/;
			$create_tmx_def = $1;
		}

		if (/Prompt user whether to make TMX:/) {
			/\[(.*)\]/;
			$create_tmx_prompt = $1;
		}

		if (/Language code 1 default:/) {
			/\[(.*)\]/;
			$l1_code_def = $1;
		}
		if (/Language code 2 default:/) {
			/\[(.*)\]/;
			$l2_code_def = $1;
		}

		if (/Prompt user for language code 1:/) {
			/\[(.*)\]/;
			$l1_code_prompt = $1;
		}
		if (/Prompt user for language code 2:/) {
			/\[(.*)\]/;
			$l2_code_prompt = $1;
		}

		if (/Prompt user for creation date and time:/) {
			/\[(.*)\]/;
			$creationdate_prompt = $1;
		}

		if (/Creator ID default:/) {
			/\[(.*)\]/;
			$creationid_def = $1;
		}

		if (/Prompt user for creator ID:/) {
			/\[(.*)\]/;
			$creationid_prompt = $1;
		}

		if (/Default TMX note:/) {
			/\[(.*)\]/;
			$tmxnote_def = $1;
		}

		if (/Prompt user for TMX note:/) {
			/\[(.*)\]/;
			$tmxnote_prompt = $1;
		}

		if (/Offer to write to txt/) {
			/\[(.*)\]/;
			$ask_master_TM = $1;
		}

		if (/Master TM path:/) {
			/\[([^;]*);? ?(.*)\]/;
			$master_TM_path_1 = $1;
			$master_TM_path_2 = $2;
		}

		if (/Chop up files larger than this size/) {
			/\[(.*)\]/;
			$chopmode = $1;
		}

		if (/Ask for confirmation after segmenting/) {
			/\[(.*)\]/;
			$confirm_segmenting = $1;
		}

		if (/Pdf conversion mode/) {
			/\[(.*)\]/;
			$pdfmode = $1;
		}

		if (/GUI/) {
			/\[(.*)\]/;
			$gui = lc($1);
		}

	}
	close SETUP;

	# default values in case the setup file is bad
	$filetype_def or $filetype_def = "t";
	$filetype_prompt or $filetype_prompt = "y";
	$l1_def or $l1_def = "hu";
	$l2_def or $l2_def = "en";
	$l1_prompt or $l1_prompt = "y";
	$l2_prompt or $l2_prompt = "y";
	$segmenttext_def or $segmenttext_def = "y";
	$segmenttext_prompt or $segmenttext_prompt= "y";
	$cleanup_def or $cleanup_def = "y";
	$cleanup_prompt or $cleanup_prompt = "y";
	$review_def or $review_def = "x";
	$review_prompt or $review_prompt = "y";
	$create_tmx_def or $create_tmx_def = "y";
	$create_tmx_prompt or $create_tmx_prompt = "y";
	$l1_code_def or $l1_code_def = "EN-GB";
	$l2_code_def or $l2_code_def = "HU";
	$l1_code_prompt or $l1_code_prompt = "y";
	$l2_code_prompt or $l2_code_prompt = "y";
	$creationdate_prompt or $creationdate_prompt = "y";
	#$creationid_def or $creationid_def = "Aligner";
	$creationid_prompt or $creationid_prompt = "y";
	$ask_master_TM or $ask_master_TM = "n";
	$chopmode or $chopmode = 0;
	$tmxnote_def or $tmxnote_def = "";
	$tmxnote_prompt or $tmxnote_prompt = "y";
	$pdfmode or $pdfmode = "y";
	if ($OS eq "Windows") {$gui or $gui = "y"} else {$gui or $gui = "n"};

	print LOG "Setup: filetype_def: $filetype_def; filetype_prompt: $filetype_prompt; l1_def: $l1_def; l2_def: $l2_def; l1_prompt: $l1_prompt; l2_prompt: $l2_prompt; segmenttext_def: $segmenttext_def; segmenttext_prompt: $segmenttext_prompt=; cleanup_def: $cleanup_def; cleanup_prompt: $cleanup_prompt; review_def: $review_def; review_prompt: $review_prompt; create_tmx_def: $create_tmx_def; create_tmx_prompt: $create_tmx_prompt; l1_code_def: $l1_code_def; l2_code_def: $l2_code_def; l1_code_prompt: $l1_code_prompt; l2_code_prompt: $l2_code_prompt; creationdate_prompt: $creationdate_prompt; creationid_def: $creationid_def; creationid_prompt: $creationid_prompt; ask_master_TM: $ask_master_TM; chopmode: $chopmode; tmxnote_def: $tmxnote_def; tmxnote_prompt: $tmxnote_prompt; pdfmode: $pdfmode\n";

}